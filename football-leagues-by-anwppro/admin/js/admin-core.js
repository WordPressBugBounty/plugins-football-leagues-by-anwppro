var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw") throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object)) __typeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
(function() {
  "use strict";
  var __vite_style__ = document.createElement("style");
  __vite_style__.textContent = '.mx-icon-left:before,.mx-icon-right:before,.mx-icon-double-left:before,.mx-icon-double-right:before,.mx-icon-double-left:after,.mx-icon-double-right:after{content:"";position:relative;top:-1px;display:inline-block;width:10px;height:10px;vertical-align:middle;border-style:solid;border-color:currentColor;border-width:2px 0 0 2px;border-radius:1px;box-sizing:border-box;transform-origin:center;transform:rotate(-45deg) scale(0.7)}.mx-icon-double-left:after{left:-4px}.mx-icon-double-right:before{left:4px}.mx-icon-right:before,.mx-icon-double-right:before,.mx-icon-double-right:after{transform:rotate(135deg) scale(0.7)}.mx-btn{box-sizing:border-box;line-height:1;font-size:14px;font-weight:500;padding:7px 15px;margin:0;cursor:pointer;background-color:transparent;outline:none;border:1px solid rgba(0,0,0,.1);border-radius:4px;color:#73879c;white-space:nowrap}.mx-btn:hover{border-color:#1284e7;color:#1284e7}.mx-btn-text{border:0;padding:0 4px;text-align:left;line-height:inherit}.mx-scrollbar{height:100%}.mx-scrollbar:hover .mx-scrollbar-track{opacity:1}.mx-scrollbar-wrap{height:100%;overflow-x:hidden;overflow-y:auto}.mx-scrollbar-track{position:absolute;top:2px;right:2px;bottom:2px;width:6px;z-index:1;border-radius:4px;opacity:0;transition:opacity .24s ease-out}.mx-scrollbar-track .mx-scrollbar-thumb{position:absolute;width:100%;height:0;cursor:pointer;border-radius:inherit;background-color:rgba(144,147,153,.3);transition:background-color .3s}.mx-zoom-in-down-enter-active,.mx-zoom-in-down-leave-active{opacity:1;transform:scaleY(1);transition:transform .3s cubic-bezier(0.23, 1, 0.32, 1),opacity .3s cubic-bezier(0.23, 1, 0.32, 1);transform-origin:center top}.mx-zoom-in-down-enter,.mx-zoom-in-down-enter-from,.mx-zoom-in-down-leave-to{opacity:0;transform:scaleY(0)}.mx-datepicker{position:relative;display:inline-block;width:210px}.mx-datepicker svg{width:1em;height:1em;vertical-align:-0.15em;fill:currentColor;overflow:hidden}.mx-datepicker-range{width:320px}.mx-datepicker-inline{width:auto}.mx-input-wrapper{position:relative}.mx-input-wrapper .mx-icon-clear{display:none}.mx-input-wrapper:hover .mx-icon-clear{display:block}.mx-input-wrapper:hover .mx-icon-clear+.mx-icon-calendar{display:none}.mx-input{display:inline-block;box-sizing:border-box;width:100%;height:34px;padding:6px 30px;padding-left:10px;font-size:14px;line-height:1.4;color:#555;background-color:#fff;border:1px solid #ccc;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.mx-input:hover,.mx-input:focus{border-color:#409aff}.mx-input:disabled,.mx-input.disabled{color:#ccc;background-color:#f3f3f3;border-color:#ccc;cursor:not-allowed}.mx-input:focus{outline:none}.mx-input::-ms-clear{display:none}.mx-icon-calendar,.mx-icon-clear{position:absolute;top:50%;right:8px;transform:translateY(-50%);font-size:16px;line-height:1;color:rgba(0,0,0,.5);vertical-align:middle}.mx-icon-clear{cursor:pointer}.mx-icon-clear:hover{color:rgba(0,0,0,.8)}.mx-datepicker-main{font:14px/1.5 "Helvetica Neue",Helvetica,Arial,"Microsoft Yahei",sans-serif;color:#73879c;background-color:#fff;border:1px solid #e8e8e8}.mx-datepicker-popup{position:absolute;margin-top:1px;margin-bottom:1px;box-shadow:0 6px 12px rgba(0,0,0,.175);z-index:2001}.mx-datepicker-sidebar{float:left;box-sizing:border-box;width:100px;padding:6px;overflow:auto}.mx-datepicker-sidebar+.mx-datepicker-content{margin-left:100px;border-left:1px solid #e8e8e8}.mx-datepicker-body{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.mx-btn-shortcut{display:block;padding:0 6px;line-height:24px}.mx-datepicker-header{padding:6px 8px;border-bottom:1px solid #e8e8e8}.mx-datepicker-footer{padding:6px 8px;text-align:right;border-top:1px solid #e8e8e8}.mx-calendar-range,.mx-time-range{display:flex}@media(max-width: 750px){.mx-calendar-range,.mx-time-range{flex-direction:column}}.mx-calendar{box-sizing:border-box;width:248px;padding:6px 12px}.mx-calendar+.mx-calendar{border-left:1px solid #e8e8e8}.mx-calendar-header,.mx-time-header{box-sizing:border-box;height:34px;line-height:34px;text-align:center;overflow:hidden}.mx-btn-icon-left,.mx-btn-icon-double-left{float:left}.mx-btn-icon-right,.mx-btn-icon-double-right{float:right}.mx-calendar-header-label{font-size:14px}.mx-calendar-decade-separator{margin:0 2px}.mx-calendar-decade-separator:after{content:"~"}.mx-calendar-content{position:relative;height:224px;box-sizing:border-box}.mx-calendar-content .cell{cursor:pointer}.mx-calendar-content .cell:hover{color:#73879c;background-color:#f3f9fe}.mx-calendar-content .cell.active{color:#fff;background-color:#1284e7}.mx-calendar-content .cell.in-range,.mx-calendar-content .cell.hover-in-range{color:#73879c;background-color:#dbedfb}.mx-calendar-content .cell.disabled{cursor:not-allowed;color:#ccc;background-color:#f3f3f3}.mx-calendar-week-mode .mx-date-row{cursor:pointer}.mx-calendar-week-mode .mx-date-row:hover{background-color:#f3f9fe}.mx-calendar-week-mode .mx-date-row.mx-active-week{background-color:#dbedfb}.mx-calendar-week-mode .mx-date-row .cell:hover{color:inherit;background-color:transparent}.mx-calendar-week-mode .mx-date-row .cell.active{color:inherit;background-color:transparent}.mx-week-number{opacity:.5}.mx-table{table-layout:fixed;border-collapse:separate;border-spacing:0;width:100%;height:100%;box-sizing:border-box;text-align:center}.mx-table th{padding:0;font-weight:500;vertical-align:middle}.mx-table td{padding:0;vertical-align:middle}.mx-table-date td,.mx-table-date th{height:32px;font-size:12px}.mx-table-date .today{color:#2a90e9}.mx-table-date .cell.not-current-month{color:#ccc;background:none}.mx-time{flex:1;width:224px;background:#fff}.mx-time+.mx-time{border-left:1px solid #e8e8e8}.mx-date-time{position:relative;width:248px;height:270px}.mx-date-time .mx-time{position:absolute;top:0;left:0;width:100%;height:100%}.mx-date-time-range{position:relative;width:496px;height:270px}.mx-date-time-range .mx-time-range{position:absolute;top:0;left:0;width:100%;height:100%}.mx-time-header{border-bottom:1px solid #e8e8e8}.mx-time-content{height:224px;box-sizing:border-box;overflow:hidden}.mx-time-columns{display:flex;width:100%;height:100%;overflow:hidden}.mx-time-column{flex:1;position:relative;border-left:1px solid #e8e8e8;text-align:center}.mx-time-column:first-child{border-left:0}.mx-time-column .mx-time-list{margin:0;padding:0;list-style:none}.mx-time-column .mx-time-list::after{content:"";display:block;height:192px}.mx-time-column .mx-time-item{cursor:pointer;font-size:12px;height:32px;line-height:32px}.mx-time-column .mx-time-item:hover{color:#73879c;background-color:#f3f9fe}.mx-time-column .mx-time-item.active{color:#1284e7;background-color:transparent;font-weight:700}.mx-time-column .mx-time-item.disabled{cursor:not-allowed;color:#ccc;background-color:#f3f3f3}.mx-time-option{cursor:pointer;padding:8px 10px;font-size:14px;line-height:20px}.mx-time-option:hover{color:#73879c;background-color:#f3f9fe}.mx-time-option.active{color:#1284e7;background-color:transparent;font-weight:700}.mx-time-option.disabled{cursor:not-allowed;color:#ccc;background-color:#f3f3f3}\n.tabulator{background-color:#888;border:1px solid #999;font-size:14px;overflow:hidden;position:relative;text-align:left;-webkit-transform:translateZ(0);-moz-transform:translateZ(0);-ms-transform:translateZ(0);-o-transform:translateZ(0);transform:translateZ(0)}.tabulator[tabulator-layout=fitDataFill] .tabulator-tableholder .tabulator-table{min-width:100%}.tabulator[tabulator-layout=fitDataTable]{display:inline-block}.tabulator.tabulator-block-select,.tabulator.tabulator-ranges .tabulator-cell:not(.tabulator-editing){user-select:none}.tabulator .tabulator-header{background-color:#e6e6e6;border-bottom:1px solid #999;box-sizing:border-box;color:#555;font-weight:700;outline:none;overflow:hidden;position:relative;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;white-space:nowrap;width:100%}.tabulator .tabulator-header.tabulator-header-hidden{display:none}.tabulator .tabulator-header .tabulator-header-contents{overflow:hidden;position:relative}.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers{display:inline-block}.tabulator .tabulator-header .tabulator-col{background:#e6e6e6;border-right:1px solid #aaa;box-sizing:border-box;display:inline-flex;flex-direction:column;justify-content:flex-start;overflow:hidden;position:relative;text-align:left;vertical-align:bottom}.tabulator .tabulator-header .tabulator-col.tabulator-moving{background:#cdcdcd;border:1px solid #999;pointer-events:none;position:absolute}.tabulator .tabulator-header .tabulator-col.tabulator-range-highlight{background-color:#d6d6d6;color:#000}.tabulator .tabulator-header .tabulator-col.tabulator-range-selected{background-color:#3876ca;color:#fff}.tabulator .tabulator-header .tabulator-col .tabulator-col-content{box-sizing:border-box;padding:4px;position:relative}.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button{padding:0 8px}.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover{cursor:pointer;opacity:.6}.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder{position:relative}.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title{box-sizing:border-box;overflow:hidden;text-overflow:ellipsis;vertical-align:bottom;white-space:nowrap;width:100%}.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap{text-overflow:clip;white-space:normal}.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor{background:#fff;border:1px solid #999;box-sizing:border-box;padding:1px;width:100%}.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button+.tabulator-title-editor{width:calc(100% - 22px)}.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter{align-items:center;bottom:0;display:flex;position:absolute;right:4px;top:0}.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow{border-bottom:6px solid #bbb;border-left:6px solid transparent;border-right:6px solid transparent;height:0;width:0}.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols{border-top:1px solid #aaa;display:flex;margin-right:-1px;overflow:hidden;position:relative}.tabulator .tabulator-header .tabulator-col .tabulator-header-filter{box-sizing:border-box;margin-top:2px;position:relative;text-align:center;width:100%}.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea{height:auto!important}.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg{margin-top:3px}.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear{height:0;width:0}.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title{padding-right:25px}@media (hover:hover) and (pointer:fine){.tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover{background-color:#cdcdcd;cursor:pointer}}.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort=none] .tabulator-col-content .tabulator-col-sorter{color:#bbb}@media (hover:hover) and (pointer:fine){.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort=none] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover{border-bottom:6px solid #555;cursor:pointer}}.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort=none] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow{border-bottom:6px solid #bbb;border-top:none}.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort=ascending] .tabulator-col-content .tabulator-col-sorter{color:#666}@media (hover:hover) and (pointer:fine){.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort=ascending] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover{border-bottom:6px solid #555;cursor:pointer}}.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort=ascending] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow{border-bottom:6px solid #666;border-top:none}.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort=descending] .tabulator-col-content .tabulator-col-sorter{color:#666}@media (hover:hover) and (pointer:fine){.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort=descending] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover{border-top:6px solid #555;cursor:pointer}}.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort=descending] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow{border-bottom:none;border-top:6px solid #666;color:#666}.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title{align-items:center;display:flex;justify-content:center;text-orientation:mixed;writing-mode:vertical-rl}.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title{transform:rotate(180deg)}.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title{padding-right:0;padding-top:20px}.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title{padding-bottom:20px;padding-right:0}.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter{bottom:auto;justify-content:center;left:0;right:0;top:4px}.tabulator .tabulator-header .tabulator-frozen{left:0;position:sticky;z-index:11}.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left{border-right:2px solid #aaa}.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right{border-left:2px solid #aaa}.tabulator .tabulator-header .tabulator-calcs-holder{background:#f3f3f3!important;border-bottom:1px solid #aaa;border-top:1px solid #aaa;box-sizing:border-box;display:inline-block}.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row{background:#f3f3f3!important}.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle{display:none}.tabulator .tabulator-header .tabulator-frozen-rows-holder{display:inline-block}.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty{display:none}.tabulator .tabulator-tableholder{-webkit-overflow-scrolling:touch;overflow:auto;position:relative;white-space:nowrap;width:100%}.tabulator .tabulator-tableholder:focus{outline:none}.tabulator .tabulator-tableholder .tabulator-placeholder{align-items:center;box-sizing:border-box;display:flex;justify-content:center;min-width:100%;width:100%}.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode=virtual]{min-height:100%}.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents{color:#ccc;display:inline-block;font-size:20px;font-weight:700;padding:10px;text-align:center;white-space:normal}.tabulator .tabulator-tableholder .tabulator-table{background-color:#fff;color:#333;display:inline-block;overflow:visible;position:relative;white-space:nowrap}.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs{background:#e2e2e2!important;font-weight:700}.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top{border-bottom:2px solid #aaa}.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom{border-top:2px solid #aaa}.tabulator .tabulator-tableholder .tabulator-range-overlay{inset:0;pointer-events:none;position:absolute;z-index:10}.tabulator .tabulator-tableholder .tabulator-range-overlay .tabulator-range{border:1px solid #2975dd;box-sizing:border-box;position:absolute}.tabulator .tabulator-tableholder .tabulator-range-overlay .tabulator-range.tabulator-range-active:after{background-color:#2975dd;border-radius:999px;bottom:-3px;content:"";height:6px;position:absolute;right:-3px;width:6px}.tabulator .tabulator-tableholder .tabulator-range-overlay .tabulator-range-cell-active{border:2px solid #2975dd;box-sizing:border-box;position:absolute}.tabulator .tabulator-footer{background-color:#e6e6e6;border-top:1px solid #999;color:#555;font-weight:700;user-select:none;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;white-space:nowrap}.tabulator .tabulator-footer .tabulator-footer-contents{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:5px 10px}.tabulator .tabulator-footer .tabulator-footer-contents:empty{display:none}.tabulator .tabulator-footer .tabulator-spreadsheet-tabs{margin-top:-5px;overflow-x:auto}.tabulator .tabulator-footer .tabulator-spreadsheet-tabs .tabulator-spreadsheet-tab{border:1px solid #999;border-bottom-left-radius:5px;border-bottom-right-radius:5px;border-top:none;display:inline-block;font-size:.9em;padding:5px}.tabulator .tabulator-footer .tabulator-spreadsheet-tabs .tabulator-spreadsheet-tab:hover{cursor:pointer;opacity:.7}.tabulator .tabulator-footer .tabulator-spreadsheet-tabs .tabulator-spreadsheet-tab.tabulator-spreadsheet-tab-active{background:#fff}.tabulator .tabulator-footer .tabulator-calcs-holder{background:#f3f3f3!important;border-bottom:1px solid #aaa;border-top:1px solid #aaa;box-sizing:border-box;overflow:hidden;text-align:left;width:100%}.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row{background:#f3f3f3!important;display:inline-block}.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle{display:none}.tabulator .tabulator-footer .tabulator-calcs-holder:only-child{border-bottom:none;margin-bottom:-5px}.tabulator .tabulator-footer>*+.tabulator-page-counter{margin-left:10px}.tabulator .tabulator-footer .tabulator-page-counter{font-weight:400}.tabulator .tabulator-footer .tabulator-paginator{color:#555;flex:1;font-family:inherit;font-size:inherit;font-weight:inherit;text-align:right}.tabulator .tabulator-footer .tabulator-page-size{border:1px solid #aaa;border-radius:3px;display:inline-block;margin:0 5px;padding:2px 5px}.tabulator .tabulator-footer .tabulator-pages{margin:0 7px}.tabulator .tabulator-footer .tabulator-page{background:hsla(0,0%,100%,.2);border:1px solid #aaa;border-radius:3px;display:inline-block;margin:0 2px;padding:2px 5px}.tabulator .tabulator-footer .tabulator-page.active{color:#d00}.tabulator .tabulator-footer .tabulator-page:disabled{opacity:.5}@media (hover:hover) and (pointer:fine){.tabulator .tabulator-footer .tabulator-page:not(disabled):hover{background:rgba(0,0,0,.2);color:#fff;cursor:pointer}}.tabulator .tabulator-col-resize-handle{display:inline-block;margin-left:-3px;margin-right:-3px;position:relative;vertical-align:middle;width:6px;z-index:11}@media (hover:hover) and (pointer:fine){.tabulator .tabulator-col-resize-handle:hover{cursor:ew-resize}}.tabulator .tabulator-col-resize-handle:last-of-type{margin-right:0;width:3px}.tabulator .tabulator-col-resize-guide{background-color:#999;height:100%;margin-left:-.5px;opacity:.5;position:absolute;top:0;width:4px}.tabulator .tabulator-row-resize-guide{background-color:#999;height:4px;left:0;margin-top:-.5px;opacity:.5;position:absolute;width:100%}.tabulator .tabulator-alert{align-items:center;background:rgba(0,0,0,.4);display:flex;height:100%;left:0;position:absolute;text-align:center;top:0;width:100%;z-index:100}.tabulator .tabulator-alert .tabulator-alert-msg{background:#fff;border-radius:10px;display:inline-block;font-size:16px;font-weight:700;margin:0 auto;padding:10px 20px}.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg{border:4px solid #333;color:#000}.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error{border:4px solid #d00;color:#590000}.tabulator-row{background-color:#fff;box-sizing:border-box;min-height:22px;position:relative}.tabulator-row.tabulator-row-even{background-color:#efefef}@media (hover:hover) and (pointer:fine){.tabulator-row.tabulator-selectable:hover{background-color:#bbb;cursor:pointer}}.tabulator-row.tabulator-selected{background-color:#9abcea}@media (hover:hover) and (pointer:fine){.tabulator-row.tabulator-selected:hover{background-color:#769bcc;cursor:pointer}}.tabulator-row.tabulator-row-moving{background:#fff;border:1px solid #000}.tabulator-row.tabulator-moving{border-bottom:1px solid #aaa;border-top:1px solid #aaa;pointer-events:none;position:absolute;z-index:15}.tabulator-row.tabulator-range-highlight .tabulator-cell.tabulator-range-row-header{background-color:#d6d6d6;color:#000}.tabulator-row.tabulator-range-highlight.tabulator-range-selected .tabulator-cell.tabulator-range-row-header,.tabulator-row.tabulator-range-selected .tabulator-cell.tabulator-range-row-header{background-color:#3876ca;color:#fff}.tabulator-row .tabulator-row-resize-handle{bottom:0;height:5px;left:0;position:absolute;right:0}.tabulator-row .tabulator-row-resize-handle.prev{bottom:auto;top:0}@media (hover:hover) and (pointer:fine){.tabulator-row .tabulator-row-resize-handle:hover{cursor:ns-resize}}.tabulator-row .tabulator-responsive-collapse{border-bottom:1px solid #aaa;border-top:1px solid #aaa;box-sizing:border-box;padding:5px}.tabulator-row .tabulator-responsive-collapse:empty{display:none}.tabulator-row .tabulator-responsive-collapse table{font-size:14px}.tabulator-row .tabulator-responsive-collapse table tr td{position:relative}.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type{padding-right:10px}.tabulator-row .tabulator-cell{border-right:1px solid #aaa;box-sizing:border-box;display:inline-block;outline:none;overflow:hidden;padding:4px;position:relative;text-overflow:ellipsis;vertical-align:middle;white-space:nowrap}.tabulator-row .tabulator-cell.tabulator-row-header{background:#e6e6e6;border-bottom:1px solid #aaa;border-right:1px solid #999}.tabulator-row .tabulator-cell.tabulator-frozen{background-color:inherit;display:inline-block;left:0;position:sticky;z-index:11}.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left{border-right:2px solid #aaa}.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right{border-left:2px solid #aaa}.tabulator-row .tabulator-cell.tabulator-editing{border:1px solid #1d68cd;outline:none;padding:0}.tabulator-row .tabulator-cell.tabulator-editing input,.tabulator-row .tabulator-cell.tabulator-editing select{background:transparent;border:1px;outline:none}.tabulator-row .tabulator-cell.tabulator-validation-fail{border:1px solid #d00}.tabulator-row .tabulator-cell.tabulator-validation-fail input,.tabulator-row .tabulator-cell.tabulator-validation-fail select{background:transparent;border:1px;color:#d00}.tabulator-row .tabulator-cell.tabulator-row-handle{align-items:center;display:inline-flex;justify-content:center;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none}.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box{width:80%}.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar{background:#666;height:3px;margin-top:2px;width:100%}.tabulator-row .tabulator-cell.tabulator-range-selected:not(.tabulator-range-only-cell-selected):not(.tabulator-range-row-header){background-color:#9abcea}.tabulator-row .tabulator-cell .tabulator-data-tree-branch-empty{display:inline-block;width:7px}.tabulator-row .tabulator-cell .tabulator-data-tree-branch{border-bottom:2px solid #aaa;border-bottom-left-radius:1px;border-left:2px solid #aaa;display:inline-block;height:9px;margin-right:5px;margin-top:-9px;vertical-align:middle;width:7px}.tabulator-row .tabulator-cell .tabulator-data-tree-control{align-items:center;background:rgba(0,0,0,.1);border:1px solid #333;border-radius:2px;display:inline-flex;height:11px;justify-content:center;margin-right:5px;overflow:hidden;vertical-align:middle;width:11px}@media (hover:hover) and (pointer:fine){.tabulator-row .tabulator-cell .tabulator-data-tree-control:hover{background:rgba(0,0,0,.2);cursor:pointer}}.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse{background:transparent;display:inline-block;height:7px;position:relative;width:1px}.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after{background:#333;content:"";height:1px;left:-3px;position:absolute;top:3px;width:7px}.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand{background:#333;display:inline-block;height:7px;position:relative;width:1px}.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after{background:#333;content:"";height:1px;left:-3px;position:absolute;top:3px;width:7px}.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle{align-items:center;background:#666;border-radius:20px;color:#fff;display:inline-flex;font-size:1.1em;font-weight:700;height:15px;justify-content:center;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-o-user-select:none;width:15px}@media (hover:hover) and (pointer:fine){.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover{cursor:pointer;opacity:.7}}.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close{display:initial}.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open{display:none}.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg{stroke:#fff}.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close{display:none}.tabulator-row .tabulator-cell .tabulator-traffic-light{border-radius:14px;display:inline-block;height:14px;width:14px}.tabulator-row.tabulator-group{background:#ccc;border-bottom:1px solid #999;border-right:1px solid #aaa;border-top:1px solid #999;box-sizing:border-box;font-weight:700;min-width:100%;padding:5px 5px 5px 10px}@media (hover:hover) and (pointer:fine){.tabulator-row.tabulator-group:hover{background-color:rgba(0,0,0,.1);cursor:pointer}}.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow{border-bottom:0;border-left:6px solid transparent;border-right:6px solid transparent;border-top:6px solid #666;margin-right:10px}.tabulator-row.tabulator-group.tabulator-group-level-1{padding-left:30px}.tabulator-row.tabulator-group.tabulator-group-level-2{padding-left:50px}.tabulator-row.tabulator-group.tabulator-group-level-3{padding-left:70px}.tabulator-row.tabulator-group.tabulator-group-level-4{padding-left:90px}.tabulator-row.tabulator-group.tabulator-group-level-5{padding-left:110px}.tabulator-row.tabulator-group .tabulator-group-toggle{display:inline-block}.tabulator-row.tabulator-group .tabulator-arrow{border-bottom:6px solid transparent;border-left:6px solid #666;border-right:0;border-top:6px solid transparent;display:inline-block;height:0;margin-right:16px;vertical-align:middle;width:0}.tabulator-row.tabulator-group span{color:#d00;margin-left:10px}.tabulator-toggle{background:#dcdcdc;border:1px solid #ccc;box-sizing:border-box;display:flex;flex-direction:row}.tabulator-toggle.tabulator-toggle-on{background:#1c6cc2}.tabulator-toggle .tabulator-toggle-switch{background:#fff;border:1px solid #ccc;box-sizing:border-box}.tabulator-popup-container{-webkit-overflow-scrolling:touch;background:#fff;border:1px solid #aaa;box-shadow:0 0 5px 0 rgba(0,0,0,.2);box-sizing:border-box;display:inline-block;font-size:14px;overflow-y:auto;position:absolute;z-index:10000}.tabulator-popup{border-radius:3px;padding:5px}.tabulator-tooltip{border-radius:2px;box-shadow:none;font-size:12px;max-width:Min(500px,100%);padding:3px 5px;pointer-events:none}.tabulator-menu .tabulator-menu-item{box-sizing:border-box;padding:5px 10px;position:relative;user-select:none}.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled{opacity:.5}@media (hover:hover) and (pointer:fine){.tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover{background:#efefef;cursor:pointer}}.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu{padding-right:25px}.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu:after{border-color:#aaa;border-style:solid;border-width:1px 1px 0 0;content:"";display:inline-block;height:7px;position:absolute;right:10px;top:calc(5px + .4em);transform:rotate(45deg);vertical-align:top;width:7px}.tabulator-menu .tabulator-menu-separator{border-top:1px solid #aaa}.tabulator-edit-list{-webkit-overflow-scrolling:touch;font-size:14px;max-height:200px;overflow-y:auto}.tabulator-edit-list .tabulator-edit-list-item{color:#333;outline:none;padding:4px}.tabulator-edit-list .tabulator-edit-list-item.active{background:#1d68cd;color:#fff}.tabulator-edit-list .tabulator-edit-list-item.active.focused{outline:1px solid hsla(0,0%,100%,.5)}.tabulator-edit-list .tabulator-edit-list-item.focused{outline:1px solid #1d68cd}@media (hover:hover) and (pointer:fine){.tabulator-edit-list .tabulator-edit-list-item:hover{background:#1d68cd;color:#fff;cursor:pointer}}.tabulator-edit-list .tabulator-edit-list-placeholder{color:#333;padding:4px;text-align:center}.tabulator-edit-list .tabulator-edit-list-group{border-bottom:1px solid #aaa;color:#333;font-weight:700;padding:6px 4px 4px}.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2,.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2{padding-left:12px}.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3,.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3{padding-left:20px}.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4,.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4{padding-left:28px}.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5,.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5{padding-left:36px}.tabulator.tabulator-ltr{direction:ltr}.tabulator.tabulator-rtl{direction:rtl;text-align:initial}.tabulator.tabulator-rtl .tabulator-header .tabulator-col{border-left:1px solid #aaa;border-right:initial;text-align:initial}.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols{margin-left:-1px;margin-right:0}.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title{padding-left:25px;padding-right:0}.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter{left:8px;right:auto}.tabulator.tabulator-rtl .tabulator-tableholder .tabulator-range-overlay .tabulator-range.tabulator-range-active:after{background-color:#2975dd;border-radius:999px;bottom:-3px;content:"";height:6px;left:-3px;position:absolute;right:auto;width:6px}.tabulator.tabulator-rtl .tabulator-row .tabulator-cell{border-left:1px solid #aaa;border-right:initial}.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch{border-bottom-left-radius:0;border-bottom-right-radius:1px;border-left:initial;border-right:2px solid #aaa;margin-left:5px;margin-right:0}.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control{margin-left:5px;margin-right:0}.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left{border-left:2px solid #aaa}.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right{border-right:2px solid #aaa}.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type{margin-left:0;margin-right:-3px;width:3px}.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder{text-align:initial}.tabulator-print-fullscreen{bottom:0;left:0;position:absolute;right:0;top:0;z-index:10000}body.tabulator-print-fullscreen-hide>:not(.tabulator-print-fullscreen){display:none!important}.tabulator-print-table{border-collapse:collapse}.tabulator-print-table .tabulator-data-tree-branch{border-bottom:2px solid #aaa;border-bottom-left-radius:1px;border-left:2px solid #aaa;display:inline-block;height:9px;margin-right:5px;margin-top:-9px;vertical-align:middle;width:7px}.tabulator-print-table .tabulator-print-table-group{background:#ccc;border-bottom:1px solid #999;border-right:1px solid #aaa;border-top:1px solid #999;box-sizing:border-box;font-weight:700;min-width:100%;padding:5px 5px 5px 10px}@media (hover:hover) and (pointer:fine){.tabulator-print-table .tabulator-print-table-group:hover{background-color:rgba(0,0,0,.1);cursor:pointer}}.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow{border-bottom:0;border-left:6px solid transparent;border-right:6px solid transparent;border-top:6px solid #666;margin-right:10px}.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td{padding-left:30px!important}.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td{padding-left:50px!important}.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td{padding-left:70px!important}.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td{padding-left:90px!important}.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td{padding-left:110px!important}.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle{display:inline-block}.tabulator-print-table .tabulator-print-table-group .tabulator-arrow{border-bottom:6px solid transparent;border-left:6px solid #666;border-right:0;border-top:6px solid transparent;display:inline-block;height:0;margin-right:16px;vertical-align:middle;width:0}.tabulator-print-table .tabulator-print-table-group span{color:#d00;margin-left:10px}.tabulator-print-table .tabulator-data-tree-control{align-items:center;background:rgba(0,0,0,.1);border:1px solid #333;border-radius:2px;display:inline-flex;height:11px;justify-content:center;margin-right:5px;overflow:hidden;vertical-align:middle;width:11px}@media (hover:hover) and (pointer:fine){.tabulator-print-table .tabulator-data-tree-control:hover{background:rgba(0,0,0,.2);cursor:pointer}}.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse{background:transparent;display:inline-block;height:7px;position:relative;width:1px}.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after{background:#333;content:"";height:1px;left:-3px;position:absolute;top:3px;width:7px}.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand{background:#333;display:inline-block;height:7px;position:relative;width:1px}.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after{background:#333;content:"";height:1px;left:-3px;position:absolute;top:3px;width:7px}\n/*# sourceMappingURL=tabulator.min.css.map */\n/* Keyboard shortcut styling */\nkbd[data-v-20184428] {\n  display: inline-block;\n  padding: 2px 6px;\n  font-family: monospace;\n  font-size: 12px;\n  line-height: 1.4;\n  color: #333;\n  background-color: #f7f7f7;\n  border: 1px solid #ccc;\n  border-radius: 3px;\n  box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);\n  margin: 0 2px;\n}\n.tabulator[data-v-20184428] {\n  font-size: 14px;\n}\n\n/* Sticky header */\n.tabulator .tabulator-header[data-v-20184428] {\n  position: sticky;\n  top: 0;\n  z-index: 10;\n  background-color: #fff;\n}\n.tabulator .tabulator-header .tabulator-col[data-v-20184428] {\n  padding-left: 20px;\n  padding-right: 20px;\n  white-space: nowrap;\n}\n.tabulator .tabulator-cell[data-v-20184428] {\n  padding: 8px;\n  text-align: left;\n}\n.tabulator .tabulator-cell[tabulator-field="import_status"][data-v-20184428],\n.tabulator .tabulator-cell[tabulator-field="import_info"][data-v-20184428],\n.tabulator .tabulator-col[tabulator-field="import_status"][data-v-20184428],\n.tabulator .tabulator-col[tabulator-field="import_info"][data-v-20184428] {\n  color: rgba(0, 0, 0, 0.5);\n  pointer-events: none !important;\n  user-select: none !important;\n  background-color: #f8f9fa !important;\n  cursor: not-allowed !important;\n}\n\n/* Row header (row numbers) styling */\n.tabulator .tabulator-row-handle[data-v-20184428] {\n  background-color: transparent;\n  text-align: center;\n  font-weight: normal;\n  color: #adb5bd;\n  border-right: 1px solid #e9ecef;\n  padding: 8px 4px;\n  width: 50px;\n}\n.tabulator .tabulator-row-handle-box[data-v-20184428] {\n  background-color: transparent;\n}\n\n/* Range selection styling */\n.tabulator .tabulator-range-selected[data-v-20184428] {\n  background-color: rgba(0, 123, 255, 0.15) !important;\n  border: 2px solid #007bff;\n}\n.tabulator .tabulator-range-active[data-v-20184428] {\n  background-color: rgba(0, 123, 255, 0.25) !important;\n  outline: 2px solid #007bff;\n  outline-offset: -2px;\n}\n\n/* Make focused cell more visible for keyboard navigation */\n.tabulator .tabulator-cell.tabulator-focused[data-v-20184428] {\n  outline: 2px solid #007bff;\n  outline-offset: -2px;\n}\n\n/* Cell being edited - different highlight */\n.tabulator .tabulator-cell.tabulator-editing[data-v-20184428] {\n  outline: 2px solid #28a745 !important;\n  outline-offset: -2px;\n  background-color: #f0fff4 !important;\n}\n.resize-observer[data-v-b329ee4c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}.resize-observer[data-v-b329ee4c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}.v-popper__popper{z-index:10000;top:0;left:0;outline:none}.v-popper__popper.v-popper__popper--hidden{visibility:hidden;opacity:0;transition:opacity .15s,visibility .15s;pointer-events:none}.v-popper__popper.v-popper__popper--shown{visibility:visible;opacity:1;transition:opacity .15s}.v-popper__popper.v-popper__popper--skip-transition,.v-popper__popper.v-popper__popper--skip-transition>.v-popper__wrapper{transition:none!important}.v-popper__backdrop{position:absolute;top:0;left:0;width:100%;height:100%;display:none}.v-popper__inner{position:relative;box-sizing:border-box;overflow-y:auto}.v-popper__inner>div{position:relative;z-index:1;max-width:inherit;max-height:inherit}.v-popper__arrow-container{position:absolute;width:10px;height:10px}.v-popper__popper--arrow-overflow .v-popper__arrow-container,.v-popper__popper--no-positioning .v-popper__arrow-container{display:none}.v-popper__arrow-inner,.v-popper__arrow-outer{border-style:solid;position:absolute;top:0;left:0;width:0;height:0}.v-popper__arrow-inner{visibility:hidden;border-width:7px}.v-popper__arrow-outer{border-width:6px}.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-inner{left:-2px}.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-outer,.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-outer{left:-1px}.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-outer{border-bottom-width:0;border-left-color:transparent!important;border-right-color:transparent!important;border-bottom-color:transparent!important}.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-inner{top:-2px}.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-container{top:0}.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-outer{border-top-width:0;border-left-color:transparent!important;border-right-color:transparent!important;border-top-color:transparent!important}.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-inner{top:-4px}.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-outer{top:-6px}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-inner{top:-2px}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-outer,.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-outer{top:-1px}.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-outer{border-left-width:0;border-left-color:transparent!important;border-top-color:transparent!important;border-bottom-color:transparent!important}.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-inner{left:-4px}.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-outer{left:-6px}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-container{right:-10px}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-outer{border-right-width:0;border-top-color:transparent!important;border-right-color:transparent!important;border-bottom-color:transparent!important}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-inner{left:-2px}.v-popper--theme-tooltip .v-popper__inner{background:rgba(0,0,0,.8);color:#fff;border-radius:6px;padding:7px 12px 6px}.v-popper--theme-tooltip .v-popper__arrow-outer{border-color:#000c}.v-popper--theme-dropdown .v-popper__inner{background:#fff;color:#000;border-radius:6px;border:1px solid #ddd;box-shadow:0 6px 30px #0000001a}.v-popper--theme-dropdown .v-popper__arrow-inner{visibility:visible;border-color:#fff}.v-popper--theme-dropdown .v-popper__arrow-outer{border-color:#ddd}\n.toggle-container{display:inline-block}.toggle-container:focus{box-shadow:0 0 0 var(--toggle-ring-width,3px) var(--toggle-ring-color,rgba(16,185,129,.188));outline:none}.toggle{align-items:center;border:var(--toggle-border,.125rem) solid;border-radius:999px;box-sizing:content-box;cursor:pointer;display:flex;font-size:var(--toggle-font-size,.75rem);height:var(--toggle-height,1.25rem);line-height:1;position:relative;transition:all .3s;width:var(--toggle-width,3rem)}.toggle-on{background:var(--toggle-bg-on,#10b981);border-color:var(--toggle-border-on,#10b981);color:var(--toggle-text-on,#fff);justify-content:flex-start}.toggle-off{background:var(--toggle-bg-off,#e5e7eb);border-color:var(--toggle-border-off,#e5e7eb);color:var(--toggle-text-off,#374151);justify-content:flex-end}.toggle-on-disabled{background:var(--toggle-bg-on-disabled,#d1d5db);border-color:var(--toggle-border-on-disabled,#d1d5db);color:var(--toggle-text-on-disabled,#9ca3af);cursor:not-allowed;justify-content:flex-start}.toggle-off-disabled{background:var(--toggle-bg-off-disabled,#e5e7eb);border-color:var(--toggle-border-off-disabled,#e5e7eb);color:var(--toggle-text-off-disabled,#9ca3af);cursor:not-allowed;justify-content:flex-end}.toggle-handle{background:var(--toggle-handle-enabled,#fff);border-radius:50%;display:inline-block;height:var(--toggle-height,1.25rem);position:absolute;top:0;transition-duration:var(--toggle-duration,.15s);transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);width:var(--toggle-height,1.25rem)}.toggle-handle-on{left:100%;transform:translateX(-100%)}.toggle-handle-off{left:0}.toggle-handle-on-disabled{background:var(--toggle-handle-disabled,#f3f4f6);left:100%;transform:translateX(-100%)}.toggle-handle-off-disabled{background:var(--toggle-handle-disabled,#f3f4f6);left:0}.toggle-label{box-sizing:border-box;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap;width:calc(var(--toggle-width, 3.25rem) - var(--toggle-height, 1.25rem))}:root{--vs-colors--lightest: rgba(60, 60, 60, .26);--vs-colors--light: rgba(60, 60, 60, .5);--vs-colors--dark: #333;--vs-colors--darkest: rgba(0, 0, 0, .15);--vs-search-input-color: inherit;--vs-search-input-placeholder-color: inherit;--vs-font-size: 1rem;--vs-line-height: 1.4;--vs-state-disabled-bg: rgb(248, 248, 248);--vs-state-disabled-color: var(--vs-colors--light);--vs-state-disabled-controls-color: var(--vs-colors--light);--vs-state-disabled-cursor: not-allowed;--vs-border-color: var(--vs-colors--lightest);--vs-border-width: 1px;--vs-border-style: solid;--vs-border-radius: 4px;--vs-actions-padding: 4px 6px 0 3px;--vs-controls-color: var(--vs-colors--light);--vs-controls-size: 1;--vs-controls--deselect-text-shadow: 0 1px 0 #fff;--vs-selected-bg: #f0f0f0;--vs-selected-color: var(--vs-colors--dark);--vs-selected-border-color: var(--vs-border-color);--vs-selected-border-style: var(--vs-border-style);--vs-selected-border-width: var(--vs-border-width);--vs-dropdown-bg: #fff;--vs-dropdown-color: inherit;--vs-dropdown-z-index: 1000;--vs-dropdown-min-width: 160px;--vs-dropdown-max-height: 350px;--vs-dropdown-box-shadow: 0px 3px 6px 0px var(--vs-colors--darkest);--vs-dropdown-option-bg: #000;--vs-dropdown-option-color: var(--vs-dropdown-color);--vs-dropdown-option-padding: 3px 20px;--vs-dropdown-option--active-bg: #5897fb;--vs-dropdown-option--active-color: #fff;--vs-dropdown-option--deselect-bg: #fb5858;--vs-dropdown-option--deselect-color: #fff;--vs-transition-timing-function: cubic-bezier(1, -.115, .975, .855);--vs-transition-duration: .15s}.v-select{position:relative;font-family:inherit}.v-select,.v-select *{box-sizing:border-box}:root{--vs-transition-timing-function: cubic-bezier(1, .5, .8, 1);--vs-transition-duration: .15s}@-webkit-keyframes vSelectSpinner{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes vSelectSpinner{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.vs__fade-enter-active,.vs__fade-leave-active{pointer-events:none;transition:opacity var(--vs-transition-duration) var(--vs-transition-timing-function)}.vs__fade-enter,.vs__fade-leave-to{opacity:0}:root{--vs-disabled-bg: var(--vs-state-disabled-bg);--vs-disabled-color: var(--vs-state-disabled-color);--vs-disabled-cursor: var(--vs-state-disabled-cursor)}.vs--disabled .vs__dropdown-toggle,.vs--disabled .vs__clear,.vs--disabled .vs__search,.vs--disabled .vs__selected,.vs--disabled .vs__open-indicator{cursor:var(--vs-disabled-cursor);background-color:var(--vs-disabled-bg)}.v-select[dir=rtl] .vs__actions{padding:0 3px 0 6px}.v-select[dir=rtl] .vs__clear{margin-left:6px;margin-right:0}.v-select[dir=rtl] .vs__deselect{margin-left:0;margin-right:2px}.v-select[dir=rtl] .vs__dropdown-menu{text-align:right}.vs__dropdown-toggle{-webkit-appearance:none;-moz-appearance:none;appearance:none;display:flex;padding:0 0 4px;background:none;border:var(--vs-border-width) var(--vs-border-style) var(--vs-border-color);border-radius:var(--vs-border-radius);white-space:normal}.vs__selected-options{display:flex;flex-basis:100%;flex-grow:1;flex-wrap:wrap;padding:0 2px;position:relative}.vs__actions{display:flex;align-items:center;padding:var(--vs-actions-padding)}.vs--searchable .vs__dropdown-toggle{cursor:text}.vs--unsearchable .vs__dropdown-toggle{cursor:pointer}.vs--open .vs__dropdown-toggle{border-bottom-color:transparent;border-bottom-left-radius:0;border-bottom-right-radius:0}.vs__open-indicator{fill:var(--vs-controls-color);transform:scale(var(--vs-controls-size));transition:transform var(--vs-transition-duration) var(--vs-transition-timing-function);transition-timing-function:var(--vs-transition-timing-function)}.vs--open .vs__open-indicator{transform:rotate(180deg) scale(var(--vs-controls-size))}.vs--loading .vs__open-indicator{opacity:0}.vs__clear{fill:var(--vs-controls-color);padding:0;border:0;background-color:transparent;cursor:pointer;margin-right:8px}.vs__dropdown-menu{display:block;box-sizing:border-box;position:absolute;top:calc(100% - var(--vs-border-width));left:0;z-index:var(--vs-dropdown-z-index);padding:5px 0;margin:0;width:100%;max-height:var(--vs-dropdown-max-height);min-width:var(--vs-dropdown-min-width);overflow-y:auto;box-shadow:var(--vs-dropdown-box-shadow);border:var(--vs-border-width) var(--vs-border-style) var(--vs-border-color);border-top-style:none;border-radius:0 0 var(--vs-border-radius) var(--vs-border-radius);text-align:left;list-style:none;background:var(--vs-dropdown-bg);color:var(--vs-dropdown-color)}.vs__no-options{text-align:center}.vs__dropdown-option{line-height:1.42857143;display:block;padding:var(--vs-dropdown-option-padding);clear:both;color:var(--vs-dropdown-option-color);white-space:nowrap;cursor:pointer}.vs__dropdown-option--highlight{background:var(--vs-dropdown-option--active-bg);color:var(--vs-dropdown-option--active-color)}.vs__dropdown-option--deselect{background:var(--vs-dropdown-option--deselect-bg);color:var(--vs-dropdown-option--deselect-color)}.vs__dropdown-option--disabled{background:var(--vs-state-disabled-bg);color:var(--vs-state-disabled-color);cursor:var(--vs-state-disabled-cursor)}.vs__selected{display:flex;align-items:center;background-color:var(--vs-selected-bg);border:var(--vs-selected-border-width) var(--vs-selected-border-style) var(--vs-selected-border-color);border-radius:var(--vs-border-radius);color:var(--vs-selected-color);line-height:var(--vs-line-height);margin:4px 2px 0;padding:0 .25em;z-index:0}.vs__deselect{display:inline-flex;-webkit-appearance:none;-moz-appearance:none;appearance:none;margin-left:4px;padding:0;border:0;cursor:pointer;background:none;fill:var(--vs-controls-color);text-shadow:var(--vs-controls--deselect-text-shadow)}.vs--single .vs__selected{background-color:transparent;border-color:transparent}.vs--single.vs--open .vs__selected,.vs--single.vs--loading .vs__selected{position:absolute;opacity:.4}.vs--single.vs--searching .vs__selected{display:none}.vs__search::-webkit-search-cancel-button{display:none}.vs__search::-webkit-search-decoration,.vs__search::-webkit-search-results-button,.vs__search::-webkit-search-results-decoration,.vs__search::-ms-clear{display:none}.vs__search,.vs__search:focus{color:var(--vs-search-input-color);-webkit-appearance:none;-moz-appearance:none;appearance:none;line-height:var(--vs-line-height);font-size:var(--vs-font-size);border:1px solid transparent;border-left:none;outline:none;margin:4px 0 0;padding:0 7px;background:none;box-shadow:none;width:0;max-width:100%;flex-grow:1;z-index:1}.vs__search::-moz-placeholder{color:var(--vs-search-input-placeholder-color)}.vs__search::placeholder{color:var(--vs-search-input-placeholder-color)}.vs--unsearchable .vs__search{opacity:1}.vs--unsearchable:not(.vs--disabled) .vs__search{cursor:pointer}.vs--single.vs--searching:not(.vs--open):not(.vs--loading) .vs__search{opacity:.2}.vs__spinner{align-self:center;opacity:0;font-size:5px;text-indent:-9999em;overflow:hidden;border-top:.9em solid rgba(100,100,100,.1);border-right:.9em solid rgba(100,100,100,.1);border-bottom:.9em solid rgba(100,100,100,.1);border-left:.9em solid rgba(60,60,60,.45);transform:translateZ(0) scale(var(--vs-controls--spinner-size, var(--vs-controls-size)));-webkit-animation:vSelectSpinner 1.1s infinite linear;animation:vSelectSpinner 1.1s infinite linear;transition:opacity .1s}.vs__spinner,.vs__spinner:after{border-radius:50%;width:5em;height:5em;transform:scale(var(--vs-controls--spinner-size, var(--vs-controls-size)))}.vs--loading .vs__spinner{opacity:1}\n.vfm--fixed{position:fixed}.vfm--absolute{position:absolute}.vfm--inset{top:0;right:0;bottom:0;left:0}.vfm--overlay{z-index:-1;background-color:#00000080}.vfm--prevent-none{pointer-events:none}.vfm--prevent-auto{pointer-events:auto}.vfm--outline-none:focus{outline:none}@keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-out{0%{opacity:1}to{opacity:0}}.vfm-fade-enter-active{animation:fade-in .3s ease}.vfm-fade-leave-active{animation:fade-out .3s ease}.vfm-bounce-back{transition-property:transform;transition-duration:.3s}.vfm-slide-up-enter-active,.vfm-slide-up-leave-active,.vfm-slide-down-enter-active,.vfm-slide-down-leave-active{transition:transform .3s ease}.vfm-slide-down-enter-from,.vfm-slide-down-leave-to{transform:translateY(100vh)!important}.vfm-slide-up-enter-from,.vfm-slide-up-leave-to{transform:translateY(-100vh)!important}.vfm-slide-right-enter-active,.vfm-slide-right-leave-active,.vfm-slide-left-enter-active,.vfm-slide-left-leave-active{transition:transform .3s ease}.vfm-slide-right-enter-from,.vfm-slide-right-leave-to{transform:translate(100vw)!important}.vfm-slide-left-enter-from,.vfm-slide-left-leave-to{transform:translate(-100vw)!important}.vfm-swipe-banner-back,.vfm-swipe-banner-forward{position:fixed;top:0;bottom:0;width:27px;z-index:10}.vfm-swipe-banner-back{left:0}.vfm-swipe-banner-forward{right:0}\n/*$vite$:1*/';
  document.head.appendChild(__vite_style__);
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(",")) map[key] = 1;
    return (val) => val in map;
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend$1 = Object.assign;
  const remove = (arr, el) => {
    const i2 = arr.indexOf(el);
    if (i2 > -1) {
      arr.splice(i2, 1);
    }
  };
  const hasOwnProperty$b = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty$b.call(val, key);
  const isArray$2 = Array.isArray;
  const isMap$1 = (val) => toTypeString(val) === "[object Map]";
  const isSet$1 = (val) => toTypeString(val) === "[object Set]";
  const isDate$2 = (val) => toTypeString(val) === "[object Date]";
  const isFunction$3 = (val) => typeof val === "function";
  const isString$1 = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isObject$3 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject$3(val) || isFunction$3(val)) && isFunction$3(val.then) && isFunction$3(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString = (value) => objectToString$1.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$3 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return ((str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    });
  };
  const camelizeRE = /-\w/g;
  const camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (c2) => c2.slice(1).toUpperCase());
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction(
    (str) => {
      const s2 = str ? `on${capitalize(str)}` : ``;
      return s2;
    }
  );
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i2 = 0; i2 < fns.length; i2++) {
      fns[i2](...arg);
    }
  };
  const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val) => {
    const n2 = parseFloat(val);
    return isNaN(n2) ? val : n2;
  };
  const toNumber = (val) => {
    const n2 = isString$1(val) ? Number(val) : NaN;
    return isNaN(n2) ? val : n2;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray$2(value)) {
      const res = {};
      for (let i2 = 0; i2 < value.length; i2++) {
        const item = value[i2];
        const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString$1(value) || isObject$3(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$1(value)) {
      res = value;
    } else if (isArray$2(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        const normalized = normalizeClass(value[i2]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$3(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps(props) {
    if (!props) return null;
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (style) {
      props.style = normalizeStyle(style);
    }
    return props;
  }
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  function looseCompareArrays(a2, b2) {
    if (a2.length !== b2.length) return false;
    let equal = true;
    for (let i2 = 0; equal && i2 < a2.length; i2++) {
      equal = looseEqual(a2[i2], b2[i2]);
    }
    return equal;
  }
  function looseEqual(a2, b2) {
    if (a2 === b2) return true;
    let aValidType = isDate$2(a2);
    let bValidType = isDate$2(b2);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
    }
    aValidType = isSymbol(a2);
    bValidType = isSymbol(b2);
    if (aValidType || bValidType) {
      return a2 === b2;
    }
    aValidType = isArray$2(a2);
    bValidType = isArray$2(b2);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
    }
    aValidType = isObject$3(a2);
    bValidType = isObject$3(b2);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a2).length;
      const bKeysCount = Object.keys(b2).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a2) {
        const aHasKey = a2.hasOwnProperty(key);
        const bHasKey = b2.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
          return false;
        }
      }
    }
    return String(a2) === String(b2);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  const isRef$1 = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString = (val) => {
    return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$3(val) && (val.toString === objectToString$1 || !isFunction$3(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap$1(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i2) => {
            entries[stringifySymbol(key, i2) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet$1(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject$3(val) && !isArray$2(val) && !isPlainObject$3(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v2, i2 = "") => {
    var _a2;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i2})` : v2
    );
  };
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this._on = 0;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i2, l2;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].pause();
          }
        }
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i2, l2;
          if (this.scopes) {
            for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
              this.scopes[i2].resume();
            }
          }
          for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
            this.effects[i2].resume();
          }
        }
      }
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      if (++this._on === 1) {
        this.prevScope = activeEffectScope;
        activeEffectScope = this;
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      if (this._on > 0 && --this._on === 0) {
        activeEffectScope = this.prevScope;
        this.prevScope = void 0;
      }
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i2, l2;
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].stop();
        }
        this.effects.length = 0;
        for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
          this.cleanups[i2]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last2 = this.parent.scopes.pop();
          if (last2 && last2 !== this) {
            this.parent.scopes[this.index] = last2;
            last2.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn, failSilently = false) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    }
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link2 = this.deps; link2; link2 = link2.nextDep) {
          removeSub(link2);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedSub;
  let batchedComputed;
  function batch(sub, isComputed2 = false) {
    sub.flags |= 8;
    if (isComputed2) {
      sub.next = batchedComputed;
      batchedComputed = sub;
      return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e = batchedComputed;
      batchedComputed = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        e = next;
      }
    }
    let error;
    while (batchedSub) {
      let e = batchedSub;
      batchedSub = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        if (e.flags & 1) {
          try {
            ;
            e.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e = next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (let link2 = sub.deps; link2; link2 = link2.nextDep) {
      link2.version = -1;
      link2.prevActiveLink = link2.dep.activeLink;
      link2.dep.activeLink = link2;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    let link2 = tail;
    while (link2) {
      const prev = link2.prevDep;
      if (link2.version === -1) {
        if (link2 === tail) tail = prev;
        removeSub(link2);
        removeDep(link2);
      } else {
        head = link2;
      }
      link2.dep.activeLink = link2.prevActiveLink;
      link2.prevActiveLink = void 0;
      link2 = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link2 = sub.deps; link2; link2 = link2.nextDep) {
      if (link2.dep.version !== link2.version || link2.dep.computed && (refreshComputed(link2.dep.computed) || link2.dep.version !== link2.version)) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= -17;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
      return;
    }
    computed2.flags |= 2;
    const dep = computed2.dep;
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2.flags |= 128;
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= -3;
    }
  }
  function removeSub(link2, soft = false) {
    const { dep, prevSub, nextSub } = link2;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link2.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link2.nextSub = void 0;
    }
    if (dep.subs === link2) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l2 = dep.computed.deps; l2; l2 = l2.nextDep) {
          removeSub(l2, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link2) {
    const { prevDep, nextDep } = link2;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link2.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link2.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last2 = trackStack.pop();
    shouldTrack = last2 === void 0 ? true : last2;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Link {
    constructor(sub, dep) {
      this.sub = sub;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class Dep {
    // TODO isolatedDeclarations "__v_skip"
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
      this.__v_skip = true;
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link2 = this.activeLink;
      if (link2 === void 0 || link2.sub !== activeSub) {
        link2 = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link2;
        } else {
          link2.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link2;
          activeSub.depsTail = link2;
        }
        addSub(link2);
      } else if (link2.version === -1) {
        link2.version = this.version;
        if (link2.nextDep) {
          const next = link2.nextDep;
          next.prevDep = link2.prevDep;
          if (link2.prevDep) {
            link2.prevDep.nextDep = next;
          }
          link2.prevDep = activeSub.depsTail;
          link2.nextDep = void 0;
          activeSub.depsTail.nextDep = link2;
          activeSub.depsTail = link2;
          if (activeSub.deps === link2) {
            activeSub.deps = next;
          }
        }
      }
      return link2;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (false) ;
        for (let link2 = this.subs; link2; link2 = link2.prevSub) {
          if (link2.sub.notify()) {
            ;
            link2.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link2) {
    link2.dep.sc++;
    if (link2.sub.flags & 4) {
      const computed2 = link2.dep.computed;
      if (computed2 && !link2.dep.subs) {
        computed2.flags |= 4 | 16;
        for (let l2 = computed2.deps; l2; l2 = l2.nextDep) {
          addSub(l2);
        }
      }
      const currentTail = link2.dep.subs;
      if (currentTail !== link2) {
        link2.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link2;
      }
      link2.dep.subs = link2;
    }
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = /* @__PURE__ */ Symbol(
    ""
  );
  const MAP_KEY_ITERATE_KEY = /* @__PURE__ */ Symbol(
    ""
  );
  const ARRAY_ITERATE_KEY = /* @__PURE__ */ Symbol(
    ""
  );
  function track(target, type, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
        dep.map = depsMap;
        dep.key = key;
      }
      {
        dep.track();
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run = (dep) => {
      if (dep) {
        {
          dep.trigger();
        }
      }
    };
    startBatch();
    if (type === "clear") {
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray$2(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
            run(dep);
          }
        });
      } else {
        if (key !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key));
        }
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type) {
          case "add":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$1(target)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function getDepFromReactive(object, key) {
    const depMap = targetMap.get(object);
    return depMap && depMap.get(key);
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  function toWrapped(target, item) {
    if (isReadonly(target)) {
      return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);
    }
    return toReactive(item);
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator$1(this, Symbol.iterator, (item) => toWrapped(this, item));
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x2) => isArray$2(x2) ? reactiveReadArray(x2) : x2)
      );
    },
    entries() {
      return iterator$1(this, "entries", (value) => {
        value[1] = toWrapped(this, value[1]);
        return value;
      });
    },
    every(fn, thisArg) {
      return apply(this, "every", fn, thisArg, void 0, arguments);
    },
    filter(fn, thisArg) {
      return apply(
        this,
        "filter",
        fn,
        thisArg,
        (v2) => v2.map((item) => toWrapped(this, item)),
        arguments
      );
    },
    find(fn, thisArg) {
      return apply(
        this,
        "find",
        fn,
        thisArg,
        (item) => toWrapped(this, item),
        arguments
      );
    },
    findIndex(fn, thisArg) {
      return apply(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast(fn, thisArg) {
      return apply(
        this,
        "findLast",
        fn,
        thisArg,
        (item) => toWrapped(this, item),
        arguments
      );
    },
    findLastIndex(fn, thisArg) {
      return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn, thisArg) {
      return apply(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimization required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn, thisArg) {
      return apply(this, "map", fn, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn, ...args) {
      return reduce(this, "reduce", fn, args);
    },
    reduceRight(fn, ...args) {
      return reduce(this, "reduceRight", fn, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn, thisArg) {
      return apply(this, "some", fn, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator$1(this, "values", (item) => toWrapped(this, item));
    }
  };
  function iterator$1(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (!result.done) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto$1 = Array.prototype;
  function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto$1[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index2) {
          return fn.call(this, toWrapped(self2, item), index2, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function(item, index2) {
          return fn.call(this, item, index2, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index2) {
          return fn.call(this, acc, toWrapped(self2, item), index2, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function(acc, item, index2) {
          return fn.call(this, acc, item, index2, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  function hasOwnProperty$a(key) {
    if (!isSymbol(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      if (key === "__v_skip") return target["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray$2(target);
      if (!isReadonly2) {
        let fn;
        if (targetIsArray && (fn = arrayInstrumentations[key])) {
          return fn;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty$a;
        }
      }
      const res = Reflect.get(
        target,
        key,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef(target) ? target : receiver
      );
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        const value = targetIsArray && isIntegerKey(key) ? res : res.value;
        return isReadonly2 && isObject$3(value) ? readonly(value) : value;
      }
      if (isObject$3(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      const isArrayWithIntegerKey = isArray$2(target) && isIntegerKey(key);
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return true;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(
        target,
        key,
        value,
        isRef(target) ? target : receiver
      );
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray$2(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      return true;
    }
    deleteProperty(target, key) {
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v2) => Reflect.getPrototypeOf(v2);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap$1(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      },
      get size() {
        const target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return target.size;
      },
      has(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      },
      forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      }
    };
    extend$1(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const proto = getProto(target);
          const hadKey = proto.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger(target, "add", value, value);
          }
          return this;
        },
        set(key, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          }
          const oldValue = get.call(target, key);
          target.set(key, value);
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
          return this;
        },
        delete(key) {
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          }
          get ? get.call(target, key) : void 0;
          const result = target.delete(key);
          if (hadKey) {
            trigger(target, "delete", key, void 0);
          }
          return result;
        },
        clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const result = target.clear();
          if (hadItems) {
            trigger(
              target,
              "clear",
              void 0,
              void 0
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$3(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
  function isRef(r2) {
    return r2 ? r2["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive(value);
      this["__v_isShallow"] = isShallow2;
    }
    get value() {
      {
        this.dep.track();
      }
      return this._value;
    }
    set value(newValue) {
      const oldValue = this._rawValue;
      const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
      newValue = useDirectValue ? newValue : toRaw(newValue);
      if (hasChanged(newValue, oldValue)) {
        this._rawValue = newValue;
        this._value = useDirectValue ? newValue : toReactive(newValue);
        {
          this.dep.trigger();
        }
      }
    }
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object) {
    const ret = isArray$2(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this["__v_isRef"] = true;
      this._value = void 0;
      this._raw = toRaw(_object);
      let shallow = true;
      let obj = _object;
      if (!isArray$2(_object) || !isIntegerKey(String(_key))) {
        do {
          shallow = !isProxy(obj) || isShallow(obj);
        } while (shallow && (obj = obj["__v_raw"]));
      }
      this._shallow = shallow;
    }
    get value() {
      let val = this._object[this._key];
      if (this._shallow) {
        val = unref(val);
      }
      return this._value = val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      if (this._shallow && isRef(this._raw[this._key])) {
        const nestedRef = this._object[this._key];
        if (isRef(nestedRef)) {
          nestedRef.value = newVal;
          return;
        }
      }
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(this._raw, this._key);
    }
  }
  class GetterRefImpl {
    constructor(_getter) {
      this._getter = _getter;
      this["__v_isRef"] = true;
      this["__v_isReadonly"] = true;
      this._value = void 0;
    }
    get value() {
      return this._value = this._getter();
    }
  }
  function toRef(source, key, defaultValue) {
    if (isRef(source)) {
      return source;
    } else if (isFunction$3(source)) {
      return new GetterRefImpl(source);
    } else if (isObject$3(source) && arguments.length > 1) {
      return propertyToRef(source, key, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    return new ObjectRefImpl(source, key, defaultValue);
  }
  class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && // avoid infinite self recursion
      activeSub !== this) {
        batch(this, true);
        return true;
      }
    }
    get value() {
      const link2 = this.dep.track();
      refreshComputed(this);
      if (link2) {
        link2.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction$3(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    }
  }
  function watch$1(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, once, scheduler, augmentJob, call } = options;
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray$2(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
      getter = () => source.map((s2) => {
        if (isRef(s2)) {
          return s2.value;
        } else if (isReactive(s2)) {
          return reactiveGetter(s2);
        } else if (isFunction$3(s2)) {
          return call ? call(s2, 2) : s2();
        } else ;
      });
    } else if (isFunction$3(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope && scope.active) {
        remove(scope.effects, effect2);
      }
    };
    if (once && cb) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            oldValue = newValue;
            call ? call(cb, 3, args) : (
              // @ts-expect-error
              cb(...args)
            );
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject$3(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Map();
    if ((seen.get(value) || 0) >= depth) {
      return value;
    }
    seen.set(value, depth);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray$2(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        traverse(value[i2], depth, seen);
      }
    } else if (isSet$1(value) || isMap$1(value)) {
      value.forEach((v2) => {
        traverse(v2, depth, seen);
      });
    } else if (isPlainObject$3(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }
  const stack = [];
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a2) => {
            var _a2, _b2;
            return (_b2 = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b2 : JSON.stringify(a2);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last2 = normalizedStack[0];
      if (last2 && last2.vnode === currentVNode) {
        last2.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i2) => {
      logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString$1(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction$3(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function callWithErrorHandling(fn, instance, type, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction$3(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray$2(fn)) {
      const values = [];
      for (let i2 = 0; i2 < fn.length; i2++) {
        values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
      }
      return values;
    }
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
            if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
    if (throwInProd) {
      throw err;
    } else {
      console.error(err);
    }
  }
  const queue = [];
  let flushIndex = -1;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
      !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$2(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i2 = flushIndex + 1) {
    for (; i2 < queue.length; i2++) {
      const cb = queue[i2];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        queue.splice(i2, 1);
        i2--;
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a2, b2) => getId(a2) - getId(b2)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        if (!(cb.flags & 8)) cb();
        cb.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (false) ;
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs();
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  const withScopeId = (_id) => withCtx;
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings2 = vnode.dirs || (vnode.dirs = []);
    for (let i2 = 0; i2 < directives.length; i2++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
      if (dir) {
        if (isFunction$3(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings2.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings2 = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i2 = 0; i2 < bindings2.length; i2++) {
      const binding = bindings2[i2];
      if (oldBindings) {
        binding.oldValue = oldBindings[i2].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  function provide(key, value) {
    if (currentInstance) {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = getCurrentInstance();
    if (instance || currentApp) {
      let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else ;
    }
  }
  function hasInjectionContext() {
    return !!(getCurrentInstance() || currentApp);
  }
  const ssrContextKey = /* @__PURE__ */ Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      return ctx;
    }
  };
  function watchEffect(effect2, options) {
    return doWatch(effect2, null, options);
  }
  function watch(source, cb, options) {
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options;
    const baseWatchOptions = extend$1({}, options);
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$3(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i2 = 0; i2 < segments.length && cur; i2++) {
        cur = cur[segments[i2]];
      }
      return cur;
    };
  }
  const TeleportEndKey = /* @__PURE__ */ Symbol("_vte");
  const isTeleport = (type) => type.__isTeleport;
  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
  const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString$1(targetSelector)) {
      if (!select) {
        return null;
      } else {
        const target = select(targetSelector);
        return target;
      }
    } else {
      return targetSelector;
    }
  };
  const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (n1 == null) {
        const placeholder = n2.el = createText("");
        const mainAnchor = n2.anchor = createText("");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountToTarget = () => {
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = prepareAnchor(target, n2, createText, insert);
          if (target) {
            if (namespace !== "svg" && isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace !== "mathml" && isTargetMathML(target)) {
              namespace = "mathml";
            }
            if (parentComponent && parentComponent.isCE) {
              (parentComponent.ce._teleportTargets || (parentComponent.ce._teleportTargets = /* @__PURE__ */ new Set())).add(target);
            }
            if (!disabled) {
              mount(target, targetAnchor);
              updateCssVars(n2, false);
            }
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
          updateCssVars(n2, true);
        }
        if (isTeleportDeferred(n2.props)) {
          n2.el.__isMounted = false;
          queuePostRenderEffect(() => {
            mountToTarget();
            delete n2.el.__isMounted;
          }, parentSuspense);
        } else {
          mountToTarget();
        }
      } else {
        if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
          queuePostRenderEffect(() => {
            TeleportImpl.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          }, parentSuspense);
          return;
        }
        n2.el = n1.el;
        n2.targetStart = n1.targetStart;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
        updateCssVars(n2, disabled);
      }
    },
    remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const {
        shapeFlag,
        children,
        anchor,
        targetStart,
        targetAnchor,
        target,
        props
      } = vnode;
      if (target) {
        hostRemove(targetStart);
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props);
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          move(
            children[i2],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector, insert, createText }
  }, hydrateChildren) {
    function hydrateDisabledTeleport(node2, vnode2, targetStart, targetAnchor) {
      vnode2.anchor = hydrateChildren(
        nextSibling(node2),
        vnode2,
        parentNode(node2),
        parentComponent,
        parentSuspense,
        slotScopeIds,
        optimized
      );
      vnode2.targetStart = targetStart;
      vnode2.targetAnchor = targetAnchor;
    }
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    const disabled = isTeleportDisabled(vnode.props);
    if (target) {
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (disabled) {
          hydrateDisabledTeleport(
            node,
            vnode,
            targetNode,
            targetNode && nextSibling(targetNode)
          );
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            if (targetAnchor && targetAnchor.nodeType === 8) {
              if (targetAnchor.data === "teleport start anchor") {
                vnode.targetStart = targetAnchor;
              } else if (targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            targetAnchor = nextSibling(targetAnchor);
          }
          if (!vnode.targetAnchor) {
            prepareAnchor(target, vnode, createText, insert);
          }
          hydrateChildren(
            targetNode && nextSibling(targetNode),
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode, disabled);
    } else if (disabled) {
      if (vnode.shapeFlag & 16) {
        hydrateDisabledTeleport(node, vnode, node, nextSibling(node));
      }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  const Teleport = TeleportImpl;
  function updateCssVars(vnode, isDisabled) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node, anchor;
      if (isDisabled) {
        node = vnode.el;
        anchor = vnode.anchor;
      } else {
        node = vnode.targetStart;
        anchor = vnode.targetAnchor;
      }
      while (node && node !== anchor) {
        if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }
  function prepareAnchor(target, vnode, createText, insert) {
    const targetStart = vnode.targetStart = createText("");
    const targetAnchor = vnode.targetAnchor = createText("");
    targetStart[TeleportEndKey] = targetAnchor;
    if (target) {
      insert(targetStart, target);
      insert(targetAnchor, target);
    }
    return targetAnchor;
  }
  const leaveCbKey = /* @__PURE__ */ Symbol("_leaveCb");
  const enterCbKey$1 = /* @__PURE__ */ Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const recursiveGetSubtree = (instance) => {
    const subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        const child = findNonCommentChild(children);
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getInnerChild$1(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        let enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance,
          // #11061, ensure enterHooks is fresh after clone
          (hooks) => enterHooks = hooks
        );
        if (innerChild.type !== Comment) {
          setTransitionHooks(innerChild, enterHooks);
        }
        let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(oldInnerChild, innerChild) && recursiveGetSubtree(instance).type !== Comment) {
          let leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in" && innerChild.type !== Comment) {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (!(instance.job.flags & 8)) {
                instance.update();
              }
              delete leavingHooks.afterLeave;
              oldInnerChild = void 0;
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
              enterHooks.delayedLeave = () => {
                delayedLeave();
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
            };
          } else {
            oldInnerChild = void 0;
          }
        } else if (oldInnerChild) {
          oldInnerChild = void 0;
        }
        return child;
      };
    }
  };
  function findNonCommentChild(children) {
    let child = children[0];
    if (children.length > 1) {
      for (const c2 of children) {
        if (c2.type !== Comment) {
          child = c2;
          break;
        }
      }
    }
    return child;
  }
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance, postClone) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook2 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook2(hook, args);
      if (isArray$2(hook)) {
        if (hook.every((hook2) => hook2.length <= 1)) done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
            /* cancelled */
          );
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook2(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey$1] = (cancelled) => {
          if (called) return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el]);
          } else {
            callHook2(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey$1] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key2 = String(vnode.key);
        if (el[enterCbKey$1]) {
          el[enterCbKey$1](
            true
            /* cancelled */
          );
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called) return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el]);
          } else {
            callHook2(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        const hooks2 = resolveTransitionHooks(
          vnode2,
          props,
          state,
          instance,
          postClone
        );
        if (postClone) postClone(hooks2);
        return hooks2;
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getInnerChild$1(vnode) {
    if (!isKeepAlive(vnode)) {
      if (isTeleport(vnode.type) && vnode.children) {
        return findNonCommentChild(vnode.children);
      }
      return vnode;
    }
    if (vnode.component) {
      return vnode.component.subTree;
    }
    const { shapeFlag, children } = vnode;
    if (children) {
      if (shapeFlag & 16) {
        return children[0];
      }
      if (shapeFlag & 32 && isFunction$3(children.default)) {
        return children.default();
      }
    }
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i2 = 0; i2 < children.length; i2++) {
      let child = children[i2];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
      if (child.type === Fragment) {
        if (child.patchFlag & 128) keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i2 = 0; i2 < ret.length; i2++) {
        ret[i2].patchFlag = -2;
      }
    }
    return ret;
  }
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options, extraOptions) {
    return isFunction$3(options) ? (
      // #8236: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  const pendingSetRefMap = /* @__PURE__ */ new WeakMap();
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$2(rawRef)) {
      rawRef.forEach(
        (r2, i2) => setRef(
          r2,
          oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i2] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ ? NO : (key) => {
      return hasOwn(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref3) {
      invalidatePendingSetRef(oldRawRef);
      if (isString$1(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        {
          oldRef.value = null;
        }
        const oldRawRefAtom = oldRawRef;
        if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;
      }
    }
    if (isFunction$3(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString$1(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray$2(existing) && remove(existing, refValue);
            } else {
              if (!isArray$2(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  const newVal = [refValue];
                  {
                    ref3.value = newVal;
                  }
                  if (rawRef.k) refs[rawRef.k] = newVal;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (canSetSetupRef(ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            {
              ref3.value = value;
            }
            if (rawRef.k) refs[rawRef.k] = value;
          } else ;
        };
        if (value) {
          const job = () => {
            doSet();
            pendingSetRefMap.delete(rawRef);
          };
          job.id = -1;
          pendingSetRefMap.set(rawRef, job);
          queuePostRenderEffect(job, parentSuspense);
        } else {
          invalidatePendingSetRef(rawRef);
          doSet();
        }
      }
    }
  }
  function invalidatePendingSetRef(rawRef) {
    const pendingSetRef = pendingSetRefMap.get(rawRef);
    if (pendingSetRef) {
      pendingSetRef.flags |= 8;
      pendingSetRefMap.delete(rawRef);
    }
  }
  getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
  getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
  const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const COMPONENTS = "components";
  const DIRECTIVES = "directives";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = /* @__PURE__ */ Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString$1(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      return res;
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  function renderList(source, renderItem, cache, index2) {
    let ret;
    const cached = cache;
    const sourceIsArray = isArray$2(source);
    if (sourceIsArray || isString$1(source)) {
      const sourceIsReactiveArray = sourceIsArray && isReactive(source);
      let needsWrap = false;
      let isReadonlySource = false;
      if (sourceIsReactiveArray) {
        needsWrap = !isShallow(source);
        isReadonlySource = isReadonly(source);
        source = shallowReadArray(source);
      }
      ret = new Array(source.length);
      for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
        ret[i2] = renderItem(
          needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i2])) : toReactive(source[i2]) : source[i2],
          i2,
          void 0,
          cached
        );
      }
    } else if (typeof source === "number") {
      ret = new Array(source);
      for (let i2 = 0; i2 < source; i2++) {
        ret[i2] = renderItem(i2 + 1, i2, void 0, cached);
      }
    } else if (isObject$3(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i2) => renderItem(item, i2, void 0, cached)
        );
      } else {
        const keys2 = Object.keys(source);
        ret = new Array(keys2.length);
        for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
          const key = keys2[i2];
          ret[i2] = renderItem(source[key], key, i2, cached);
        }
      }
    } else {
      ret = [];
    }
    return ret;
  }
  function createSlots(slots, dynamicSlots) {
    for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
      const slot = dynamicSlots[i2];
      if (isArray$2(slot)) {
        for (let j2 = 0; j2 < slot.length; j2++) {
          slots[slot[j2].name] = slot[j2].fn;
        }
      } else if (slot) {
        slots[slot.name] = slot.key ? (...args) => {
          const res = slot.fn(...args);
          if (res) res.key = slot.key;
          return res;
        } : slot.fn;
      }
    }
    return slots;
  }
  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
      const hasProps = Object.keys(props).length > 0;
      if (name !== "default") props.name = name;
      return openBlock(), createBlock(
        Fragment,
        null,
        [createVNode("slot", props, fallback && fallback())],
        hasProps ? -2 : 64
      );
    }
    let slot = slots[name];
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
    // key attached in the `createSlots` helper, respect that
    validSlotContent && validSlotContent.key;
    const rendered = createBlock(
      Fragment,
      {
        key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
        (!validSlotContent && fallback ? "_fb" : "")
      },
      validSlotContent || (fallback ? fallback() : []),
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child)) return true;
      if (child.type === Comment) return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    for (const key in obj) {
      ret[toHandlerKey(key)] = obj[key];
    }
    return ret;
  }
  const getPublicInstance = (i2) => {
    if (!i2) return null;
    if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
    return getPublicInstance(i2.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
      $: (i2) => i2,
      $el: (i2) => i2.vnode.el,
      $data: (i2) => i2.data,
      $props: (i2) => i2.props,
      $attrs: (i2) => i2.attrs,
      $slots: (i2) => i2.slots,
      $refs: (i2) => i2.refs,
      $parent: (i2) => getPublicInstance(i2.parent),
      $root: (i2) => getPublicInstance(i2.root),
      $host: (i2) => i2.ce,
      $emit: (i2) => i2.emit,
      $options: (i2) => resolveMergedOptions(i2),
      $forceUpdate: (i2) => i2.f || (i2.f = () => {
        queueJob(i2.update);
      }),
      $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
      $watch: (i2) => instanceWatch.bind(i2)
    })
  );
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
      if (key[0] !== "$") {
        const n2 = accessCache[key];
        if (n2 !== void 0) {
          switch (n2) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (hasOwn(props, key)) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else ;
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, props, type }
    }, key) {
      let cssModules;
      return !!(accessCache[key] || data !== EMPTY_OBJ && key[0] !== "$" && hasOwn(data, key) || hasSetupBinding(setupState, key) || hasOwn(props, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  function useAttrs() {
    return getContext().attrs;
  }
  function getContext(calledFunctionName) {
    const i2 = getCurrentInstance();
    return i2.setupContext || (i2.setupContext = createSetupContext(i2));
  }
  function normalizePropsOrEmits(props) {
    return isArray$2(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook$1(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction$3(methodHandler)) {
          {
            ctx[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data = dataOptions.call(publicThis, publicThis);
      if (!isObject$3(data)) ;
      else {
        instance.data = reactive(data);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c2 = computed({
          get,
          set
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c2.value,
          set: (v2) => c2.value = v2
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$2(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$2(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val,
            enumerable: true
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$2(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject$3(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key] = injected;
      }
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString$1(raw)) {
      const handler = ctx[raw];
      if (isFunction$3(handler)) {
        {
          watch(getter, handler);
        }
      }
    } else if (isFunction$3(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject$3(raw)) {
      if (isArray$2(raw)) {
        raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
      } else {
        const handler = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$3(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else ;
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject$3(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to2, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to2, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m2) => mergeOptions(to2, m2, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") ;
      else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to2[key] = strat ? strat(to2[key], from[key]) : from[key];
      }
    }
    return to2;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to2, from) {
    if (!from) {
      return to2;
    }
    if (!to2) {
      return from;
    }
    return function mergedDataFn() {
      return extend$1(
        isFunction$3(to2) ? to2.call(this, this) : to2,
        isFunction$3(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to2, from) {
    return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray$2(raw)) {
      const res = {};
      for (let i2 = 0; i2 < raw.length; i2++) {
        res[raw[i2]] = raw[i2];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to2, from) {
    return to2 ? [...new Set([].concat(to2, from))] : from;
  }
  function mergeObjectOptions(to2, from) {
    return to2 ? extend$1(/* @__PURE__ */ Object.create(null), to2, from) : from;
  }
  function mergeEmitsOrPropsOptions(to2, from) {
    if (to2) {
      if (isArray$2(to2) && isArray$2(from)) {
        return [.../* @__PURE__ */ new Set([...to2, ...from])];
      }
      return extend$1(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to2),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to2, from) {
    if (!to2) return from;
    if (!from) return to2;
    const merged = extend$1(/* @__PURE__ */ Object.create(null), to2);
    for (const key in from) {
      merged[key] = mergeAsArray(to2[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render2, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$3(rootComponent)) {
        rootComponent = extend$1({}, rootComponent);
      }
      if (rootProps != null && !isObject$3(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v2) {
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) ;
          else if (plugin && isFunction$3(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction$3(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else ;
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            }
          }
          return app;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            {
              render2(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            return getComponentPublicInstance(vnode.component);
          }
        },
        onUnmount(cleanupFn) {
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render2(null, app._container);
            delete app._container.__vue_app__;
          }
        },
        provide(key, value) {
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a2) => isString$1(a2) ? a2.trim() : a2);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  const mixinEmitsCache = /* @__PURE__ */ new WeakMap();
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinEmitsCache : appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$3(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend$1(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$3(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray$2(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend$1(normalized, raw);
    }
    if (isObject$3(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  function markAttrsAccessed() {
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render2,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = false ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render2.call(
            thisProxy,
            proxyToUse,
            renderCache,
            false ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component;
        if (false) ;
        result = normalizeVNode(
          render22.length > 1 ? render22(
            false ? shallowReadonly(props) : props,
            false ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            false ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root2 = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root2;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root2 = cloneVNode(root2, fallthroughAttrs, false, true);
        }
      }
    }
    if (vnode.dirs) {
      root2 = cloneVNode(root2, null, false, true);
      root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      setTransitionHooks(root2, vnode.transition);
    }
    {
      result = root2;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i2 = 0; i2 < dynamicProps.length; i2++) {
          const key = dynamicProps[i2];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i2 = 0; i2 < nextKeys.length; i2++) {
      const key = nextKeys[i2];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root2 = parent.subTree;
      if (root2.suspense && root2.suspense.activeBranch === vnode) {
        root2.el = vnode.el;
      }
      if (root2 === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
          let key = propsToUpdate[i2];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i2 = 0; i2 < needCastKeys.length; i2++) {
        const key = needCastKeys[i2];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$3(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$3(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend$1(normalized, props);
        if (keys2) needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$3(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$2(raw)) {
      for (let i2 = 0; i2 < raw.length; i2++) {
        const normalizedKey = camelize(raw[i2]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$3(opt) ? { type: opt } : extend$1({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray$2(propType)) {
            for (let index2 = 0; index2 < propType.length; ++index2) {
              const type = propType[index2];
              const typeName = isFunction$3(type) && type.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction$3(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$3(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    }
    return false;
  }
  const isInternalKey = (key) => key === "_" || key === "_ctx" || key === "$stable";
  const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (false) ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction$3(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || !isInternalKey(key)) {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    const target = getGlobalThis();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref3, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else ;
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      } else if (ref3 == null && n1 && n1.ref != null) {
        setRef(n1.ref, null, parentSuspense, n1, true);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          {
            hostSetText(el, n2.children);
          }
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        const customElement = !!(n1.el && n1.el._isVueCE) ? n1.el : null;
        try {
          if (customElement) {
            customElement._beginPatch();
          }
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } finally {
          if (customElement) {
            customElement._endPatch();
          }
        }
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
          hostSetScopeId(el, slotScopeIds[i2]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i2 = start; i2 < children.length; i2++) {
        const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
              const key = propsToUpdate[i2];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i2 = 0; i2 < newChildren.length; i2++) {
        const oldVNode = oldChildren[i2];
        const newVNode = newChildren[i2];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren && n1.dynamicChildren.length === dynamicChildren.length) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (
            // #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n2.key != null || parentComponent && n2 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n2,
              true
              /* shallow */
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance, false, optimized);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
          initialVNode.placeholder = placeholder.el;
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m: m2, parent, root: root2, type } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          {
            if (root2.ce && // @ts-expect-error _def is private
            root2.ce._def.shadowRoot !== false) {
              root2.ce._injectChildStyle(type);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            initialVNode.el = subTree.el;
          }
          if (m2) {
            queuePostRenderEffect(m2, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u: u2, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u2) {
            queuePostRenderEffect(u2, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i2;
      for (i2 = 0; i2 < commonLength; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        patch(
          c1[i2],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i2 = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[i2];
        const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i2++;
      }
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i2 > e1) {
        if (i2 <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i2 <= e2) {
            patch(
              null,
              c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i2++;
          }
        }
      } else if (i2 > e2) {
        while (i2 <= e1) {
          unmount(c1[i2], parentComponent, parentSuspense, true);
          i2++;
        }
      } else {
        const s1 = i2;
        const s2 = i2;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i2 = s2; i2 <= e2; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i2);
          }
        }
        let j2;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
        for (i2 = s1; i2 <= e1; i2++) {
          const prevChild = c1[i2];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j2 = s2; j2 <= e2; j2++) {
              if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                newIndex = j2;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j2 = increasingNewIndexSequence.length - 1;
        for (i2 = toBePatched - 1; i2 >= 0; i2--) {
          const nextIndex = s2 + i2;
          const nextChild = c2[nextIndex];
          const anchorVNode = c2[nextIndex + 1];
          const anchor = nextIndex + 1 < l2 ? (
            // #13559, #14173 fallback to el placeholder for unresolved async component
            anchorVNode.el || resolveAsyncComponentPlaceholder(anchorVNode)
          ) : parentAnchor;
          if (newIndexToOldIndexMap[i2] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
              move(nextChild, container, anchor, 2);
            } else {
              j2--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i2 = 0; i2 < children.length; i2++) {
          move(children[i2], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => {
            if (vnode.ctx.isUnmounted) {
              hostRemove(el);
            } else {
              hostInsert(el, container, anchor);
            }
          };
          const performLeave = () => {
            if (el._isLeaving) {
              el[leaveCbKey](
                true
                /* cancelled */
              );
            }
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        pauseTracking();
        setRef(ref3, null, parentSuspense, vnode, true);
        resetTracking();
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const { bum, scope, job, subTree, um, m: m2, a: a2 } = instance;
      invalidateMount(m2);
      invalidateMount(a2);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i2 = start; i2 < children.length; i2++) {
        unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render2 = (vnode, container, namespace) => {
      let instance;
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
          instance = container._vnode.component;
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs(instance);
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    return {
      render: render2,
      hydrate,
      createApp: createAppAPI(render2)
    };
  }
  function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$2(ch1) && isArray$2(ch2)) {
      for (let i2 = 0; i2 < ch1.length; i2++) {
        const c1 = ch1[i2];
        let c2 = ch2[i2];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          if (c2.patchFlag !== -1) {
            c2.el = c1.el;
          } else {
            c2.__elIndex = i2 + // take fragment start anchor into account
            (n1.type === Fragment ? 1 : 0);
          }
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i2, j2, u2, v2, c2;
    const len = arr.length;
    for (i2 = 0; i2 < len; i2++) {
      const arrI = arr[i2];
      if (arrI !== 0) {
        j2 = result[result.length - 1];
        if (arr[j2] < arrI) {
          p2[i2] = j2;
          result.push(i2);
          continue;
        }
        u2 = 0;
        v2 = result.length - 1;
        while (u2 < v2) {
          c2 = u2 + v2 >> 1;
          if (arr[result[c2]] < arrI) {
            u2 = c2 + 1;
          } else {
            v2 = c2;
          }
        }
        if (arrI < arr[result[u2]]) {
          if (u2 > 0) {
            p2[i2] = result[u2 - 1];
          }
          result[u2] = i2;
        }
      }
    }
    u2 = result.length;
    v2 = result[u2 - 1];
    while (u2-- > 0) {
      result[u2] = v2;
      v2 = p2[v2];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i2 = 0; i2 < hooks.length; i2++)
        hooks[i2].flags |= 8;
    }
  }
  function resolveAsyncComponentPlaceholder(anchorVnode) {
    if (anchorVnode.placeholder) {
      return anchorVnode.placeholder;
    }
    const instance = anchorVnode.component;
    if (instance) {
      return resolveAsyncComponentPlaceholder(instance.subTree);
    }
    return null;
  }
  const isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$2(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const Fragment = /* @__PURE__ */ Symbol.for("v-fgt");
  const Text = /* @__PURE__ */ Symbol.for("v-txt");
  const Comment = /* @__PURE__ */ Symbol.for("v-cmt");
  const Static = /* @__PURE__ */ Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$3(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$1(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(
        type,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$3(style)) {
        if (isProxy(style) && !isArray$2(style)) {
          style = extend$1({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$3(type) ? 4 : isFunction$3(type) ? 2 : 0;
    return createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      placeholder: vnode.placeholder,
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$2(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$2(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$3(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i2 = 0; i2 < args.length; i2++) {
      const toMerge = args[i2];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g2 = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g2[key])) setters = g2[key] = [];
      setters.push(setter);
      return (v2) => {
        if (setters.length > 1) setters.forEach((set) => set(v2));
        else setters[0](v2);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v2) => currentInstance = v2
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v2) => isInSSRComponentSetup = v2
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized || isSSR);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component;
    if (setup) {
      pauseTracking();
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          instance.props,
          setupContext
        ]
      );
      const isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult);
      }
    } else {
      finishComponentSetup(instance);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$3(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$3(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance);
  }
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])\w/g;
  const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(instance.components) || instance.parent && inferFromRegistry(
        instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$3(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    return c2;
  };
  function h$4(type, propsOrChildren, children) {
    try {
      setBlockTracking(-1);
      const l2 = arguments.length;
      if (l2 === 2) {
        if (isObject$3(propsOrChildren) && !isArray$2(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l2 > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l2 === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    } finally {
      setBlockTracking(1);
    }
  }
  const version = "3.5.26";
  let policy = void 0;
  const tt$2 = typeof window !== "undefined" && window.trustedTypes;
  if (tt$2) {
    try {
      policy = /* @__PURE__ */ tt$2.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e) {
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const TRANSITION = "transition";
  const ANIMATION = "animation";
  const vtcKey = /* @__PURE__ */ Symbol("_vtc");
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  const TransitionPropsValidators = /* @__PURE__ */ extend$1(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  const decorate$1 = (t) => {
    t.displayName = "Transition";
    t.props = TransitionPropsValidators;
    return t;
  };
  const Transition = /* @__PURE__ */ decorate$1(
    (props, { slots }) => h$4(BaseTransition, resolveTransitionProps(props), slots)
  );
  const callHook = (hook, args = []) => {
    if (isArray$2(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done, isCancelled) => {
      el._enterCancelled = isCancelled;
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend$1(baseProps, {
      onBeforeEnter(el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        if (!el._enterCancelled) {
          forceReflow(el);
          addTransitionClass(el, leaveActiveClass);
        } else {
          addTransitionClass(el, leaveActiveClass);
          forceReflow(el);
        }
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false, void 0, true);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true, void 0, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$3(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n2 = NumberOf(duration);
      return [n2, n2];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout != null) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(?:transform|all)(?:,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
  }
  function toMs(s2) {
    if (s2 === "auto") return 0;
    return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow(el) {
    const targetDocument = el ? el.ownerDocument : document;
    return targetDocument.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = /* @__PURE__ */ Symbol("_vod");
  const vShowHidden = /* @__PURE__ */ Symbol("_vsh");
  const vShow = {
    // used for prop mismatch check during hydration
    name: "show",
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  const CSS_VAR_TEXT = /* @__PURE__ */ Symbol("");
  const displayRE = /(?:^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString$1(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString$1(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray$2(val)) {
      val.forEach((v2) => setStyle(style, name, v2));
    } else {
      if (val == null) val = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i2 = 0; i2 < prefixes.length; i2++) {
      const prefixed = prefixes[i2] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean2 ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
      if (value != null) {
        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? (
        // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        el.type === "checkbox" ? "on" : ""
      ) : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
    }
    needRemove && el.removeAttribute(attrName || key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = /* @__PURE__ */ Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          nextValue,
          instance
        );
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m2;
      while (m2 = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m2[0].length);
        options[m2[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p$3 = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p$3.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray$2(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn) => (e2) => !e2._stopped && fn && fn(e2)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else if (
      // #11081 force set props for possible async custom element
      el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
    ) {
      patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction$3(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
      return false;
    }
    if (key === "sandbox" && el.tagName === "IFRAME") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString$1(value)) {
      return false;
    }
    return key in el;
  }
  const positionMap = /* @__PURE__ */ new WeakMap();
  const newPositionMap = /* @__PURE__ */ new WeakMap();
  const moveCbKey = /* @__PURE__ */ Symbol("_moveCb");
  const enterCbKey = /* @__PURE__ */ Symbol("_enterCb");
  const decorate = (t) => {
    delete t.props.mode;
    return t;
  };
  const TransitionGroupImpl = /* @__PURE__ */ decorate({
    name: "TransitionGroup",
    props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevChildren;
      let children;
      onUpdated(() => {
        if (!prevChildren.length) {
          return;
        }
        const moveClass = props.moveClass || `${props.name || "v"}-move`;
        if (!hasCSSTransform(
          prevChildren[0].el,
          instance.vnode.el,
          moveClass
        )) {
          prevChildren = [];
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        const movedChildren = prevChildren.filter(applyTranslation);
        forceReflow(instance.vnode.el);
        movedChildren.forEach((c2) => {
          const el = c2.el;
          const style = el.style;
          addTransitionClass(el, moveClass);
          style.transform = style.webkitTransform = style.transitionDuration = "";
          const cb = el[moveCbKey] = (e) => {
            if (e && e.target !== el) {
              return;
            }
            if (!e || e.propertyName.endsWith("transform")) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
        prevChildren = [];
      });
      return () => {
        const rawProps = toRaw(props);
        const cssTransitionProps = resolveTransitionProps(rawProps);
        let tag = rawProps.tag || Fragment;
        prevChildren = [];
        if (children) {
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.el && child.el instanceof Element) {
              prevChildren.push(child);
              setTransitionHooks(
                child,
                resolveTransitionHooks(
                  child,
                  cssTransitionProps,
                  state,
                  instance
                )
              );
              positionMap.set(child, {
                left: child.el.offsetLeft,
                top: child.el.offsetTop
              });
            }
          }
        }
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.key != null) {
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
          }
        }
        return createVNode(tag, null, children);
      };
    }
  });
  const TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c2) {
    const el = c2.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey]) {
      el[enterCbKey]();
    }
  }
  function recordPosition(c2) {
    newPositionMap.set(c2, {
      left: c2.el.offsetLeft,
      top: c2.el.offsetTop
    });
  }
  function applyTranslation(c2) {
    const oldPos = positionMap.get(c2);
    const newPos = newPositionMap.get(c2);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s2 = c2.el.style;
      s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
      s2.transitionDuration = "0s";
      return c2;
    }
  }
  function hasCSSTransform(el, root2, moveClass) {
    const clone = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
      });
    }
    moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
    clone.style.display = "none";
    const container = root2.nodeType === 1 ? root2 : root2.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
  }
  const getModelAssigner = (vnode) => {
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  const assignKey = /* @__PURE__ */ Symbol("_assign");
  function castValue(value, trim2, number) {
    if (trim2) value = value.trim();
    if (number) value = looseToNumber(value);
    return value;
  }
  const vModelText = {
    created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      const castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener(el, lazy ? "change" : "input", (e) => {
        if (e.target.composing) return;
        el[assignKey](castValue(el.value, trim2, castToNumber));
      });
      if (trim2 || castToNumber) {
        addEventListener(el, "change", () => {
          el.value = castValue(el.value, trim2, castToNumber);
        });
      }
      if (!lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
      el.value = value == null ? "" : value;
    },
    beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim: trim2, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (el.composing) return;
      const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
      const newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim2 && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _2, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      addEventListener(el, "change", () => {
        const modelValue = el._modelValue;
        const elementValue = getValue$1(el);
        const checked = el.checked;
        const assign2 = el[assignKey];
        if (isArray$2(modelValue)) {
          const index2 = looseIndexOf(modelValue, elementValue);
          const found = index2 !== -1;
          if (checked && !found) {
            assign2(modelValue.concat(elementValue));
          } else if (!checked && found) {
            const filtered = [...modelValue];
            filtered.splice(index2, 1);
            assign2(filtered);
          }
        } else if (isSet$1(modelValue)) {
          const cloned = new Set(modelValue);
          if (checked) {
            cloned.add(elementValue);
          } else {
            cloned.delete(elementValue);
          }
          assign2(cloned);
        } else {
          assign2(getCheckboxValue(el, checked));
        }
      });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      setChecked(el, binding, vnode);
    }
  };
  function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    let checked;
    if (isArray$2(value)) {
      checked = looseIndexOf(value, vnode.props.value) > -1;
    } else if (isSet$1(value)) {
      checked = value.has(vnode.props.value);
    } else {
      if (value === oldValue) return;
      checked = looseEqual(value, getCheckboxValue(el, true));
    }
    if (el.checked !== checked) {
      el.checked = checked;
    }
  }
  const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
      const isSetModel = isSet$1(value);
      addEventListener(el, "change", () => {
        const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map(
          (o2) => number ? looseToNumber(getValue$1(o2)) : getValue$1(o2)
        );
        el[assignKey](
          el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
        );
        el._assigning = true;
        nextTick(() => {
          el._assigning = false;
        });
      });
      el[assignKey] = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
      setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
    },
    updated(el, { value }) {
      if (!el._assigning) {
        setSelected(el, value);
      }
    }
  };
  function setSelected(el, value) {
    const isMultiple = el.multiple;
    const isArrayValue = isArray$2(value);
    if (isMultiple && !isArrayValue && !isSet$1(value)) {
      return;
    }
    for (let i2 = 0, l2 = el.options.length; i2 < l2; i2++) {
      const option = el.options[i2];
      const optionValue = getValue$1(option);
      if (isMultiple) {
        if (isArrayValue) {
          const optionType = typeof optionValue;
          if (optionType === "string" || optionType === "number") {
            option.selected = value.some((v2) => String(v2) === String(optionValue));
          } else {
            option.selected = looseIndexOf(value, optionValue) > -1;
          }
        } else {
          option.selected = value.has(optionValue);
        }
      } else if (looseEqual(getValue$1(option), value)) {
        if (el.selectedIndex !== i2) el.selectedIndex = i2;
        return;
      }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
      el.selectedIndex = -1;
    }
  }
  function getValue$1(el) {
    return "_value" in el ? el._value : el.value;
  }
  function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
  }
  const systemModifiers = ["ctrl", "shift", "alt", "meta"];
  const modifierGuards = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
  };
  const withModifiers = (fn, modifiers) => {
    const cache = fn._withMods || (fn._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = ((event, ...args) => {
      for (let i2 = 0; i2 < modifiers.length; i2++) {
        const guard = modifierGuards[modifiers[i2]];
        if (guard && guard(event, modifiers)) return;
      }
      return fn(event, ...args);
    }));
  };
  const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  const withKeys = (fn, modifiers) => {
    const cache = fn._withKeys || (fn._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = ((event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some(
        (k2) => k2 === eventKey || keyNames[k2] === eventKey
      )) {
        return fn(event);
      }
    }));
  };
  const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component = app._component;
      if (!isFunction$3(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  });
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function normalizeContainer(container) {
    if (isString$1(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  let activePinia;
  const setActivePinia = (pinia) => activePinia = pinia;
  const piniaSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function isPlainObject$2(o2) {
    return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia = markRaw({
      install(app) {
        setActivePinia(pinia);
        pinia._a = app;
        app.provide(piniaSymbol, pinia);
        app.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      },
      use(plugin) {
        if (!this._a) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia;
  }
  const noop$2 = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop$2) {
    subscriptions.add(callback);
    const removeSubscription = () => {
      const isDel = subscriptions.delete(callback);
      isDel && onCleanup();
    };
    if (!detached && getCurrentScope()) {
      onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  const ACTION_MARKER = Symbol();
  const ACTION_NAME = Symbol();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    } else if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject$2(targetValue) && isPlainObject$2(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function shouldHydrate(obj) {
    return !isPlainObject$2(obj) || !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o2) {
    return !!(isRef(o2) && o2.effect);
  }
  function createOptionsStore(id, options, pinia, hot) {
    const { state, actions: actions2, getters } = options;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
      if (!initialState && true) {
        pinia.state.value[id] = state ? state() : {};
      }
      const localState = toRefs(pinia.state.value[id]);
      return assign(localState, actions2, Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = markRaw(computed(() => {
          setActivePinia(pinia);
          const store2 = pinia._s.get(id);
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options, pinia, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    const $subscribeOptions = { deep: true };
    let isListening;
    let isSyncListening;
    let subscriptions = /* @__PURE__ */ new Set();
    let actionSubscriptions = /* @__PURE__ */ new Set();
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    if (!isOptionsStore && !initialState && true) {
      pinia.state.value[$id] = {};
    }
    ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      noop$2
    );
    function $dispose() {
      scope.stop();
      subscriptions.clear();
      actionSubscriptions.clear();
      pinia._s.delete($id);
    }
    const action = (fn, name = "") => {
      if (ACTION_MARKER in fn) {
        fn[ACTION_NAME] = name;
        return fn;
      }
      const wrappedAction = function() {
        setActivePinia(pinia);
        const args = Array.from(arguments);
        const afterCallbackSet = /* @__PURE__ */ new Set();
        const onErrorCallbackSet = /* @__PURE__ */ new Set();
        function after(callback) {
          afterCallbackSet.add(callback);
        }
        function onError(callback) {
          onErrorCallbackSet.add(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name: wrappedAction[ACTION_NAME],
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = fn.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackSet, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackSet, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackSet, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackSet, ret);
        return ret;
      };
      wrappedAction[ACTION_MARKER] = true;
      wrappedAction[ACTION_NAME] = name;
      return wrappedAction;
    };
    const partialStore = {
      _p: pinia,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = reactive(partialStore);
    pinia._s.set($id, store);
    const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
        if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          pinia.state.value[$id][key] = prop;
        }
      } else if (typeof prop === "function") {
        const actionValue = action(prop, key);
        setupStore[key] = actionValue;
        optionsForPlugin.actions[key] = prop;
      } else ;
    }
    assign(store, setupStore);
    assign(toRaw(store), setupStore);
    Object.defineProperty(store, "$state", {
      get: () => pinia.state.value[$id],
      set: (state) => {
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    pinia._p.forEach((extender) => {
      {
        assign(store, scope.run(() => extender({
          store,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        })));
      }
    });
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  // @__NO_SIDE_EFFECTS__
  function defineStore(id, setup, setupOptions) {
    let options;
    const isSetupStore = typeof setup === "function";
    options = isSetupStore ? setupOptions : setup;
    function useStore(pinia, hot) {
      const hasContext = hasInjectionContext();
      pinia = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia || (hasContext ? inject(piniaSymbol, null) : null);
      if (pinia)
        setActivePinia(pinia);
      pinia = activePinia;
      if (!pinia._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia);
        } else {
          createOptionsStore(id, options, pinia);
        }
      }
      const store = pinia._s.get(id);
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  function tryOnScopeDispose$1(fn) {
    if (getCurrentScope()) {
      onScopeDispose(fn);
      return true;
    }
    return false;
  }
  function toValue$1(r2) {
    return typeof r2 === "function" ? r2() : unref(r2);
  }
  const isClient = typeof window !== "undefined" && typeof document !== "undefined";
  typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
  const toString$1 = Object.prototype.toString;
  const isObject$2 = (val) => toString$1.call(val) === "[object Object]";
  const noop$1 = () => {
  };
  function unrefElement$1(elRef) {
    var _a2;
    const plain = toValue$1(elRef);
    return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
  }
  const defaultWindow = isClient ? window : void 0;
  function useEventListener(...args) {
    let target;
    let events2;
    let listeners;
    let options;
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      [events2, listeners, options] = args;
      target = defaultWindow;
    } else {
      [target, events2, listeners, options] = args;
    }
    if (!target)
      return noop$1;
    if (!Array.isArray(events2))
      events2 = [events2];
    if (!Array.isArray(listeners))
      listeners = [listeners];
    const cleanups = [];
    const cleanup = () => {
      cleanups.forEach((fn) => fn());
      cleanups.length = 0;
    };
    const register = (el, event, listener, options2) => {
      el.addEventListener(event, listener, options2);
      return () => el.removeEventListener(event, listener, options2);
    };
    const stopWatch = watch(
      () => [unrefElement$1(target), toValue$1(options)],
      ([el, options2]) => {
        cleanup();
        if (!el)
          return;
        const optionsClone = isObject$2(options2) ? __spreadValues({}, options2) : options2;
        cleanups.push(
          ...events2.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, optionsClone));
          })
        );
      },
      { immediate: true, flush: "post" }
    );
    const stop = () => {
      stopWatch();
      cleanup();
    };
    tryOnScopeDispose$1(stop);
    return stop;
  }
  function tryOnScopeDispose(fn) {
    if (getCurrentScope()) {
      onScopeDispose(fn);
      return true;
    }
    return false;
  }
  function toValue(r2) {
    return typeof r2 === "function" ? r2() : unref(r2);
  }
  typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
  function unrefElement(elRef) {
    var _a2;
    const plain = toValue(elRef);
    return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
  }
  var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    var _element$getRootNode;
    return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
  } : function(element) {
    return element === null || element === void 0 ? void 0 : element.ownerDocument;
  };
  var _isInert = function isInert(node, lookUp) {
    var _node$getAttribute;
    if (lookUp === void 0) {
      lookUp = true;
    }
    var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
    var inert = inertAtt === "" || inertAtt === "true";
    var result = inert || lookUp && node && _isInert(node.parentNode);
    return result;
  };
  var isContentEditable = function isContentEditable2(node) {
    var _node$getAttribute2;
    var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
    return attValue === "" || attValue === "true";
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter) {
    if (_isInert(el)) {
      return [];
    }
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
  };
  var _getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element = elementsToCheck.shift();
      if (_isInert(element, false)) {
        continue;
      }
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements();
        var content = assigned.length ? assigned : element.children;
        var nestedCandidates = _getCandidatesIteratively(content, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches.call(element, candidateSelector);
        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
          candidates.push(element);
        }
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
        var validShadowRoot = !_isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = _getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
        }
      }
    }
    return candidates;
  };
  var hasTabIndex = function hasTabIndex2(node) {
    return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
  };
  var getTabIndex = function getTabIndex2(node) {
    if (!node) {
      throw new Error("No node provided");
    }
    if (node.tabIndex < 0) {
      if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
    var tabIndex = getTabIndex(node);
    if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
      return 0;
    }
    return tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
    return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r2;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      if (nodes[i2].checked && nodes[i2].form === form) {
        return nodes[i2];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isNodeAttached = function isNodeAttached2(node) {
    var _nodeRoot;
    var nodeRoot = node && getRootNode(node);
    var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
    var attached = false;
    if (nodeRoot && nodeRoot !== node) {
      var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
      attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
      while (!attached && nodeRootHost) {
        var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
        nodeRoot = getRootNode(nodeRootHost);
        nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
      }
    }
    return attached;
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (displayCheck === "full-native") {
      if ("checkVisibility" in node) {
        var visible = node.checkVisibility({
          // Checking opacity might be desirable for some use cases, but natively,
          // opacity zero elements _are_ focusable and tabbable.
          checkOpacity: false,
          opacityProperty: false,
          contentVisibilityAuto: true,
          visibilityProperty: true,
          // This is an alias for `visibilityProperty`. Contemporary browsers
          // support both. However, this alias has wider browser support (Chrome
          // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
          // we include it anyway.
          checkVisibilityCSS: true
        });
        return !visible;
      }
    }
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    if (!displayCheck || displayCheck === "full" || // full-native can run this branch when it falls through in case
    // Element#checkVisibility is unsupported
    displayCheck === "full-native" || displayCheck === "legacy-full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (isNodeAttached(node)) {
        return !node.getClientRects().length;
      }
      if (displayCheck !== "legacy-full") {
        return true;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i2 = 0; i2 < parentNode.children.length; i2++) {
            var child = parentNode.children.item(i2);
            if (child.tagName === "LEGEND") {
              return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
    if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
    //  because we're limited in the type of selectors we can use in JSDom (see related
    //  note related to `candidateSelectors`)
    _isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
    if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
      return false;
    }
    return true;
  };
  var isShadowRootTabbable = function isShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var _sortByOrder = function sortByOrder(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i2) {
      var isScope = !!item.scopeParent;
      var element = isScope ? item.scopeParent : item;
      var candidateTabindex = getSortOrderTabIndex(element, isScope);
      var elements = isScope ? _sortByOrder(item.candidates) : element;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
      } else {
        orderedTabbables.push({
          documentOrder: i2,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(container, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = _getCandidatesIteratively([container], options.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options),
        flatten: false,
        getShadowRoot: options.getShadowRoot,
        shadowRootFilter: isShadowRootTabbable
      });
    } else {
      candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return _sortByOrder(candidates);
  };
  var focusable = function focusable2(container, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = _getCandidatesIteratively([container], options.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options),
        flatten: true,
        getShadowRoot: options.getShadowRoot
      });
    } else {
      candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };
  function _arrayLikeToArray(r2, a2) {
    (null == a2 || a2 > r2.length) && (a2 = r2.length);
    for (var e = 0, n2 = Array(a2); e < a2; e++) n2[e] = r2[e];
    return n2;
  }
  function _arrayWithoutHoles$1(r2) {
    if (Array.isArray(r2)) return _arrayLikeToArray(r2);
  }
  function _defineProperty$1(e, r2, t) {
    return (r2 = _toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r2] = t, e;
  }
  function _iterableToArray$1(r2) {
    if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
  }
  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys$1(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$1(Object(t), true).forEach(function(r3) {
        _defineProperty$1(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _toConsumableArray$1(r2) {
    return _arrayWithoutHoles$1(r2) || _iterableToArray$1(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread$1();
  }
  function _toPrimitive(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i2 = e.call(t, r2);
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i2 = _toPrimitive(t, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _unsupportedIterableToArray(r2, a2) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
      var t = {}.toString.call(r2).slice(8, -1);
      return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a2) : void 0;
    }
  }
  var activeFocusTraps = {
    activateTrap: function activateTrap(trapStack, trap) {
      if (trapStack.length > 0) {
        var activeTrap = trapStack[trapStack.length - 1];
        if (activeTrap !== trap) {
          activeTrap._setPausedState(true);
        }
      }
      var trapIndex = trapStack.indexOf(trap);
      if (trapIndex === -1) {
        trapStack.push(trap);
      } else {
        trapStack.splice(trapIndex, 1);
        trapStack.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trapStack, trap) {
      var trapIndex = trapStack.indexOf(trap);
      if (trapIndex !== -1) {
        trapStack.splice(trapIndex, 1);
      }
      if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {
        trapStack[trapStack.length - 1]._setPausedState(false);
      }
    }
  };
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e) {
    return (e === null || e === void 0 ? void 0 : e.key) === "Escape" || (e === null || e === void 0 ? void 0 : e.key) === "Esc" || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
  };
  var isTabEvent = function isTabEvent2(e) {
    return (e === null || e === void 0 ? void 0 : e.key) === "Tab" || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
  };
  var isKeyForward = function isKeyForward2(e) {
    return isTabEvent(e) && !e.shiftKey;
  };
  var isKeyBackward = function isKeyBackward2(e) {
    return isTabEvent(e) && e.shiftKey;
  };
  var delay = function delay2(fn) {
    return setTimeout(fn, 0);
  };
  var valueOrHandler = function valueOrHandler2(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value.apply(void 0, params) : value;
  };
  var getActualTarget = function getActualTarget2(event) {
    return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
  };
  var internalTrapStack = [];
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc2 = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
    var config = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward,
      isKeyBackward
    }, userOptions);
    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   posTabIndexesFound: boolean,
      //   firstTabbableNode: HTMLElement|undefined,
      //   lastTabbableNode: HTMLElement|undefined,
      //   firstDomTabbableNode: HTMLElement|undefined,
      //   lastDomTabbableNode: HTMLElement|undefined,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      manuallyPaused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: void 0,
      // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
      recentNavEvent: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element, event) {
      var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
      return state.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
        //  web components if the `tabbableOptions.getShadowRoot` option was used for
        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
        //  look inside web components even if open)
        (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
          return node === element;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$hasFallback = _ref2.hasFallback, hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? [] : _ref2$params;
      var optionValue = config[optionName];
      if (typeof optionValue === "function") {
        optionValue = optionValue.apply(void 0, _toConsumableArray$1(params));
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        try {
          node = doc2.querySelector(optionValue);
        } catch (err) {
          throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
        }
        if (!node) {
          if (!hasFallback) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus", {
        hasFallback: true
      });
      if (node === false) {
        return false;
      }
      if (node === void 0 || node && !isFocusable(node, config.tabbableOptions)) {
        if (findContainerIndex(doc2.activeElement) >= 0) {
          node = doc2.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      } else if (node === null) {
        node = getNodeForOption("fallbackFocus");
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state.containerGroups = state.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config.tabbableOptions);
        var focusableNodes = focusable(container, config.tabbableOptions);
        var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
        var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
        var firstDomTabbableNode = focusableNodes.find(function(node) {
          return isTabbable(node);
        });
        var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
          return isTabbable(node);
        });
        var posTabIndexesFound = !!tabbableNodes.find(function(node) {
          return getTabIndex(node) > 0;
        });
        return {
          container,
          tabbableNodes,
          focusableNodes,
          /** True if at least one node with positive `tabindex` was found in this container. */
          posTabIndexesFound,
          /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
          firstTabbableNode,
          /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
          lastTabbableNode,
          // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
          //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
          //  because that API doesn't work with Shadow DOM as well as it should (@see
          //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
          //  to address an edge case related to positive tabindex support, this seems like a much easier,
          //  "close enough most of the time" alternative for positive tabindexes which should generally
          //  be avoided anyway...
          /** First tabbable node in container, __DOM__ order; `undefined` if none. */
          firstDomTabbableNode,
          /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
          lastDomTabbableNode,
          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = tabbableNodes.indexOf(node);
            if (nodeIdx < 0) {
              if (forward) {
                return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                  return isTabbable(el);
                });
              }
              return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                return isTabbable(el);
              });
            }
            return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
      if (state.containerGroups.find(function(g2) {
        return g2.posTabIndexesFound;
      }) && state.containerGroups.length > 1) {
        throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
      }
    };
    var _getActiveElement = function getActiveElement(el) {
      var activeElement = el.activeElement;
      if (!activeElement) {
        return;
      }
      if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
        return _getActiveElement(activeElement.shadowRoot);
      }
      return activeElement;
    };
    var _tryFocus = function tryFocus(node) {
      if (node === false) {
        return;
      }
      if (node === _getActiveElement(document)) {
        return;
      }
      if (!node || !node.focus) {
        _tryFocus(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config.preventScroll
      });
      state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node ? node : node === false ? false : previousActiveElement;
    };
    var findNextNavNode = function findNextNavNode2(_ref3) {
      var target = _ref3.target, event = _ref3.event, _ref3$isBackward = _ref3.isBackward, isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
      target = target || getActualTarget(event);
      updateTabbableNodes();
      var destinationNode = null;
      if (state.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target, event);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref4) {
            var firstTabbableNode = _ref4.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup.nextTabbableNode(target, false);
          }
        } else {
          var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref5) {
            var lastTabbableNode = _ref5.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    };
    var checkPointerDown = function checkPointerDown2(e) {
      var target = getActualTarget(e);
      if (findContainerIndex(target, e) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e)) {
        trap.deactivate({
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked (and if not focusable, to "nothing"); by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node), whether the
          //  outside click was on a focusable node or not
          returnFocus: config.returnFocusOnDeactivate
        });
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e)) {
        return;
      }
      e.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(event) {
      var target = getActualTarget(event);
      var targetContained = findContainerIndex(target, event) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        var nextNode;
        var navAcrossContainers = true;
        if (state.mostRecentlyFocusedNode) {
          if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
            var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
            var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
            if (tabbableNodes.length > 0) {
              var mruTabIdx = tabbableNodes.findIndex(function(node) {
                return node === state.mostRecentlyFocusedNode;
              });
              if (mruTabIdx >= 0) {
                if (config.isKeyForward(state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!state.containerGroups.some(function(g2) {
              return g2.tabbableNodes.some(function(n2) {
                return getTabIndex(n2) > 0;
              });
            })) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: state.mostRecentlyFocusedNode,
            isBackward: config.isKeyBackward(state.recentNavEvent)
          });
        }
        if (nextNode) {
          _tryFocus(nextNode);
        } else {
          _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
        }
      }
      state.recentNavEvent = void 0;
    };
    var checkKeyNav = function checkKeyNav2(event) {
      var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      state.recentNavEvent = event;
      var destinationNode = findNextNavNode({
        event,
        isBackward
      });
      if (destinationNode) {
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        _tryFocus(destinationNode);
      }
    };
    var checkTabKey = function checkTabKey2(event) {
      if (config.isKeyForward(event) || config.isKeyBackward(event)) {
        checkKeyNav(event, config.isKeyBackward(event));
      }
    };
    var checkEscapeKey = function checkEscapeKey2(event) {
      if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        trap.deactivate();
      }
    };
    var checkClick = function checkClick2(e) {
      var target = getActualTarget(e);
      if (findContainerIndex(target, e) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e)) {
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e)) {
        return;
      }
      e.preventDefault();
      e.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state.active) {
        return;
      }
      activeFocusTraps.activateTrap(trapStack, trap);
      state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
        _tryFocus(getInitialFocusNode());
      }) : _tryFocus(getInitialFocusNode());
      doc2.addEventListener("focusin", checkFocusIn, true);
      doc2.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("keydown", checkTabKey, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("keydown", checkEscapeKey);
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state.active) {
        return;
      }
      doc2.removeEventListener("focusin", checkFocusIn, true);
      doc2.removeEventListener("mousedown", checkPointerDown, true);
      doc2.removeEventListener("touchstart", checkPointerDown, true);
      doc2.removeEventListener("click", checkClick, true);
      doc2.removeEventListener("keydown", checkTabKey, true);
      doc2.removeEventListener("keydown", checkEscapeKey);
      return trap;
    };
    var checkDomRemoval = function checkDomRemoval2(mutations) {
      var isFocusedNodeRemoved = mutations.some(function(mutation) {
        var removedNodes = Array.from(mutation.removedNodes);
        return removedNodes.some(function(node) {
          return node === state.mostRecentlyFocusedNode;
        });
      });
      if (isFocusedNodeRemoved) {
        _tryFocus(getInitialFocusNode());
      }
    };
    var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
    var updateObservedNodes = function updateObservedNodes2() {
      if (!mutationObserver) {
        return;
      }
      mutationObserver.disconnect();
      if (state.active && !state.paused) {
        state.containers.map(function(container) {
          mutationObserver.observe(container, {
            subtree: true,
            childList: true
          });
        });
      }
    };
    trap = {
      get active() {
        return state.active;
      },
      get paused() {
        return state.paused;
      },
      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }
        var onActivate = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = _getActiveElement(doc2);
        onActivate === null || onActivate === void 0 || onActivate();
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          updateObservedNodes();
          onPostActivate === null || onPostActivate === void 0 || onPostActivate();
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }
        var options = _objectSpread2({
          onDeactivate: config.onDeactivate,
          onPostDeactivate: config.onPostDeactivate,
          checkCanReturnFocus: config.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state.delayInitialFocusTimer);
        state.delayInitialFocusTimer = void 0;
        removeListeners();
        state.active = false;
        state.paused = false;
        updateObservedNodes();
        activeFocusTraps.deactivateTrap(trapStack, trap);
        var onDeactivate = getOption(options, "onDeactivate");
        var onPostDeactivate = getOption(options, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
        var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
        onDeactivate === null || onDeactivate === void 0 || onDeactivate();
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }
            onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause(pauseOptions) {
        if (!state.active) {
          return this;
        }
        state.manuallyPaused = true;
        return this._setPausedState(true, pauseOptions);
      },
      unpause: function unpause(unpauseOptions) {
        if (!state.active) {
          return this;
        }
        state.manuallyPaused = false;
        if (trapStack[trapStack.length - 1] !== this) {
          return this;
        }
        return this._setPausedState(false, unpauseOptions);
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function(element) {
          return typeof element === "string" ? doc2.querySelector(element) : element;
        });
        if (state.active) {
          updateTabbableNodes();
        }
        updateObservedNodes();
        return this;
      }
    };
    Object.defineProperties(trap, {
      _isManuallyPaused: {
        value: function value() {
          return state.manuallyPaused;
        }
      },
      _setPausedState: {
        value: function value(paused, options) {
          if (state.paused === paused) {
            return this;
          }
          state.paused = paused;
          if (paused) {
            var onPause = getOption(options, "onPause");
            var onPostPause = getOption(options, "onPostPause");
            onPause === null || onPause === void 0 || onPause();
            removeListeners();
            updateObservedNodes();
            onPostPause === null || onPostPause === void 0 || onPostPause();
          } else {
            var onUnpause = getOption(options, "onUnpause");
            var onPostUnpause = getOption(options, "onPostUnpause");
            onUnpause === null || onUnpause === void 0 || onUnpause();
            updateTabbableNodes();
            addListeners();
            updateObservedNodes();
            onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
          }
          return this;
        }
      }
    });
    trap.updateContainerElements(elements);
    return trap;
  };
  function useFocusTrap(target, options = {}) {
    let trap;
    const _a2 = options, { immediate } = _a2, focusTrapOptions = __objRest(_a2, ["immediate"]);
    const hasFocus = ref(false);
    const isPaused = ref(false);
    const activate = (opts) => trap && trap.activate(opts);
    const deactivate = (opts) => trap && trap.deactivate(opts);
    const pause = () => {
      if (trap) {
        trap.pause();
        isPaused.value = true;
      }
    };
    const unpause = () => {
      if (trap) {
        trap.unpause();
        isPaused.value = false;
      }
    };
    watch(
      () => unrefElement(target),
      (el) => {
        if (!el)
          return;
        trap = createFocusTrap(el, __spreadProps(__spreadValues({}, focusTrapOptions), {
          onActivate() {
            hasFocus.value = true;
            if (options.onActivate)
              options.onActivate();
          },
          onDeactivate() {
            hasFocus.value = false;
            if (options.onDeactivate)
              options.onDeactivate();
          }
        }));
        if (immediate)
          activate();
      },
      { flush: "post" }
    );
    tryOnScopeDispose(() => deactivate());
    return {
      hasFocus,
      isPaused,
      activate,
      deactivate,
      pause,
      unpause
    };
  }
  const uo = (e) => (...o2) => {
    e && (e == null || e(...o2), e = null);
  }, q$3 = () => {
  };
  function oe$3(e, o2, l2) {
    return e > l2 ? l2 : e < o2 ? o2 : e;
  }
  const we$3 = (e) => typeof e == "string";
  function fe$3(e, o2) {
    var s2;
    const l2 = ((s2 = $$2(e, o2)) == null ? void 0 : s2[0]) || o2;
    e.push(l2);
  }
  function $$2(e, o2) {
    const l2 = e.indexOf(o2);
    if (l2 !== -1)
      return e.splice(l2, 1);
  }
  const co = {
    /**
     * @description Set `null | false` to disable teleport.
     * @default `'body'`
     * @example
     * ```js
     * teleportTo: '#modals'
     * ```
     */
    teleportTo: {
      type: [String, null, Boolean, Object],
      default: "body"
    },
    /**
     * @description An uniq name for the open/close a modal via vfm.open/vfm.close APIs.
     * @default `undefined`
     * @example Symbol: `Symbol('MyModal')`
     * @example String: `'AUniqString'`
     * @example Number: `300`
     */
    modalId: {
      type: [String, Number, Symbol],
      default: void 0
    },
    /**
     * @description Display the modal or not.
     * @default `undefined`
     * @example
     * ```js
     * const showModal = ref(false)
     * v-model="showModal"
     * ```
     */
    modelValue: {
      type: Boolean,
      default: void 0
    },
    /**
     * @description Render the modal via `if` or `show`.
     * @default `'if'`
     * @example
     * ```js
     * displayDirective: 'if'
     * ```
     * @example
     * ```js
     * displayDirective: 'show'
     * ```
     */
    displayDirective: {
      type: String,
      default: "if",
      validator: (e) => ["if", "show", "visible"].includes(e)
    },
    /**
     * @description Hide the overlay or not.
     * @default `undefined`
     * @example
     * ```js
     * hideOverlay="true"
     * ```
     */
    hideOverlay: {
      type: Boolean,
      default: void 0
    },
    /**
     * @description Customize the overlay behavior.
     */
    overlayBehavior: {
      type: String,
      default: "auto",
      validator: (e) => ["auto", "persist"].includes(e)
    },
    /**
     * @description Customize the overlay transition.
     * @default `undefined`
     */
    overlayTransition: {
      type: [String, Object],
      default: void 0
    },
    /**
     * @description Customize the content transition.
     * @default `undefined`
     */
    contentTransition: {
      type: [String, Object],
      default: void 0
    },
    /**
     * @description Bind class to vfm__overlay.
     * @default `undefined`
     */
    overlayClass: {
      type: void 0,
      default: void 0
    },
    /**
     * @description Bind class to vfm__content.
     * @default `undefined`
     */
    contentClass: {
      type: void 0,
      default: void 0
    },
    /**
     * @description Bind style to vfm__overlay.
     * @default `undefined`
     */
    overlayStyle: {
      type: [String, Object, Array],
      default: void 0
    },
    /**
     * @description Bind style to vfm__content.
     * @default `undefined`
     */
    contentStyle: {
      type: [String, Object, Array],
      default: void 0
    },
    /**
     * @description Is it allow to close the modal by clicking the overlay.
     * @default `true`
     */
    clickToClose: {
      type: Boolean,
      default: true
    },
    /**
     * @description Is it allow to close the modal by keypress `esc`.
     * @default `true`
     */
    escToClose: {
      type: Boolean,
      default: true
    },
    /**
     * @description Is it allow to click outside of the vfm__content when the modal is opened
     * @default `'non-interactive'`
     */
    background: {
      type: String,
      default: "non-interactive",
      validator: (e) => ["interactive", "non-interactive"].includes(e)
    },
    /**
     * @description
     * * Use `{ disabled: true }` to disable the focusTrap.
     * * Checkout the createOptions type here https://github.com/focus-trap/focus-trap for more.
     * @default `{ allowOutsideClick: true }`
     */
    focusTrap: {
      type: [Boolean, Object],
      default: () => ({
        allowOutsideClick: true
      })
    },
    /**
     * @description Lock body scroll or not when the modal is opened.
     * @default `true`
     */
    lockScroll: {
      type: Boolean,
      default: true
    },
    /**
     * @description Creates a padding-right when scroll is locked to prevent the page from jumping
     * @default `true`
     */
    reserveScrollBarGap: {
      type: Boolean,
      default: true
    },
    /**
     * @description Define how to increase the zIndex when there are nested modals
     * @default `({ index }) => 1000 + 2 * index`
     */
    zIndexFn: {
      type: Function,
      default: ({ index: e }) => 1e3 + 2 * e
    },
    /**
     * @description The direction of swiping to close the modal
     * @default `none`
     * @example
     * Set swipeToClose="none" to disable swiping to close
     * ```js
     * swipeToClose="none"
     * ```
     */
    swipeToClose: {
      type: String,
      default: "none",
      validator: (e) => ["none", "up", "right", "down", "left"].includes(e)
    },
    /**
     * @description Threshold for swipe to close
     * @default `0`
     */
    threshold: {
      type: Number,
      default: 0
    },
    /**
     * @description If set `:showSwipeBanner="true"`, only allow clicking `swipe-banner` slot to swipe to close
     * @default `undefined`
     * @example
     * ```js
     * swipeToClose="right"
     * :showSwipeBanner="true"
     * ```
     * ```html
     * <VueFinalModal
     *   ...
     *   swipeToClose="right"
     *   :showSwipeBanner="true"
     * >
     *   <template #swipe-banner>
     *     <div style="position: absolute; height: 100%; top: 0; left: 0; width: 10px;" />
     *   </template>
     *   ...modal content
     * </VueFinalModal>
     * ```
     */
    showSwipeBanner: {
      type: Boolean,
      default: void 0
    },
    /**
     * @description When set `:preventNavigationGestures="true"`, there will be two invisible bars for prevent navigation gestures including swiping back/forward on mobile webkit. For example: Safari mobile.
     * @default `undefined`
     * @example
     * Set preventNavigationGestures="true" to prevent Safari navigation gestures including swiping back/forward.
     * ```js
     * :preventNavigationGestures="true"
     * ```
     */
    preventNavigationGestures: {
      type: Boolean,
      default: void 0
    }
  };
  function Oe$3(e = false) {
    const o2 = ref(e), l2 = ref(o2.value ? 0 : void 0);
    return [o2, l2, {
      beforeEnter() {
        l2.value = 1;
      },
      afterEnter() {
        l2.value = 0;
      },
      beforeLeave() {
        l2.value = 3;
      },
      afterLeave() {
        l2.value = 2;
      }
    }];
  }
  function fo(e, o2) {
    const { modelValueLocal: l2, onEntering: s2, onEnter: u2, onLeaving: c2, onLeave: a2 } = o2, n2 = ref(l2.value), [t, r2, m2] = Oe$3(n2.value), [f2, M2, S2] = Oe$3(n2.value), V2 = computed(() => typeof e.contentTransition == "string" ? { name: e.contentTransition, appear: true } : __spreadValues({ appear: true }, e.contentTransition)), O2 = computed(() => typeof e.overlayTransition == "string" ? { name: e.overlayTransition, appear: true } : __spreadValues({ appear: true }, e.overlayTransition)), E2 = computed(
      () => (e.hideOverlay || M2.value === 2) && r2.value === 2
      /* Leave */
    );
    watch(
      E2,
      (k2) => {
        k2 && (n2.value = false);
      }
    ), watch(r2, (k2) => {
      if (k2 === 1) {
        if (!n2.value)
          return;
        s2 == null || s2();
      } else if (k2 === 0) {
        if (!n2.value)
          return;
        u2 == null || u2();
      } else
        k2 === 3 ? c2 == null || c2() : k2 === 2 && (a2 == null || a2());
    });
    function w2() {
      return __async(this, null, function* () {
        n2.value = true, yield nextTick(), t.value = true, f2.value = true;
      });
    }
    function D2() {
      t.value = false, f2.value = false;
    }
    return {
      visible: n2,
      contentVisible: t,
      contentListeners: m2,
      contentTransition: V2,
      overlayVisible: f2,
      overlayListeners: S2,
      overlayTransition: O2,
      enterTransition: w2,
      leaveTransition: D2
    };
  }
  function vo(e, o2, l2) {
    const { vfmRootEl: s2, vfmContentEl: u2, visible: c2, modelValueLocal: a2 } = l2, n2 = ref();
    function t() {
      c2.value && e.escToClose && (a2.value = false);
    }
    function r2(f2) {
      n2.value = f2 == null ? void 0 : f2.target;
    }
    function m2() {
      var f2;
      n2.value === s2.value && (e.clickToClose ? a2.value = false : ((f2 = u2.value) == null || f2.focus(), o2("clickOutside")));
    }
    return {
      onEsc: t,
      onMouseupRoot: m2,
      onMousedown: r2
    };
  }
  function po(e, o2, l2) {
    let s2 = false;
    const { open: u2, close: c2 } = l2, a2 = ref(false), n2 = {
      get value() {
        return a2.value;
      },
      set value(r2) {
        t(r2);
      }
    };
    function t(r2) {
      (r2 ? u2() : c2()) ? (a2.value = r2, r2 !== e.modelValue && o2("update:modelValue", r2)) : (s2 = true, o2("update:modelValue", !r2), nextTick(() => {
        s2 = false;
      }));
    }
    return watch(() => e.modelValue, (r2) => {
      s2 || (n2.value = !!r2);
    }), {
      modelValueLocal: n2
    };
  }
  function yo(e, o2) {
    if (e.focusTrap === false)
      return {
        focus() {
        },
        blur() {
        }
      };
    const { focusEl: l2 } = o2, { hasFocus: s2, activate: u2, deactivate: c2 } = useFocusTrap(l2, e.focusTrap);
    function a2() {
      requestAnimationFrame(() => {
        u2();
      });
    }
    function n2() {
      s2.value && c2();
    }
    return { focus: a2, blur: n2 };
  }
  let be$3 = false;
  if (typeof window < "u") {
    const e = {
      get passive() {
        be$3 = true;
      }
    };
    window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
  }
  const He$2 = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
  let j = [], le$3 = false, ne$1 = 0, je$1 = -1, W$3, X$3;
  const ho = (e) => {
    if (!e || e.nodeType !== Node.ELEMENT_NODE)
      return false;
    const o2 = window.getComputedStyle(e);
    return ["auto", "scroll"].includes(o2.overflowY) && e.scrollHeight > e.clientHeight;
  }, mo = (e, o2) => !(e.scrollTop === 0 && o2 < 0 || e.scrollTop + e.clientHeight + o2 >= e.scrollHeight && o2 > 0), wo = (e) => {
    const o2 = [];
    for (; e; ) {
      if (o2.push(e), e.classList.contains("vfm"))
        return o2;
      e = e.parentElement;
    }
    return o2;
  }, bo = (e, o2) => {
    let l2 = false;
    return wo(e).forEach((u2) => {
      ho(u2) && mo(u2, o2) && (l2 = true);
    }), l2;
  }, Ne$2 = (e) => j.some(() => bo(e, -ne$1)), se$2 = (e) => {
    const o2 = e || window.event;
    return Ne$2(o2.target) || o2.touches.length > 1 ? true : (o2.preventDefault && o2.preventDefault(), false);
  }, To = (e) => {
    if (X$3 === void 0) {
      const o2 = !!e && e.reserveScrollBarGap === true, l2 = window.innerWidth - document.documentElement.clientWidth;
      if (o2 && l2 > 0) {
        const s2 = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
        X$3 = document.body.style.paddingRight, document.body.style.paddingRight = `${s2 + l2}px`;
      }
    }
    W$3 === void 0 && (W$3 = document.body.style.overflow, document.body.style.overflow = "hidden");
  }, So = () => {
    X$3 !== void 0 && (document.body.style.paddingRight = X$3, X$3 = void 0), W$3 !== void 0 && (document.body.style.overflow = W$3, W$3 = void 0);
  }, Mo = (e) => e ? e.scrollHeight - e.scrollTop <= e.clientHeight : false, go = (e, o2) => (ne$1 = e.targetTouches[0].clientY - je$1, Ne$2(e.target) ? false : o2 && o2.scrollTop === 0 && ne$1 > 0 || Mo(o2) && ne$1 < 0 ? se$2(e) : (e.stopPropagation(), true)), Co = (e, o2) => {
    if (!e) {
      console.error(
        "disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."
      );
      return;
    }
    if (j.some((s2) => s2.targetElement === e))
      return;
    const l2 = {
      targetElement: e,
      options: o2 || {}
    };
    j = [...j, l2], He$2 ? (e.ontouchstart = (s2) => {
      s2.targetTouches.length === 1 && (je$1 = s2.targetTouches[0].clientY);
    }, e.ontouchmove = (s2) => {
      s2.targetTouches.length === 1 && go(s2, e);
    }, le$3 || (document.addEventListener("touchmove", se$2, be$3 ? { passive: false } : void 0), le$3 = true)) : To(o2);
  }, ko = (e) => {
    if (!e) {
      console.error(
        "enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."
      );
      return;
    }
    j = j.filter((o2) => o2.targetElement !== e), He$2 ? (e.ontouchstart = null, e.ontouchmove = null, le$3 && j.length === 0 && (document.removeEventListener("touchmove", se$2, be$3 ? { passive: false } : void 0), le$3 = false)) : j.length || So();
  };
  function Vo(e, o2) {
    const { lockScrollEl: l2, modelValueLocal: s2 } = o2;
    let u2;
    watch(l2, (n2) => {
      n2 && (u2 = n2);
    }, { immediate: true }), watch(() => e.lockScroll, (n2) => {
      n2 ? a2() : c2();
    }), onBeforeUnmount(() => {
      c2();
    });
    function c2() {
      u2 && ko(u2);
    }
    function a2() {
      s2.value && e.lockScroll && u2 && Co(u2, {
        reserveScrollBarGap: e.reserveScrollBarGap,
        allowTouchMove: (n2) => {
          for (; n2 && n2 !== document.body; ) {
            if (n2.getAttribute("vfm-scroll-lock-ignore") !== null)
              return true;
            n2 = n2.parentElement;
          }
          return false;
        }
      });
    }
    return {
      enableBodyScroll: c2,
      disableBodyScroll: a2
    };
  }
  function Eo(e) {
    const o2 = ref();
    function l2(u2) {
      var c2;
      o2.value = (c2 = e.zIndexFn) == null ? void 0 : c2.call(e, { index: u2 <= -1 ? 0 : u2 });
    }
    function s2() {
      o2.value = void 0;
    }
    return {
      zIndex: o2,
      refreshZIndex: l2,
      resetZIndex: s2
    };
  }
  const ve$2 = {
    beforeMount(e, { value: o2 }, { transition: l2 }) {
      e._vov = e.style.visibility === "hidden" ? "" : e.style.visibility, l2 && o2 ? l2.beforeEnter(e) : G$3(e, o2);
    },
    mounted(e, { value: o2 }, { transition: l2 }) {
      l2 && o2 && l2.enter(e);
    },
    updated(e, { value: o2, oldValue: l2 }, { transition: s2 }) {
      !o2 != !l2 && (s2 ? o2 ? (s2.beforeEnter(e), G$3(e, true), s2.enter(e)) : s2.leave(e, () => {
        G$3(e, false);
      }) : G$3(e, o2));
    },
    beforeUnmount(e, { value: o2 }) {
      G$3(e, o2);
    }
  };
  function G$3(e, o2) {
    e.style.visibility = o2 ? e._vov : "hidden";
  }
  const De$1 = (e) => {
    if (e instanceof MouseEvent) {
      const { clientX: o2, clientY: l2 } = e;
      return { x: o2, y: l2 };
    } else {
      const { clientX: o2, clientY: l2 } = e.targetTouches[0];
      return { x: o2, y: l2 };
    }
  };
  function Bo(e) {
    if (!e)
      return false;
    let o2 = false;
    const l2 = {
      get passive() {
        return o2 = true, false;
      }
    };
    return e.addEventListener("x", q$3, l2), e.removeEventListener("x", q$3), o2;
  }
  function Oo(e, {
    threshold: o2 = 0,
    onSwipeStart: l2,
    onSwipe: s2,
    onSwipeEnd: u2,
    passive: c2 = true
  }) {
    const a2 = reactive({ x: 0, y: 0 }), n2 = reactive({ x: 0, y: 0 }), t = computed(() => a2.x - n2.x), r2 = computed(() => a2.y - n2.y), { max: m2, abs: f2 } = Math, M2 = computed(
      () => m2(f2(t.value), f2(r2.value)) >= o2
    ), S2 = ref(false), V2 = computed(() => M2.value ? f2(t.value) > f2(r2.value) ? t.value > 0 ? "left" : "right" : r2.value > 0 ? "up" : "down" : "none"), O2 = (p2, h2) => {
      a2.x = p2, a2.y = h2;
    }, E2 = (p2, h2) => {
      n2.x = p2, n2.y = h2;
    };
    let w2, D2;
    function k2(p2) {
      w2.capture && !w2.passive && p2.preventDefault();
      const { x: h2, y: R2 } = De$1(p2);
      O2(h2, R2), E2(h2, R2), l2 == null || l2(p2), D2 = [
        useEventListener(e, "mousemove", P2, w2),
        useEventListener(e, "touchmove", P2, w2),
        useEventListener(e, "mouseup", i2, w2),
        useEventListener(e, "touchend", i2, w2),
        useEventListener(e, "touchcancel", i2, w2)
      ];
    }
    function P2(p2) {
      const { x: h2, y: R2 } = De$1(p2);
      E2(h2, R2), !S2.value && M2.value && (S2.value = true), S2.value && (s2 == null || s2(p2));
    }
    function i2(p2) {
      S2.value && (u2 == null || u2(p2, V2.value)), S2.value = false, D2.forEach((h2) => h2());
    }
    let b2 = [];
    return onMounted(() => {
      const p2 = Bo(window == null ? void 0 : window.document);
      c2 ? w2 = p2 ? { passive: true } : { capture: false } : w2 = p2 ? { passive: false, capture: true } : { capture: true }, b2 = [
        useEventListener(e, "mousedown", k2, w2),
        useEventListener(e, "touchstart", k2, w2)
      ];
    }), {
      isSwiping: S2,
      direction: V2,
      coordsStart: a2,
      coordsEnd: n2,
      lengthX: t,
      lengthY: r2,
      stop: () => {
        b2.forEach((p2) => p2()), D2.forEach((p2) => p2());
      }
    };
  }
  function Do(e, o2) {
    const { vfmContentEl: l2, modelValueLocal: s2 } = o2, u2 = 0.1, c2 = 300, a2 = ref(), n2 = computed(() => {
      if (!(e.swipeToClose === void 0 || e.swipeToClose === "none"))
        return e.showSwipeBanner ? a2.value : l2.value;
    }), t = ref(0), r2 = ref(true);
    let m2 = q$3, f2 = true, M2, S2 = false;
    const { lengthX: V2, lengthY: O2, direction: E2, isSwiping: w2 } = Oo(n2, {
      threshold: e.threshold,
      onSwipeStart(i2) {
        m2 = useEventListener(document, "selectionchange", () => {
          var b2;
          r2.value = (b2 = window.getSelection()) == null ? void 0 : b2.isCollapsed;
        }), M2 = (/* @__PURE__ */ new Date()).getTime(), S2 = P2(i2 == null ? void 0 : i2.target);
      },
      onSwipe() {
        var i2, b2, L2, p2;
        if (S2 && r2.value && E2.value === e.swipeToClose) {
          if (E2.value === "up") {
            const h2 = oe$3(Math.abs(O2.value || 0), 0, ((i2 = n2.value) == null ? void 0 : i2.offsetHeight) || 0) - (e.threshold || 0);
            t.value = h2;
          } else if (E2.value === "down") {
            const h2 = oe$3(Math.abs(O2.value || 0), 0, ((b2 = n2.value) == null ? void 0 : b2.offsetHeight) || 0) - (e.threshold || 0);
            t.value = -h2;
          } else if (E2.value === "right") {
            const h2 = oe$3(Math.abs(V2.value || 0), 0, ((L2 = n2.value) == null ? void 0 : L2.offsetWidth) || 0) - (e.threshold || 0);
            t.value = -h2;
          } else if (E2.value === "left") {
            const h2 = oe$3(Math.abs(V2.value || 0), 0, ((p2 = n2.value) == null ? void 0 : p2.offsetWidth) || 0) - (e.threshold || 0);
            t.value = h2;
          }
        }
      },
      onSwipeEnd(i2, b2) {
        if (m2(), !r2.value) {
          r2.value = true;
          return;
        }
        const L2 = (/* @__PURE__ */ new Date()).getTime(), p2 = b2 === e.swipeToClose, h2 = (() => {
          var J2, Q2;
          if (b2 === "up" || b2 === "down")
            return Math.abs((O2 == null ? void 0 : O2.value) || 0) > u2 * (((J2 = n2.value) == null ? void 0 : J2.offsetHeight) || 0);
          if (b2 === "left" || b2 === "right")
            return Math.abs((V2 == null ? void 0 : V2.value) || 0) > u2 * (((Q2 = n2.value) == null ? void 0 : Q2.offsetWidth) || 0);
        })(), R2 = L2 - M2 <= c2;
        if (f2 && S2 && p2 && (h2 || R2)) {
          s2.value = false;
          return;
        }
        t.value = 0;
      }
    }), D2 = computed(() => {
      if (e.swipeToClose === "none")
        return;
      const i2 = (() => {
        switch (e.swipeToClose) {
          case "up":
          case "down":
            return "translateY";
          case "left":
          case "right":
            return "translateX";
        }
      })();
      return {
        class: { "vfm-bounce-back": !w2.value },
        style: { transform: `${i2}(${-t.value}px)` }
      };
    });
    watch(
      () => r2.value,
      (i2) => {
        i2 || (t.value = 0);
      }
    ), watch(
      () => s2.value,
      (i2) => {
        i2 && (t.value = 0);
      }
    ), watch(
      () => t.value,
      (i2, b2) => {
        switch (e.swipeToClose) {
          case "down":
          case "right":
            f2 = i2 < b2;
            break;
          case "up":
          case "left":
            f2 = i2 > b2;
            break;
        }
      }
    );
    function k2(i2) {
      e.preventNavigationGestures && i2.preventDefault();
    }
    function P2(i2) {
      const b2 = i2 == null ? void 0 : i2.tagName;
      if (!b2 || ["INPUT", "TEXTAREA"].includes(b2))
        return false;
      const L2 = (() => {
        switch (e.swipeToClose) {
          case "up":
            return (i2 == null ? void 0 : i2.scrollTop) + (i2 == null ? void 0 : i2.clientHeight) === (i2 == null ? void 0 : i2.scrollHeight);
          case "left":
            return (i2 == null ? void 0 : i2.scrollLeft) + (i2 == null ? void 0 : i2.clientWidth) === (i2 == null ? void 0 : i2.scrollWidth);
          case "down":
            return (i2 == null ? void 0 : i2.scrollTop) === 0;
          case "right":
            return (i2 == null ? void 0 : i2.scrollLeft) === 0;
          default:
            return false;
        }
      })();
      return i2 === n2.value ? L2 : L2 && P2(i2 == null ? void 0 : i2.parentElement);
    }
    return {
      vfmContentEl: l2,
      swipeBannerEl: a2,
      bindSwipe: D2,
      onTouchStartSwipeBanner: k2
    };
  }
  const Ye$1 = Symbol("vfm");
  let H$3;
  const Lo = (e) => H$3 = e, Po = {
    install: q$3,
    modals: [],
    openedModals: [],
    openedModalOverlays: [],
    dynamicModals: [],
    modalsContainers: ref([]),
    get: () => {
    },
    toggle: () => {
    },
    open: () => {
    },
    close: () => {
    },
    closeAll: () => Promise.allSettled([])
  }, Ao = () => getCurrentInstance() && inject(Ye$1, Po) || H$3;
  function zo() {
    const e = shallowReactive([]), o2 = shallowReactive([]), l2 = shallowReactive([]), s2 = shallowReactive([]), u2 = ref([]), c2 = markRaw({
      install(a2) {
        a2.provide(Ye$1, c2), a2.config.globalProperties.$vfm = c2;
      },
      modals: e,
      openedModals: o2,
      openedModalOverlays: l2,
      dynamicModals: s2,
      modalsContainers: u2,
      get(a2) {
        return e.find((n2) => {
          var t, r2;
          return ((r2 = (t = Z$3(n2)) == null ? void 0 : t.value.modalId) == null ? void 0 : r2.value) === a2;
        });
      },
      toggle(a2, n2) {
        var r2;
        const t = c2.get(a2);
        return (r2 = Z$3(t)) == null ? void 0 : r2.value.toggle(n2);
      },
      open(a2) {
        return c2.toggle(a2, true);
      },
      close(a2) {
        return c2.toggle(a2, false);
      },
      closeAll() {
        return Promise.allSettled(
          o2.reduce((a2, n2) => {
            const t = Z$3(n2), r2 = t == null ? void 0 : t.value.toggle(false);
            return r2 && a2.push(r2), a2;
          }, [])
        );
      }
    });
    return Lo(c2), c2;
  }
  function Z$3(e) {
    var o2;
    return (o2 = e == null ? void 0 : e.exposed) == null ? void 0 : o2.modalExposed;
  }
  const Io = /* @__PURE__ */ defineComponent({ inheritAttrs: false }), Ro = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, Io), {
    __name: "VueFinalModal",
    props: co,
    emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
    setup(e, { expose: o2, emit: l2 }) {
      const s2 = e, u2 = l2, c2 = useAttrs(), a2 = getCurrentInstance(), { modals: n2, openedModals: t, openedModalOverlays: r2 } = K$2(), m2 = ref(), f2 = ref(), { focus: M2, blur: S2 } = yo(s2, { focusEl: m2 }), { zIndex: V2, refreshZIndex: O2, resetZIndex: E2 } = Eo(s2), { modelValueLocal: w2 } = po(s2, u2, { open: We2, close: Xe2 }), { enableBodyScroll: D2, disableBodyScroll: k2 } = Vo(s2, {
        lockScrollEl: m2,
        modelValueLocal: w2
      });
      let P2 = q$3;
      const {
        visible: i2,
        contentVisible: b2,
        contentListeners: L2,
        contentTransition: p2,
        overlayVisible: h2,
        overlayListeners: R2,
        overlayTransition: J2,
        enterTransition: Q2,
        leaveTransition: xe2
      } = fo(s2, {
        modelValueLocal: w2,
        onEntering() {
          nextTick(() => {
            k2(), M2();
          });
        },
        onEnter() {
          u2("opened"), P2("opened");
        },
        onLeave() {
          $$2(t, a2), E2(), D2(), u2("closed"), P2("closed");
        }
      }), { onEsc: ze2, onMouseupRoot: Ge2, onMousedown: Te2 } = vo(s2, u2, { vfmRootEl: m2, vfmContentEl: f2, visible: i2, modelValueLocal: w2 }), {
        swipeBannerEl: $e,
        bindSwipe: Ue2,
        onTouchStartSwipeBanner: Se2
      } = Do(s2, { vfmContentEl: f2, modelValueLocal: w2 }), Me2 = computed(() => a2 ? t.indexOf(a2) : -1);
      watch([() => s2.zIndexFn, Me2], () => {
        i2.value && O2(Me2.value);
      }), onMounted(() => {
        fe$3(n2, a2);
      }), s2.modelValue && (w2.value = true);
      function We2() {
        let d2 = false;
        return u2("beforeOpen", { stop: () => d2 = true }), d2 ? false : (fe$3(t, a2), fe$3(r2, a2), ie2(), Q2(), true);
      }
      function Xe2() {
        let d2 = false;
        return u2("beforeClose", { stop: () => d2 = true }), d2 ? false : ($$2(r2, a2), ie2(), S2(), xe2(), true);
      }
      function Ze2() {
        w2.value = false;
      }
      onBeforeUnmount(() => {
        D2(), $$2(n2, a2), $$2(t, a2), S2(), ie2();
      });
      function ie2() {
        return __async(this, null, function* () {
          yield nextTick();
          const d2 = r2.filter((y2) => {
            var A2;
            const T2 = Z$3(y2);
            return (T2 == null ? void 0 : T2.value.overlayBehavior.value) === "auto" && !((A2 = T2 == null ? void 0 : T2.value.hideOverlay) != null && A2.value);
          });
          d2.forEach((y2, T2) => {
            const A2 = Z$3(y2);
            A2 != null && A2.value && (A2.value.overlayVisible.value = T2 === d2.length - 1);
          });
        });
      }
      const Ke2 = toRef(() => s2.modalId), ge2 = toRef(() => s2.hideOverlay), qe2 = toRef(() => s2.overlayBehavior), Je2 = computed(() => ({
        modalId: Ke2,
        hideOverlay: ge2,
        overlayBehavior: qe2,
        overlayVisible: h2,
        toggle(d2) {
          return new Promise((y2) => {
            P2 = uo((A2) => y2(A2));
            const T2 = typeof d2 == "boolean" ? d2 : !w2.value;
            w2.value = T2;
          });
        }
      }));
      return o2({
        modalExposed: Je2
      }), (d2, y2) => (openBlock(), createBlock(Teleport, {
        to: d2.teleportTo ? d2.teleportTo : void 0,
        disabled: !d2.teleportTo
      }, [
        d2.displayDirective !== "if" || unref(i2) ? withDirectives((openBlock(), createElementBlock("div", mergeProps({ key: 0 }, unref(c2), {
          ref_key: "vfmRootEl",
          ref: m2,
          class: ["vfm vfm--fixed vfm--inset", { "vfm--prevent-none": d2.background === "interactive" }],
          style: { zIndex: unref(V2) },
          role: "dialog",
          "aria-modal": "true",
          onKeydown: y2[7] || (y2[7] = withKeys(() => unref(ze2)(), ["esc"])),
          onMouseup: y2[8] || (y2[8] = withModifiers(() => unref(Ge2)(), ["self"])),
          onMousedown: y2[9] || (y2[9] = withModifiers((T2) => unref(Te2)(T2), ["self"]))
        }), [
          ge2.value ? createCommentVNode("", true) : (openBlock(), createBlock(Transition, mergeProps({ key: 0 }, unref(J2), toHandlers(unref(R2))), {
            default: withCtx(() => [
              d2.displayDirective !== "if" || unref(h2) ? withDirectives((openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["vfm__overlay vfm--overlay vfm--absolute vfm--inset vfm--prevent-none", d2.overlayClass]),
                style: normalizeStyle(d2.overlayStyle),
                "aria-hidden": "true"
              }, null, 6)), [
                [vShow, d2.displayDirective !== "show" || unref(h2)],
                [unref(ve$2), d2.displayDirective !== "visible" || unref(h2)]
              ]) : createCommentVNode("", true)
            ]),
            _: 1
          }, 16)),
          createVNode(Transition, mergeProps(unref(p2), toHandlers(unref(L2))), {
            default: withCtx(() => [
              d2.displayDirective !== "if" || unref(b2) ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
                key: 0,
                ref_key: "vfmContentEl",
                ref: f2,
                class: ["vfm__content vfm--outline-none", [d2.contentClass, { "vfm--prevent-auto": d2.background === "interactive" }]],
                style: d2.contentStyle,
                tabindex: "0"
              }, unref(Ue2), {
                onMousedown: y2[6] || (y2[6] = () => unref(Te2)())
              }), [
                renderSlot(d2.$slots, "default", normalizeProps(guardReactiveProps({ close: Ze2 }))),
                d2.showSwipeBanner ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_key: "swipeBannerEl",
                  ref: $e,
                  class: "vfm-swipe-banner-container",
                  onTouchstart: y2[2] || (y2[2] = (T2) => unref(Se2)(T2))
                }, [
                  renderSlot(d2.$slots, "swipe-banner", {}, () => [
                    createBaseVNode("div", {
                      class: "vfm-swipe-banner-back",
                      onTouchstart: y2[0] || (y2[0] = (T2) => d2.swipeToClose === "left" && T2.preventDefault())
                    }, null, 32),
                    createBaseVNode("div", {
                      class: "vfm-swipe-banner-forward",
                      onTouchstart: y2[1] || (y2[1] = (T2) => d2.swipeToClose === "right" && T2.preventDefault())
                    }, null, 32)
                  ])
                ], 544)) : !d2.showSwipeBanner && d2.preventNavigationGestures ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: "vfm-swipe-banner-container",
                  onTouchstart: y2[5] || (y2[5] = (T2) => unref(Se2)(T2))
                }, [
                  createBaseVNode("div", {
                    class: "vfm-swipe-banner-back",
                    onTouchstart: y2[3] || (y2[3] = (T2) => d2.swipeToClose === "left" && T2.preventDefault())
                  }, null, 32),
                  createBaseVNode("div", {
                    class: "vfm-swipe-banner-forward",
                    onTouchstart: y2[4] || (y2[4] = (T2) => d2.swipeToClose === "right" && T2.preventDefault())
                  }, null, 32)
                ], 32)) : createCommentVNode("", true)
              ], 16)), [
                [vShow, d2.displayDirective !== "show" || unref(b2)],
                [unref(ve$2), d2.displayDirective !== "visible" || unref(b2)]
              ]) : createCommentVNode("", true)
            ]),
            _: 3
          }, 16)
        ], 16)), [
          [vShow, d2.displayDirective !== "show" || unref(i2)],
          [unref(ve$2), d2.displayDirective !== "visible" || unref(i2)]
        ]) : createCommentVNode("", true)
      ], 8, ["to", "disabled"]));
    }
  }));
  function K$2() {
    const e = Ao();
    if (!e)
      throw new Error(
        `[Vue Final Modal]: getActiveVfm was called with no active Vfm. Did you forget to install vfm?
	const vfm = createVfm()
	app.use(vfm)
This will fail in production.`
      );
    return e;
  }
  function re$3(e) {
    return typeof e == "object" && e !== null ? "component" in e : false;
  }
  const jo = ["innerHTML"], Wo = /* @__PURE__ */ defineComponent({
    __name: "ModalsContainer",
    setup(e) {
      const { modalsContainers: o2, dynamicModals: l2 } = K$2(), s2 = Symbol("ModalsContainer"), u2 = computed(() => {
        var n2;
        return s2 === ((n2 = o2.value) == null ? void 0 : n2[0]);
      });
      o2.value.push(s2), onBeforeUnmount(() => {
        o2.value = o2.value.filter((n2) => n2 !== s2);
      });
      function c2(n2) {
        var t, r2, m2;
        (r2 = (t = l2[n2]) == null ? void 0 : t.resolveClosed) == null || r2.call(t), (m2 = l2[n2]) != null && m2.keepAlive || l2.splice(n2, 1);
      }
      function a2(n2) {
        var t, r2;
        (r2 = (t = l2[n2]) == null ? void 0 : t.resolveOpened) == null || r2.call(t);
      }
      return (n2, t) => u2.value ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(l2), (r2, m2) => (openBlock(), createBlock(resolveDynamicComponent(r2.component), mergeProps({
        key: r2.id
      }, __spreadValues({
        displayDirective: r2 != null && r2.keepAlive ? "show" : void 0
      }, typeof r2.attrs == "object" ? r2.attrs : {}), {
        modelValue: r2.modelValue,
        "onUpdate:modelValue": (f2) => r2.modelValue = f2,
        onClosed: () => c2(m2),
        onOpened: () => a2(m2)
      }), createSlots({ _: 2 }, [
        renderList(r2.slots, (f2, M2) => ({
          name: M2,
          fn: withCtx(() => [
            unref(we$3)(f2) ? (openBlock(), createElementBlock("div", {
              key: 0,
              innerHTML: f2
            }, null, 8, jo)) : unref(re$3)(f2) ? (openBlock(), createBlock(resolveDynamicComponent(f2.component), normalizeProps(mergeProps({ key: 1 }, f2.attrs)), null, 16)) : (openBlock(), createBlock(resolveDynamicComponent(f2), { key: 2 }))
          ])
        }))
      ]), 1040, ["modelValue", "onUpdate:modelValue", "onClosed", "onOpened"]))), 128)) : createCommentVNode("", true);
    }
  });
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var Symbol$1 = root.Symbol;
  var objectProto$b = Object.prototype;
  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$b.toString;
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$9.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var objectProto$a = Object.prototype;
  var nativeObjectToString = objectProto$a.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var isArray$1 = Array.isArray;
  function isObject$1(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction$2(value) {
    if (!isObject$1(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = (function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  })();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var funcProto$1 = Function.prototype;
  var funcToString$1 = funcProto$1.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto$9 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var WeakMap$1 = getNative(root, "WeakMap");
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ (function() {
    function object() {
    }
    return function(proto) {
      if (!isObject$1(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  })();
  var defineProperty = (function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  })();
  function arrayEach(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var objectProto$8 = Object.prototype;
  var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$7.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction$2(value);
  }
  var objectProto$7 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$7;
    return value === proto;
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  var argsTag$2 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$2;
  }
  var objectProto$6 = Object.prototype;
  var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
  var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
  };
  function stubFalse() {
    return false;
  }
  var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$2 = moduleExports$2 ? root.Buffer : void 0;
  var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
  var isBuffer$1 = nativeIsBuffer || stubFalse;
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
  var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal.process;
  var nodeUtil = (function() {
    try {
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  })();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if (hasOwnProperty$5.call(value, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var nativeKeys = overArg(Object.keys, Object);
  var objectProto$4 = Object.prototype;
  var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$4.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function keys$1(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  var nativeCreate = getNative(Object, "create");
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  var objectProto$3 = Object.prototype;
  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? void 0 : result;
    }
    return hasOwnProperty$3.call(data, key) ? data[key] : void 0;
  }
  var objectProto$2 = Object.prototype;
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty$2.call(data, key);
  }
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  var Map$1 = getNative(root, "Map");
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$1 || ListCache)(),
      "string": new Hash()
    };
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size2 = data.size;
    data.set(key, value);
    this.size += data.size == size2 ? 0 : 1;
    return this;
  }
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset2 = array.length;
    while (++index2 < length) {
      array[offset2 + index2] = values[index2];
    }
    return array;
  }
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer$1 = moduleExports ? root.Buffer : void 0;
  Buffer$1 ? Buffer$1.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    {
      return buffer.slice();
    }
  }
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function stubArray() {
    return [];
  }
  var objectProto$1 = Object.prototype;
  var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys$1, getSymbols);
  }
  var DataView = getNative(root, "DataView");
  var Promise$1 = getNative(root, "Promise");
  var Set$1 = getNative(root, "Set");
  var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
  var dataViewTag$2 = "[object DataView]";
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$2;
          case mapCtorString:
            return mapTag$3;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$3;
          case weakMapCtorString:
            return weakMapTag$1;
        }
      }
      return result;
    };
  }
  var objectProto = Object.prototype;
  var hasOwnProperty$1 = objectProto.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  var Uint8Array$1 = root.Uint8Array;
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = cloneArrayBuffer(dataView.buffer);
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = cloneArrayBuffer(typedArray.buffer);
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$1:
        return cloneArrayBuffer(object);
      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);
      case dataViewTag$1:
        return cloneDataView(object);
      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object);
      case mapTag$2:
        return new Ctor();
      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);
      case regexpTag$1:
        return cloneRegExp(object);
      case setTag$2:
        return new Ctor();
      case symbolTag$1:
        return cloneSymbol(object);
    }
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  var mapTag$1 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag$1;
  }
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  var setTag$1 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag$1;
  }
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key, object, stack2) {
    var result;
    if (result !== void 0) {
      return result;
    }
    if (!isObject$1(value)) {
      return value;
    }
    var isArr = isArray$1(value);
    if (isArr) {
      result = initCloneArray(value);
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer$1(value)) {
        return cloneBuffer(value);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result = isFunc ? {} : initCloneObject(value);
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag);
      }
    }
    stack2 || (stack2 = new Stack());
    var stacked = stack2.get(value);
    if (stacked) {
      return stacked;
    }
    stack2.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
      });
    }
    var keysFunc = getAllKeys;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
    });
    return result;
  }
  var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }
  const notyf$3 = new Notyf({ duration: 5e3 });
  const useTrStore = /* @__PURE__ */ defineStore("tr", () => {
    const activeRequest = ref("");
    const activeStageId = ref("");
    const removedStages = ref([]);
    const addedStages = ref([]);
    const appConfig = reactive({
      optionsLeagues: window._flTournament.leaguesList || [],
      optionsSeasons: window._flTournament.seasonsList || [],
      optionsCountries: window._flTournament.countriesList || [],
      optionsTeams: window._flTournament.clubsList || [],
      stageGames: window._flTournament.stageGames || {}
    });
    const leagueId = ref(window._flTournament.leagueId || "");
    const seasonIds = ref(window._flTournament.seasonIds ? window._flTournament.seasonIds.split(",").map((i2) => Number(i2)) : []);
    const logo = ref(window._flTournament.logo || "");
    const logo_id = ref(window._flTournament.logo_id || "");
    const leagueSelected = computed(() => {
      return appConfig.optionsLeagues.find((l2) => Number(l2.id) === Number(leagueId.value));
    });
    const seasonsSelected = computed(() => {
      return appConfig.optionsSeasons.filter((s2) => seasonIds.value.map((i2) => Number(i2)).includes(Number(s2.id)));
    });
    const modals = reactive({
      seasonSelector: false,
      leagueSelector: false,
      groupManage: false,
      deleteStage: false,
      deleteRound: false,
      deleteGroup: false
    });
    const modalData = reactive({
      seasonsCreateMode: false,
      seasonsMultipleMode: false,
      seasonsCreateName: "",
      leaguesCreateMode: false,
      leaguesCreateName: "",
      leaguesCreateCountry: "",
      deleteGroupIndex: "",
      deleteRoundIndex: "",
      deleteRoundId: "",
      teamsRound: {},
      teamsGroup: {}
    });
    const stages = ref(cloneDeep(window._flTournament.stages) || []);
    const activeStage = computed(() => {
      return stages.value.find((s2) => s2.stageId === activeStageId.value);
    });
    const activeStageIndex = computed(() => {
      return stages.value.findIndex((s2) => s2.stageId === activeStageId.value);
    });
    const activeStageGamesFixStatusNeeded = computed(() => {
      var _a2, _b2;
      let fixNeeded = false;
      if ("friendly" !== activeStage.value.competitionStatusSaved && "friendly" !== activeStage.value.competitionStatus) {
        if ((_a2 = appConfig.stageGames[activeStage.value.stageId]) == null ? void 0 : _a2.friendly) {
          fixNeeded = true;
        }
      } else if ("friendly" === activeStage.value.competitionStatusSaved && "friendly" === activeStage.value.competitionStatus) {
        if ((_b2 = appConfig.stageGames[activeStage.value.stageId]) == null ? void 0 : _b2.official) {
          fixNeeded = true;
        }
      }
      return fixNeeded;
    });
    const setActiveStage = (id = "") => {
      if (id) {
        activeStageId.value = id;
      } else if (stages.value.length) {
        activeStageId.value = stages.value[stages.value.length - 1].stageId;
      } else {
        activeStageId.value = "";
      }
      if (activeStageId.value) {
        const aIndex = stages.value.findIndex((s2) => s2.stageId === activeStageId.value);
        const aStage = stages.value[aIndex];
        if (!aStage.rounds.length) {
          setTimeout(() => addInitialRound(), 0);
        } else {
          let nextIdRound = Math.max(...aStage.rounds.map((r2) => Number(r2.id))) + 1;
          if (nextIdRound > Number(aStage.nextIdRound)) {
            stages.value[aIndex].nextIdRound = nextIdRound;
          }
          let groupIds = [];
          aStage.rounds.forEach((r2) => {
            var _a2;
            if ((_a2 = r2.groups) == null ? void 0 : _a2.length) {
              r2.groups.forEach((g2) => {
                groupIds.push(Number(g2.id));
              });
            }
          });
          let nextIdGroup = Math.max(...groupIds) + 1;
          if (nextIdGroup > Number(aStage.nextIdGroup)) {
            stages.value[aIndex].nextIdGroup = nextIdGroup;
          }
        }
      }
    };
    const addInitialRound = () => {
      const groupData = {
        id: Number(activeStage.value.nextIdGroup),
        round: Number(activeStage.value.nextIdRound),
        teams: [],
        title: "#" + activeStage.value.nextIdGroup
      };
      stages.value[activeStageIndex.value].rounds = [
        {
          "id": Number(activeStage.value.nextIdRound),
          "title": "Round #" + activeStage.value.nextIdRound,
          "groups": [groupData]
        }
      ];
      incrementGroupId();
      incrementRoundId();
    };
    const incrementRoundId = () => {
      stages.value[activeStageIndex.value].nextIdRound++;
    };
    const incrementGroupId = () => {
      stages.value[activeStageIndex.value].nextIdGroup++;
    };
    const showError = (error) => {
      var _a2, _b2, _c, _d;
      const errorHeader = error.message ? error.message : "";
      const errorText = ((_b2 = (_a2 = error == null ? void 0 : error.response) == null ? void 0 : _a2.data) == null ? void 0 : _b2.message) ? error.response.data.message : "";
      const isWarning2 = "anwp_rest_warning" === ((_d = (_c = error == null ? void 0 : error.response) == null ? void 0 : _c.data) == null ? void 0 : _d.code);
      const toastMessage = errorHeader ? `<b>${errorHeader}</b><br>${errorText}` : errorText;
      if (isWarning2) {
        notyf$3.success(toastMessage);
      } else {
        notyf$3.error(toastMessage);
      }
    };
    const showSuccess = (successText = "", successHeader = "") => {
      const toastMessage = successHeader ? `<b>${successHeader}</b><br>${successText}` : successText;
      notyf$3.success(toastMessage);
    };
    return {
      activeStageGamesFixStatusNeeded,
      addedStages,
      activeRequest,
      activeStageId,
      activeStage,
      activeStageIndex,
      appConfig,
      incrementRoundId,
      incrementGroupId,
      leagueId,
      leagueSelected,
      logo,
      logo_id,
      modalData,
      modals,
      removedStages,
      seasonIds,
      seasonsSelected,
      setActiveStage,
      showError,
      showSuccess,
      stages
    };
  });
  const _hoisted_1$W = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$Q = { class: "my-0" };
  const _hoisted_3$O = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$N = {
    key: 0,
    class: "anwp-text-center"
  };
  const _hoisted_5$L = { class: "anwp-text-lg anwp-font-bold" };
  const _hoisted_6$J = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_7$G = { class: "d-flex flex-row-reverse" };
  const _sfc_main$V = {
    __name: "AppModalRoundDelete",
    setup(__props) {
      const trStore = useTrStore();
      const l10n = window._flTournamentL10n;
      const deleteRound = () => {
        if (0 < trStore.modalData.deleteRoundIndex) {
          trStore.stages[trStore.activeStageIndex].rounds = trStore.stages[trStore.activeStageIndex].rounds.filter((r2) => Number(r2.id) !== trStore.modalData.deleteRoundId);
        }
        trStore.modals.deleteRound = false;
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(trStore).modals.deleteRound,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(trStore).modals.deleteRound = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          onClosed: _cache[4] || (_cache[4] = ($event) => unref(trStore).modalData.deleteRoundIndex = ""),
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(trStore).modals.deleteRound = false),
              type: "button"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$W, [
              createBaseVNode("h4", _hoisted_2$Q, toDisplayString(unref(l10n).confirm_delete), 1)
            ]),
            createBaseVNode("div", _hoisted_3$O, [
              unref(trStore).modalData.deleteRoundIndex ? (openBlock(), createElementBlock("div", _hoisted_4$N, [
                createBaseVNode("div", _hoisted_5$L, toDisplayString(unref(l10n).are_you_sure), 1),
                createBaseVNode("p", null, toDisplayString(unref(l10n).want_to_delete_round), 1)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_6$J, [
              createBaseVNode("div", _hoisted_7$G, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary text-capitalize",
                  onClick: _cache[1] || (_cache[1] = ($event) => unref(trStore).modals.deleteRound = false)
                }, "Close"),
                unref(trStore).modalData.deleteRoundIndex ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: _cache[2] || (_cache[2] = withModifiers(($event) => deleteRound(), ["prevent"])),
                  type: "button",
                  class: "button button-secondary mx-2 text-capitalize anwp-border-red-600 anwp-text-red-600"
                }, " Delete Round ")) : createCommentVNode("", true)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$V = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$P = { class: "my-0" };
  const _hoisted_3$N = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$M = { class: "anwp-text-center" };
  const _hoisted_5$K = { class: "anwp-text-lg anwp-font-bold" };
  const _hoisted_6$I = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_7$F = { class: "d-flex flex-row-reverse" };
  const _sfc_main$U = {
    __name: "AppModalStageDelete",
    setup(__props) {
      const trStore = useTrStore();
      const l10n = window._flTournamentL10n;
      const deleteStage = () => {
        if (!String(trStore.activeStageId).includes("temp")) {
          trStore.removedStages.push(trStore.activeStageId);
        }
        trStore.stages = trStore.stages.filter((s2) => s2.stageId !== trStore.activeStageId);
        trStore.modals.deleteStage = false;
        trStore.setActiveStage();
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(trStore).modals.deleteStage,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(trStore).modals.deleteStage = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(trStore).modals.deleteStage = false),
              type: "button"
            }, [..._cache[4] || (_cache[4] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$V, [
              createBaseVNode("h4", _hoisted_2$P, toDisplayString(unref(l10n).confirm_delete), 1)
            ]),
            createBaseVNode("div", _hoisted_3$N, [
              createBaseVNode("div", _hoisted_4$M, [
                createBaseVNode("div", _hoisted_5$K, toDisplayString(unref(l10n).are_you_sure), 1),
                _cache[5] || (_cache[5] = createBaseVNode("p", null, "Do you really want to delete the Competition Stage with all its rounds and groups/ties?", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_6$I, [
              createBaseVNode("div", _hoisted_7$F, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary text-capitalize",
                  onClick: _cache[1] || (_cache[1] = ($event) => unref(trStore).modals.deleteStage = false)
                }, "Close"),
                createBaseVNode("button", {
                  onClick: _cache[2] || (_cache[2] = withModifiers(($event) => deleteStage(), ["prevent"])),
                  type: "button",
                  class: "button button-secondary mx-2 text-capitalize anwp-border-red-600 anwp-text-red-600"
                }, " Delete Stage ")
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  var _export_sfc$1 = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$T = {
    data() {
      return {
        innerValue: 1
      };
    },
    props: {
      modelValue: {
        type: Number
      },
      pageCount: {
        type: Number,
        required: true
      },
      initialPage: {
        type: Number,
        default: 1
      },
      forcePage: {
        type: Number
      },
      clickHandler: {
        type: Function,
        default: () => {
        }
      },
      pageRange: {
        type: Number,
        default: 3
      },
      marginPages: {
        type: Number,
        default: 1
      },
      prevText: {
        type: String,
        default: "Prev"
      },
      nextText: {
        type: String,
        default: "Next"
      },
      breakViewText: {
        type: String,
        default: ""
      },
      containerClass: {
        type: String,
        default: "pagination"
      },
      pageClass: {
        type: String,
        default: "page-item"
      },
      pageLinkClass: {
        type: String,
        default: "page-link"
      },
      prevClass: {
        type: String,
        default: "page-item"
      },
      prevLinkClass: {
        type: String,
        default: "page-link"
      },
      nextClass: {
        type: String,
        default: "page-item"
      },
      nextLinkClass: {
        type: String,
        default: "page-link"
      },
      breakViewClass: {
        type: String
      },
      breakViewLinkClass: {
        type: String
      },
      activeClass: {
        type: String,
        default: "active"
      },
      disabledClass: {
        type: String,
        default: "disabled"
      },
      noLiSurround: {
        type: Boolean,
        default: false
      },
      firstLastButton: {
        type: Boolean,
        default: false
      },
      firstButtonText: {
        type: String,
        default: "First"
      },
      lastButtonText: {
        type: String,
        default: "Last"
      },
      hidePrevNext: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      selected: {
        get: function() {
          return this.modelValue || this.innerValue;
        },
        set: function(newValue) {
          this.innerValue = newValue;
        }
      },
      pages: function() {
        let items = {};
        if (this.pageCount <= this.pageRange) {
          for (let index2 = 0; index2 < this.pageCount; index2++) {
            let page = {
              index: index2,
              content: index2 + 1,
              selected: index2 === this.selected - 1
            };
            items[index2] = page;
          }
        } else {
          const halfPageRange = Math.floor(this.pageRange / 2);
          let setPageItem = (index2) => {
            let page = {
              index: index2,
              content: index2 + 1,
              selected: index2 === this.selected - 1
            };
            items[index2] = page;
          };
          let setBreakView = (index2) => {
            let breakView = {
              disabled: true,
              breakView: true
            };
            items[index2] = breakView;
          };
          for (let i2 = 0; i2 < this.marginPages; i2++) {
            setPageItem(i2);
          }
          let selectedRangeLow = 0;
          if (this.selected - halfPageRange > 0) {
            selectedRangeLow = this.selected - 1 - halfPageRange;
          }
          let selectedRangeHigh = selectedRangeLow + this.pageRange - 1;
          if (selectedRangeHigh >= this.pageCount) {
            selectedRangeHigh = this.pageCount - 1;
            selectedRangeLow = selectedRangeHigh - this.pageRange + 1;
          }
          for (let i2 = selectedRangeLow; i2 <= selectedRangeHigh && i2 <= this.pageCount - 1; i2++) {
            setPageItem(i2);
          }
          if (selectedRangeLow > this.marginPages) {
            setBreakView(selectedRangeLow - 1);
          }
          if (selectedRangeHigh + 1 < this.pageCount - this.marginPages) {
            setBreakView(selectedRangeHigh + 1);
          }
          for (let i2 = this.pageCount - 1; i2 >= this.pageCount - this.marginPages; i2--) {
            setPageItem(i2);
          }
        }
        return items;
      }
    },
    methods: {
      handlePageSelected(selected) {
        if (this.selected === selected)
          return;
        this.innerValue = selected;
        this.$emit("update:modelValue", selected);
        this.clickHandler(selected);
      },
      prevPage() {
        if (this.selected <= 1)
          return;
        this.handlePageSelected(this.selected - 1);
      },
      nextPage() {
        if (this.selected >= this.pageCount)
          return;
        this.handlePageSelected(this.selected + 1);
      },
      firstPageSelected() {
        return this.selected === 1;
      },
      lastPageSelected() {
        return this.selected === this.pageCount || this.pageCount === 0;
      },
      selectFirstPage() {
        if (this.selected <= 1)
          return;
        this.handlePageSelected(1);
      },
      selectLastPage() {
        if (this.selected >= this.pageCount)
          return;
        this.handlePageSelected(this.pageCount);
      }
    },
    beforeMount() {
      this.innerValue = this.initialPage;
    },
    beforeUpdate() {
      if (this.forcePage === void 0)
        return;
      if (this.forcePage !== this.selected) {
        this.selected = this.forcePage;
      }
    }
  };
  const _hoisted_1$U = ["tabindex", "innerHTML"];
  const _hoisted_2$O = ["tabindex", "innerHTML"];
  const _hoisted_3$M = ["onClick", "onKeyup"];
  const _hoisted_4$L = ["tabindex", "innerHTML"];
  const _hoisted_5$J = ["tabindex", "innerHTML"];
  const _hoisted_6$H = ["innerHTML"];
  const _hoisted_7$E = ["innerHTML"];
  const _hoisted_8$B = ["onClick", "onKeyup"];
  const _hoisted_9$w = ["innerHTML"];
  const _hoisted_10$u = ["innerHTML"];
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return !$props.noLiSurround ? (openBlock(), createElementBlock("ul", {
      key: 0,
      class: normalizeClass($props.containerClass)
    }, [
      $props.firstLastButton ? (openBlock(), createElementBlock("li", {
        key: 0,
        class: normalizeClass([$props.pageClass, $options.firstPageSelected() ? $props.disabledClass : ""])
      }, [
        createBaseVNode("a", {
          onClick: _cache[0] || (_cache[0] = ($event) => $options.selectFirstPage()),
          onKeyup: _cache[1] || (_cache[1] = withKeys(($event) => $options.selectFirstPage(), ["enter"])),
          class: normalizeClass($props.pageLinkClass),
          tabindex: $options.firstPageSelected() ? -1 : 0,
          innerHTML: $props.firstButtonText
        }, null, 42, _hoisted_1$U)
      ], 2)) : createCommentVNode("", true),
      !($options.firstPageSelected() && $props.hidePrevNext) ? (openBlock(), createElementBlock("li", {
        key: 1,
        class: normalizeClass([$props.prevClass, $options.firstPageSelected() ? $props.disabledClass : ""])
      }, [
        createBaseVNode("a", {
          onClick: _cache[2] || (_cache[2] = ($event) => $options.prevPage()),
          onKeyup: _cache[3] || (_cache[3] = withKeys(($event) => $options.prevPage(), ["enter"])),
          class: normalizeClass($props.prevLinkClass),
          tabindex: $options.firstPageSelected() ? -1 : 0,
          innerHTML: $props.prevText
        }, null, 42, _hoisted_2$O)
      ], 2)) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.pages, (page) => {
        return openBlock(), createElementBlock("li", {
          key: page.index,
          class: normalizeClass([$props.pageClass, page.selected ? $props.activeClass : "", page.disabled ? $props.disabledClass : "", page.breakView ? $props.breakViewClass : ""])
        }, [
          page.breakView ? (openBlock(), createElementBlock("a", {
            key: 0,
            class: normalizeClass([$props.pageLinkClass, $props.breakViewLinkClass]),
            tabindex: "0"
          }, [
            renderSlot(_ctx.$slots, "breakViewContent", {}, () => [
              createTextVNode(toDisplayString($props.breakViewText), 1)
            ])
          ], 2)) : page.disabled ? (openBlock(), createElementBlock("a", {
            key: 1,
            class: normalizeClass($props.pageLinkClass),
            tabindex: "0"
          }, toDisplayString(page.content), 3)) : (openBlock(), createElementBlock("a", {
            key: 2,
            onClick: ($event) => $options.handlePageSelected(page.index + 1),
            onKeyup: withKeys(($event) => $options.handlePageSelected(page.index + 1), ["enter"]),
            class: normalizeClass($props.pageLinkClass),
            tabindex: "0"
          }, toDisplayString(page.content), 43, _hoisted_3$M))
        ], 2);
      }), 128)),
      !($options.lastPageSelected() && $props.hidePrevNext) ? (openBlock(), createElementBlock("li", {
        key: 2,
        class: normalizeClass([$props.nextClass, $options.lastPageSelected() ? $props.disabledClass : ""])
      }, [
        createBaseVNode("a", {
          onClick: _cache[4] || (_cache[4] = ($event) => $options.nextPage()),
          onKeyup: _cache[5] || (_cache[5] = withKeys(($event) => $options.nextPage(), ["enter"])),
          class: normalizeClass($props.nextLinkClass),
          tabindex: $options.lastPageSelected() ? -1 : 0,
          innerHTML: $props.nextText
        }, null, 42, _hoisted_4$L)
      ], 2)) : createCommentVNode("", true),
      $props.firstLastButton ? (openBlock(), createElementBlock("li", {
        key: 3,
        class: normalizeClass([$props.pageClass, $options.lastPageSelected() ? $props.disabledClass : ""])
      }, [
        createBaseVNode("a", {
          onClick: _cache[6] || (_cache[6] = ($event) => $options.selectLastPage()),
          onKeyup: _cache[7] || (_cache[7] = withKeys(($event) => $options.selectLastPage(), ["enter"])),
          class: normalizeClass($props.pageLinkClass),
          tabindex: $options.lastPageSelected() ? -1 : 0,
          innerHTML: $props.lastButtonText
        }, null, 42, _hoisted_5$J)
      ], 2)) : createCommentVNode("", true)
    ], 2)) : (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass($props.containerClass)
    }, [
      $props.firstLastButton ? (openBlock(), createElementBlock("a", {
        key: 0,
        onClick: _cache[8] || (_cache[8] = ($event) => $options.selectFirstPage()),
        onKeyup: _cache[9] || (_cache[9] = withKeys(($event) => $options.selectFirstPage(), ["enter"])),
        class: normalizeClass([$props.pageLinkClass, $options.firstPageSelected() ? $props.disabledClass : ""]),
        tabindex: "0",
        innerHTML: $props.firstButtonText
      }, null, 42, _hoisted_6$H)) : createCommentVNode("", true),
      !($options.firstPageSelected() && $props.hidePrevNext) ? (openBlock(), createElementBlock("a", {
        key: 1,
        onClick: _cache[10] || (_cache[10] = ($event) => $options.prevPage()),
        onKeyup: _cache[11] || (_cache[11] = withKeys(($event) => $options.prevPage(), ["enter"])),
        class: normalizeClass([$props.prevLinkClass, $options.firstPageSelected() ? $props.disabledClass : ""]),
        tabindex: "0",
        innerHTML: $props.prevText
      }, null, 42, _hoisted_7$E)) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.pages, (page) => {
        return openBlock(), createElementBlock(Fragment, null, [
          page.breakView ? (openBlock(), createElementBlock("a", {
            key: page.index,
            class: normalizeClass([$props.pageLinkClass, $props.breakViewLinkClass, page.disabled ? $props.disabledClass : ""]),
            tabindex: "0"
          }, [
            renderSlot(_ctx.$slots, "breakViewContent", {}, () => [
              createTextVNode(toDisplayString($props.breakViewText), 1)
            ])
          ], 2)) : page.disabled ? (openBlock(), createElementBlock("a", {
            key: page.index,
            class: normalizeClass([$props.pageLinkClass, page.selected ? $props.activeClass : "", $props.disabledClass]),
            tabindex: "0"
          }, toDisplayString(page.content), 3)) : (openBlock(), createElementBlock("a", {
            key: page.index,
            onClick: ($event) => $options.handlePageSelected(page.index + 1),
            onKeyup: withKeys(($event) => $options.handlePageSelected(page.index + 1), ["enter"]),
            class: normalizeClass([$props.pageLinkClass, page.selected ? $props.activeClass : ""]),
            tabindex: "0"
          }, toDisplayString(page.content), 43, _hoisted_8$B))
        ], 64);
      }), 256)),
      !($options.lastPageSelected() && $props.hidePrevNext) ? (openBlock(), createElementBlock("a", {
        key: 2,
        onClick: _cache[12] || (_cache[12] = ($event) => $options.nextPage()),
        onKeyup: _cache[13] || (_cache[13] = withKeys(($event) => $options.nextPage(), ["enter"])),
        class: normalizeClass([$props.nextLinkClass, $options.lastPageSelected() ? $props.disabledClass : ""]),
        tabindex: "0",
        innerHTML: $props.nextText
      }, null, 42, _hoisted_9$w)) : createCommentVNode("", true),
      $props.firstLastButton ? (openBlock(), createElementBlock("a", {
        key: 3,
        onClick: _cache[14] || (_cache[14] = ($event) => $options.selectLastPage()),
        onKeyup: _cache[15] || (_cache[15] = withKeys(($event) => $options.selectLastPage(), ["enter"])),
        class: normalizeClass([$props.pageLinkClass, $options.lastPageSelected() ? $props.disabledClass : ""]),
        tabindex: "0",
        innerHTML: $props.lastButtonText
      }, null, 42, _hoisted_10$u)) : createCommentVNode("", true)
    ], 2));
  }
  var Paginate = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["render", _sfc_render$2]]);
  const _hoisted_1$T = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$N = { class: "d-flex flex-column" };
  const _hoisted_3$L = { class: "anwp-text-xs anwp-font-normal anwp-opacity-60 anwp-text-nowrap" };
  const _hoisted_4$K = { class: "anwp-text-base anwp-leading-1" };
  const _hoisted_5$I = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_6$G = { class: "d-md-flex" };
  const _hoisted_7$D = { class: "col-md-6 bg-light py-3" };
  const _hoisted_8$A = { class: "my-2" };
  const _hoisted_9$v = ["onClick"];
  const _hoisted_10$t = ["src"];
  const _hoisted_11$s = { class: "mr-2 anwp-leading-1" };
  const _hoisted_12$r = { class: "col-md-6 py-0 anwp-h-min-300" };
  const _hoisted_13$q = {
    key: 0,
    class: "anwp-bg-blue-100 anwp-border anwp-border-blue-800 p-3 anwp-text-blue-800 anwp-text-sm"
  };
  const _hoisted_14$q = { class: "d-flex" };
  const _hoisted_15$o = { class: "anwp-flex-1 d-flex flex-column" };
  const _hoisted_16$n = {
    key: 0,
    class: "anwp-flex-1 ml-3"
  };
  const _hoisted_17$m = { class: "anwp-flex-1 ml-3" };
  const _hoisted_18$l = ["onClick"];
  const _hoisted_19$l = ["src"];
  const _hoisted_20$j = { class: "mr-2 anwp-leading-1" };
  const _hoisted_21$j = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_22$j = { class: "d-flex" };
  const _hoisted_23$h = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_24$f = { class: "my-0" };
  const _hoisted_25$d = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_26$c = { class: "anwp-text-center" };
  const _hoisted_27$c = { class: "anwp-text-lg anwp-font-bold" };
  const _hoisted_28$c = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_29$c = { class: "d-flex flex-row-reverse" };
  const _sfc_main$S = {
    __name: "AppModalGroupManage",
    setup(__props) {
      const trStore = useTrStore();
      const l10n = window._flTournamentL10n;
      const pageNumber = ref(1);
      const activeFilter = ref("");
      const activeSearch = ref("");
      const activeCountry = ref("");
      const resetActiveFilters = () => {
        pageNumber.value = 1;
        activeSearch.value = "";
        if (activeFilter.value === "prev_round" && !trStore.activeStage.rounds.findIndex((r2) => Number(r2.id) === Number(trStore.modalData.teamsRound.id))) {
          activeFilter.value = "";
        }
        if (activeFilter.value === "prev_stage" && !trStore.stages.findIndex((s2) => s2.stageId === trStore.activeStage.stageId)) {
          activeFilter.value = "";
        }
      };
      const teamsInModal = computed(() => {
        let teams = Object.values(trStore.appConfig.optionsTeams).filter((t) => !trStore.modalData.teamsGroup.clubs.includes(Number(t.id))).sort((a2, b2) => a2.title.localeCompare(b2.title));
        if ("" !== activeSearch.value.trim()) {
          teams = teams.filter((p2) => p2.title.toLowerCase().includes(activeSearch.value.toLowerCase().trim()));
        }
        if (activeCountry.value) {
          teams = teams.filter((p2) => p2.country.toLowerCase() === activeCountry.value.toLowerCase());
        }
        if ("prev_round" === activeFilter.value) {
          const prevRoundIndex = trStore.activeStage.rounds.findIndex((r2) => Number(r2.id) === Number(trStore.modalData.teamsRound.id)) - 1;
          const prevRoundTeams = trStore.activeStage.rounds[prevRoundIndex].groups.flatMap(({ clubs }) => clubs);
          const currRoundTeams = trStore.activeStage.rounds[prevRoundIndex + 1].groups.flatMap(({ clubs }) => clubs);
          const availableTeams = prevRoundTeams.filter((t) => !currRoundTeams.includes(t));
          return teams.filter((t) => availableTeams.includes(Number(t.id)));
        } else if ("prev_stage" === activeFilter.value) {
          let prevStageTeams = [];
          trStore.stages[trStore.activeStageIndex - 1].rounds.forEach(({ groups }) => {
            prevStageTeams = [...prevStageTeams, ...groups.flatMap(({ clubs }) => clubs)];
          });
          const currRoundIndex = trStore.activeStage.rounds.findIndex((r2) => Number(r2.id) === Number(trStore.modalData.teamsRound.id));
          const currRoundTeams = trStore.activeStage.rounds[currRoundIndex].groups.flatMap(({ clubs }) => clubs);
          const availableTeams = prevStageTeams.filter((t) => !currRoundTeams.includes(t));
          return teams.filter((t) => availableTeams.includes(Number(t.id)));
        }
        return teams;
      });
      const teamsInModalPaginated = computed(() => {
        if (!teamsInModal.value.length) {
          return [];
        }
        return teamsInModal.value.slice((pageNumber.value - 1) * 10, pageNumber.value * 10);
      });
      const teamsInModalPages = computed(() => {
        return teamsInModal.value.length ? Math.ceil(teamsInModal.value.length / 10) : 0;
      });
      const filterOptions = computed(() => {
        const actions2 = [
          {
            name: "- not set -",
            value: ""
          }
        ];
        if (trStore.activeStage.rounds.findIndex((r2) => Number(r2.id) === Number(trStore.modalData.teamsRound.id))) {
          actions2.push({
            name: "Previous Round",
            value: "prev_round"
          });
        }
        if (trStore.stages.findIndex((s2) => s2.stageId === trStore.activeStage.stageId)) {
          actions2.push({
            name: "Previous Stage",
            value: "prev_stage"
          });
        }
        return actions2;
      });
      const addTeamToGroup = (teamId) => {
        trStore.modalData.teamsGroup.clubs.push(teamId);
      };
      const deleteTeamFromGroup = (teamId) => {
        trStore.modalData.teamsGroup.clubs = trStore.modalData.teamsGroup.clubs.filter((t) => Number(t) !== Number(teamId));
      };
      const deleteGroup = () => {
        trStore.modalData.teamsRound.groups = trStore.modalData.teamsRound.groups.filter((g2) => Number(g2.id) !== Number(trStore.modalData.teamsGroup.id));
        trStore.modals.deleteGroup = false;
        trStore.modals.groupManage = false;
      };
      return (_ctx, _cache) => {
        const _component_v_select = resolveComponent("v-select");
        const _directive_tooltip = resolveDirective("tooltip");
        return openBlock(), createElementBlock(Fragment, null, [
          createVNode(unref(Ro), {
            modelValue: unref(trStore).modals.groupManage,
            "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => unref(trStore).modals.groupManage = $event),
            "z-index-fn": () => 100060,
            "focus-trap": false,
            "teleport-to": false,
            onBeforeOpen: _cache[11] || (_cache[11] = ($event) => resetActiveFilters()),
            class: "anwp-vfm-admin-modal",
            "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--top"
          }, {
            default: withCtx(() => {
              var _a2;
              return [
                createBaseVNode("button", {
                  class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0",
                  onClick: _cache[0] || (_cache[0] = ($event) => unref(trStore).modals.groupManage = false),
                  type: "button"
                }, [..._cache[16] || (_cache[16] = [
                  createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                    createBaseVNode("use", { "xlink:href": "#icon-x" })
                  ], -1)
                ])]),
                createBaseVNode("div", _hoisted_1$T, [
                  createBaseVNode("div", _hoisted_2$N, [
                    createBaseVNode("span", _hoisted_3$L, toDisplayString("knockout" === unref(trStore).activeStage.type ? "Match-up" : "Group"), 1),
                    createBaseVNode("span", _hoisted_4$K, toDisplayString(unref(trStore).modalData.teamsGroup.title), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_5$I, [
                  createBaseVNode("div", _hoisted_6$G, [
                    createBaseVNode("div", _hoisted_7$D, [
                      createBaseVNode("h4", _hoisted_8$A, " Teams in " + toDisplayString("knockout" === unref(trStore).activeStage.type ? "Match-up" : "Group") + " (" + toDisplayString(unref(trStore).modalData.teamsGroup.clubs.length) + ") ", 1),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(trStore).modalData.teamsGroup.clubs, (teamId) => {
                        var _a3, _b2;
                        return openBlock(), createElementBlock("div", {
                          key: teamId,
                          class: "py-2 my-1 anwp-bg-gray-100 text-dark d-flex align-items-center anwp-h-min-40 anwp-border anwp-border-gray-400"
                        }, [
                          withDirectives((openBlock(), createElementBlock("div", {
                            class: "anwp-cursor-pointer anwp-w-30 anwp-h-30 anwp-rounded mx-3 d-flex align-items-center justify-content-center anwp-border anwp-border-gray-500",
                            onClick: withModifiers(($event) => deleteTeamFromGroup(teamId), ["prevent"])
                          }, [..._cache[17] || (_cache[17] = [
                            createBaseVNode("svg", { class: "anwp-icon anwp-icon--s18 anwp-icon--octi anwp-text-red-800 anwp-fill-current" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-x" })
                            ], -1)
                          ])], 8, _hoisted_9$v)), [
                            [_directive_tooltip, "reject team from group"]
                          ]),
                          ((_a3 = unref(trStore).appConfig.optionsTeams[teamId]) == null ? void 0 : _a3.logo) ? (openBlock(), createElementBlock("img", {
                            key: 0,
                            src: unref(trStore).appConfig.optionsTeams[teamId].logo,
                            alt: "team logo",
                            class: "mr-2 anwp-h-30 anwp-w-30 anwp-object-contain p-1 bg-white border rounded"
                          }, null, 8, _hoisted_10$t)) : createCommentVNode("", true),
                          createBaseVNode("span", _hoisted_11$s, toDisplayString(((_b2 = unref(trStore).appConfig.optionsTeams[teamId]) == null ? void 0 : _b2.title) || teamId), 1)
                        ]);
                      }), 128))
                    ]),
                    createBaseVNode("div", _hoisted_12$r, [
                      "knockout" === unref(trStore).activeStage.type && unref(trStore).modalData.teamsGroup.clubs.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_13$q, [..._cache[18] || (_cache[18] = [
                        createTextVNode(" The maximum number of teams has been reached!", -1),
                        createBaseVNode("br", null, null, -1),
                        createBaseVNode("br", null, null, -1),
                        createTextVNode(" The knockout tournament system allows only two teams per match-up. If you need more teams, switch to the round-robin (group) tournament system. ", -1)
                      ])])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createBaseVNode("div", _hoisted_14$q, [
                          createBaseVNode("div", _hoisted_15$o, [
                            _cache[19] || (_cache[19] = createBaseVNode("label", {
                              class: "small d-block mb-1",
                              for: "active-filter-club-search-mob"
                            }, "Type to search", -1)),
                            withDirectives(createBaseVNode("input", {
                              class: "w-100",
                              id: "active-filter-club-search-mob",
                              onInput: _cache[1] || (_cache[1] = ($event) => pageNumber.value = 1),
                              type: "text",
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => activeSearch.value = $event)
                            }, null, 544), [
                              [vModelText, activeSearch.value]
                            ])
                          ]),
                          ((_a2 = filterOptions.value) == null ? void 0 : _a2.length) > 1 ? (openBlock(), createElementBlock("div", _hoisted_16$n, [
                            _cache[20] || (_cache[20] = createBaseVNode("label", {
                              class: "small d-block mb-1",
                              for: "anwp-sl-input-filter-options"
                            }, "Filter Options", -1)),
                            createVNode(_component_v_select, {
                              id: "anwp-sl-input-filter-options",
                              label: "name",
                              modelValue: activeFilter.value,
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => activeFilter.value = $event),
                              clearable: false,
                              filterable: false,
                              searchable: false,
                              "onOption:selected": _cache[4] || (_cache[4] = ($event) => {
                                pageNumber.value = 1;
                              }),
                              options: filterOptions.value,
                              reduce: (o2) => o2.value
                            }, null, 8, ["modelValue", "options", "reduce"])
                          ])) : createCommentVNode("", true),
                          createBaseVNode("div", _hoisted_17$m, [
                            _cache[21] || (_cache[21] = createBaseVNode("label", {
                              class: "small d-block mb-1",
                              for: "anwp-modaal-team-country-filter"
                            }, "Country", -1)),
                            createVNode(_component_v_select, {
                              id: "anwp-modaal-team-country-filter",
                              modelValue: activeCountry.value,
                              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => activeCountry.value = $event),
                              options: unref(trStore).appConfig.optionsCountries,
                              clearable: true,
                              filterable: true,
                              searchable: true,
                              "onOption:selected": _cache[6] || (_cache[6] = ($event) => {
                                pageNumber.value = 1;
                              }),
                              placeholder: "- select country -",
                              reduce: (country) => country.code
                            }, null, 8, ["modelValue", "options", "reduce"])
                          ])
                        ]),
                        _cache[23] || (_cache[23] = createBaseVNode("hr", null, null, -1)),
                        teamsInModal.value.length ? (openBlock(), createBlock(unref(Paginate), {
                          key: 0,
                          class: "anwp-user-select-none mb-2 mb-0",
                          modelValue: pageNumber.value,
                          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => pageNumber.value = $event),
                          "page-count": teamsInModalPages.value,
                          "prev-text": "prev",
                          "next-text": "next",
                          "container-class": "anwp-pagination",
                          "page-class": "anwp-page-item",
                          "prev-class": "anwp-page-item",
                          "next-class": "anwp-page-item",
                          "next-link-class": "anwp-page-link",
                          "prev-link-class": "anwp-page-link",
                          "page-link-class": "anwp-page-link"
                        }, null, 8, ["modelValue", "page-count"])) : createCommentVNode("", true),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(teamsInModalPaginated.value, (team) => {
                          return openBlock(), createElementBlock("div", {
                            key: team.id,
                            class: "py-2 my-1 anwp-bg-gray-100 text-dark d-flex align-items-center anwp-h-min-40 anwp-border anwp-border-gray-400"
                          }, [
                            createBaseVNode("div", {
                              class: "anwp-cursor-pointer anwp-w-30 anwp-h-30 anwp-rounded mx-3 d-flex align-items-center justify-content-center anwp-border anwp-border-gray-500",
                              onClick: withModifiers(($event) => addTeamToGroup(team.id), ["prevent"])
                            }, [..._cache[22] || (_cache[22] = [
                              createBaseVNode("svg", { class: "anwp-icon anwp-icon--s18 anwp-icon--octi anwp-fill-current anwp-text-blue-700" }, [
                                createBaseVNode("use", { "xlink:href": "#icon-plus" })
                              ], -1)
                            ])], 8, _hoisted_18$l),
                            team.logo ? (openBlock(), createElementBlock("img", {
                              key: 0,
                              src: team.logo,
                              alt: "team logo",
                              class: "mr-2 anwp-h-30 anwp-w-30 anwp-object-contain p-1 bg-white border rounded"
                            }, null, 8, _hoisted_19$l)) : createCommentVNode("", true),
                            createBaseVNode("span", _hoisted_20$j, toDisplayString(team.title), 1)
                          ]);
                        }), 128))
                      ], 64))
                    ])
                  ])
                ]),
                createBaseVNode("div", _hoisted_21$j, [
                  createBaseVNode("div", _hoisted_22$j, [
                    unref(trStore).modalData.teamsRound.groups.length > 1 ? (openBlock(), createElementBlock("a", {
                      key: 0,
                      class: "text-decoration-none anwp-text-red-700",
                      href: "#",
                      onClick: _cache[8] || (_cache[8] = withModifiers(($event) => {
                        unref(trStore).modals.deleteGroup = true;
                      }, ["prevent"]))
                    }, " Delete Group ")) : createCommentVNode("", true),
                    createBaseVNode("button", {
                      type: "button",
                      class: "button button-secondary text-capitalize ml-auto",
                      onClick: _cache[9] || (_cache[9] = ($event) => unref(trStore).modals.groupManage = false)
                    }, "Close")
                  ])
                ])
              ];
            }),
            _: 1
          }, 8, ["modelValue"]),
          createVNode(unref(Ro), {
            modelValue: unref(trStore).modals.deleteGroup,
            "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => unref(trStore).modals.deleteGroup = $event),
            "z-index-fn": () => 100080,
            "focus-trap": false,
            "teleport-to": false,
            class: "anwp-vfm-admin-modal",
            "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
          }, {
            default: withCtx(() => [
              createBaseVNode("button", {
                class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0",
                onClick: _cache[12] || (_cache[12] = ($event) => unref(trStore).modals.deleteGroup = false),
                type: "button"
              }, [..._cache[24] || (_cache[24] = [
                createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-x" })
                ], -1)
              ])]),
              createBaseVNode("div", _hoisted_23$h, [
                createBaseVNode("h4", _hoisted_24$f, toDisplayString(unref(l10n).confirm_delete), 1)
              ]),
              createBaseVNode("div", _hoisted_25$d, [
                createBaseVNode("div", _hoisted_26$c, [
                  createBaseVNode("div", _hoisted_27$c, toDisplayString(unref(l10n).are_you_sure), 1),
                  createBaseVNode("p", null, " Do you really want to delete this " + toDisplayString("knockout" === unref(trStore).activeStage.type ? "Match-up" : "Group") + "? It can break statistics if you have any games connected to it. ", 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_28$c, [
                createBaseVNode("div", _hoisted_29$c, [
                  createBaseVNode("button", {
                    type: "button",
                    class: "button button-secondary text-capitalize",
                    onClick: _cache[13] || (_cache[13] = ($event) => unref(trStore).modals.deleteGroup = false)
                  }, "Close"),
                  createBaseVNode("button", {
                    onClick: _cache[14] || (_cache[14] = withModifiers(($event) => deleteGroup(), ["prevent"])),
                    type: "button",
                    class: "button button-secondary mx-2 text-capitalize anwp-border-red-600 anwp-text-red-600"
                  }, " Delete Group ")
                ])
              ])
            ]),
            _: 1
          }, 8, ["modelValue"])
        ], 64);
      };
    }
  };
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const { iterator, toStringTag } = Symbol;
  const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction$1 = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject$1 = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
  };
  const isEmptyObject = (val) => {
    if (!isObject(val) || isBuffer(val)) {
      return false;
    }
    try {
      return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
    } catch (e) {
      return false;
    }
  };
  const isDate$1 = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction$1(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i2;
    let l2;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
        fn.call(null, obj[i2], i2, obj);
      }
    } else {
      if (isBuffer(obj)) {
        return;
      }
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    if (isBuffer(obj)) {
      return null;
    }
    key = key.toLowerCase();
    const keys2 = Object.keys(obj);
    let i2 = keys2.length;
    let _key;
    while (i2-- > 0) {
      _key = keys2[i2];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless, skipUndefined } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue2 = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject$1(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else if (!skipUndefined || !isUndefined(val)) {
        result[targetKey] = val;
      }
    };
    for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
      arguments[i2] && forEach(arguments[i2], assignValue2);
    }
    return result;
  }
  const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key) => {
      if (thisArg && isFunction$1(val)) {
        a2[key] = bind(val, thisArg);
      } else {
        a2[key] = val;
      }
    }, { allOwnKeys });
    return a2;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i2;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i2 = props.length;
      while (i2-- > 0) {
        prop = props[i2];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i2 = thing.length;
    if (!isNumber(i2)) return null;
    const arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[iterator];
    const _iterator = generator.call(obj);
    let result;
    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches2;
    const arr = [];
    while ((matches2 = regExp.exec(str)) !== null) {
      arr.push(matches2);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer2(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction$1(value)) return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  };
  const noop = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
  }
  const toJSONObject = (obj) => {
    const stack2 = new Array(10);
    const visit = (source, i2) => {
      if (isObject(source)) {
        if (stack2.indexOf(source) >= 0) {
          return;
        }
        if (isBuffer(source)) {
          return source;
        }
        if (!("toJSON" in source)) {
          stack2[i2] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i2 + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack2[i2] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction$1(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
  const utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject: isPlainObject$1,
    isEmptyObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate: isDate$1,
    isFile,
    isBlob,
    isRegExp,
    isFunction: isFunction$1,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable
  };
  function AxiosError$1(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$1.inherits(AxiosError$1, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const prototype$1 = AxiosError$1.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError$1, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError$1.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    const msg = error && error.message ? error.message : "Error";
    const errCode = code == null && error ? error.code : code;
    AxiosError$1.call(axiosError, msg, errCode, config, request, response);
    if (error && axiosError.cause == null) {
      Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
    }
    axiosError.name = error && error.name || "Error";
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i2) {
      token = removeBrackets(token);
      return !dots && i2 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData$1(obj, formData, options) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$1.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (utils$1.isBoolean(value)) {
        return value.toString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index2) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack2 = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils$1.isUndefined(value)) return;
      if (stack2.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack2.push(value);
      utils$1.forEach(value, function each(el, key) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$1.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack2.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData$1(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode;
    if (utils$1.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {void}
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    }
  }
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin
  }, Symbol.toStringTag, { value: "Module" }));
  const platform = __spreadValues(__spreadValues({}, utils), platform$1);
  function toURLEncodedForm(data, options) {
    return toFormData$1(data, new platform.classes.URLSearchParams(), __spreadValues({
      visitor: function(value, key, path, helpers) {
        if (platform.isNode && utils$1.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  function parsePropPath(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i2;
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index2) {
      let name = path[index2++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index2 >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index2);
      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData$1(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data, this.parseReviver);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i2;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
      i2 = line.indexOf(":");
      key = line.substring(0, i2).trim().toLowerCase();
      val = line.substring(i2 + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$1.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value)) return;
    if (utils$1.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }
    if (utils$1.isRegExp(filter)) {
      return filter.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  let AxiosHeaders$1 = class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils$1.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
        let obj = {}, dest, key;
        for (const entry of header) {
          if (!utils$1.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils$1.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i2 = keys2.length;
      let deleted = false;
      while (i2--) {
        const key = keys2[i2];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key = utils$1.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed2 = new this(first);
      targets.forEach((target) => computed2.set(target));
      return computed2;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders$1);
  function transformData(fns, response) {
    const config = this || defaults;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel$1(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError$1(message, config, request) {
    AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError$1, AxiosError$1, {
    __CANCEL__: true
  });
  function settle(resolve2, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError$1(
        "Request failed with status code " + response.status,
        [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min2) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min2 = min2 !== void 0 ? min2 : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i2 = tail;
      let bytesCount = 0;
      while (i2 !== head) {
        bytesCount += bytes[i2++];
        i2 = i2 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min2) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn(...args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange2 = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange2 ? (total - loaded) / rate : void 0,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
  const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
    url = new URL(url, platform.origin);
    return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
  })(
    new URL(platform.origin),
    platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
  ) : () => true;
  const cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure, sameSite) {
        if (typeof document === "undefined") return;
        const cookie = [`${name}=${encodeURIComponent(value)}`];
        if (utils$1.isNumber(expires)) {
          cookie.push(`expires=${new Date(expires).toUTCString()}`);
        }
        if (utils$1.isString(path)) {
          cookie.push(`path=${path}`);
        }
        if (utils$1.isString(domain)) {
          cookie.push(`domain=${domain}`);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        if (utils$1.isString(sameSite)) {
          cookie.push(`SameSite=${sameSite}`);
        }
        document.cookie = cookie.join("; ");
      },
      read(name) {
        if (typeof document === "undefined") return null;
        const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
        return match ? decodeURIComponent(match[1]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5, "/");
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? __spreadValues({}, thing) : thing;
  function mergeConfig$1(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a2, b2, prop, caseless) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(a2, b2, prop, caseless);
      } else if (!utils$1.isUndefined(a2)) {
        return getMergedValue(void 0, a2, prop, caseless);
      }
    }
    function valueFromConfig2(a2, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a2, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils$1.isUndefined(a2)) {
        return getMergedValue(void 0, a2);
      }
    }
    function mergeDirectKeys(a2, b2, prop) {
      if (prop in config2) {
        return getMergedValue(a2, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a2);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
    };
    utils$1.forEach(Object.keys(__spreadValues(__spreadValues({}, config1), config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  const resolveConfig = (config) => {
    const newConfig = mergeConfig$1({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    if (utils$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if (utils$1.isFunction(data.getHeaders)) {
        const formHeaders = data.getHeaders();
        const allowedHeaders = ["content-type", "content-length"];
        Object.entries(formHeaders).forEach(([key, val]) => {
          if (allowedHeaders.includes(key.toLowerCase())) {
            headers.set(key, val);
          }
        });
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve2(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError2(event) {
        const msg = event && event.message ? event.message : "Network Error";
        const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config, request);
        err.event = event || null;
        reject(err);
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError$1(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$1.asap(unsubscribe);
      return signal;
    }
  };
  const streamChunk = function* (chunk2, chunkSize) {
    let len = chunk2.byteLength;
    if (len < chunkSize) {
      yield chunk2;
      return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
      end = pos + chunkSize;
      yield chunk2.slice(pos, end);
      pos = end;
    }
  };
  const readBytes = function(iterable, chunkSize) {
    return __asyncGenerator(this, null, function* () {
      try {
        for (var iter = __forAwait(readStream(iterable)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const chunk2 = temp.value;
          yield* __yieldStar(streamChunk(chunk2, chunkSize));
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  };
  const readStream = function(stream) {
    return __asyncGenerator(this, null, function* () {
      if (stream[Symbol.asyncIterator]) {
        yield* __yieldStar(stream);
        return;
      }
      const reader = stream.getReader();
      try {
        for (; ; ) {
          const { done, value } = yield new __await(reader.read());
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        yield new __await(reader.cancel());
      }
    });
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator2 = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      pull(controller) {
        return __async(this, null, function* () {
          try {
            const { done: done2, value } = yield iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        });
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator2.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const { isFunction } = utils$1;
  const globalFetchAPI = (({ Request, Response }) => ({
    Request,
    Response
  }))(utils$1.global);
  const {
    ReadableStream: ReadableStream$1,
    TextEncoder
  } = utils$1.global;
  const test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e) {
      return false;
    }
  };
  const factory = (env) => {
    env = utils$1.merge.call({
      skipUndefined: true
    }, globalFetchAPI, env);
    const { fetch: envFetch, Request, Response } = env;
    const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
    const isRequestSupported = isFunction(Request);
    const isResponseSupported = isFunction(Response);
    if (!isFetchSupported) {
      return false;
    }
    const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
    const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : (str) => __async(null, null, function* () {
      return new Uint8Array(yield new Request(str).arrayBuffer());
    }));
    const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request(platform.origin, {
        body: new ReadableStream$1(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
    const resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && (() => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = (res, config) => {
          let method = res && res[type];
          if (method) {
            return method.call(res);
          }
          throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
        });
      });
    })();
    const getBodyLength = (body) => __async(null, null, function* () {
      if (body == null) {
        return 0;
      }
      if (utils$1.isBlob(body)) {
        return body.size;
      }
      if (utils$1.isSpecCompliantForm(body)) {
        const _request = new Request(platform.origin, {
          method: "POST",
          body
        });
        return (yield _request.arrayBuffer()).byteLength;
      }
      if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$1.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$1.isString(body)) {
        return (yield encodeText(body)).byteLength;
      }
    });
    const resolveBodyLength = (headers, body) => __async(null, null, function* () {
      const length = utils$1.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    });
    return (config) => __async(null, null, function* () {
      let {
        url,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config);
      let _fetch = envFetch || fetch;
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
      let request = null;
      const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
        composedSignal.unsubscribe();
      });
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = yield resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request(url, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
          }
        }
        if (!utils$1.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
        const resolvedOptions = __spreadProps(__spreadValues({}, fetchOptions), {
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: isCredentialsSupported ? withCredentials : void 0
        });
        request = isRequestSupported && new Request(url, resolvedOptions);
        let response = yield isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions);
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              unsubscribe && unsubscribe();
            }),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = yield resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
        !isStreamResponse && unsubscribe && unsubscribe();
        return yield new Promise((resolve2, reject) => {
          settle(resolve2, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config,
            request
          });
        });
      } catch (err) {
        unsubscribe && unsubscribe();
        if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError$1.from(err, err && err.code, config, request);
      }
    });
  };
  const seedCache = /* @__PURE__ */ new Map();
  const getFetch = (config) => {
    let env = config && config.env || {};
    const { fetch: fetch2, Request, Response } = env;
    const seeds = [
      Request,
      Response,
      fetch2
    ];
    let len = seeds.length, i2 = len, seed, target, map = seedCache;
    while (i2--) {
      seed = seeds[i2];
      target = map.get(seed);
      target === void 0 && map.set(seed, target = i2 ? /* @__PURE__ */ new Map() : factory(env));
      map = target;
    }
    return target;
  };
  getFetch();
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: {
      get: getFetch
    }
  };
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  function getAdapter$1(adapters2, config) {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters2[i2];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }
      if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {
        break;
      }
      rejectedReasons[id || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  }
  const adapters = {
    /**
     * Resolve an adapter from a list of adapter names or functions.
     * @type {Function}
     */
    getAdapter: getAdapter$1,
    /**
     * Exposes all known adapters
     * @type {Object<string, Function|Object>}
     */
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError$1(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults.adapter, config);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel$1(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION$1 = "1.13.2";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError$1(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError$1.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options);
    let i2 = keys2.length;
    while (i2-- > 0) {
      const opt = keys2[i2];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  let Axios$1 = class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config) {
      return __async(this, null, function* () {
        try {
          return yield this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack2;
              } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack2;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      });
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig$1(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      if (config.allowAbsoluteUrls !== void 0) ;
      else if (this.defaults.allowAbsoluteUrls !== void 0) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }
      validator.assertOptions(config, {
        baseUrl: validators.spelling("baseURL"),
        withXsrfToken: validators.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i2 = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift(...requestInterceptorChain);
        chain.push(...responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i2 < len) {
          promise = promise.then(chain[i2++], chain[i2++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      while (i2 < len) {
        const onFulfilled = requestInterceptorChain[i2++];
        const onRejected = requestInterceptorChain[i2++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i2 = 0;
      len = responseInterceptorChain.length;
      while (i2 < len) {
        promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig$1(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios$1.prototype[method] = generateHTTPMethod();
    Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  let CancelToken$1 = class CancelToken2 {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i2 = token._listeners.length;
        while (i2-- > 0) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve2) => {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError$1(message, config, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken2(function executor(c2) {
        cancel = c2;
      });
      return {
        token,
        cancel
      };
    }
  };
  function spread$1(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError$1(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode$1 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
    WebServerIsDown: 521,
    ConnectionTimedOut: 522,
    OriginIsUnreachable: 523,
    TimeoutOccurred: 524,
    SslHandshakeFailed: 525,
    InvalidSslCertificate: 526
  };
  Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
    HttpStatusCode$1[value] = key;
  });
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);
    utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError$1;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel$1;
  axios.VERSION = VERSION$1;
  axios.toFormData = toFormData$1;
  axios.AxiosError = AxiosError$1;
  axios.Cancel = axios.CanceledError;
  axios.all = function all2(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread$1;
  axios.isAxiosError = isAxiosError$1;
  axios.mergeConfig = mergeConfig$1;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const {
    Axios,
    AxiosError,
    CanceledError,
    isCancel,
    CancelToken,
    VERSION,
    all,
    Cancel,
    isAxiosError,
    spread,
    toFormData,
    AxiosHeaders,
    HttpStatusCode,
    formToJSON,
    getAdapter,
    mergeConfig
  } = axios;
  const _hoisted_1$S = {
    key: 0,
    class: "anwp-border anwp-border-gray-500 bg-white p-3 pb-4 d-sm-flex flex-wrap align-items-start anwp-fl-stage-tab__content"
  };
  const _hoisted_2$M = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_3$K = {
    class: "mb-1 anwp-text-gray-800",
    for: "stage-title"
  };
  const _hoisted_4$J = { class: "ml-auto mt-n2" };
  const _hoisted_5$H = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_6$F = {
    class: "mb-1 anwp-text-gray-800",
    for: "stage-tournament-system"
  };
  const _hoisted_7$C = { value: "round-robin" };
  const _hoisted_8$z = { value: "knockout" };
  const _hoisted_9$u = {
    key: 0,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_10$s = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-input-num-formatRobin"
  };
  const _hoisted_11$r = { value: "single" };
  const _hoisted_12$q = { value: "double" };
  const _hoisted_13$p = { value: "custom" };
  const _hoisted_14$p = {
    key: 1,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_15$n = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-input-num-formatKnockout"
  };
  const _hoisted_16$m = { value: "two" };
  const _hoisted_17$l = { value: "single" };
  const _hoisted_18$k = { class: "d-flex flex-column mb-4 mr-sm-2 px-2 ml-sm-auto pl-sm-2" };
  const _hoisted_19$k = {
    for: "anwpfl-input-competition-type",
    class: "d-flex align-items-center mb-1 anwp-text-gray-800"
  };
  const _hoisted_20$i = { class: "mr-2" };
  const _hoisted_21$i = { class: "anwp-icon anwp-icon--octi anwp-icon--s14 ml-auto" };
  const _hoisted_22$i = { value: "" };
  const _hoisted_23$g = { value: "friendly" };
  const _hoisted_24$e = {
    key: 2,
    class: "d-flex w-100 mr-sm-2 px-2"
  };
  const _hoisted_25$c = { class: "ml-auto anwp-border anwp-border-orange-600 anwp-bg-orange-100 p-3 d-flex" };
  const _hoisted_26$b = { class: "flex-grow-1 w-100" };
  const _hoisted_27$b = {
    key: 0,
    class: "spinner ml-2 is-active"
  };
  const _hoisted_28$b = {
    key: 0,
    class: "anwp-font-semibold w-100 py-1 px-2 anwp-bg-gray-200 d-flex"
  };
  const _hoisted_29$b = ["onUpdate:modelValue"];
  const _hoisted_30$b = ["onClick"];
  const _hoisted_31$b = { class: "d-flex align-items-center py-1 mx-n2 anwp-border-bottom anwp-border-gray-400 anwp-bg-gray-200 anwp-text-gray-800" };
  const _hoisted_32$b = ["onUpdate:modelValue"];
  const _hoisted_33$b = { class: "ml-4 anwp-bg-gray-400 rounded-circle px-2 mr-2" };
  const _hoisted_34$a = ["onClick"];
  const _hoisted_35$a = ["src"];
  const _hoisted_36$a = { class: "mr-2 anwp-leading-1" };
  const _hoisted_37$8 = { class: "d-flex w-100 mt-auto" };
  const _hoisted_38$7 = { class: "ml-auto" };
  const _hoisted_39$6 = { class: "anwp-border anwp-border-gray-400 m-2 p-2 anwp-w-300 d-flex align-items-center justify-content-center py-5" };
  const _hoisted_40$6 = ["onClick"];
  const _hoisted_41$6 = { class: "d-flex w-100" };
  const _hoisted_42$5 = { class: "ml-auto pr-1" };
  const _hoisted_43$5 = { class: "d-flex flex-wrap w-100 align-items-end" };
  const _sfc_main$R = {
    __name: "AppStage",
    setup(__props) {
      const trStore = useTrStore();
      const l10n = window._flTournamentL10n;
      const AppAxios = axios.create({
        baseURL: window._flTournament.rest_root,
        headers: {
          "X-WP-Nonce": window._flTournament.rest_nonce
        }
      });
      const modalOpenRoundDeleteConfirm = (roundIndex, roundId) => {
        trStore.modalData.deleteRoundIndex = roundIndex;
        trStore.modalData.deleteRoundId = roundId;
        trStore.modals.deleteRound = true;
      };
      const addNewRound = () => {
        const newRound = {
          id: Number(trStore.activeStage.nextIdRound),
          title: "Round #" + Number(trStore.activeStage.nextIdRound),
          groups: []
        };
        trStore.stages[trStore.activeStageIndex].rounds.push(newRound);
        addNewGroup(trStore.activeStage.nextIdRound);
        trStore.incrementRoundId();
      };
      const addNewGroup = (roundId) => {
        let roundIndex = trStore.activeStage.rounds.findIndex((r2) => Number(r2.id) === Number(roundId));
        const newGroup = {
          id: Number(trStore.activeStage.nextIdGroup),
          title: "#" + trStore.activeStage.nextIdGroup,
          round: Number(roundId),
          clubs: []
        };
        trStore.stages[trStore.activeStageIndex].rounds[roundIndex].groups.push(newGroup);
        trStore.incrementGroupId();
      };
      const openGroupManageModal = (round, group) => {
        trStore.modalData.teamsRound = round;
        trStore.modalData.teamsGroup = group;
        trStore.modals.groupManage = true;
      };
      const fixStageGameStatuses = (stageId) => {
        if ("fix-game-status" === trStore.activeRequest) {
          return false;
        }
        trStore.activeRequest = "fix-game-status";
        AppAxios.post(`anwpfl/competition/fix_game_status`, {
          stage_id: stageId
        }).then((response) => {
          var _a2;
          if ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.games) {
            trStore.appConfig.stageGames[stageId] = response.data.games;
          } else {
            trStore.showError({ message: "Saving Data Error" });
          }
        }).catch((error) => {
          trStore.showError(error);
        }).finally(() => {
          trStore.activeRequest = "";
        });
      };
      return (_ctx, _cache) => {
        const _component_draggable = resolveComponent("draggable");
        const _directive_tooltip = resolveDirective("tooltip");
        return openBlock(), createElementBlock(Fragment, null, [
          unref(trStore).activeStage ? (openBlock(), createElementBlock("div", _hoisted_1$S, [
            createBaseVNode("div", _hoisted_2$M, [
              createBaseVNode("label", _hoisted_3$K, toDisplayString(unref(l10n).stage_title), 1),
              withDirectives(createBaseVNode("input", {
                type: "text",
                id: "stage-title",
                class: "anwp-w-300",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(trStore).stages[unref(trStore).activeStageIndex].stageTitle = $event)
              }, null, 512), [
                [vModelText, unref(trStore).stages[unref(trStore).activeStageIndex].stageTitle]
              ])
            ]),
            createBaseVNode("div", _hoisted_4$J, "Stage ID: " + toDisplayString(unref(trStore).activeStage.stageId), 1),
            _cache[21] || (_cache[21] = createBaseVNode("div", { class: "w-100" }, null, -1)),
            createBaseVNode("div", _hoisted_5$H, [
              createBaseVNode("label", _hoisted_6$F, toDisplayString(unref(l10n).competition_type), 1),
              withDirectives(createBaseVNode("select", {
                id: "stage-tournament-system",
                class: "anwp-w-min-150",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(trStore).stages[unref(trStore).activeStageIndex].type = $event)
              }, [
                createBaseVNode("option", _hoisted_7$C, toDisplayString(unref(l10n).round_robin), 1),
                createBaseVNode("option", _hoisted_8$z, toDisplayString(unref(l10n).knockout), 1)
              ], 512), [
                [vModelSelect, unref(trStore).stages[unref(trStore).activeStageIndex].type]
              ])
            ]),
            "round-robin" === unref(trStore).stages[unref(trStore).activeStageIndex].type ? (openBlock(), createElementBlock("div", _hoisted_9$u, [
              createBaseVNode("label", _hoisted_10$s, toDisplayString(unref(l10n).round_robin_format), 1),
              withDirectives(createBaseVNode("select", {
                id: "anwpfl-input-num-formatRobin",
                class: "anwp-w-min-150",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(trStore).stages[unref(trStore).activeStageIndex].formatRobin = $event)
              }, [
                createBaseVNode("option", _hoisted_11$r, toDisplayString(unref(l10n).single), 1),
                createBaseVNode("option", _hoisted_12$q, toDisplayString(unref(l10n).double), 1),
                createBaseVNode("option", _hoisted_13$p, toDisplayString(unref(l10n).custom), 1)
              ], 512), [
                [vModelSelect, unref(trStore).stages[unref(trStore).activeStageIndex].formatRobin]
              ])
            ])) : createCommentVNode("", true),
            "knockout" === unref(trStore).stages[unref(trStore).activeStageIndex].type ? (openBlock(), createElementBlock("div", _hoisted_14$p, [
              createBaseVNode("label", _hoisted_15$n, toDisplayString(unref(l10n).knockout_format), 1),
              withDirectives(createBaseVNode("select", {
                id: "anwpfl-input-num-formatKnockout",
                class: "anwp-w-min-150",
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(trStore).stages[unref(trStore).activeStageIndex].formatKnockout = $event)
              }, [
                createBaseVNode("option", _hoisted_16$m, toDisplayString(unref(l10n).two_legged_ties), 1),
                createBaseVNode("option", _hoisted_17$l, toDisplayString(unref(l10n).single_leg_ties), 1)
              ], 512), [
                [vModelSelect, unref(trStore).stages[unref(trStore).activeStageIndex].formatKnockout]
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_18$k, [
              createBaseVNode("label", _hoisted_19$k, [
                createBaseVNode("span", _hoisted_20$i, toDisplayString(unref(l10n).competition_status), 1),
                withDirectives((openBlock(), createElementBlock("svg", _hoisted_21$i, [..._cache[8] || (_cache[8] = [
                  createBaseVNode("use", { "xlink:href": "#icon-question" }, null, -1)
                ])])), [
                  [_directive_tooltip, `${unref(l10n).friendly_not_calculated}`]
                ])
              ]),
              withDirectives(createBaseVNode("select", {
                id: "anwpfl-input-competition-type",
                name: "_anwpfl_competition_status",
                class: "anwp-w-min-150",
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(trStore).stages[unref(trStore).activeStageIndex].competitionStatus = $event)
              }, [
                createBaseVNode("option", _hoisted_22$i, toDisplayString(unref(l10n).official), 1),
                createBaseVNode("option", _hoisted_23$g, toDisplayString(unref(l10n).friendly), 1)
              ], 512), [
                [vModelSelect, unref(trStore).stages[unref(trStore).activeStageIndex].competitionStatus]
              ])
            ]),
            unref(trStore).activeStageGamesFixStatusNeeded ? (openBlock(), createElementBlock("div", _hoisted_24$e, [
              createBaseVNode("div", _hoisted_25$c, [
                createBaseVNode("div", _hoisted_26$b, [
                  createTextVNode(" You have Games with incorrect status " + toDisplayString(unref(trStore).appConfig.stageGames[unref(trStore).activeStage.stageId]), 1),
                  _cache[9] || (_cache[9] = createBaseVNode("br", null, null, -1)),
                  _cache[10] || (_cache[10] = createTextVNode(" Change your Stage Status or click the Fix button to change status of all Games to ", -1)),
                  createBaseVNode("b", null, '"' + toDisplayString("friendly" === unref(trStore).activeStage.competitionStatusSaved ? unref(l10n).friendly : unref(l10n).official) + '"', 1),
                  _cache[11] || (_cache[11] = createTextVNode(".", -1)),
                  _cache[12] || (_cache[12] = createBaseVNode("br", null, null, -1))
                ]),
                createBaseVNode("div", null, [
                  createBaseVNode("button", {
                    type: "button",
                    class: "button button-secondary ml-3 px-4 d-flex",
                    onClick: _cache[5] || (_cache[5] = withModifiers(($event) => fixStageGameStatuses(unref(trStore).activeStage.stageId), ["prevent"]))
                  }, [
                    _cache[13] || (_cache[13] = createTextVNode(" Fix ", -1)),
                    "fix-game-status" === unref(trStore).activeRequest ? (openBlock(), createElementBlock("span", _hoisted_27$b)) : createCommentVNode("", true)
                  ])
                ])
              ])
            ])) : createCommentVNode("", true),
            _cache[22] || (_cache[22] = createBaseVNode("div", { class: "w-100 my-3" }, null, -1)),
            _cache[23] || (_cache[23] = createBaseVNode("div", { class: "anwp-font-semibold anwp-text-sm w-100 py-2 px-3 anwp-bg-gray-400 mx-sm-3" }, "Stage Rounds", -1)),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(trStore).stages[unref(trStore).activeStageIndex].rounds, (round, roundIndex) => {
              return openBlock(), createElementBlock("div", {
                key: round.id,
                class: "anwp-bg-gray-100 anwp-border anwp-border-gray-300 w-100 mt-3 mx-3"
              }, [
                "knockout" === unref(trStore).activeStage.type ? (openBlock(), createElementBlock("div", _hoisted_28$b, [
                  _cache[15] || (_cache[15] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s18 mr-2" }, [
                    createBaseVNode("use", { "xlink:href": "#icon-git-compare" })
                  ], -1)),
                  "knockout" === unref(trStore).activeStage.type ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 0,
                    type: "text",
                    class: "anwp-w-300",
                    "onUpdate:modelValue": ($event) => unref(trStore).stages[unref(trStore).activeStageIndex].rounds[roundIndex].title = $event
                  }, null, 8, _hoisted_29$b)), [
                    [vModelText, unref(trStore).stages[unref(trStore).activeStageIndex].rounds[roundIndex].title]
                  ]) : createCommentVNode("", true),
                  unref(trStore).activeStage.rounds.length > 1 && roundIndex >= 1 ? (openBlock(), createElementBlock("button", {
                    key: 1,
                    onClick: withModifiers(($event) => modalOpenRoundDeleteConfirm(roundIndex, round.id), ["prevent"]),
                    type: "button",
                    class: "px-2 d-flex align-items-center ml-auto anwp-cursor-pointer"
                  }, [..._cache[14] || (_cache[14] = [
                    createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s18" }, [
                      createBaseVNode("use", { "xlink:href": "#icon-x" })
                    ], -1)
                  ])], 8, _hoisted_30$b)) : createCommentVNode("", true)
                ])) : createCommentVNode("", true),
                createVNode(_component_draggable, {
                  modelValue: round.groups,
                  "onUpdate:modelValue": ($event) => round.groups = $event,
                  class: "p-3 d-flex flex-row flex-wrap",
                  handle: ".anwp-drag-handler",
                  "force-fallback": true
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(round.groups, (group) => {
                      return openBlock(), createElementBlock("div", {
                        key: group.id,
                        class: "anwp-border anwp-border-gray-400 m-2 py-0 px-2 d-flex flex-column bg-white anwp-w-300 anwp-h-min-100"
                      }, [
                        createBaseVNode("div", _hoisted_31$b, [
                          _cache[17] || (_cache[17] = createBaseVNode("div", { class: "anwp-drag-handler anwp-w-30 anwp-text-center pt-1 px-2" }, [
                            createBaseVNode("svg", { class: "anwp-icon anwp-icon--s24 anwp-icon--octi mr-0" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-grabber" })
                            ])
                          ], -1)),
                          withDirectives(createBaseVNode("input", {
                            class: "ml-3 anwp-w-150 mr-auto",
                            type: "text",
                            "onUpdate:modelValue": ($event) => group.title = $event
                          }, null, 8, _hoisted_32$b), [
                            [vModelText, group.title]
                          ]),
                          createBaseVNode("div", _hoisted_33$b, toDisplayString(group.clubs.length), 1),
                          createBaseVNode("a", {
                            href: "#",
                            onClick: withModifiers(($event) => openGroupManageModal(round, group), ["prevent"]),
                            class: "anwp-border-left anwp-border-gray-400 py-1 px-2 d-flex align-items-center flex-shrink-1"
                          }, [..._cache[16] || (_cache[16] = [
                            createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s18 mx-1" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-gear" })
                            ], -1)
                          ])], 8, _hoisted_34$a)
                        ]),
                        createVNode(_component_draggable, {
                          modelValue: group.clubs,
                          "onUpdate:modelValue": ($event) => group.clubs = $event,
                          class: "p-2",
                          group: `group-${group.id}`,
                          handle: ".anwp-drag-handler2",
                          "force-fallback": true
                        }, {
                          default: withCtx(() => [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(group.clubs, (teamId) => {
                              var _a2, _b2;
                              return openBlock(), createElementBlock("div", {
                                key: teamId,
                                class: "py-2 my-1 anwp-bg-gray-100 text-dark d-flex align-items-center anwp-h-min-40 anwp-border anwp-border-gray-400"
                              }, [
                                _cache[18] || (_cache[18] = createBaseVNode("div", { class: "anwp-drag-handler2 anwp-w-30 anwp-text-center pt-1 px-2 mr-3 anwp-cursor-move" }, [
                                  createBaseVNode("svg", { class: "anwp-icon anwp-icon--s24 anwp-icon--octi mr-0" }, [
                                    createBaseVNode("use", { "xlink:href": "#icon-grabber" })
                                  ])
                                ], -1)),
                                ((_a2 = unref(trStore).appConfig.optionsTeams[teamId]) == null ? void 0 : _a2.logo) ? (openBlock(), createElementBlock("img", {
                                  key: 0,
                                  src: unref(trStore).appConfig.optionsTeams[teamId].logo,
                                  alt: "team logo",
                                  class: "mr-2 anwp-h-30 anwp-w-30 anwp-object-contain p-1 bg-white border rounded"
                                }, null, 8, _hoisted_35$a)) : createCommentVNode("", true),
                                createBaseVNode("span", _hoisted_36$a, toDisplayString(((_b2 = unref(trStore).appConfig.optionsTeams[teamId]) == null ? void 0 : _b2.title) ? unref(trStore).appConfig.optionsTeams[teamId].title : teamId), 1)
                              ]);
                            }), 128))
                          ]),
                          _: 2
                        }, 1032, ["modelValue", "onUpdate:modelValue", "group"]),
                        createBaseVNode("div", _hoisted_37$8, [
                          createBaseVNode("span", _hoisted_38$7, "Group ID: " + toDisplayString(group.id), 1)
                        ])
                      ]);
                    }), 128)),
                    createBaseVNode("div", _hoisted_39$6, [
                      createBaseVNode("button", {
                        type: "button",
                        class: "button button-secondary d-flex align-items-center",
                        onClick: withModifiers(($event) => addNewGroup(round.id), ["prevent"])
                      }, [..._cache[19] || (_cache[19] = [
                        createBaseVNode("svg", { class: "anwp-icon anwp-icon--s18 anwp-icon--octi mr-2" }, [
                          createBaseVNode("use", { "xlink:href": "#icon-plus" })
                        ], -1),
                        createTextVNode(" Add New Group/Match-up ", -1)
                      ])], 8, _hoisted_40$6)
                    ])
                  ]),
                  _: 2
                }, 1032, ["modelValue", "onUpdate:modelValue"]),
                createBaseVNode("div", _hoisted_41$6, [
                  createBaseVNode("span", _hoisted_42$5, "Round ID: " + toDisplayString(round.id), 1)
                ])
              ]);
            }), 128)),
            _cache[24] || (_cache[24] = createBaseVNode("div", { class: "w-100 my-2" }, null, -1)),
            createBaseVNode("div", _hoisted_43$5, [
              "knockout" === unref(trStore).activeStage.type ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                class: "button mx-3 my-2 d-flex align-items-center",
                onClick: _cache[6] || (_cache[6] = withModifiers(($event) => addNewRound(), ["prevent"]))
              }, [
                _cache[20] || (_cache[20] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16 mr-2" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-git-compare" })
                ], -1)),
                createTextVNode(" " + toDisplayString(unref(l10n).add_new_round), 1)
              ])) : createCommentVNode("", true),
              !unref(trStore).activeStage.root ? (openBlock(), createElementBlock("a", {
                key: 1,
                class: "ml-auto anwp-text-red-700 mr-3",
                href: "#",
                onClick: _cache[7] || (_cache[7] = withModifiers(($event) => {
                  unref(trStore).modals.deleteStage = true;
                }, ["prevent"]))
              }, " Delete Stage ")) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true),
          createVNode(_sfc_main$V),
          createVNode(_sfc_main$S),
          createVNode(_sfc_main$U)
        ], 64);
      };
    }
  };
  const _hoisted_1$R = {
    class: "anwp-overflow-auto mt-2",
    style: { marginBottom: "-1px" }
  };
  const _hoisted_2$L = { class: "d-flex align-items-end" };
  const _hoisted_3$J = ["onClick"];
  const _hoisted_4$I = { class: "d-flex flex-column anwp-user-select-none" };
  const _hoisted_5$G = {
    key: 0,
    class: "anwp-text-base anwp-leading-1"
  };
  const _hoisted_6$E = {
    key: 1,
    class: "anwp-text-base anwp-leading-1 anwp-opacity-70"
  };
  const _hoisted_7$B = ["value"];
  const _hoisted_8$y = ["value"];
  const _hoisted_9$t = ["value"];
  const _sfc_main$Q = {
    __name: "AppStages",
    setup(__props) {
      const trStore = useTrStore();
      trStore.setActiveStage();
      const addNewStage = () => {
        const stageId = `temp-${trStore.stages.length}-${(/* @__PURE__ */ new Date()).valueOf()}`;
        const newStage = {
          stageTitle: "",
          title: "",
          stageId,
          competitionStatus: "",
          type: "round-robin",
          formatRobin: "double",
          formatKnockout: "single",
          nextIdGroup: 2,
          nextIdRound: 2,
          root: false,
          rounds: [{
            id: 1,
            title: "",
            groups: [
              {
                id: 1,
                title: "",
                round: 1,
                clubs: []
              }
            ]
          }]
        };
        trStore.stages.push(newStage);
        trStore.addedStages.push(stageId);
        trStore.setActiveStage();
      };
      return (_ctx, _cache) => {
        const _component_draggable = resolveComponent("draggable");
        return openBlock(), createElementBlock(Fragment, null, [
          createBaseVNode("div", _hoisted_1$R, [
            createBaseVNode("div", _hoisted_2$L, [
              createVNode(_component_draggable, {
                class: "d-flex mt-4",
                modelValue: unref(trStore).stages,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(trStore).stages = $event),
                handle: ".anwp-drag-handler",
                "force-fallback": true
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(trStore).stages, (stage) => {
                    return openBlock(), createElementBlock("div", {
                      key: stage.stageId,
                      class: normalizeClass(["anwp-border anwp-border-gray-500 pt-2 pb-3 pl-2 pr-3 mr-2 d-flex align-items-center", unref(trStore).activeStageId === stage.stageId ? "anwp-fl-stage-tab__active" : "anwp-cursor-pointer"]),
                      onClick: ($event) => unref(trStore).activeStageId === stage.stageId || unref(trStore).setActiveStage(stage.stageId)
                    }, [
                      _cache[3] || (_cache[3] = createBaseVNode("svg", { class: "anwp-drag-handler anwp-icon anwp-icon--s24 anwp-icon--octi mr-2" }, [
                        createBaseVNode("use", { "xlink:href": "#icon-grabber" })
                      ], -1)),
                      createBaseVNode("div", _hoisted_4$I, [
                        _cache[2] || (_cache[2] = createBaseVNode("span", { class: "anwp-text-xs anwp-font-normal anwp-opacity-60 anwp-text-nowrap" }, "Competition Stage", -1)),
                        stage.stageTitle ? (openBlock(), createElementBlock("span", _hoisted_5$G, toDisplayString(stage.stageTitle), 1)) : (openBlock(), createElementBlock("span", _hoisted_6$E, "- stage title -"))
                      ])
                    ], 10, _hoisted_3$J);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue"]),
              createBaseVNode("div", {
                onClick: _cache[1] || (_cache[1] = withModifiers(($event) => addNewStage(), ["prevent"])),
                class: "anwp-border anwp-border-gray-500 pt-3 pb-3 pl-2 pr-3 ml-auto d-flex align-items-center anwp-cursor-pointer"
              }, [..._cache[4] || (_cache[4] = [
                createBaseVNode("svg", { class: "anwp-drag-handler anwp-icon anwp-icon--s18 anwp-icon--octi mr-2" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-plus" })
                ], -1),
                createBaseVNode("span", { class: "anwp-text-sm anwp-leading-1 anwp-opacity-80 anwp-text-nowrap" }, "Add New Stage", -1)
              ])])
            ])
          ]),
          createVNode(_sfc_main$R),
          createBaseVNode("input", {
            type: "hidden",
            name: "_fl_stages_data",
            value: JSON.stringify(unref(trStore).stages)
          }, null, 8, _hoisted_7$B),
          createBaseVNode("input", {
            type: "hidden",
            name: "_fl_stages_removed",
            value: unref(trStore).removedStages.join("|")
          }, null, 8, _hoisted_8$y),
          createBaseVNode("input", {
            type: "hidden",
            name: "_fl_stages_added",
            value: unref(trStore).addedStages.join("|")
          }, null, 8, _hoisted_9$t)
        ], 64);
      };
    }
  };
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$P = {
    name: "app-block-header",
    props: {
      iconClass: {
        type: String,
        default: "anwp-icon--octi anwp-fill-current"
      },
      icon: {
        type: String,
        default: ""
      }
    }
  };
  const _hoisted_1$Q = { class: "anwp-border-bottom anwp-border-gray-500 bg-white d-flex align-items-center px-3 py-2 anwp-text-gray-700 anwp-font-semibold" };
  const _hoisted_2$K = ["xlink:href"];
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$Q, [
      $props.icon ? (openBlock(), createElementBlock("svg", {
        key: 0,
        class: normalizeClass(["anwp-icon anwp-icon--s16 mr-2", $props.iconClass])
      }, [
        createBaseVNode("use", { "xlink:href": $props.icon }, null, 8, _hoisted_2$K)
      ], 2)) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default")
    ]);
  }
  const AppBlockHeader = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$1]]);
  const _hoisted_1$P = {
    key: 0,
    class: "alert alert-warning d-flex py-2 border-warning mb-3"
  };
  const _hoisted_2$J = { class: "mt-0 mb-1 anwp-text-orange-500 anwp-text-lg" };
  const _hoisted_3$I = { class: "list-unstyled mt-0 mb-1" };
  const _hoisted_4$H = { class: "anwp-border anwp-border-gray-500" };
  const _hoisted_5$F = { class: "bg-white p-3 pb-4 d-sm-flex flex-wrap align-items-start" };
  const _hoisted_6$D = { class: "anwp-flex-none anwp-w-150 text-center mx-auto mx-sm-0" };
  const _hoisted_7$A = { class: "d-block text-center mt-2" };
  const _hoisted_8$x = {
    key: 0,
    class: "d-flex flex-column mt-3 align-items-center"
  };
  const _hoisted_9$s = ["src"];
  const _hoisted_10$r = { class: "d-sm-flex flex-wrap" };
  const _hoisted_11$q = { class: "mb-4 m-sm-2 anwp-w-min-200 px-2" };
  const _hoisted_12$p = { class: "d-block" };
  const _hoisted_13$o = {
    key: 0,
    class: "d-flex align-items-end anwp-h-min-30 border-bottom anwp-text-base"
  };
  const _hoisted_14$o = {
    key: 0,
    class: "options__flag f32 mr-2"
  };
  const _hoisted_15$m = {
    key: 0,
    class: "options__flag f32 mr-2"
  };
  const _hoisted_16$l = {
    key: 1,
    class: "text-center anwp-text-orange-500 text-lowercase"
  };
  const _hoisted_17$k = { class: "mb-4 m-sm-2 anwp-w-min-200 px-2" };
  const _hoisted_18$j = { class: "d-block" };
  const _hoisted_19$j = { key: 0 };
  const _hoisted_20$h = { class: "mr-2" };
  const _hoisted_21$h = {
    key: 1,
    class: "text-center anwp-text-orange-500 text-lowercase"
  };
  const _hoisted_22$h = ["value"];
  const _hoisted_23$f = ["value"];
  const _hoisted_24$d = ["value"];
  const _hoisted_25$b = ["value"];
  const _sfc_main$O = {
    __name: "AppTournamentSetup",
    setup(__props) {
      var _a2;
      const trStore = useTrStore();
      const l10n = window._flTournamentL10n;
      const hasGames = ((_a2 = window._flTournament) == null ? void 0 : _a2.gamesQty) > 0;
      const mediaImageUploader = wp.media({
        title: l10n.select_image,
        library: {
          type: "image"
        },
        button: {
          text: l10n.select_image
        },
        multiple: false
      });
      const openMedia = () => {
        mediaImageUploader.on("select", function() {
          setMediaUploaderFile(mediaImageUploader.state().get("selection").first().toJSON());
        }.bind(this));
        mediaImageUploader.open();
      };
      const setMediaUploaderFile = (attachment) => {
        if ("undefined" !== typeof attachment && attachment.url) {
          trStore.logo = attachment.url;
          trStore.logo_id = attachment.id;
        }
      };
      const modalSeasonsOpen = () => {
        trStore.modalData.seasonsCreateMode = false;
        trStore.modalData.seasonsMultipleMode = trStore.seasonsSelected.length > 1;
        trStore.modals.seasonSelector = true;
      };
      const modalLeaguesOpen = () => {
        trStore.modalData.leaguesCreateMode = false;
        trStore.modals.leagueSelector = true;
      };
      return (_ctx, _cache) => {
        var _a3;
        const _directive_tooltip = resolveDirective("tooltip");
        return openBlock(), createElementBlock(Fragment, null, [
          !unref(trStore).leagueId || !unref(trStore).seasonIds.length ? (openBlock(), createElementBlock("div", _hoisted_1$P, [
            _cache[4] || (_cache[4] = createBaseVNode("div", { class: "align-self-center mr-3 pr-1" }, [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s36" }, [
                createBaseVNode("use", { "xlink:href": "#icon-alert" })
              ])
            ], -1)),
            createBaseVNode("div", null, [
              createBaseVNode("p", _hoisted_2$J, toDisplayString(unref(l10n).fill_in_the_required_fields) + ":", 1),
              createBaseVNode("ul", _hoisted_3$I, [
                withDirectives(createBaseVNode("li", { class: "my-0 anwp-text-base text-capitalize" }, "- " + toDisplayString(unref(l10n).league), 513), [
                  [vShow, !unref(trStore).leagueId]
                ]),
                withDirectives(createBaseVNode("li", { class: "my-0 anwp-text-base text-capitalize" }, "- " + toDisplayString(unref(l10n).season), 513), [
                  [vShow, !unref(trStore).seasonIds.length]
                ])
              ])
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_4$H, [
            createVNode(AppBlockHeader, { icon: "#icon-gear" }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(l10n).general), 1)
              ]),
              _: 1
            }),
            createBaseVNode("div", _hoisted_5$F, [
              createBaseVNode("div", _hoisted_6$D, [
                createBaseVNode("label", _hoisted_7$A, toDisplayString(unref(l10n).competition_logo), 1),
                unref(trStore).logo ? (openBlock(), createElementBlock("div", _hoisted_8$x, [
                  createBaseVNode("img", {
                    src: unref(trStore).logo,
                    class: "border p-1 anwp-w-100 anwp-h-80 anwp-object-contain",
                    alt: ""
                  }, null, 8, _hoisted_9$s),
                  createBaseVNode("a", {
                    href: "#",
                    onClick: _cache[0] || (_cache[0] = withModifiers(($event) => {
                      unref(trStore).logo = "";
                      unref(trStore).logo_id = "";
                    }, ["prevent"])),
                    class: "mt-1"
                  }, toDisplayString(unref(l10n).remove_image), 1)
                ])) : createCommentVNode("", true),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary my-3",
                  onClick: _cache[1] || (_cache[1] = ($event) => openMedia())
                }, toDisplayString(unref(l10n).select_image), 1)
              ]),
              _cache[6] || (_cache[6] = createBaseVNode("div", { class: "d-none d-sm-block border-right my-2 align-self-stretch" }, "", -1)),
              createBaseVNode("div", _hoisted_10$r, [
                createBaseVNode("div", _hoisted_11$q, [
                  createBaseVNode("label", _hoisted_12$p, toDisplayString(unref(l10n).league), 1),
                  hasGames ? (openBlock(), createElementBlock("div", _hoisted_13$o, [
                    unref(trStore).leagueSelected ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      unref(trStore).leagueSelected.country_code ? (openBlock(), createElementBlock("div", _hoisted_14$o, [
                        createBaseVNode("span", {
                          class: normalizeClass(["flag", unref(trStore).leagueSelected.country_code])
                        }, null, 2)
                      ])) : createCommentVNode("", true),
                      createBaseVNode("div", null, toDisplayString(unref(trStore).leagueSelected.name), 1)
                    ], 64)) : createCommentVNode("", true)
                  ])) : withDirectives((openBlock(), createElementBlock("div", {
                    key: 1,
                    class: "d-flex align-items-end anwp-h-min-30 border-bottom anwp-text-blue-500 anwp-text-base anwp-cursor-pointer",
                    onClick: _cache[2] || (_cache[2] = withModifiers(($event) => modalLeaguesOpen(), ["prevent"]))
                  }, [
                    ((_a3 = unref(trStore).leagueSelected) == null ? void 0 : _a3.id) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      unref(trStore).leagueSelected.country_code ? (openBlock(), createElementBlock("div", _hoisted_15$m, [
                        createBaseVNode("span", {
                          class: normalizeClass(["flag", unref(trStore).leagueSelected.country_code])
                        }, null, 2)
                      ])) : createCommentVNode("", true),
                      createBaseVNode("div", null, toDisplayString(unref(trStore).leagueSelected.name), 1)
                    ], 64)) : (openBlock(), createElementBlock("div", _hoisted_16$l, "- " + toDisplayString(unref(l10n).select_league) + " -", 1))
                  ])), [
                    [_directive_tooltip, unref(l10n).click_to_change]
                  ])
                ]),
                createBaseVNode("div", _hoisted_17$k, [
                  createBaseVNode("label", _hoisted_18$j, toDisplayString(unref(l10n).season), 1),
                  withDirectives((openBlock(), createElementBlock("div", {
                    class: "d-flex flex-wrap align-items-end anwp-h-min-30 border-bottom anwp-text-blue-500 anwp-text-base anwp-cursor-pointer",
                    onClick: _cache[3] || (_cache[3] = withModifiers(($event) => modalSeasonsOpen(), ["prevent"]))
                  }, [
                    unref(trStore).seasonsSelected.length ? (openBlock(), createElementBlock("div", _hoisted_19$j, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(trStore).seasonsSelected, (season) => {
                        return openBlock(), createElementBlock("span", _hoisted_20$h, toDisplayString(season.title) + toDisplayString(unref(trStore).seasonsSelected.length > 1 ? "; " : ""), 1);
                      }), 256))
                    ])) : (openBlock(), createElementBlock("div", _hoisted_21$h, "- " + toDisplayString(unref(l10n).select_season) + " -", 1))
                  ])), [
                    [_directive_tooltip, unref(l10n).click_to_change]
                  ])
                ]),
                _cache[5] || (_cache[5] = createBaseVNode("div", { class: "w-100 my-2" }, null, -1))
              ]),
              createBaseVNode("input", {
                type: "hidden",
                name: "_anwpfl_league_id",
                value: unref(trStore).leagueId
              }, null, 8, _hoisted_22$h),
              createBaseVNode("input", {
                type: "hidden",
                name: "_anwpfl_season_ids",
                value: unref(trStore).seasonIds.join(",")
              }, null, 8, _hoisted_23$f),
              createBaseVNode("input", {
                type: "hidden",
                name: "_anwpfl_logo",
                value: unref(trStore).logo
              }, null, 8, _hoisted_24$d),
              createBaseVNode("input", {
                type: "hidden",
                name: "_anwpfl_logo_id",
                value: unref(trStore).logo_id
              }, null, 8, _hoisted_25$b)
            ])
          ])
        ], 64);
      };
    }
  };
  const _hoisted_1$O = { class: "anwp-vfm-admin-modal__title d-flex flex-wrap align-items-center" };
  const _hoisted_2$I = { class: "my-0 mr-3 text-capitalize" };
  const _hoisted_3$H = { class: "ml-auto mr-5 font-italic" };
  const _hoisted_4$G = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_5$E = { key: 0 };
  const _hoisted_6$C = {
    class: "d-block mb-1",
    for: "anwp-modaal-league-create-name"
  };
  const _hoisted_7$z = { class: "anwp-global-info my-2" };
  const _hoisted_8$w = { class: "wp-list-table widefat fixed striped" };
  const _hoisted_9$r = ["onClick"];
  const _hoisted_10$q = ["onClick", "checked"];
  const _hoisted_11$p = ["onClick", "checked"];
  const _hoisted_12$o = { class: "alert alert-info my-3" };
  const _hoisted_13$n = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_14$n = { class: "d-flex" };
  const _sfc_main$N = {
    __name: "AppModalSeasonSelector",
    setup(__props) {
      const AppAxios = axios.create({
        baseURL: window._flTournament.rest_root,
        headers: {
          "X-WP-Nonce": window._flTournament.rest_nonce
        }
      });
      const trStore = useTrStore();
      const l10n = window._flTournamentL10n;
      const modalSeasonSelect = (seasonId) => {
        if (trStore.modalData.seasonsMultipleMode) {
          if (trStore.seasonIds.includes(seasonId)) {
            trStore.seasonIds = trStore.seasonIds.filter((s2) => Number(s2) !== Number(seasonId));
          } else {
            trStore.seasonIds.push(seasonId);
          }
        } else {
          trStore.seasonIds = [seasonId];
          trStore.modals.seasonSelector = false;
        }
      };
      const modalSeasonsCreate = () => {
        trStore.modalData.seasonsCreateMode = true;
        trStore.modalData.seasonsCreateName = "";
        setTimeout(() => {
          document.getElementById("anwp-modaal-season-create-name").focus();
        }, 1);
      };
      const modalSeasonsSaveNew = () => {
        if (trStore.activeRequest) {
          trStore.showError({ message: "Another request is active." });
          return false;
        }
        if ("" === trStore.modalData.seasonsCreateName.trim()) {
          trStore.showError({ message: l10n.empty_season_name_not_allowed });
          return false;
        }
        trStore.activeRequest = "create_season";
        AppAxios.post(
          "anwpfl/helper/create_season",
          { season_name: trStore.modalData.seasonsCreateName }
        ).then((response) => {
          if (response.data.seasons) {
            trStore.appConfig.optionsSeasons = response.data.seasons;
            trStore.showSuccess(l10n.seasons_updated);
            if (response.data.season_id) {
              modalSeasonSelect(response.data.season_id);
            }
          }
        }).catch((error) => {
          trStore.showError(error);
        }).finally(() => {
          trStore.activeRequest = "";
          trStore.modalData.seasonsCreateMode = false;
          trStore.modalData.seasonsCreateName = "";
        });
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(trStore).modals.seasonSelector,
          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(trStore).modals.seasonSelector = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--medium"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(trStore).modals.seasonSelector = false)
            }, [..._cache[7] || (_cache[7] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$O, [
              createBaseVNode("h4", _hoisted_2$I, toDisplayString(unref(l10n).select_season), 1),
              createBaseVNode("label", _hoisted_3$H, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  class: "mr-1",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(trStore).modalData.seasonsMultipleMode = $event)
                }, null, 512), [
                  [vModelCheckbox, unref(trStore).modalData.seasonsMultipleMode]
                ]),
                createTextVNode(" " + toDisplayString(unref(l10n).allows_multiple_seasons), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_4$G, [
              unref(trStore).modalData.seasonsCreateMode ? (openBlock(), createElementBlock("div", _hoisted_5$E, [
                createBaseVNode("label", _hoisted_6$C, toDisplayString(unref(l10n).season_name), 1),
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  class: "w-100",
                  id: "anwp-modaal-season-create-name",
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(trStore).modalData.seasonsCreateName = $event)
                }, null, 512), [
                  [vModelText, unref(trStore).modalData.seasonsCreateName]
                ]),
                createBaseVNode("div", _hoisted_7$z, toDisplayString(unref(l10n).recommended_season_name), 1)
              ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                withDirectives(createBaseVNode("table", _hoisted_8$w, [
                  createBaseVNode("thead", null, [
                    createBaseVNode("tr", null, [
                      _cache[8] || (_cache[8] = createBaseVNode("th", { class: "check-column" }, null, -1)),
                      createBaseVNode("th", null, toDisplayString(unref(l10n).season), 1),
                      _cache[9] || (_cache[9] = createBaseVNode("th", null, "ID", -1))
                    ])
                  ]),
                  createBaseVNode("tbody", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(trStore).appConfig.optionsSeasons, (season) => {
                      return openBlock(), createElementBlock("tr", {
                        key: season.id,
                        onClick: withModifiers(($event) => modalSeasonSelect(season.id), ["prevent"]),
                        class: "anwp-cursor-pointer"
                      }, [
                        createBaseVNode("td", null, [
                          unref(trStore).modalData.seasonsMultipleMode ? (openBlock(), createElementBlock("input", {
                            key: 0,
                            type: "checkbox",
                            class: "mr-0",
                            onClick: withModifiers(($event) => modalSeasonSelect(season.id), ["stop"]),
                            checked: unref(trStore).seasonIds.includes(season.id)
                          }, null, 8, _hoisted_10$q)) : (openBlock(), createElementBlock("input", {
                            key: 1,
                            type: "radio",
                            class: "mr-0",
                            onClick: withModifiers(($event) => modalSeasonSelect(season.id), ["stop"]),
                            checked: unref(trStore).seasonIds.includes(season.id)
                          }, null, 8, _hoisted_11$p))
                        ]),
                        createBaseVNode("td", null, toDisplayString(season.title), 1),
                        createBaseVNode("td", null, toDisplayString(season.id), 1)
                      ], 8, _hoisted_9$r);
                    }), 128))
                  ]),
                  createBaseVNode("tfoot", null, [
                    createBaseVNode("tr", null, [
                      _cache[10] || (_cache[10] = createBaseVNode("th", null, null, -1)),
                      createBaseVNode("th", null, toDisplayString(unref(l10n).season), 1),
                      _cache[11] || (_cache[11] = createBaseVNode("th", null, "ID", -1))
                    ])
                  ])
                ], 512), [
                  [vShow, unref(trStore).appConfig.optionsSeasons.length]
                ]),
                withDirectives(createBaseVNode("div", _hoisted_12$o, [
                  createTextVNode(toDisplayString(unref(l10n).no_published_seasons_available), 1),
                  _cache[12] || (_cache[12] = createBaseVNode("br", null, null, -1)),
                  createTextVNode(" " + toDisplayString(unref(l10n).click_create_new_season_add_new_one), 1)
                ], 512), [
                  [vShow, !unref(trStore).appConfig.optionsSeasons.length]
                ])
              ], 64))
            ]),
            createBaseVNode("div", _hoisted_13$n, [
              createBaseVNode("div", _hoisted_14$n, [
                !unref(trStore).modalData.seasonsCreateMode ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  class: "button button-secondary px-4 mr-3",
                  onClick: _cache[3] || (_cache[3] = withModifiers(($event) => modalSeasonsCreate(), ["prevent"]))
                }, toDisplayString(unref(l10n).create_new_season), 1)) : (openBlock(), createElementBlock("button", {
                  key: 1,
                  type: "button",
                  class: normalizeClass(["button button-primary px-4 mr-3", { "disabled": unref(trStore).activeRequest === "create_season" }]),
                  onClick: _cache[4] || (_cache[4] = withModifiers(($event) => modalSeasonsSaveNew(), ["prevent"]))
                }, toDisplayString(unref(l10n).save_new_season), 3)),
                createBaseVNode("span", {
                  class: normalizeClass(["spinner ml-n1", { "is-active": unref(trStore).activeRequest === "create_season" }])
                }, null, 2),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary px-4 ml-auto",
                  onClick: _cache[5] || (_cache[5] = withModifiers(($event) => {
                    unref(trStore).modals.seasonSelector = false;
                  }, ["prevent"]))
                }, toDisplayString(unref(l10n).close), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$N = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$H = { class: "my-0 text-capitalize" };
  const _hoisted_3$G = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$F = { key: 0 };
  const _hoisted_5$D = {
    class: "d-block mb-1",
    for: "anwp-modaal-league-create-name"
  };
  const _hoisted_6$B = {
    class: "d-block mb-1 mt-2",
    for: "anwp-modaal-league-create-country"
  };
  const _hoisted_7$y = { class: "d-flex mt-2 mb-3" };
  const _hoisted_8$v = { class: "wp-list-table widefat fixed striped" };
  const _hoisted_9$q = ["onClick"];
  const _hoisted_10$p = ["checked", "onClick"];
  const _hoisted_11$o = { class: "py-1 px-0" };
  const _hoisted_12$n = {
    key: 0,
    class: "options__flag f32 text-center"
  };
  const _hoisted_13$m = { class: "alert alert-info my-3" };
  const _hoisted_14$m = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_15$l = { class: "d-flex" };
  const _sfc_main$M = {
    __name: "AppModalLeagueSelector",
    setup(__props) {
      const AppAxios = axios.create({
        baseURL: window._flTournament.rest_root,
        headers: {
          "X-WP-Nonce": window._flTournament.rest_nonce
        }
      });
      const trStore = useTrStore();
      const l10n = window._flTournamentL10n;
      const filterLeagueCountry = ref("");
      const filterLeagueName = ref("");
      const resetFilters = () => {
        filterLeagueCountry.value = "";
        filterLeagueName.value = "";
      };
      const filteredLeagues = computed(() => {
        return trStore.appConfig.optionsLeagues.filter((c2) => {
          if (filterLeagueCountry.value && c2.country_code !== filterLeagueCountry.value) {
            return false;
          }
          if (filterLeagueName.value.trim() && !c2.name.toLowerCase().includes(filterLeagueName.value.toLowerCase().trim())) {
            return false;
          }
          return true;
        });
      });
      const modalLeagueSelect = (leagueId) => {
        trStore.leagueId = leagueId;
        trStore.modals.leagueSelector = false;
      };
      const modalLeaguesCreate = () => {
        trStore.modalData.leaguesCreateMode = true;
        trStore.modalData.leaguesCreateName = "";
        trStore.modalData.leaguesCreateCountry = "";
        setTimeout(() => {
          var _a2;
          (_a2 = document.getElementById("anwp-modaal-league-create-name")) == null ? void 0 : _a2.focus();
        }, 1);
      };
      const modalLeagueSaveNew = () => {
        if (trStore.activeRequest) {
          trStore.showError({ message: "Another request is active." });
          return false;
        }
        if ("" === trStore.modalData.leaguesCreateName.trim()) {
          trStore.showError({ message: l10n.empty_league_name_not_allowed });
          return false;
        }
        trStore.activeRequest = "create_league";
        AppAxios.post(
          "anwpfl/helper/create_league",
          {
            league_name: trStore.modalData.leaguesCreateName,
            country_code: trStore.modalData.leaguesCreateCountry
          }
        ).then((response) => {
          if (response.data.leagues) {
            trStore.appConfig.optionsLeagues = response.data.leagues;
            trStore.showSuccess(l10n.leagues_updated);
            if (response.data.created_league_id) {
              modalLeagueSelect(response.data.created_league_id);
            }
          }
        }).catch((error) => {
          trStore.showError(error || l10n.data_save_error);
        }).finally(() => {
          trStore.activeRequest = "";
          trStore.modalData.leaguesCreateMode = false;
          trStore.modalData.leaguesCreateName = "";
          trStore.modalData.leaguesCreateCountry = "";
        });
      };
      return (_ctx, _cache) => {
        const _component_v_select = resolveComponent("v-select");
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(trStore).modals.leagueSelector,
          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => unref(trStore).modals.leagueSelector = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          onBeforeOpen: _cache[9] || (_cache[9] = ($event) => resetFilters()),
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--medium anwp-vfm-admin-modal__wrapper--top"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(trStore).modals.leagueSelector = false)
            }, [..._cache[10] || (_cache[10] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$N, [
              createBaseVNode("h4", _hoisted_2$H, toDisplayString(unref(l10n).select_league), 1)
            ]),
            createBaseVNode("div", _hoisted_3$G, [
              unref(trStore).modalData.leaguesCreateMode ? (openBlock(), createElementBlock("div", _hoisted_4$F, [
                createBaseVNode("label", _hoisted_5$D, toDisplayString(unref(l10n).league_name), 1),
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  class: "w-100",
                  id: "anwp-modaal-league-create-name",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(trStore).modalData.leaguesCreateName = $event)
                }, null, 512), [
                  [vModelText, unref(trStore).modalData.leaguesCreateName]
                ]),
                createBaseVNode("label", _hoisted_6$B, toDisplayString(unref(l10n).country), 1),
                createVNode(_component_v_select, {
                  id: "anwp-modaal-league-create-country",
                  modelValue: unref(trStore).modalData.leaguesCreateCountry,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(trStore).modalData.leaguesCreateCountry = $event),
                  appendToBody: true,
                  class: "anwp-w-min-200 anwp-v__search-visible bg-white",
                  options: unref(trStore).appConfig.optionsCountries,
                  clearable: true,
                  filterable: true,
                  searchable: true,
                  placeholder: "- select country -",
                  reduce: (country) => country.code
                }, null, 8, ["modelValue", "options", "reduce"])
              ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("div", _hoisted_7$y, [
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => filterLeagueName.value = $event),
                    type: "text",
                    class: "anwp-w-200"
                  }, null, 512), [
                    [vModelText, filterLeagueName.value]
                  ]),
                  createVNode(_component_v_select, {
                    id: "anwp-modaal-league-create-country",
                    modelValue: filterLeagueCountry.value,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => filterLeagueCountry.value = $event),
                    appendToBody: true,
                    class: "anwp-w-min-200 anwp-v__search-visible bg-white ml-auto",
                    options: unref(trStore).appConfig.optionsCountries,
                    clearable: true,
                    filterable: true,
                    searchable: true,
                    placeholder: "- select country -",
                    reduce: (country) => country.code
                  }, null, 8, ["modelValue", "options", "reduce"])
                ]),
                withDirectives(createBaseVNode("table", _hoisted_8$v, [
                  createBaseVNode("thead", null, [
                    createBaseVNode("tr", null, [
                      _cache[11] || (_cache[11] = createBaseVNode("th", { class: "check-column" }, null, -1)),
                      createBaseVNode("th", null, toDisplayString(unref(l10n).competition), 1),
                      createBaseVNode("th", null, toDisplayString(unref(l10n).country), 1),
                      _cache[12] || (_cache[12] = createBaseVNode("th", null, null, -1)),
                      _cache[13] || (_cache[13] = createBaseVNode("th", null, "ID", -1))
                    ])
                  ]),
                  createBaseVNode("tbody", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLeagues.value, (league) => {
                      return openBlock(), createElementBlock("tr", {
                        key: league.id,
                        onClick: withModifiers(($event) => modalLeagueSelect(league.id), ["prevent"]),
                        class: "anwp-cursor-pointer"
                      }, [
                        createBaseVNode("td", null, [
                          createBaseVNode("input", {
                            type: "radio",
                            class: "mr-0",
                            checked: Number(unref(trStore).leagueId) === Number(league.id),
                            onClick: withModifiers(($event) => modalLeagueSelect(league.id), ["stop"])
                          }, null, 8, _hoisted_10$p)
                        ]),
                        createBaseVNode("td", null, toDisplayString(league.name), 1),
                        createBaseVNode("td", null, toDisplayString(league.country), 1),
                        createBaseVNode("td", _hoisted_11$o, [
                          league.country_code ? (openBlock(), createElementBlock("div", _hoisted_12$n, [
                            createBaseVNode("span", {
                              class: normalizeClass(["flag", league.country_code])
                            }, null, 2)
                          ])) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", null, toDisplayString(league.id), 1)
                      ], 8, _hoisted_9$q);
                    }), 128))
                  ]),
                  createBaseVNode("tfoot", null, [
                    createBaseVNode("tr", null, [
                      _cache[14] || (_cache[14] = createBaseVNode("th", null, null, -1)),
                      createBaseVNode("th", null, toDisplayString(unref(l10n).competition), 1),
                      createBaseVNode("th", null, toDisplayString(unref(l10n).country), 1),
                      _cache[15] || (_cache[15] = createBaseVNode("th", null, null, -1)),
                      _cache[16] || (_cache[16] = createBaseVNode("th", null, "ID", -1))
                    ])
                  ])
                ], 512), [
                  [vShow, filteredLeagues.value.length]
                ]),
                withDirectives(createBaseVNode("div", _hoisted_13$m, [
                  createTextVNode(toDisplayString(unref(l10n).no_published_leagues_available), 1),
                  _cache[17] || (_cache[17] = createBaseVNode("br", null, null, -1)),
                  createTextVNode(" " + toDisplayString(unref(l10n).click_create_new_league_add_new_one), 1)
                ], 512), [
                  [vShow, !unref(trStore).appConfig.optionsLeagues.length]
                ])
              ], 64))
            ]),
            createBaseVNode("div", _hoisted_14$m, [
              createBaseVNode("div", _hoisted_15$l, [
                !unref(trStore).modalData.leaguesCreateMode ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  class: "button button-secondary px-4 mr-3",
                  onClick: _cache[5] || (_cache[5] = withModifiers(($event) => modalLeaguesCreate(), ["prevent"]))
                }, toDisplayString(unref(l10n).create_new_league), 1)) : (openBlock(), createElementBlock("button", {
                  key: 1,
                  type: "button",
                  class: normalizeClass(["button button-primary px-4 mr-3", { "disabled": unref(trStore).activeRequest === "create_league" }]),
                  onClick: _cache[6] || (_cache[6] = withModifiers(($event) => modalLeagueSaveNew(), ["prevent"]))
                }, toDisplayString(unref(l10n).save_new_league), 3)),
                createBaseVNode("span", {
                  class: normalizeClass(["spinner ml-n1", { "is-active": unref(trStore).activeRequest === "create_league" }])
                }, null, 2),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary px-4 ml-auto",
                  onClick: _cache[7] || (_cache[7] = withModifiers(($event) => {
                    unref(trStore).modals.leagueSelector = false;
                  }, ["prevent"]))
                }, toDisplayString(unref(l10n).close), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$M = { class: "anwp-vue-game-wrapper anwp-b-wrap anwp-vue-wrapper-ready" };
  const _sfc_main$L = {
    __name: "AppTournament",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$M, [
          createVNode(_sfc_main$O),
          createVNode(_sfc_main$Q),
          createVNode(unref(Wo)),
          createVNode(_sfc_main$N),
          createVNode(_sfc_main$M)
        ]);
      };
    }
  };
  const _hoisted_1$L = { class: "anwp-vue-plugin-health-wrapper anwp-b-wrap anwp-vue-wrapper-ready" };
  const _hoisted_2$G = { class: "anwp-border anwp-border-gray-500 bg-white p-3" };
  const _hoisted_3$F = { class: "my-3" };
  const _hoisted_4$E = { class: "d-flex flex-wrap align-items-center anwp-bg-gray-200 py-1 px-1" };
  const _hoisted_5$C = { class: "my-0 anwp-text-sm mr-3 anwp-font-normal py-1 ml-2" };
  const _hoisted_6$A = ["src"];
  const _hoisted_7$x = ["innerHTML"];
  const _hoisted_8$u = {
    key: 0,
    class: "my-3 d-flex"
  };
  const _hoisted_9$p = ["href"];
  const _hoisted_10$o = ["onClick"];
  const _hoisted_11$n = ["src"];
  const _sfc_main$K = {
    __name: "AppPluginHealth",
    setup(__props) {
      const notyf2 = new Notyf();
      const appOptions = {
        spinnerUrl: window._anwpPluginHealthData.spinner_url,
        rest_root: window._anwpPluginHealthData.rest_root,
        rest_nonce: window._anwpPluginHealthData.rest_nonce,
        actions: cloneDeep(window._anwpPluginHealthData.actions)
      };
      const AppAxios = axios.create({
        baseURL: appOptions.rest_root,
        headers: {
          "X-WP-Nonce": appOptions.rest_nonce
        }
      });
      const activeRequest = ref("");
      const activeActionIndex = ref(0);
      const runTests = () => {
        if (activeRequest.value) {
          notyf2.error("Another request is active!");
          return false;
        }
        testAction();
      };
      const testAction = () => {
        if (activeActionIndex.value >= appOptions.actions.length) {
          resetRequest();
          return false;
        }
        activeRequest.value = appOptions.actions[activeActionIndex.value].slug;
        AppAxios.get(`anwpfl/health-test/${appOptions.actions[activeActionIndex.value].slug}`).then((response) => {
          var _a2, _b2;
          appOptions.actions[activeActionIndex.value].status = ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.status) ? response.data.status : "";
          appOptions.actions[activeActionIndex.value].fix_data = ((_b2 = response == null ? void 0 : response.data) == null ? void 0 : _b2.fix_data) ? response.data.fix_data : {};
          activeActionIndex.value++;
          testAction();
        }).catch((error) => {
          notyf2.error(error);
          resetRequest();
        });
      };
      const fixIssue = (actionIndex, actionData, actionContext) => {
        if (activeRequest.value) {
          notyf2.error("Another request is active!");
          return false;
        }
        activeRequest.value = appOptions.actions[actionIndex].slug + "-" + actionContext;
        AppAxios.post(
          `anwpfl/health-fix/${appOptions.actions[actionIndex].slug}`,
          {
            action_data: actionData,
            action_context: actionContext
          }
        ).then((response) => {
          var _a2, _b2;
          appOptions.actions[actionIndex].status = ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.status) ? response.data.status : "";
          appOptions.actions[actionIndex].fix_data = ((_b2 = response == null ? void 0 : response.data) == null ? void 0 : _b2.fix_data) ? response.data.fix_data : {};
        }).catch((error) => {
          notyf2.error(error);
        }).finally(() => activeRequest.value = "");
      };
      const resetRequest = () => {
        activeActionIndex.value = 0;
        activeRequest.value = "";
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$L, [
          createBaseVNode("div", _hoisted_2$G, [
            _cache[1] || (_cache[1] = createBaseVNode("div", { class: "anwp-text-base anwp-text-gray-800 mt-2" }, " Run tests to check some common problems ", -1)),
            createBaseVNode("button", {
              class: "button px-4 mt-3 mb-4",
              type: "button",
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => runTests(), ["prevent"]))
            }, "Run"),
            createBaseVNode("div", _hoisted_3$F, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(appOptions.actions, (action, actionIndex) => {
                return openBlock(), createElementBlock("div", {
                  key: actionIndex,
                  class: "mb-3"
                }, [
                  createBaseVNode("div", _hoisted_4$E, [
                    createBaseVNode("h3", _hoisted_5$C, toDisplayString(action.title), 1),
                    activeRequest.value === action.slug ? (openBlock(), createElementBlock("img", {
                      key: 0,
                      class: "ml-auto",
                      src: appOptions.spinnerUrl
                    }, null, 8, _hoisted_6$A)) : (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass(["ml-auto px-3 py-0 anwp-flex-none text-white", { "anwp-bg-green-500": "ok" === action.status, "anwp-bg-orange-500": "problems" === action.status }])
                    }, toDisplayString(action.status), 3))
                  ]),
                  createBaseVNode("div", {
                    class: "anwp-text-sm my-2",
                    innerHTML: action.fix_data.text
                  }, null, 8, _hoisted_7$x),
                  "problems" === action.status ? (openBlock(), createElementBlock("div", _hoisted_8$u, [
                    "link" === action.fix_data.link_type ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(action.fix_data.links, (fixLink) => {
                      return openBlock(), createElementBlock("a", {
                        href: fixLink.link,
                        target: "_blank",
                        class: "button px-3 mr-2"
                      }, toDisplayString(fixLink.text), 9, _hoisted_9$p);
                    }), 256)) : "action" === action.fix_data.link_type ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(action.fix_data.links, (fixLink) => {
                      return openBlock(), createElementBlock("button", {
                        class: "button px-3 mr-2 d-flex align-items-center",
                        type: "button",
                        onClick: withModifiers(($event) => fixIssue(actionIndex, fixLink.data, fixLink.context), ["prevent"])
                      }, [
                        createTextVNode(toDisplayString(fixLink.text) + " ", 1),
                        activeRequest.value === `${action.slug}-${fixLink.context}` ? (openBlock(), createElementBlock("img", {
                          key: 0,
                          class: "ml-2",
                          src: appOptions.spinnerUrl,
                          alt: "spinner"
                        }, null, 8, _hoisted_11$n)) : createCommentVNode("", true)
                      ], 8, _hoisted_10$o);
                    }), 256)) : createCommentVNode("", true)
                  ])) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ])
        ]);
      };
    }
  };
  const _hoisted_1$K = { class: "anwp-b-wrap anwp-vue-wrapper-ready" };
  const _hoisted_2$F = {
    key: 0,
    id: "anwp-fl-manual-player-metabox"
  };
  const _hoisted_3$E = { class: "mt-2 mb-4 p-2 anwp-border anwp-border-blue-600 anwp-bg-blue-100" };
  const _hoisted_4$D = { class: "table-responsive" };
  const _hoisted_5$B = { class: "table table-bordered anwp-fl-input-table anwp-fl-stats-manual-table anwp-border-collapse" };
  const _hoisted_6$z = { class: "anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" };
  const _hoisted_7$w = { class: "anwp-fl-td-vertical" };
  const _hoisted_8$t = { class: "anwp-fl-td-vertical" };
  const _hoisted_9$o = { class: "anwp-fl-td-vertical" };
  const _hoisted_10$n = { class: "anwp-fl-td-vertical" };
  const _hoisted_11$m = { class: "anwp-fl-td-vertical" };
  const _hoisted_12$m = { class: "anwp-fl-td-vertical" };
  const _hoisted_13$l = { class: "anwp-fl-td-vertical" };
  const _hoisted_14$l = { class: "anwp-fl-td-vertical" };
  const _hoisted_15$k = { class: "anwp-fl-td-vertical" };
  const _hoisted_16$k = { class: "anwp-fl-td-vertical" };
  const _hoisted_17$j = { class: "anwp-fl-td-vertical" };
  const _hoisted_18$i = { class: "anwp-fl-td-vertical" };
  const _hoisted_19$i = { class: "anwp-fl-td-vertical" };
  const _hoisted_20$g = { class: "anwp-fl-td-vertical" };
  const _hoisted_21$g = { class: "anwp-fl-td-vertical" };
  const _hoisted_22$g = { class: "py-1 anwp-w-10" };
  const _hoisted_23$e = ["onUpdate:modelValue"];
  const _hoisted_24$c = { value: "" };
  const _hoisted_25$a = ["value"];
  const _hoisted_26$a = { class: "py-1 anwp-w-10" };
  const _hoisted_27$a = ["onUpdate:modelValue"];
  const _hoisted_28$a = { value: "new" };
  const _hoisted_29$a = { value: "id" };
  const _hoisted_30$a = ["onUpdate:modelValue"];
  const _hoisted_31$a = ["onUpdate:modelValue"];
  const _hoisted_32$a = ["value"];
  const _hoisted_33$a = { class: "p-0 anwp-w-10" };
  const _hoisted_34$9 = ["onUpdate:modelValue"];
  const _hoisted_35$9 = { class: "p-0 anwp-w-10" };
  const _hoisted_36$9 = ["onUpdate:modelValue"];
  const _hoisted_37$7 = { class: "p-0 anwp-w-10" };
  const _hoisted_38$6 = ["onUpdate:modelValue"];
  const _hoisted_39$5 = { class: "p-0 anwp-w-10" };
  const _hoisted_40$5 = ["onUpdate:modelValue"];
  const _hoisted_41$5 = { class: "p-0 anwp-w-10" };
  const _hoisted_42$4 = ["onUpdate:modelValue"];
  const _hoisted_43$4 = { class: "p-0 anwp-w-10" };
  const _hoisted_44$4 = ["onUpdate:modelValue"];
  const _hoisted_45$4 = { class: "p-0 anwp-w-10" };
  const _hoisted_46$4 = ["onUpdate:modelValue"];
  const _hoisted_47$4 = { class: "p-0 anwp-w-10" };
  const _hoisted_48$3 = ["onUpdate:modelValue"];
  const _hoisted_49$2 = { class: "p-0 anwp-w-10" };
  const _hoisted_50$2 = ["onUpdate:modelValue"];
  const _hoisted_51$2 = { class: "p-0 anwp-w-10" };
  const _hoisted_52$2 = ["onUpdate:modelValue"];
  const _hoisted_53$1 = { class: "p-0 anwp-w-10" };
  const _hoisted_54$1 = ["onUpdate:modelValue"];
  const _hoisted_55$1 = { class: "p-0 anwp-w-10" };
  const _hoisted_56$1 = ["onUpdate:modelValue"];
  const _hoisted_57$1 = { class: "p-0 anwp-w-10" };
  const _hoisted_58$1 = ["onUpdate:modelValue"];
  const _hoisted_59$1 = { class: "p-2 anwp-w-10 anwp-text-center align-top" };
  const _hoisted_60$1 = ["onClick"];
  const _hoisted_61$1 = { class: "mt-n2 mb-4 anwp-text-xs anwp-text-gray-600" };
  const _hoisted_62$1 = { class: "my-2" };
  const _hoisted_63$1 = ["value"];
  const _sfc_main$J = {
    __name: "AppPlayerManual",
    setup(__props) {
      const l10n = window.anwpPlayerManualData.l10n;
      const statsData = ref(window.anwpPlayerManualData.statsData || []);
      const appOptions = {
        seasons: window.anwpPlayerManualData.seasons_list,
        competitions: window.anwpPlayerManualData.competitions_list
      };
      const addNewRecord = () => {
        const recordEmpty = {
          id: statsData.value.length + 1,
          season_id: "",
          competition_id: "",
          competition_text: "",
          competition_type: "new",
          played: "",
          started: "",
          sub_in: "",
          minutes: "",
          card_y: "",
          card_yr: "",
          card_r: "",
          goals: "",
          goals_penalty: "",
          assists: "",
          own_goals: "",
          goals_conceded: "",
          clean_sheets: ""
        };
        statsData.value.push(recordEmpty);
      };
      return (_ctx, _cache) => {
        const _component_draggable = resolveComponent("draggable");
        return openBlock(), createElementBlock("div", _hoisted_1$K, [
          statsData.value.length ? (openBlock(), createElementBlock("div", _hoisted_2$F, [
            createBaseVNode("p", _hoisted_3$E, [
              createTextVNode(" * " + toDisplayString(unref(l10n).notice_1), 1),
              _cache[2] || (_cache[2] = createBaseVNode("br", null, null, -1)),
              createTextVNode(" ** " + toDisplayString(unref(l10n).notice_2), 1),
              _cache[3] || (_cache[3] = createBaseVNode("br", null, null, -1)),
              createTextVNode(" *** " + toDisplayString(unref(l10n).notice_3), 1)
            ]),
            createBaseVNode("div", _hoisted_4$D, [
              createBaseVNode("table", _hoisted_5$B, [
                createBaseVNode("thead", null, [
                  createBaseVNode("tr", _hoisted_6$z, [
                    _cache[4] || (_cache[4] = createBaseVNode("td", null, null, -1)),
                    createBaseVNode("td", _hoisted_7$w, toDisplayString(unref(l10n).season), 1),
                    createBaseVNode("td", _hoisted_8$t, toDisplayString(unref(l10n).competition), 1),
                    createBaseVNode("td", _hoisted_9$o, toDisplayString(unref(l10n).played_matches), 1),
                    createBaseVNode("td", _hoisted_10$n, toDisplayString(unref(l10n).started), 1),
                    createBaseVNode("td", _hoisted_11$m, toDisplayString(unref(l10n).substituted_in), 1),
                    createBaseVNode("td", _hoisted_12$m, toDisplayString(unref(l10n).minutes), 1),
                    createBaseVNode("td", _hoisted_13$l, toDisplayString(unref(l10n).card_y), 1),
                    createBaseVNode("td", _hoisted_14$l, toDisplayString(unref(l10n).card_yr), 1),
                    createBaseVNode("td", _hoisted_15$k, toDisplayString(unref(l10n).card_r), 1),
                    createBaseVNode("td", _hoisted_16$k, toDisplayString(unref(l10n).goals), 1),
                    createBaseVNode("td", _hoisted_17$j, toDisplayString(unref(l10n).goals_penalty), 1),
                    createBaseVNode("td", _hoisted_18$i, toDisplayString(unref(l10n).assists), 1),
                    createBaseVNode("td", _hoisted_19$i, toDisplayString(unref(l10n).own_goals), 1),
                    createBaseVNode("td", _hoisted_20$g, toDisplayString(unref(l10n).goals_conceded), 1),
                    createBaseVNode("td", _hoisted_21$g, toDisplayString(unref(l10n).clean_sheets), 1),
                    _cache[5] || (_cache[5] = createBaseVNode("td", null, null, -1))
                  ])
                ]),
                createVNode(_component_draggable, {
                  modelValue: statsData.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => statsData.value = $event),
                  handle: ".anwp-drag-handler",
                  tag: "tbody",
                  "force-fallback": true
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(statsData.value, (rowData, rowIndex) => {
                      return openBlock(), createElementBlock("tr", {
                        class: "anwp-border anwp-border-gray-400",
                        key: rowData.id
                      }, [
                        _cache[7] || (_cache[7] = createBaseVNode("td", { class: "anwp-drag-handler anwp-w-30 anwp-text-center pt-1 px-2" }, [
                          createBaseVNode("svg", { class: "anwp-icon anwp-icon--s24 anwp-icon--octi mr-0" }, [
                            createBaseVNode("use", { "xlink:href": "#icon-grabber" })
                          ])
                        ], -1)),
                        createBaseVNode("td", _hoisted_22$g, [
                          withDirectives(createBaseVNode("select", {
                            class: normalizeClass(["anwp-border-gray-500 anwp-w-130 mt-1 mx-2", rowData.season_id ? "" : "anwp-border-red-600 anwp-text-red-600"]),
                            "onUpdate:modelValue": ($event) => rowData.season_id = $event
                          }, [
                            createBaseVNode("option", _hoisted_24$c, "- " + toDisplayString(unref(l10n).select_season) + " -", 1),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(appOptions.seasons, (season) => {
                              return openBlock(), createElementBlock("option", {
                                value: season.id,
                                key: season.id
                              }, toDisplayString(season.title), 9, _hoisted_25$a);
                            }), 128))
                          ], 10, _hoisted_23$e), [
                            [vModelSelect, rowData.season_id]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_26$a, [
                          withDirectives(createBaseVNode("select", {
                            class: "anwp-border-gray-500 anwp-w-200 mx-2 mb-2 mt-1",
                            "onUpdate:modelValue": ($event) => rowData.competition_type = $event
                          }, [
                            createBaseVNode("option", _hoisted_28$a, toDisplayString(unref(l10n).new_competition), 1),
                            createBaseVNode("option", _hoisted_29$a, toDisplayString(unref(l10n).existing_competition), 1)
                          ], 8, _hoisted_27$a), [
                            [vModelSelect, rowData.competition_type]
                          ]),
                          "new" === rowData.competition_type ? withDirectives((openBlock(), createElementBlock("input", {
                            key: 0,
                            class: normalizeClass(["anwp-border-gray-500 anwp-w-200 mx-2 mb-1", rowData.competition_text ? "" : "anwp-border-red-600 anwp-text-red-600"]),
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.competition_text = $event
                          }, null, 10, _hoisted_30$a)), [
                            [vModelText, rowData.competition_text]
                          ]) : withDirectives((openBlock(), createElementBlock("select", {
                            key: 1,
                            class: normalizeClass(["anwp-border-gray-500 anwp-w-200 mx-2 mb-1", rowData.competition_id ? "" : "anwp-border-red-600 anwp-text-red-600"]),
                            "onUpdate:modelValue": ($event) => rowData.competition_id = $event
                          }, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(appOptions.competitions, (competition) => {
                              return openBlock(), createElementBlock("option", {
                                value: competition.id
                              }, toDisplayString(competition.title), 9, _hoisted_32$a);
                            }), 256))
                          ], 10, _hoisted_31$a)), [
                            [vModelSelect, rowData.competition_id]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_33$a, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.played = $event
                          }, null, 8, _hoisted_34$9), [
                            [
                              vModelText,
                              rowData.played,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_35$9, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.started = $event
                          }, null, 8, _hoisted_36$9), [
                            [
                              vModelText,
                              rowData.started,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_37$7, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.sub_in = $event
                          }, null, 8, _hoisted_38$6), [
                            [
                              vModelText,
                              rowData.sub_in,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_39$5, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.minutes = $event
                          }, null, 8, _hoisted_40$5), [
                            [
                              vModelText,
                              rowData.minutes,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_41$5, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.card_y = $event
                          }, null, 8, _hoisted_42$4), [
                            [
                              vModelText,
                              rowData.card_y,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_43$4, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.card_yr = $event
                          }, null, 8, _hoisted_44$4), [
                            [
                              vModelText,
                              rowData.card_yr,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_45$4, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.card_r = $event
                          }, null, 8, _hoisted_46$4), [
                            [
                              vModelText,
                              rowData.card_r,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_47$4, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.goals = $event
                          }, null, 8, _hoisted_48$3), [
                            [
                              vModelText,
                              rowData.goals,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_49$2, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.goals_penalty = $event
                          }, null, 8, _hoisted_50$2), [
                            [
                              vModelText,
                              rowData.goals_penalty,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_51$2, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.assists = $event
                          }, null, 8, _hoisted_52$2), [
                            [
                              vModelText,
                              rowData.assists,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_53$1, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.own_goals = $event
                          }, null, 8, _hoisted_54$1), [
                            [
                              vModelText,
                              rowData.own_goals,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_55$1, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.goals_conceded = $event
                          }, null, 8, _hoisted_56$1), [
                            [
                              vModelText,
                              rowData.goals_conceded,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_57$1, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-border-gray-400 anwp-w-50 m-1",
                            type: "text",
                            "onUpdate:modelValue": ($event) => rowData.clean_sheets = $event
                          }, null, 8, _hoisted_58$1), [
                            [
                              vModelText,
                              rowData.clean_sheets,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_59$1, [
                          createBaseVNode("button", {
                            type: "button",
                            class: "anwp-cursor-pointer d-flex align-items-center justify-content-center my-1 button anwp-border-red-600 anwp-hide-sortable-drag mx-3",
                            onClick: withModifiers(($event) => {
                              statsData.value.splice(rowIndex, 1);
                            }, ["prevent"])
                          }, [..._cache[6] || (_cache[6] = [
                            createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-x" })
                            ], -1)
                          ])], 8, _hoisted_60$1)
                        ])
                      ]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                _cache[8] || (_cache[8] = createBaseVNode("tfoot", null, [
                  createBaseVNode("tr", { class: "anwp-border anwp-border-gray-400 anwp-bg-gray-200" }, [
                    createBaseVNode("td"),
                    createBaseVNode("td"),
                    createBaseVNode("td"),
                    createBaseVNode("td")
                  ])
                ], -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_61$1, " * " + toDisplayString(unref(l10n).notice_max), 1)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_62$1, [
            createBaseVNode("button", {
              class: "button d-flex align-items-center",
              type: "button",
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => addNewRecord(), ["prevent"]))
            }, [
              _cache[9] || (_cache[9] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16 mr-2" }, [
                createBaseVNode("use", { "xlink:href": "#icon-plus" })
              ], -1)),
              createTextVNode(" " + toDisplayString(unref(l10n).add_new_record), 1)
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_player_manual_data",
            value: JSON.stringify(statsData.value)
          }, null, 8, _hoisted_63$1)
        ]);
      };
    }
  };
  const _hoisted_1$J = { class: "anwp-vue-match-setup-wrapper anwp-b-wrap anwp-vue-wrapper-ready" };
  const _hoisted_2$E = { class: "anwp-border anwp-border-gray-500" };
  const _hoisted_3$D = { class: "p-3 d-sm-flex flex-wrap align-items-center bg-light" };
  const _hoisted_4$C = { class: "bg-white p-3 pb-4 d-sm-flex flex-wrap align-items-start" };
  const _hoisted_5$A = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_6$y = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-selected-competition"
  };
  const _hoisted_7$v = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_8$s = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-selected-season"
  };
  const _hoisted_9$n = {
    key: 0,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_10$m = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-selected-round"
  };
  const _hoisted_11$l = { class: "ml-1" };
  const _hoisted_12$l = { class: "ml-1" };
  const _hoisted_13$k = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_14$k = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-selected-home"
  };
  const _hoisted_15$j = { class: "d-flex align-items-center py-1" };
  const _hoisted_16$j = { class: "ml-1" };
  const _hoisted_17$i = { class: "d-flex align-items-center" };
  const _hoisted_18$h = { class: "ml-1" };
  const _hoisted_19$h = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_20$f = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-selected-away"
  };
  const _hoisted_21$f = { class: "d-flex align-items-center py-1" };
  const _hoisted_22$f = { class: "ml-1" };
  const _hoisted_23$d = { class: "d-flex align-items-center" };
  const _hoisted_24$b = { class: "ml-1" };
  const _hoisted_25$9 = { class: "d-sm-flex flex-wrap p-3 bg-light align-items-center" };
  const _hoisted_26$9 = ["disabled"];
  const _hoisted_27$9 = { class: "ml-auto d-flex align-items-center" };
  const _hoisted_28$9 = { class: "mx-2 mb-0" };
  const _hoisted_29$9 = ["value"];
  const _hoisted_30$9 = ["value"];
  const _hoisted_31$9 = ["value"];
  const _hoisted_32$9 = ["value"];
  const _hoisted_33$9 = ["value"];
  const _hoisted_34$8 = ["value"];
  const _hoisted_35$8 = ["value"];
  const _hoisted_36$8 = ["value"];
  const _sfc_main$I = {
    __name: "AppMatchSetup",
    setup(__props) {
      var _a2, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m;
      const selectedCompetition = ref(Number((_a2 = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _a2.competitionId) || "");
      const selectedSeason = ref(Number((_b2 = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _b2.season) || "");
      const selectedRound = ref(Number((_c = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _c.round) || "");
      const selectedGroup = ref(Number((_d = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _d.group) || "");
      const selectedHome = ref(Number((_e2 = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _e2.clubHome) || "");
      const selectedAway = ref(Number((_f = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _f.clubAway) || "");
      const filterActive = ref(!((_g = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _g.setupMatch));
      const ignoreStructure = ref(false);
      const activeSeason = ref(((_h = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _h.activeSeason) || 0);
      const optionsCompetition = ((_i = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _i.competitions) || [];
      const optionsSeasons = ((_j = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _j.seasons_list) || [];
      const optionsClubs = ((_k = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _k.clubs_list) || [];
      const l10n = Object.assign({}, window._anwp_FL_MatchSetup_L10n);
      const activeCompetitions = computed(() => {
        return filterActive.value ? optionsCompetition.filter((c2) => Number(c2.season_ids) === Number(activeSeason.value)) : optionsCompetition;
      });
      const activeCompetitionObj = computed(() => {
        return selectedCompetition.value ? optionsCompetition.find((c2) => Number(c2.id) === Number(selectedCompetition.value)) : null;
      });
      const activeCompetitionSeasonIds = computed(() => {
        var _a3, _b3;
        return selectedCompetition.value ? ((_b3 = (_a3 = activeCompetitionObj.value) == null ? void 0 : _a3.season_ids) == null ? void 0 : _b3.split(",").map((i2) => Number(i2))) || [] : [];
      });
      const activeSeasons = computed(() => {
        return activeCompetitionSeasonIds.value.length ? optionsSeasons.filter((s2) => activeCompetitionSeasonIds.value.includes(Number(s2.id))) : [];
      });
      const activeRounds = computed(() => {
        var _a3;
        return ((_a3 = activeCompetitionObj == null ? void 0 : activeCompetitionObj.value) == null ? void 0 : _a3.rounds) || [];
      });
      const activeHomeTeams = computed(() => {
        var _a3, _b3;
        if (ignoreStructure.value) {
          return optionsClubs;
        }
        if (!selectedCompetition.value || !selectedSeason.value || !selectedRound.value || !activeCompetitionObj.value || !((_a3 = activeCompetitionObj.value) == null ? void 0 : _a3.groups)) {
          return [];
        }
        let teamIds = [];
        if ("knockout" === activeCompetitionObj.value.type && ((_b3 = activeCompetitionObj.value.rounds) == null ? void 0 : _b3.length) > 1) {
          if (selectedRound.value) {
            activeCompetitionObj.value.groups.filter((g2) => Number(g2.round) === Number(selectedRound.value)).forEach((gr) => {
              teamIds = [...teamIds, ...gr.clubs.map((c2) => Number(c2))];
            });
          }
        } else {
          activeCompetitionObj.value.groups.forEach((gr) => {
            teamIds = [...teamIds, ...gr.clubs.map((c2) => Number(c2))];
          });
        }
        return optionsClubs.filter((c2) => teamIds.includes(Number(c2.id)));
      });
      const activeAwayTeams = computed(() => {
        var _a3, _b3;
        if (ignoreStructure.value) {
          return optionsClubs;
        }
        if (!selectedCompetition.value || !selectedSeason.value || !selectedHome.value || !selectedRound.value || !((_a3 = activeCompetitionObj.value) == null ? void 0 : _a3.groups)) {
          return [];
        }
        let teamIds = [];
        if ("knockout" === activeCompetitionObj.value.type && ((_b3 = activeCompetitionObj.value.rounds) == null ? void 0 : _b3.length) > 1) {
          if (selectedRound.value) {
            activeCompetitionObj.value.groups.filter((g2) => Number(g2.round) === Number(selectedRound.value) && g2.clubs.map((c2) => Number(c2)).includes(Number(selectedHome.value))).forEach((gr) => {
              teamIds = [...teamIds, ...gr.clubs.map((c2) => Number(c2)).filter((cl) => Number(cl) !== Number(selectedHome.value))];
            });
          }
        } else {
          activeCompetitionObj.value.groups.filter((g2) => g2.clubs.map((c2) => Number(c2)).includes(Number(selectedHome.value))).forEach((gr) => {
            teamIds = [...teamIds, ...gr.clubs.map((c2) => Number(c2)).filter((cl) => Number(cl) !== Number(selectedHome.value))];
          });
        }
        return optionsClubs.filter((c2) => teamIds.includes(Number(c2.id)));
      });
      const readyToSave = computed(() => {
        return !!(selectedCompetition.value && selectedHome.value && selectedAway.value && selectedSeason.value);
      });
      watch(activeSeasons, () => {
        if (!activeSeasons.value.find((a2) => Number(a2.id) === Number(selectedSeason.value))) {
          selectedSeason.value = "";
        }
        if (!selectedCompetition.value && selectedSeason.value) {
          selectedSeason.value = "";
        } else if (selectedCompetition.value && !selectedSeason.value && activeSeasons.value.length) {
          selectedSeason.value = activeSeasons.value[0].id;
        }
      });
      watch(activeRounds, () => {
        if (!activeRounds.value.find((a2) => Number(a2.id) === Number(selectedRound.value))) {
          selectedRound.value = "";
        }
        if (!selectedCompetition.value && selectedRound.value) {
          selectedRound.value = "";
        } else if (selectedCompetition.value && !selectedRound.value && activeRounds.value.length) {
          selectedRound.value = activeRounds.value[0].id;
        }
        selectedGroup.value = "";
      });
      watch(activeHomeTeams, () => {
        if (!activeHomeTeams.value.find((a2) => Number(a2.id) === Number(selectedHome.value))) {
          selectedHome.value = "";
        }
        if (!selectedCompetition.value && selectedHome.value && !ignoreStructure.value) {
          selectedHome.value = "";
        } else if (selectedCompetition.value && !selectedHome.value && activeHomeTeams.value.length) {
          selectedHome.value = activeHomeTeams.value[0].id;
        }
      });
      watch(activeAwayTeams, () => {
        if (!activeAwayTeams.value.find((a2) => Number(a2.id) === Number(selectedAway.value))) {
          selectedAway.value = "";
        }
        if (!selectedCompetition.value && selectedAway.value && !ignoreStructure.value) {
          selectedAway.value = "";
        }
        if (!selectedHome.value && !ignoreStructure.value) {
          selectedAway.value = "";
        }
      });
      watch(selectedAway, () => {
        var _a3;
        if (!selectedHome.value && selectedAway.value && !ignoreStructure.value) {
          selectedAway.value = "";
        }
        if (selectedAway.value && !ignoreStructure.value) {
          selectedGroup.value = ((_a3 = activeCompetitionObj.value.groups.find(
            (g2) => Number(g2.round) === Number(selectedRound.value) && g2.clubs.map((c2) => Number(c2)).includes(Number(selectedHome.value)) && g2.clubs.map((c2) => Number(c2)).includes(Number(selectedAway.value))
          )) == null ? void 0 : _a3.id) || "";
        } else {
          selectedGroup.value = "";
        }
      });
      if (selectedGroup.value && ((_l = window._anwp_FL_MatchSetup_Data) == null ? void 0 : _l.setupMatch) && !selectedRound.value) {
        selectedRound.value = Number((_m = activeCompetitionObj.value.groups.find((g2) => Number(g2.id) === Number(selectedGroup.value))) == null ? void 0 : _m.round) || "";
      }
      return (_ctx, _cache) => {
        var _a3, _b3;
        const _component_toggle = resolveComponent("toggle");
        const _component_v_select = resolveComponent("v-select");
        const _directive_tooltip = resolveDirective("tooltip");
        return openBlock(), createElementBlock("div", _hoisted_1$J, [
          createBaseVNode("div", _hoisted_2$E, [
            createVNode(AppBlockHeader, { icon: "#icon-gear" }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(l10n).match_setup), 1)
              ]),
              _: 1
            }),
            createBaseVNode("div", _hoisted_3$D, [
              _cache[7] || (_cache[7] = createBaseVNode("label", { class: "mr-3 mb-0" }, "show only active competitions", -1)),
              createVNode(_component_toggle, {
                modelValue: filterActive.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => filterActive.value = $event),
                "on-label": unref(l10n).yes,
                "off-label": unref(l10n).no,
                class: "anwp-toggle-w-60"
              }, null, 8, ["modelValue", "on-label", "off-label"])
            ]),
            createBaseVNode("div", _hoisted_4$C, [
              _cache[8] || (_cache[8] = createBaseVNode("div", { class: "w-100 mt-2" }, null, -1)),
              createBaseVNode("div", _hoisted_5$A, [
                createBaseVNode("label", _hoisted_6$y, toDisplayString(unref(l10n).competition), 1),
                createVNode(_component_v_select, {
                  id: "anwp-fl-selected-competition",
                  modelValue: selectedCompetition.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedCompetition.value = $event),
                  class: "anwp-w-min-400 anwp-v__search-visible",
                  label: "title_full",
                  options: activeCompetitions.value,
                  clearable: true,
                  filterable: true,
                  searchable: true,
                  reduce: (o2) => o2.id,
                  placeholder: "- select competition -"
                }, null, 8, ["modelValue", "options", "reduce"])
              ]),
              createBaseVNode("div", _hoisted_7$v, [
                createBaseVNode("label", _hoisted_8$s, toDisplayString(unref(l10n).season), 1),
                createVNode(_component_v_select, {
                  id: "anwp-fl-selected-season",
                  modelValue: selectedSeason.value,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => selectedSeason.value = $event),
                  class: "anwp-w-min-150 anwp-v__search-visible",
                  label: "title",
                  options: activeSeasons.value,
                  disabled: !activeSeasons.value.length,
                  clearable: false,
                  filterable: false,
                  searchable: false,
                  reduce: (o2) => o2.id,
                  placeholder: "- select season -"
                }, null, 8, ["modelValue", "options", "disabled", "reduce"])
              ]),
              selectedCompetition.value && "knockout" === activeCompetitionObj.value.type && ((_a3 = activeCompetitionObj.value.rounds) == null ? void 0 : _a3.length) ? (openBlock(), createElementBlock("div", _hoisted_9$n, [
                createBaseVNode("label", _hoisted_10$m, toDisplayString(unref(l10n).round), 1),
                createVNode(_component_v_select, {
                  id: "anwp-fl-selected-round",
                  modelValue: selectedRound.value,
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selectedRound.value = $event),
                  class: "anwp-w-min-250 anwp-v__search-visible",
                  label: "title",
                  options: activeRounds.value,
                  disabled: !activeRounds.value.length,
                  clearable: false,
                  filterable: false,
                  searchable: false,
                  reduce: (o2) => o2.id,
                  placeholder: "- select round -"
                }, {
                  option: withCtx(({ id, title }) => [
                    createTextVNode(toDisplayString(title || "- round -") + " ", 1),
                    createBaseVNode("span", _hoisted_11$l, "(ID: " + toDisplayString(id) + ")", 1)
                  ]),
                  "selected-option": withCtx(({ id, title }) => [
                    createTextVNode(toDisplayString(title || "- round -") + " ", 1),
                    createBaseVNode("span", _hoisted_12$l, "(ID: " + toDisplayString(id) + ")", 1)
                  ]),
                  _: 1
                }, 8, ["modelValue", "options", "disabled", "reduce"])
              ])) : createCommentVNode("", true),
              _cache[9] || (_cache[9] = createBaseVNode("div", { class: "w-100 mt-2" }, null, -1)),
              createBaseVNode("div", _hoisted_13$k, [
                createBaseVNode("label", _hoisted_14$k, toDisplayString(unref(l10n).home_club), 1),
                createVNode(_component_v_select, {
                  id: "anwp-fl-selected-home",
                  modelValue: selectedHome.value,
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => selectedHome.value = $event),
                  class: "anwp-w-min-250 anwp-v__search-visible",
                  label: "title",
                  options: activeHomeTeams.value,
                  disabled: !activeHomeTeams.value.length,
                  clearable: false,
                  filterable: true,
                  searchable: true,
                  reduce: (o2) => o2.id,
                  placeholder: "- select team -"
                }, {
                  option: withCtx(({ logo, title }) => [
                    createBaseVNode("span", _hoisted_15$j, [
                      withDirectives(createBaseVNode("span", {
                        class: "anwp-admin-stage-club-logo mr-1",
                        style: normalizeStyle({ backgroundImage: "url(" + logo + ")" })
                      }, null, 4), [
                        [vShow, logo]
                      ]),
                      createBaseVNode("span", _hoisted_16$j, toDisplayString(title), 1)
                    ])
                  ]),
                  "selected-option": withCtx(({ logo, title }) => [
                    createBaseVNode("span", _hoisted_17$i, [
                      withDirectives(createBaseVNode("span", {
                        class: "anwp-admin-stage-club-logo mr-1",
                        style: normalizeStyle({ backgroundImage: "url(" + logo + ")" })
                      }, null, 4), [
                        [vShow, logo]
                      ]),
                      createBaseVNode("span", _hoisted_18$h, toDisplayString(title), 1)
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue", "options", "disabled", "reduce"])
              ]),
              createBaseVNode("div", _hoisted_19$h, [
                createBaseVNode("label", _hoisted_20$f, toDisplayString(unref(l10n).away_club), 1),
                createVNode(_component_v_select, {
                  id: "anwp-fl-selected-away",
                  modelValue: selectedAway.value,
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => selectedAway.value = $event),
                  class: "anwp-w-min-250 anwp-v__search-visible bg-white",
                  label: "title",
                  options: activeAwayTeams.value,
                  disabled: !activeAwayTeams.value.length,
                  clearable: false,
                  filterable: true,
                  searchable: true,
                  reduce: (o2) => o2.id,
                  placeholder: "- select team -"
                }, {
                  option: withCtx(({ logo, title }) => [
                    createBaseVNode("span", _hoisted_21$f, [
                      withDirectives(createBaseVNode("span", {
                        class: "anwp-admin-stage-club-logo mr-1",
                        style: normalizeStyle({ backgroundImage: "url(" + logo + ")" })
                      }, null, 4), [
                        [vShow, logo]
                      ]),
                      createBaseVNode("span", _hoisted_22$f, toDisplayString(title), 1)
                    ])
                  ]),
                  "selected-option": withCtx(({ logo, title }) => [
                    createBaseVNode("span", _hoisted_23$d, [
                      withDirectives(createBaseVNode("span", {
                        class: "anwp-admin-stage-club-logo mr-1",
                        style: normalizeStyle({ backgroundImage: "url(" + logo + ")" })
                      }, null, 4), [
                        [vShow, logo]
                      ]),
                      createBaseVNode("span", _hoisted_24$b, toDisplayString(title), 1)
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue", "options", "disabled", "reduce"])
              ])
            ]),
            createBaseVNode("div", _hoisted_25$9, [
              createBaseVNode("button", {
                class: normalizeClass(["button button-large mx-2 px-5 my-2 mr-3", { "button-primary": readyToSave.value }]),
                disabled: !readyToSave.value,
                id: "anwp-match-setup-save-proxy",
                type: "submit"
              }, toDisplayString(unref(l10n).save_continue), 11, _hoisted_26$9),
              createBaseVNode("div", _hoisted_27$9, [
                withDirectives((openBlock(), createElementBlock("span", null, [..._cache[10] || (_cache[10] = [
                  createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s14" }, [
                    createBaseVNode("use", { "xlink:href": "#icon-info" })
                  ], -1)
                ])])), [
                  [_directive_tooltip, unref(l10n).show_all_clubs_ignoring_structure]
                ]),
                createBaseVNode("label", _hoisted_28$9, toDisplayString(unref(l10n).ignore_group_structure), 1),
                createVNode(_component_toggle, {
                  modelValue: ignoreStructure.value,
                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => ignoreStructure.value = $event),
                  "on-label": unref(l10n).yes,
                  "off-label": unref(l10n).no,
                  class: "anwp-toggle-w-60"
                }, null, 8, ["modelValue", "on-label", "off-label"])
              ])
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_competition",
            value: selectedCompetition.value || ""
          }, null, 8, _hoisted_29$9),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_season",
            value: selectedSeason.value || ""
          }, null, 8, _hoisted_30$9),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_league",
            value: ((_b3 = activeCompetitionObj.value) == null ? void 0 : _b3.league_id) || ""
          }, null, 8, _hoisted_31$9),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_round",
            value: selectedRound.value || ""
          }, null, 8, _hoisted_32$9),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_home",
            value: selectedHome.value || ""
          }, null, 8, _hoisted_33$9),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_away",
            value: selectedAway.value || ""
          }, null, 8, _hoisted_34$8),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_group",
            value: selectedGroup.value || ""
          }, null, 8, _hoisted_35$8),
          _cache[11] || (_cache[11] = createBaseVNode("input", {
            type: "hidden",
            name: "_fl_game_save",
            value: "setup"
          }, null, -1)),
          createBaseVNode("input", {
            type: "hidden",
            name: "anwp-match-setup-submit",
            value: readyToSave.value ? "yes" : ""
          }, null, 8, _hoisted_36$8)
        ]);
      };
    }
  };
  function isDate(value) {
    return value instanceof Date || Object.prototype.toString.call(value) === "[object Date]";
  }
  function toDate(value) {
    if (isDate(value)) {
      return new Date(value.getTime());
    }
    if (value == null) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return new Date(value);
  }
  function isValidDate$1(value) {
    return isDate(value) && !isNaN(value.getTime());
  }
  function startOfWeek(value) {
    var firstDayOfWeek = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!(firstDayOfWeek >= 0 && firstDayOfWeek <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6");
    }
    var date = toDate(value);
    var day = date.getDay();
    var diff = (day + 7 - firstDayOfWeek) % 7;
    date.setDate(date.getDate() - diff);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  function startOfWeekYear(value) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$firstDayOfWeek = _ref.firstDayOfWeek, firstDayOfWeek = _ref$firstDayOfWeek === void 0 ? 0 : _ref$firstDayOfWeek, _ref$firstWeekContain = _ref.firstWeekContainsDate, firstWeekContainsDate = _ref$firstWeekContain === void 0 ? 1 : _ref$firstWeekContain;
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7");
    }
    var date = toDate(value);
    var year = date.getFullYear();
    var firstDateOfFirstWeek = /* @__PURE__ */ new Date(0);
    for (var i2 = year + 1; i2 >= year - 1; i2--) {
      firstDateOfFirstWeek.setFullYear(i2, 0, firstWeekContainsDate);
      firstDateOfFirstWeek.setHours(0, 0, 0, 0);
      firstDateOfFirstWeek = startOfWeek(firstDateOfFirstWeek, firstDayOfWeek);
      if (date.getTime() >= firstDateOfFirstWeek.getTime()) {
        break;
      }
    }
    return firstDateOfFirstWeek;
  }
  function getWeek(value) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$firstDayOfWeek = _ref2.firstDayOfWeek, firstDayOfWeek = _ref2$firstDayOfWeek === void 0 ? 0 : _ref2$firstDayOfWeek, _ref2$firstWeekContai = _ref2.firstWeekContainsDate, firstWeekContainsDate = _ref2$firstWeekContai === void 0 ? 1 : _ref2$firstWeekContai;
    var date = toDate(value);
    var firstDateOfThisWeek = startOfWeek(date, firstDayOfWeek);
    var firstDateOfFirstWeek = startOfWeekYear(date, {
      firstDayOfWeek,
      firstWeekContainsDate
    });
    var diff = firstDateOfThisWeek.getTime() - firstDateOfFirstWeek.getTime();
    return Math.round(diff / (7 * 24 * 3600 * 1e3)) + 1;
  }
  var locale$1 = {
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    weekdaysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    firstDayOfWeek: 0,
    firstWeekContainsDate: 1
  };
  var REGEX_FORMAT = /\[([^\]]+)]|YYYY|YY?|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|Z{1,2}|S{1,3}|w{1,2}|x|X|a|A/g;
  function pad(val) {
    var len = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    var output = "".concat(Math.abs(val));
    var sign = val < 0 ? "-" : "";
    while (output.length < len) {
      output = "0".concat(output);
    }
    return sign + output;
  }
  function getOffset(date) {
    return Math.round(date.getTimezoneOffset() / 15) * 15;
  }
  function formatTimezone(offset2) {
    var delimeter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var sign = offset2 > 0 ? "-" : "+";
    var absOffset = Math.abs(offset2);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    return sign + pad(hours, 2) + delimeter + pad(minutes, 2);
  }
  var meridiem = function meridiem2(h2, _2, isLowercase) {
    var word = h2 < 12 ? "AM" : "PM";
    return isLowercase ? word.toLocaleLowerCase() : word;
  };
  var formatFlags = {
    Y: function Y2(date) {
      var y2 = date.getFullYear();
      return y2 <= 9999 ? "".concat(y2) : "+".concat(y2);
    },
    // Year: 00, 01, ..., 99
    YY: function YY(date) {
      return pad(date.getFullYear(), 4).substr(2);
    },
    // Year: 1900, 1901, ..., 2099
    YYYY: function YYYY(date) {
      return pad(date.getFullYear(), 4);
    },
    // Month: 1, 2, ..., 12
    M: function M2(date) {
      return date.getMonth() + 1;
    },
    // Month: 01, 02, ..., 12
    MM: function MM(date) {
      return pad(date.getMonth() + 1, 2);
    },
    MMM: function MMM(date, locale2) {
      return locale2.monthsShort[date.getMonth()];
    },
    MMMM: function MMMM(date, locale2) {
      return locale2.months[date.getMonth()];
    },
    // Day of month: 1, 2, ..., 31
    D: function D2(date) {
      return date.getDate();
    },
    // Day of month: 01, 02, ..., 31
    DD: function DD(date) {
      return pad(date.getDate(), 2);
    },
    // Hour: 0, 1, ... 23
    H: function H2(date) {
      return date.getHours();
    },
    // Hour: 00, 01, ..., 23
    HH: function HH(date) {
      return pad(date.getHours(), 2);
    },
    // Hour: 1, 2, ..., 12
    h: function h2(date) {
      var hours = date.getHours();
      if (hours === 0) {
        return 12;
      }
      if (hours > 12) {
        return hours % 12;
      }
      return hours;
    },
    // Hour: 01, 02, ..., 12
    hh: function hh() {
      var hours = formatFlags.h.apply(formatFlags, arguments);
      return pad(hours, 2);
    },
    // Minute: 0, 1, ..., 59
    m: function m2(date) {
      return date.getMinutes();
    },
    // Minute: 00, 01, ..., 59
    mm: function mm(date) {
      return pad(date.getMinutes(), 2);
    },
    // Second: 0, 1, ..., 59
    s: function s2(date) {
      return date.getSeconds();
    },
    // Second: 00, 01, ..., 59
    ss: function ss(date) {
      return pad(date.getSeconds(), 2);
    },
    // 1/10 of second: 0, 1, ..., 9
    S: function S2(date) {
      return Math.floor(date.getMilliseconds() / 100);
    },
    // 1/100 of second: 00, 01, ..., 99
    SS: function SS(date) {
      return pad(Math.floor(date.getMilliseconds() / 10), 2);
    },
    // Millisecond: 000, 001, ..., 999
    SSS: function SSS(date) {
      return pad(date.getMilliseconds(), 3);
    },
    // Day of week: 0, 1, ..., 6
    d: function d2(date) {
      return date.getDay();
    },
    // Day of week: 'Su', 'Mo', ..., 'Sa'
    dd: function dd(date, locale2) {
      return locale2.weekdaysMin[date.getDay()];
    },
    // Day of week: 'Sun', 'Mon',..., 'Sat'
    ddd: function ddd(date, locale2) {
      return locale2.weekdaysShort[date.getDay()];
    },
    // Day of week: 'Sunday', 'Monday', ...,'Saturday'
    dddd: function dddd(date, locale2) {
      return locale2.weekdays[date.getDay()];
    },
    // AM, PM
    A: function A2(date, locale2) {
      var meridiemFunc = locale2.meridiem || meridiem;
      return meridiemFunc(date.getHours(), date.getMinutes(), false);
    },
    // am, pm
    a: function a2(date, locale2) {
      var meridiemFunc = locale2.meridiem || meridiem;
      return meridiemFunc(date.getHours(), date.getMinutes(), true);
    },
    // Timezone: -01:00, +00:00, ... +12:00
    Z: function Z2(date) {
      return formatTimezone(getOffset(date), ":");
    },
    // Timezone: -0100, +0000, ... +1200
    ZZ: function ZZ(date) {
      return formatTimezone(getOffset(date));
    },
    // Seconds timestamp: 512969520
    X: function X2(date) {
      return Math.floor(date.getTime() / 1e3);
    },
    // Milliseconds timestamp: 512969520900
    x: function x2(date) {
      return date.getTime();
    },
    w: function w2(date, locale2) {
      return getWeek(date, {
        firstDayOfWeek: locale2.firstDayOfWeek,
        firstWeekContainsDate: locale2.firstWeekContainsDate
      });
    },
    ww: function ww(date, locale2) {
      return pad(formatFlags.w(date, locale2), 2);
    }
  };
  function format(val, str) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var formatStr = str ? String(str) : "YYYY-MM-DDTHH:mm:ss.SSSZ";
    var date = toDate(val);
    if (!isValidDate$1(date)) {
      return "Invalid Date";
    }
    var locale2 = options.locale || locale$1;
    return formatStr.replace(REGEX_FORMAT, function(match, p1) {
      if (p1) {
        return p1;
      }
      if (typeof formatFlags[match] === "function") {
        return "".concat(formatFlags[match](date, locale2));
      }
      return match;
    });
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }
  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i2 = 0, arr2 = new Array(arr.length); i2 < arr.length; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
  }
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(source, true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
  function _iterableToArrayLimit(arr, i2) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _e2 = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i.next()).done); _n2 = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var formattingTokens = /(\[[^\[]*\])|(MM?M?M?|Do|DD?|ddd?d?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|S{1,3}|x|X|ZZ?|.)/g;
  var match1 = /\d/;
  var match2 = /\d\d/;
  var match3 = /\d{3}/;
  var match4 = /\d{4}/;
  var match1to2 = /\d\d?/;
  var matchShortOffset = /[+-]\d\d:?\d\d/;
  var matchSigned = /[+-]?\d+/;
  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
  var YEAR = "year";
  var MONTH = "month";
  var DAY = "day";
  var HOUR = "hour";
  var MINUTE = "minute";
  var SECOND = "second";
  var MILLISECOND = "millisecond";
  var parseFlags = {};
  var addParseFlag = function addParseFlag2(token, regex, callback) {
    var tokens = Array.isArray(token) ? token : [token];
    var func;
    if (typeof callback === "string") {
      func = function func2(input2) {
        var value = parseInt(input2, 10);
        return _defineProperty({}, callback, value);
      };
    } else {
      func = callback;
    }
    tokens.forEach(function(key) {
      parseFlags[key] = [regex, func];
    });
  };
  var escapeStringRegExp = function escapeStringRegExp2(str) {
    return str.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  };
  var matchWordRegExp = function matchWordRegExp2(localeKey) {
    return function(locale2) {
      var array = locale2[localeKey];
      if (!Array.isArray(array)) {
        throw new Error("Locale[".concat(localeKey, "] need an array"));
      }
      return new RegExp(array.map(escapeStringRegExp).join("|"));
    };
  };
  var matchWordCallback = function matchWordCallback2(localeKey, key) {
    return function(input2, locale2) {
      var array = locale2[localeKey];
      if (!Array.isArray(array)) {
        throw new Error("Locale[".concat(localeKey, "] need an array"));
      }
      var index2 = array.indexOf(input2);
      if (index2 < 0) {
        throw new Error("Invalid Word");
      }
      return _defineProperty({}, key, index2);
    };
  };
  addParseFlag("Y", matchSigned, YEAR);
  addParseFlag("YY", match2, function(input2) {
    var year = (/* @__PURE__ */ new Date()).getFullYear();
    var cent = Math.floor(year / 100);
    var value = parseInt(input2, 10);
    value = (value > 68 ? cent - 1 : cent) * 100 + value;
    return _defineProperty({}, YEAR, value);
  });
  addParseFlag("YYYY", match4, YEAR);
  addParseFlag("M", match1to2, function(input2) {
    return _defineProperty({}, MONTH, parseInt(input2, 10) - 1);
  });
  addParseFlag("MM", match2, function(input2) {
    return _defineProperty({}, MONTH, parseInt(input2, 10) - 1);
  });
  addParseFlag("MMM", matchWordRegExp("monthsShort"), matchWordCallback("monthsShort", MONTH));
  addParseFlag("MMMM", matchWordRegExp("months"), matchWordCallback("months", MONTH));
  addParseFlag("D", match1to2, DAY);
  addParseFlag("DD", match2, DAY);
  addParseFlag(["H", "h"], match1to2, HOUR);
  addParseFlag(["HH", "hh"], match2, HOUR);
  addParseFlag("m", match1to2, MINUTE);
  addParseFlag("mm", match2, MINUTE);
  addParseFlag("s", match1to2, SECOND);
  addParseFlag("ss", match2, SECOND);
  addParseFlag("S", match1, function(input2) {
    return _defineProperty({}, MILLISECOND, parseInt(input2, 10) * 100);
  });
  addParseFlag("SS", match2, function(input2) {
    return _defineProperty({}, MILLISECOND, parseInt(input2, 10) * 10);
  });
  addParseFlag("SSS", match3, MILLISECOND);
  function matchMeridiem(locale2) {
    return locale2.meridiemParse || /[ap]\.?m?\.?/i;
  }
  function defaultIsPM(input2) {
    return "".concat(input2).toLowerCase().charAt(0) === "p";
  }
  addParseFlag(["A", "a"], matchMeridiem, function(input2, locale2) {
    var isPM = typeof locale2.isPM === "function" ? locale2.isPM(input2) : defaultIsPM(input2);
    return {
      isPM
    };
  });
  function offsetFromString(str) {
    var _ref8 = str.match(/([+-]|\d\d)/g) || ["-", "0", "0"], _ref9 = _slicedToArray(_ref8, 3), symbol = _ref9[0], hour = _ref9[1], minute = _ref9[2];
    var minutes = parseInt(hour, 10) * 60 + parseInt(minute, 10);
    if (minutes === 0) {
      return 0;
    }
    return symbol === "+" ? -minutes : +minutes;
  }
  addParseFlag(["Z", "ZZ"], matchShortOffset, function(input2) {
    return {
      offset: offsetFromString(input2)
    };
  });
  addParseFlag("x", matchSigned, function(input2) {
    return {
      date: new Date(parseInt(input2, 10))
    };
  });
  addParseFlag("X", matchTimestamp, function(input2) {
    return {
      date: new Date(parseFloat(input2) * 1e3)
    };
  });
  addParseFlag("d", match1, "weekday");
  addParseFlag("dd", matchWordRegExp("weekdaysMin"), matchWordCallback("weekdaysMin", "weekday"));
  addParseFlag("ddd", matchWordRegExp("weekdaysShort"), matchWordCallback("weekdaysShort", "weekday"));
  addParseFlag("dddd", matchWordRegExp("weekdays"), matchWordCallback("weekdays", "weekday"));
  addParseFlag("w", match1to2, "week");
  addParseFlag("ww", match2, "week");
  function to24hour(hour, isPM) {
    if (hour !== void 0 && isPM !== void 0) {
      if (isPM) {
        if (hour < 12) {
          return hour + 12;
        }
      } else if (hour === 12) {
        return 0;
      }
    }
    return hour;
  }
  function getFullInputArray(input2) {
    var backupDate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Date();
    var result = [0, 0, 1, 0, 0, 0, 0];
    var backupArr = [backupDate.getFullYear(), backupDate.getMonth(), backupDate.getDate(), backupDate.getHours(), backupDate.getMinutes(), backupDate.getSeconds(), backupDate.getMilliseconds()];
    var useBackup = true;
    for (var i2 = 0; i2 < 7; i2++) {
      if (input2[i2] === void 0) {
        result[i2] = useBackup ? backupArr[i2] : result[i2];
      } else {
        result[i2] = input2[i2];
        useBackup = false;
      }
    }
    return result;
  }
  function createDate$1(y2, m2, d2, h2, M2, s2, ms) {
    var date;
    if (y2 < 100 && y2 >= 0) {
      date = new Date(y2 + 400, m2, d2, h2, M2, s2, ms);
      if (isFinite(date.getFullYear())) {
        date.setFullYear(y2);
      }
    } else {
      date = new Date(y2, m2, d2, h2, M2, s2, ms);
    }
    return date;
  }
  function createUTCDate() {
    var date;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var y2 = args[0];
    if (y2 < 100 && y2 >= 0) {
      args[0] += 400;
      date = new Date(Date.UTC.apply(Date, args));
      if (isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y2);
      }
    } else {
      date = new Date(Date.UTC.apply(Date, args));
    }
    return date;
  }
  function makeParser(dateString, format2, locale2) {
    var tokens = format2.match(formattingTokens);
    if (!tokens) {
      throw new Error();
    }
    var length = tokens.length;
    var mark = {};
    for (var i2 = 0; i2 < length; i2 += 1) {
      var token = tokens[i2];
      var parseTo = parseFlags[token];
      if (!parseTo) {
        var word = token.replace(/^\[|\]$/g, "");
        if (dateString.indexOf(word) === 0) {
          dateString = dateString.substr(word.length);
        } else {
          throw new Error("not match");
        }
      } else {
        var regex = typeof parseTo[0] === "function" ? parseTo[0](locale2) : parseTo[0];
        var parser = parseTo[1];
        var value = (regex.exec(dateString) || [])[0];
        var obj = parser(value, locale2);
        mark = _objectSpread({}, mark, {}, obj);
        dateString = dateString.replace(value, "");
      }
    }
    return mark;
  }
  function parse(str, format2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    try {
      var _options$locale = options.locale, _locale = _options$locale === void 0 ? locale$1 : _options$locale, _options$backupDate = options.backupDate, backupDate = _options$backupDate === void 0 ? /* @__PURE__ */ new Date() : _options$backupDate;
      var parseResult = makeParser(str, format2, _locale);
      var year = parseResult.year, month = parseResult.month, day = parseResult.day, hour = parseResult.hour, minute = parseResult.minute, second = parseResult.second, millisecond = parseResult.millisecond, isPM = parseResult.isPM, date = parseResult.date, offset2 = parseResult.offset, weekday = parseResult.weekday, week = parseResult.week;
      if (date) {
        return date;
      }
      var inputArray = [year, month, day, hour, minute, second, millisecond];
      inputArray[3] = to24hour(inputArray[3], isPM);
      if (week !== void 0 && month === void 0 && day === void 0) {
        var firstDate = startOfWeekYear(year === void 0 ? backupDate : new Date(year, 3), {
          firstDayOfWeek: _locale.firstDayOfWeek,
          firstWeekContainsDate: _locale.firstWeekContainsDate
        });
        return new Date(firstDate.getTime() + (week - 1) * 7 * 24 * 3600 * 1e3);
      }
      var parsedDate;
      var result = getFullInputArray(inputArray, backupDate);
      if (offset2 !== void 0) {
        result[6] += offset2 * 60 * 1e3;
        parsedDate = createUTCDate.apply(void 0, _toConsumableArray(result));
      } else {
        parsedDate = createDate$1.apply(void 0, _toConsumableArray(result));
      }
      if (weekday !== void 0 && parsedDate.getDay() !== weekday) {
        return /* @__PURE__ */ new Date(NaN);
      }
      return parsedDate;
    } catch (e) {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  var __defProp2 = Object.defineProperty;
  var __defProps2 = Object.defineProperties;
  var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues2 = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    if (__getOwnPropSymbols2)
      for (var prop of __getOwnPropSymbols2(b2)) {
        if (__propIsEnum2.call(b2, prop))
          __defNormalProp2(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
  var __objRest2 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols2)
      for (var prop of __getOwnPropSymbols2(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  const lang = {
    formatLocale: locale$1,
    yearFormat: "YYYY",
    monthFormat: "MMM",
    monthBeforeYear: true
  };
  let defaultLocale = "en";
  const locales = {};
  locales[defaultLocale] = lang;
  function locale(name, object, isLocal = false) {
    if (typeof name !== "string")
      return locales[defaultLocale];
    let l2 = defaultLocale;
    if (locales[name]) {
      l2 = name;
    }
    if (object) {
      locales[name] = object;
      l2 = name;
    }
    if (!isLocal) {
      defaultLocale = l2;
    }
    return locales[name] || locales[defaultLocale];
  }
  function getLocale(name) {
    return locale(name, void 0, true);
  }
  function chunk(arr, size2) {
    if (!Array.isArray(arr)) {
      return [];
    }
    const result = [];
    const len = arr.length;
    let i2 = 0;
    size2 = size2 || len;
    while (i2 < len) {
      result.push(arr.slice(i2, i2 += size2));
    }
    return result;
  }
  function last(array) {
    return Array.isArray(array) ? array[array.length - 1] : void 0;
  }
  function isPlainObject(obj) {
    return Object.prototype.toString.call(obj) === "[object Object]";
  }
  function pick(obj, props) {
    const res = {};
    if (!isPlainObject(obj))
      return res;
    if (!Array.isArray(props)) {
      props = [props];
    }
    props.forEach((prop) => {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        res[prop] = obj[prop];
      }
    });
    return res;
  }
  function mergeDeep(target, source) {
    if (!isPlainObject(target)) {
      return {};
    }
    let result = target;
    if (isPlainObject(source)) {
      Object.keys(source).forEach((key) => {
        let value = source[key];
        const targetValue = target[key];
        if (isPlainObject(value) && isPlainObject(targetValue)) {
          value = mergeDeep(targetValue, value);
        }
        result = __spreadProps2(__spreadValues2({}, result), { [key]: value });
      });
    }
    return result;
  }
  function padNumber(value) {
    const num = parseInt(String(value), 10);
    return num < 10 ? `0${num}` : `${num}`;
  }
  function camelcase(str) {
    const camelizeRE2 = /-(\w)/g;
    return str.replace(camelizeRE2, (_2, c2) => c2 ? c2.toUpperCase() : "");
  }
  const localeContextKey = "datepicker_locale";
  const prefixClassKey = "datepicker_prefixClass";
  const getWeekKey = "datepicker_getWeek";
  function useLocale() {
    return inject(localeContextKey, shallowRef(getLocale()));
  }
  function provideLocale(lang2) {
    const locale2 = computed(() => {
      if (isPlainObject(lang2.value)) {
        return mergeDeep(getLocale(), lang2.value);
      }
      return getLocale(lang2.value);
    });
    provide(localeContextKey, locale2);
    return locale2;
  }
  function providePrefixClass(value) {
    provide(prefixClassKey, value);
  }
  function usePrefixClass() {
    return inject(prefixClassKey, "mx");
  }
  function provideGetWeek(value) {
    provide(getWeekKey, value);
  }
  function useGetWeek() {
    return inject(getWeekKey, getWeek);
  }
  function getPopupElementSize(element) {
    const originalDisplay = element.style.display;
    const originalVisibility = element.style.visibility;
    element.style.display = "block";
    element.style.visibility = "hidden";
    const styles = window.getComputedStyle(element);
    const width = element.offsetWidth + parseInt(styles.marginLeft, 10) + parseInt(styles.marginRight, 10);
    const height = element.offsetHeight + parseInt(styles.marginTop, 10) + parseInt(styles.marginBottom, 10);
    element.style.display = originalDisplay;
    element.style.visibility = originalVisibility;
    return { width, height };
  }
  function getRelativePosition(el, targetWidth, targetHeight, fixed) {
    let left = 0;
    let top = 0;
    let offsetX = 0;
    let offsetY = 0;
    const relativeRect = el.getBoundingClientRect();
    const dw = document.documentElement.clientWidth;
    const dh = document.documentElement.clientHeight;
    if (fixed) {
      offsetX = window.pageXOffset + relativeRect.left;
      offsetY = window.pageYOffset + relativeRect.top;
    }
    if (dw - relativeRect.left < targetWidth && relativeRect.right < targetWidth) {
      left = offsetX - relativeRect.left + 1;
    } else if (relativeRect.left + relativeRect.width / 2 <= dw / 2) {
      left = offsetX;
    } else {
      left = offsetX + relativeRect.width - targetWidth;
    }
    if (relativeRect.top <= targetHeight && dh - relativeRect.bottom <= targetHeight) {
      top = offsetY + dh - relativeRect.top - targetHeight;
    } else if (relativeRect.top + relativeRect.height / 2 <= dh / 2) {
      top = offsetY + relativeRect.height;
    } else {
      top = offsetY - targetHeight;
    }
    return { left: `${left}px`, top: `${top}px` };
  }
  function getScrollParent(node, until = document.body) {
    if (!node || node === until) {
      return null;
    }
    const style = (value, prop) => getComputedStyle(value, null).getPropertyValue(prop);
    const regex = /(auto|scroll)/;
    const scroll = regex.test(style(node, "overflow") + style(node, "overflow-y") + style(node, "overflow-x"));
    return scroll ? node : getScrollParent(node.parentElement, until);
  }
  let scrollBarWidth;
  function getScrollbarWidth() {
    if (typeof window === "undefined")
      return 0;
    if (scrollBarWidth !== void 0)
      return scrollBarWidth;
    const outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.overflow = "scroll";
    outer.style.width = "100px";
    outer.style.position = "absolute";
    outer.style.top = "-9999px";
    document.body.appendChild(outer);
    const inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);
    scrollBarWidth = outer.offsetWidth - inner.offsetWidth;
    outer.parentNode.removeChild(outer);
    return scrollBarWidth;
  }
  const mousedownEvent = "ontouchend" in document ? "touchstart" : "mousedown";
  function rafThrottle(fn) {
    let isRunning = false;
    return function fnBinfRaf(...args) {
      if (isRunning)
        return;
      isRunning = true;
      requestAnimationFrame(() => {
        isRunning = false;
        fn.apply(this, args);
      });
    };
  }
  function defineVueComponent(setup, props) {
    return { setup, name: setup.name, props };
  }
  function withDefault(props, defaultProps) {
    const result = new Proxy(props, {
      get(target, key) {
        const value = target[key];
        if (value !== void 0) {
          return value;
        }
        return defaultProps[key];
      }
    });
    return result;
  }
  const keys = () => (props) => props;
  const resolveProps = (obj, booleanKeys2) => {
    const props = {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        const camelizeKey = camelcase(key);
        let value = obj[key];
        if (booleanKeys2.indexOf(camelizeKey) !== -1 && value === "") {
          value = true;
        }
        props[camelizeKey] = value;
      }
    }
    return props;
  };
  function Popup(originalProps, {
    slots
  }) {
    const props = withDefault(originalProps, {
      appendToBody: true
    });
    const prefixClass = usePrefixClass();
    const popup = ref(null);
    const position = ref({
      left: "",
      top: ""
    });
    const displayPopup = () => {
      if (!props.visible || !popup.value)
        return;
      const relativeElement = props.getRelativeElement();
      if (!relativeElement)
        return;
      const {
        width,
        height
      } = getPopupElementSize(popup.value);
      position.value = getRelativePosition(relativeElement, width, height, props.appendToBody);
    };
    watchEffect(displayPopup, {
      flush: "post"
    });
    watchEffect((onInvalidate) => {
      const relativeElement = props.getRelativeElement();
      if (!relativeElement)
        return;
      const scrollElement = getScrollParent(relativeElement) || window;
      const handleMove = rafThrottle(displayPopup);
      scrollElement.addEventListener("scroll", handleMove);
      window.addEventListener("resize", handleMove);
      onInvalidate(() => {
        scrollElement.removeEventListener("scroll", handleMove);
        window.removeEventListener("resize", handleMove);
      });
    }, {
      flush: "post"
    });
    const handleClickOutside = (evt) => {
      if (!props.visible)
        return;
      const target = evt.target;
      const el = popup.value;
      const relativeElement = props.getRelativeElement();
      if (el && !el.contains(target) && relativeElement && !relativeElement.contains(target)) {
        props.onClickOutside(evt);
      }
    };
    watchEffect((onInvalidate) => {
      document.addEventListener(mousedownEvent, handleClickOutside);
      onInvalidate(() => {
        document.removeEventListener(mousedownEvent, handleClickOutside);
      });
    });
    return () => {
      return createVNode(Teleport, {
        "to": "body",
        "disabled": !props.appendToBody
      }, {
        default: () => [createVNode(Transition, {
          "name": `${prefixClass}-zoom-in-down`
        }, {
          default: () => {
            var _a2;
            return [props.visible && createVNode("div", {
              "ref": popup,
              "class": `${prefixClass}-datepicker-main ${prefixClass}-datepicker-popup ${props.className}`,
              "style": [__spreadValues2({
                position: "absolute"
              }, position.value), props.style || {}]
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])];
          }
        })]
      });
    };
  }
  const popupProps = keys()(["style", "className", "visible", "appendToBody", "onClickOutside", "getRelativeElement"]);
  var Popup$1$1 = defineVueComponent(Popup, popupProps);
  const _hoisted_1$2$1 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    width: "1em",
    height: "1em"
  };
  const _hoisted_2$2$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M940.218 107.055H730.764v-60.51H665.6v60.51H363.055v-60.51H297.89v60.51H83.78c-18.617 0-32.581 13.963-32.581 32.581v805.237c0 18.618 13.964 32.582 32.582 32.582h861.09c18.619 0 32.583-13.964 32.583-32.582V139.636c-4.655-18.618-18.619-32.581-37.237-32.581zm-642.327 65.163v60.51h65.164v-60.51h307.2v60.51h65.163v-60.51h176.873v204.8H116.364v-204.8H297.89zM116.364 912.291V442.18H912.29v470.11H116.364z" }, null, -1);
  const _hoisted_3$2$1 = [
    _hoisted_2$2$1
  ];
  function render$2(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$2$1, _hoisted_3$2$1);
  }
  const _hoisted_1$1$1 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    width: "1em",
    height: "1em"
  };
  const _hoisted_2$1$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M810.005 274.005 572.011 512l237.994 237.995-60.01 60.01L512 572.011 274.005 810.005l-60.01-60.01L451.989 512 213.995 274.005l60.01-60.01L512 451.989l237.995-237.994z" }, null, -1);
  const _hoisted_3$1$1 = [
    _hoisted_2$1$1
  ];
  function render$1(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$1$1, _hoisted_3$1$1);
  }
  const _hoisted_1$I = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: "1em",
    height: "1em"
  };
  const _hoisted_2$D = /* @__PURE__ */ createBaseVNode("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  }, null, -1);
  const _hoisted_3$C = /* @__PURE__ */ createBaseVNode("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" }, null, -1);
  const _hoisted_4$B = /* @__PURE__ */ createBaseVNode("path", { d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z" }, null, -1);
  const _hoisted_5$z = [
    _hoisted_2$D,
    _hoisted_3$C,
    _hoisted_4$B
  ];
  function render(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$I, _hoisted_5$z);
  }
  function createDate(y2, M2 = 0, d2 = 1, h2 = 0, m2 = 0, s2 = 0, ms = 0) {
    const date = new Date(y2, M2, d2, h2, m2, s2, ms);
    if (y2 < 100 && y2 >= 0) {
      date.setFullYear(y2);
    }
    return date;
  }
  function isValidDate(date) {
    return date instanceof Date && !isNaN(date.getTime());
  }
  function isValidRangeDate(dates) {
    return Array.isArray(dates) && dates.length === 2 && dates.every(isValidDate) && dates[0] <= dates[1];
  }
  function isValidDates(dates) {
    return Array.isArray(dates) && dates.every(isValidDate);
  }
  function getValidDate(...values) {
    if (values[0] !== void 0 && values[0] !== null) {
      const date = new Date(values[0]);
      if (isValidDate(date)) {
        return date;
      }
    }
    const rest = values.slice(1);
    if (rest.length) {
      return getValidDate(...rest);
    }
    return /* @__PURE__ */ new Date();
  }
  function startOfYear(value) {
    const date = new Date(value);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  function startOfMonth(value) {
    const date = new Date(value);
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  function startOfDay(value) {
    const date = new Date(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  function getCalendar({
    firstDayOfWeek,
    year,
    month
  }) {
    const arr = [];
    const calendar = createDate(year, month, 0);
    const lastDayInLastMonth = calendar.getDate();
    const firstDayInLastMonth = lastDayInLastMonth - (calendar.getDay() + 7 - firstDayOfWeek) % 7;
    for (let i2 = firstDayInLastMonth; i2 <= lastDayInLastMonth; i2++) {
      arr.push(createDate(year, month, i2 - lastDayInLastMonth));
    }
    calendar.setMonth(month + 1, 0);
    const lastDayInCurrentMonth = calendar.getDate();
    for (let i2 = 1; i2 <= lastDayInCurrentMonth; i2++) {
      arr.push(createDate(year, month, i2));
    }
    const lastMonthLength = lastDayInLastMonth - firstDayInLastMonth + 1;
    const nextMonthLength = 6 * 7 - lastMonthLength - lastDayInCurrentMonth;
    for (let i2 = 1; i2 <= nextMonthLength; i2++) {
      arr.push(createDate(year, month, lastDayInCurrentMonth + i2));
    }
    return arr;
  }
  function setMonth(dirtyDate, dirtyMonth) {
    const date = new Date(dirtyDate);
    const month = typeof dirtyMonth === "function" ? dirtyMonth(date.getMonth()) : Number(dirtyMonth);
    const year = date.getFullYear();
    const daysInMonth = createDate(year, month + 1, 0).getDate();
    const day = date.getDate();
    date.setMonth(month, Math.min(day, daysInMonth));
    return date;
  }
  function setYear(dirtyDate, dirtyYear) {
    const date = new Date(dirtyDate);
    const year = typeof dirtyYear === "function" ? dirtyYear(date.getFullYear()) : dirtyYear;
    date.setFullYear(year);
    return date;
  }
  function diffCalendarMonths(dirtyDateLeft, dirtyDateRight) {
    const dateRight = new Date(dirtyDateRight);
    const dateLeft = new Date(dirtyDateLeft);
    const yearDiff = dateRight.getFullYear() - dateLeft.getFullYear();
    const monthDiff = dateRight.getMonth() - dateLeft.getMonth();
    return yearDiff * 12 + monthDiff;
  }
  function assignTime(target, source) {
    const date = new Date(target);
    const time = new Date(source);
    date.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
    return date;
  }
  function PickerInput(originalProps, {
    slots
  }) {
    const props = withDefault(originalProps, {
      editable: true,
      disabled: false,
      clearable: true,
      range: false,
      multiple: false
    });
    const prefixClass = usePrefixClass();
    const userInput = ref(null);
    const innerSeparator = computed(() => {
      return props.separator || (props.range ? " ~ " : ",");
    });
    const isValidValue = (value) => {
      if (props.range) {
        return isValidRangeDate(value);
      }
      if (props.multiple) {
        return isValidDates(value);
      }
      return isValidDate(value);
    };
    const isDisabledValue = (value) => {
      if (Array.isArray(value)) {
        return value.some((v2) => props.disabledDate(v2));
      }
      return props.disabledDate(value);
    };
    const text = computed(() => {
      if (userInput.value !== null) {
        return userInput.value;
      }
      if (typeof props.renderInputText === "function") {
        return props.renderInputText(props.value);
      }
      if (!isValidValue(props.value)) {
        return "";
      }
      if (Array.isArray(props.value)) {
        return props.value.map((v2) => props.formatDate(v2)).join(innerSeparator.value);
      }
      return props.formatDate(props.value);
    });
    const handleClear = (evt) => {
      var _a2;
      if (evt) {
        evt.stopPropagation();
      }
      props.onChange(props.range ? [null, null] : null);
      (_a2 = props.onClear) == null ? void 0 : _a2.call(props);
    };
    const handleChange = () => {
      var _a2;
      if (!props.editable || userInput.value === null)
        return;
      const text2 = userInput.value.trim();
      userInput.value = null;
      if (text2 === "") {
        handleClear();
        return;
      }
      let date;
      if (props.range) {
        let arr = text2.split(innerSeparator.value);
        if (arr.length !== 2) {
          arr = text2.split(innerSeparator.value.trim());
        }
        date = arr.map((v2) => props.parseDate(v2.trim()));
      } else if (props.multiple) {
        date = text2.split(innerSeparator.value).map((v2) => props.parseDate(v2.trim()));
      } else {
        date = props.parseDate(text2);
      }
      if (isValidValue(date) && !isDisabledValue(date)) {
        props.onChange(date);
      } else {
        (_a2 = props.onInputError) == null ? void 0 : _a2.call(props, text2);
      }
    };
    const handleInput = (evt) => {
      userInput.value = typeof evt === "string" ? evt : evt.target.value;
    };
    const handleKeydown = (evt) => {
      const {
        keyCode
      } = evt;
      if (keyCode === 9) {
        props.onBlur();
      } else if (keyCode === 13) {
        handleChange();
      }
    };
    return () => {
      var _a2, _b2, _c;
      const showClearIcon = !props.disabled && props.clearable && text.value;
      const inputProps = __spreadProps2(__spreadValues2({
        name: "date",
        type: "text",
        autocomplete: "off",
        value: text.value,
        class: props.inputClass || `${prefixClass}-input`,
        readonly: !props.editable,
        disabled: props.disabled,
        placeholder: props.placeholder
      }, props.inputAttr), {
        onFocus: props.onFocus,
        onKeydown: handleKeydown,
        onInput: handleInput,
        onChange: handleChange
      });
      return createVNode("div", {
        "class": `${prefixClass}-input-wrapper`,
        "onClick": props.onClick
      }, [((_a2 = slots.input) == null ? void 0 : _a2.call(slots, inputProps)) || createVNode("input", inputProps, null), showClearIcon ? createVNode("i", {
        "class": `${prefixClass}-icon-clear`,
        "onClick": handleClear
      }, [((_b2 = slots["icon-clear"]) == null ? void 0 : _b2.call(slots)) || createVNode(render$1, null, null)]) : null, createVNode("i", {
        "class": `${prefixClass}-icon-calendar`
      }, [((_c = slots["icon-calendar"]) == null ? void 0 : _c.call(slots)) || createVNode(render$2, null, null)])]);
    };
  }
  const pickerInputBaseProps = keys()(["placeholder", "editable", "disabled", "clearable", "inputClass", "inputAttr", "range", "multiple", "separator", "renderInputText", "onInputError", "onClear"]);
  const pickerInputProps = keys()(["value", "formatDate", "parseDate", "disabledDate", "onChange", "onFocus", "onBlur", "onClick", ...pickerInputBaseProps]);
  var PickerInput$1 = defineVueComponent(PickerInput, pickerInputProps);
  function Picker(originalProps, {
    slots
  }) {
    var _a2;
    const props = withDefault(originalProps, {
      prefixClass: "mx",
      valueType: "date",
      format: "YYYY-MM-DD",
      type: "date",
      disabledDate: () => false,
      disabledTime: () => false,
      confirmText: "OK"
    });
    providePrefixClass(props.prefixClass);
    provideGetWeek(((_a2 = props.formatter) == null ? void 0 : _a2.getWeek) || getWeek);
    const locale2 = provideLocale(toRef(originalProps, "lang"));
    const container = ref();
    const getContainer = () => container.value;
    const defaultOpen = ref(false);
    const popupVisible = computed(() => {
      return !props.disabled && (typeof props.open === "boolean" ? props.open : defaultOpen.value);
    });
    const openPopup = () => {
      var _a22, _b2;
      if (props.disabled || popupVisible.value)
        return;
      defaultOpen.value = true;
      (_a22 = props["onUpdate:open"]) == null ? void 0 : _a22.call(props, true);
      (_b2 = props.onOpen) == null ? void 0 : _b2.call(props);
    };
    const closePopup = () => {
      var _a22, _b2;
      if (!popupVisible.value)
        return;
      defaultOpen.value = false;
      (_a22 = props["onUpdate:open"]) == null ? void 0 : _a22.call(props, false);
      (_b2 = props.onClose) == null ? void 0 : _b2.call(props);
    };
    const formatDate = (date, fmt) => {
      fmt = fmt || props.format;
      if (isPlainObject(props.formatter) && typeof props.formatter.stringify === "function") {
        return props.formatter.stringify(date, fmt);
      }
      return format(date, fmt, {
        locale: locale2.value.formatLocale
      });
    };
    const parseDate = (value, fmt) => {
      fmt = fmt || props.format;
      if (isPlainObject(props.formatter) && typeof props.formatter.parse === "function") {
        return props.formatter.parse(value, fmt);
      }
      const backupDate = /* @__PURE__ */ new Date();
      return parse(value, fmt, {
        locale: locale2.value.formatLocale,
        backupDate
      });
    };
    const value2date = (value) => {
      switch (props.valueType) {
        case "date":
          return value instanceof Date ? new Date(value.getTime()) : /* @__PURE__ */ new Date(NaN);
        case "timestamp":
          return typeof value === "number" ? new Date(value) : /* @__PURE__ */ new Date(NaN);
        case "format":
          return typeof value === "string" ? parseDate(value) : /* @__PURE__ */ new Date(NaN);
        default:
          return typeof value === "string" ? parseDate(value, props.valueType) : /* @__PURE__ */ new Date(NaN);
      }
    };
    const date2value = (date) => {
      if (!isValidDate(date))
        return null;
      switch (props.valueType) {
        case "date":
          return date;
        case "timestamp":
          return date.getTime();
        case "format":
          return formatDate(date);
        default:
          return formatDate(date, props.valueType);
      }
    };
    const innerValue = computed(() => {
      const value = props.value;
      if (props.range) {
        return (Array.isArray(value) ? value.slice(0, 2) : [null, null]).map(value2date);
      }
      if (props.multiple) {
        return (Array.isArray(value) ? value : []).map(value2date);
      }
      return value2date(value);
    });
    const emitValue = (date, type, close = true) => {
      var _a22, _b2;
      const value = Array.isArray(date) ? date.map(date2value) : date2value(date);
      (_a22 = props["onUpdate:value"]) == null ? void 0 : _a22.call(props, value);
      (_b2 = props.onChange) == null ? void 0 : _b2.call(props, value, type);
      if (close) {
        closePopup();
      }
      return value;
    };
    const currentValue = ref(/* @__PURE__ */ new Date());
    watchEffect(() => {
      if (popupVisible.value) {
        currentValue.value = innerValue.value;
      }
    });
    const handleSelect = (val, type) => {
      if (props.confirm) {
        currentValue.value = val;
      } else {
        emitValue(val, type, !props.multiple && (type === props.type || type === "time"));
      }
    };
    const handleConfirm = () => {
      var _a22;
      const value = emitValue(currentValue.value);
      (_a22 = props.onConfirm) == null ? void 0 : _a22.call(props, value);
    };
    const disabledDateTime = (v2) => {
      return props.disabledDate(v2) || props.disabledTime(v2);
    };
    const renderSidebar = (slotProps) => {
      var _a22;
      const {
        prefixClass
      } = props;
      return createVNode("div", {
        "class": `${prefixClass}-datepicker-sidebar`
      }, [(_a22 = slots.sidebar) == null ? void 0 : _a22.call(slots, slotProps), (props.shortcuts || []).map((v2, i2) => createVNode("button", {
        "key": i2,
        "data-index": i2,
        "type": "button",
        "class": `${prefixClass}-btn ${prefixClass}-btn-text ${prefixClass}-btn-shortcut`,
        "onClick": () => {
          var _a3;
          const date = (_a3 = v2.onClick) == null ? void 0 : _a3.call(v2);
          if (date) {
            emitValue(date);
          }
        }
      }, [v2.text]))]);
    };
    return () => {
      var _a22, _b2;
      const {
        prefixClass,
        disabled,
        confirm,
        range: range2,
        popupClass,
        popupStyle,
        appendToBody
      } = props;
      const slotProps = {
        value: currentValue.value,
        ["onUpdate:value"]: handleSelect,
        emit: emitValue
      };
      const header = slots.header && createVNode("div", {
        "class": `${prefixClass}-datepicker-header`
      }, [slots.header(slotProps)]);
      const footer = (slots.footer || confirm) && createVNode("div", {
        "class": `${prefixClass}-datepicker-footer`
      }, [(_a22 = slots.footer) == null ? void 0 : _a22.call(slots, slotProps), confirm && createVNode("button", {
        "type": "button",
        "class": `${prefixClass}-btn ${prefixClass}-datepicker-btn-confirm`,
        "onClick": handleConfirm
      }, [props.confirmText])]);
      const content = (_b2 = slots.content) == null ? void 0 : _b2.call(slots, slotProps);
      const sidedar = (slots.sidebar || props.shortcuts) && renderSidebar(slotProps);
      return createVNode("div", {
        "ref": container,
        "class": {
          [`${prefixClass}-datepicker`]: true,
          [`${prefixClass}-datepicker-range`]: range2,
          disabled
        }
      }, [createVNode(PickerInput$1, __spreadProps2(__spreadValues2({}, pick(props, pickerInputBaseProps)), {
        "value": innerValue.value,
        "formatDate": formatDate,
        "parseDate": parseDate,
        "disabledDate": disabledDateTime,
        "onChange": emitValue,
        "onClick": openPopup,
        "onFocus": openPopup,
        "onBlur": closePopup
      }), pick(slots, ["icon-calendar", "icon-clear", "input"])), createVNode(Popup$1$1, {
        "className": popupClass,
        "style": popupStyle,
        "visible": popupVisible.value,
        "appendToBody": appendToBody,
        "getRelativeElement": getContainer,
        "onClickOutside": closePopup
      }, {
        default: () => [sidedar, createVNode("div", {
          "class": `${prefixClass}-datepicker-content`
        }, [header, content, footer])]
      })]);
    };
  }
  const pickerbaseProps = keys()(["value", "valueType", "type", "format", "formatter", "lang", "prefixClass", "appendToBody", "open", "popupClass", "popupStyle", "confirm", "confirmText", "shortcuts", "disabledDate", "disabledTime", "onOpen", "onClose", "onConfirm", "onChange", "onUpdate:open", "onUpdate:value"]);
  const pickerProps = [...pickerbaseProps, ...pickerInputBaseProps];
  var Picker$1 = defineVueComponent(Picker, pickerProps);
  function ButtonIcon(_a2) {
    var _b2 = _a2, {
      value
    } = _b2, rest = __objRest2(_b2, [
      "value"
    ]);
    const prefixClass = usePrefixClass();
    return createVNode("button", __spreadProps2(__spreadValues2({}, rest), {
      "type": "button",
      "class": `${prefixClass}-btn ${prefixClass}-btn-text ${prefixClass}-btn-icon-${value}`
    }), [createVNode("i", {
      "class": `${prefixClass}-icon-${value}`
    }, null)]);
  }
  function TableHeader({
    type,
    calendar,
    onUpdateCalendar
  }, {
    slots
  }) {
    var _a2;
    const prefixClass = usePrefixClass();
    const lastMonth = () => {
      onUpdateCalendar(setMonth(calendar, (v2) => v2 - 1));
    };
    const nextMonth = () => {
      onUpdateCalendar(setMonth(calendar, (v2) => v2 + 1));
    };
    const lastYear = () => {
      onUpdateCalendar(setYear(calendar, (v2) => v2 - 1));
    };
    const nextYear = () => {
      onUpdateCalendar(setYear(calendar, (v2) => v2 + 1));
    };
    const lastDecade = () => {
      onUpdateCalendar(setYear(calendar, (v2) => v2 - 10));
    };
    const nextDecade = () => {
      onUpdateCalendar(setYear(calendar, (v2) => v2 + 10));
    };
    return createVNode("div", {
      "class": `${prefixClass}-calendar-header`
    }, [createVNode(ButtonIcon, {
      "value": "double-left",
      "onClick": type === "year" ? lastDecade : lastYear
    }, null), type === "date" && createVNode(ButtonIcon, {
      "value": "left",
      "onClick": lastMonth
    }, null), createVNode(ButtonIcon, {
      "value": "double-right",
      "onClick": type === "year" ? nextDecade : nextYear
    }, null), type === "date" && createVNode(ButtonIcon, {
      "value": "right",
      "onClick": nextMonth
    }, null), createVNode("span", {
      "class": `${prefixClass}-calendar-header-label`
    }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]);
  }
  function TableDate({
    calendar,
    isWeekMode,
    showWeekNumber,
    titleFormat,
    getWeekActive,
    getCellClasses,
    onSelect,
    onUpdatePanel,
    onUpdateCalendar,
    onDateMouseEnter,
    onDateMouseLeave
  }) {
    const prefixClass = usePrefixClass();
    const getWeekNumber = useGetWeek();
    const locale2 = useLocale().value;
    const {
      yearFormat,
      monthBeforeYear,
      monthFormat = "MMM",
      formatLocale
    } = locale2;
    const firstDayOfWeek = formatLocale.firstDayOfWeek || 0;
    let days = locale2.days || formatLocale.weekdaysMin;
    days = days.concat(days).slice(firstDayOfWeek, firstDayOfWeek + 7);
    const year = calendar.getFullYear();
    const month = calendar.getMonth();
    const dates = chunk(getCalendar({
      firstDayOfWeek,
      year,
      month
    }), 7);
    const formatDate = (date, fmt) => {
      return format(date, fmt, {
        locale: locale2.formatLocale
      });
    };
    const handlePanelChange = (panel) => {
      onUpdatePanel(panel);
    };
    const getCellDate = (el) => {
      const index2 = el.getAttribute("data-index");
      const [row, col] = index2.split(",").map((v2) => parseInt(v2, 10));
      const value = dates[row][col];
      return new Date(value);
    };
    const handleCellClick = (evt) => {
      onSelect(getCellDate(evt.currentTarget));
    };
    const handleMouseEnter = (evt) => {
      if (onDateMouseEnter) {
        onDateMouseEnter(getCellDate(evt.currentTarget));
      }
    };
    const handleMouseLeave = (evt) => {
      if (onDateMouseLeave) {
        onDateMouseLeave(getCellDate(evt.currentTarget));
      }
    };
    const yearLabel = createVNode("button", {
      "type": "button",
      "class": `${prefixClass}-btn ${prefixClass}-btn-text ${prefixClass}-btn-current-year`,
      "onClick": () => handlePanelChange("year")
    }, [formatDate(calendar, yearFormat)]);
    const monthLabel = createVNode("button", {
      "type": "button",
      "class": `${prefixClass}-btn ${prefixClass}-btn-text ${prefixClass}-btn-current-month`,
      "onClick": () => handlePanelChange("month")
    }, [formatDate(calendar, monthFormat)]);
    showWeekNumber = typeof showWeekNumber === "boolean" ? showWeekNumber : isWeekMode;
    return createVNode("div", {
      "class": [`${prefixClass}-calendar ${prefixClass}-calendar-panel-date`, {
        [`${prefixClass}-calendar-week-mode`]: isWeekMode
      }]
    }, [createVNode(TableHeader, {
      "type": "date",
      "calendar": calendar,
      "onUpdateCalendar": onUpdateCalendar
    }, {
      default: () => [monthBeforeYear ? [monthLabel, yearLabel] : [yearLabel, monthLabel]]
    }), createVNode("div", {
      "class": `${prefixClass}-calendar-content`
    }, [createVNode("table", {
      "class": `${prefixClass}-table ${prefixClass}-table-date`
    }, [createVNode("thead", null, [createVNode("tr", null, [showWeekNumber && createVNode("th", {
      "class": `${prefixClass}-week-number-header`
    }, null), days.map((day) => createVNode("th", {
      "key": day
    }, [day]))])]), createVNode("tbody", null, [dates.map((row, i2) => createVNode("tr", {
      "key": i2,
      "class": [`${prefixClass}-date-row`, {
        [`${prefixClass}-active-week`]: getWeekActive(row)
      }]
    }, [showWeekNumber && createVNode("td", {
      "class": `${prefixClass}-week-number`,
      "data-index": `${i2},0`,
      "onClick": handleCellClick
    }, [createVNode("div", null, [getWeekNumber(row[0])])]), row.map((cell, j2) => createVNode("td", {
      "key": j2,
      "class": ["cell", getCellClasses(cell)],
      "title": formatDate(cell, titleFormat),
      "data-index": `${i2},${j2}`,
      "onClick": handleCellClick,
      "onMouseenter": handleMouseEnter,
      "onMouseleave": handleMouseLeave
    }, [createVNode("div", null, [cell.getDate()])]))]))])])])]);
  }
  function TableMonth({
    calendar,
    getCellClasses,
    onSelect,
    onUpdateCalendar,
    onUpdatePanel
  }) {
    const prefixClass = usePrefixClass();
    const locale2 = useLocale().value;
    const months = locale2.months || locale2.formatLocale.monthsShort;
    const getDate = (month) => {
      return createDate(calendar.getFullYear(), month);
    };
    const handleClick = (evt) => {
      const target = evt.currentTarget;
      const month = target.getAttribute("data-month");
      onSelect(getDate(parseInt(month, 10)));
    };
    return createVNode("div", {
      "class": `${prefixClass}-calendar ${prefixClass}-calendar-panel-month`
    }, [createVNode(TableHeader, {
      "type": "month",
      "calendar": calendar,
      "onUpdateCalendar": onUpdateCalendar
    }, {
      default: () => [createVNode("button", {
        "type": "button",
        "class": `${prefixClass}-btn ${prefixClass}-btn-text ${prefixClass}-btn-current-year`,
        "onClick": () => onUpdatePanel("year")
      }, [calendar.getFullYear()])]
    }), createVNode("div", {
      "class": `${prefixClass}-calendar-content`
    }, [createVNode("table", {
      "class": `${prefixClass}-table ${prefixClass}-table-month`
    }, [chunk(months, 3).map((row, i2) => createVNode("tr", {
      "key": i2
    }, [row.map((cell, j2) => {
      const month = i2 * 3 + j2;
      return createVNode("td", {
        "key": j2,
        "class": ["cell", getCellClasses(getDate(month))],
        "data-month": month,
        "onClick": handleClick
      }, [createVNode("div", null, [cell])]);
    })]))])])]);
  }
  const getDefaultYears = (calendar) => {
    const firstYear = Math.floor(calendar.getFullYear() / 10) * 10;
    const years = [];
    for (let i2 = 0; i2 < 10; i2++) {
      years.push(firstYear + i2);
    }
    return chunk(years, 2);
  };
  function TableYear({
    calendar,
    getCellClasses = () => [],
    getYearPanel = getDefaultYears,
    onSelect,
    onUpdateCalendar
  }) {
    const prefixClass = usePrefixClass();
    const getDate = (year) => {
      return createDate(year, 0);
    };
    const handleClick = (evt) => {
      const target = evt.currentTarget;
      const year = target.getAttribute("data-year");
      onSelect(getDate(parseInt(year, 10)));
    };
    const years = getYearPanel(new Date(calendar));
    const firstYear = years[0][0];
    const lastYear = last(last(years));
    return createVNode("div", {
      "class": `${prefixClass}-calendar ${prefixClass}-calendar-panel-year`
    }, [createVNode(TableHeader, {
      "type": "year",
      "calendar": calendar,
      "onUpdateCalendar": onUpdateCalendar
    }, {
      default: () => [createVNode("span", null, [firstYear]), createVNode("span", {
        "class": `${prefixClass}-calendar-decade-separator`
      }, null), createVNode("span", null, [lastYear])]
    }), createVNode("div", {
      "class": `${prefixClass}-calendar-content`
    }, [createVNode("table", {
      "class": `${prefixClass}-table ${prefixClass}-table-year`
    }, [years.map((row, i2) => createVNode("tr", {
      "key": i2
    }, [row.map((cell, j2) => createVNode("td", {
      "key": j2,
      "class": ["cell", getCellClasses(getDate(cell))],
      "data-year": cell,
      "onClick": handleClick
    }, [createVNode("div", null, [cell])]))]))])])]);
  }
  function Calendar(originalProps) {
    const props = withDefault(originalProps, {
      defaultValue: startOfDay(/* @__PURE__ */ new Date()),
      type: "date",
      disabledDate: () => false,
      getClasses: () => [],
      titleFormat: "YYYY-MM-DD"
    });
    const innerValue = computed(() => {
      const value = Array.isArray(props.value) ? props.value : [props.value];
      return value.filter(isValidDate).map((v2) => {
        if (props.type === "year")
          return startOfYear(v2);
        if (props.type === "month")
          return startOfMonth(v2);
        return startOfDay(v2);
      });
    });
    const innerCalendar = ref(/* @__PURE__ */ new Date());
    watchEffect(() => {
      let calendarDate = props.calendar;
      if (!isValidDate(calendarDate)) {
        const {
          length
        } = innerValue.value;
        calendarDate = getValidDate(length > 0 ? innerValue.value[length - 1] : props.defaultValue);
      }
      innerCalendar.value = startOfMonth(calendarDate);
    });
    const handleCalendarChange = (calendar) => {
      var _a2;
      innerCalendar.value = calendar;
      (_a2 = props.onCalendarChange) == null ? void 0 : _a2.call(props, calendar);
    };
    const panel = ref("date");
    watchEffect(() => {
      const panels = ["date", "month", "year"];
      const index2 = Math.max(panels.indexOf(props.type), panels.indexOf(props.defaultPanel));
      panel.value = index2 !== -1 ? panels[index2] : "date";
    });
    const handelPanelChange = (value) => {
      var _a2;
      const oldPanel = panel.value;
      panel.value = value;
      (_a2 = props.onPanelChange) == null ? void 0 : _a2.call(props, value, oldPanel);
    };
    const isDisabled = (date) => {
      return props.disabledDate(new Date(date), innerValue.value);
    };
    const emitDate = (date, type) => {
      var _a2, _b2, _c;
      if (!isDisabled(date)) {
        (_a2 = props.onPick) == null ? void 0 : _a2.call(props, date);
        if (props.multiple === true) {
          const nextDates = innerValue.value.filter((v2) => v2.getTime() !== date.getTime());
          if (nextDates.length === innerValue.value.length) {
            nextDates.push(date);
          }
          (_b2 = props["onUpdate:value"]) == null ? void 0 : _b2.call(props, nextDates, type);
        } else {
          (_c = props["onUpdate:value"]) == null ? void 0 : _c.call(props, date, type);
        }
      }
    };
    const handleSelectDate = (date) => {
      emitDate(date, props.type === "week" ? "week" : "date");
    };
    const handleSelectYear = (date) => {
      if (props.type === "year") {
        emitDate(date, "year");
      } else {
        handleCalendarChange(date);
        handelPanelChange("month");
        if (props.partialUpdate && innerValue.value.length === 1) {
          const value = setYear(innerValue.value[0], date.getFullYear());
          emitDate(value, "year");
        }
      }
    };
    const handleSelectMonth = (date) => {
      if (props.type === "month") {
        emitDate(date, "month");
      } else {
        handleCalendarChange(date);
        handelPanelChange("date");
        if (props.partialUpdate && innerValue.value.length === 1) {
          const value = setMonth(setYear(innerValue.value[0], date.getFullYear()), date.getMonth());
          emitDate(value, "month");
        }
      }
    };
    const getCellClasses = (cellDate, classes = []) => {
      if (isDisabled(cellDate)) {
        classes.push("disabled");
      } else if (innerValue.value.some((v2) => v2.getTime() === cellDate.getTime())) {
        classes.push("active");
      }
      return classes.concat(props.getClasses(cellDate, innerValue.value, classes.join(" ")));
    };
    const getDateClasses = (cellDate) => {
      const notCurrentMonth = cellDate.getMonth() !== innerCalendar.value.getMonth();
      const classes = [];
      if (cellDate.getTime() === (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0)) {
        classes.push("today");
      }
      if (notCurrentMonth) {
        classes.push("not-current-month");
      }
      return getCellClasses(cellDate, classes);
    };
    const getMonthClasses = (cellDate) => {
      if (props.type !== "month") {
        return innerCalendar.value.getMonth() === cellDate.getMonth() ? "active" : "";
      }
      return getCellClasses(cellDate);
    };
    const getYearClasses = (cellDate) => {
      if (props.type !== "year") {
        return innerCalendar.value.getFullYear() === cellDate.getFullYear() ? "active" : "";
      }
      return getCellClasses(cellDate);
    };
    const getWeekActive = (row) => {
      if (props.type !== "week")
        return false;
      const start = row[0].getTime();
      const end = row[6].getTime();
      return innerValue.value.some((v2) => {
        const time = v2.getTime();
        return time >= start && time <= end;
      });
    };
    return () => {
      if (panel.value === "year") {
        return createVNode(TableYear, {
          "calendar": innerCalendar.value,
          "getCellClasses": getYearClasses,
          "getYearPanel": props.getYearPanel,
          "onSelect": handleSelectYear,
          "onUpdateCalendar": handleCalendarChange
        }, null);
      }
      if (panel.value === "month") {
        return createVNode(TableMonth, {
          "calendar": innerCalendar.value,
          "getCellClasses": getMonthClasses,
          "onSelect": handleSelectMonth,
          "onUpdatePanel": handelPanelChange,
          "onUpdateCalendar": handleCalendarChange
        }, null);
      }
      return createVNode(TableDate, {
        "isWeekMode": props.type === "week",
        "showWeekNumber": props.showWeekNumber,
        "titleFormat": props.titleFormat,
        "calendar": innerCalendar.value,
        "getCellClasses": getDateClasses,
        "getWeekActive": getWeekActive,
        "onSelect": handleSelectDate,
        "onUpdatePanel": handelPanelChange,
        "onUpdateCalendar": handleCalendarChange,
        "onDateMouseEnter": props.onDateMouseEnter,
        "onDateMouseLeave": props.onDateMouseLeave
      }, null);
    };
  }
  const calendarProps = keys()(["type", "value", "defaultValue", "defaultPanel", "disabledDate", "getClasses", "calendar", "multiple", "partialUpdate", "showWeekNumber", "titleFormat", "getYearPanel", "onDateMouseEnter", "onDateMouseLeave", "onCalendarChange", "onPanelChange", "onUpdate:value", "onPick"]);
  var Calendar$1 = defineVueComponent(Calendar, calendarProps);
  const inRange = (date, range2) => {
    const value = date.getTime();
    let [min2, max2] = range2.map((v2) => v2.getTime());
    if (min2 > max2) {
      [min2, max2] = [max2, min2];
    }
    return value > min2 && value < max2;
  };
  function CalendarRange(originalProps) {
    const props = withDefault(originalProps, {
      defaultValue: /* @__PURE__ */ new Date(),
      type: "date"
    });
    const prefixClass = usePrefixClass();
    const defaultValues = computed(() => {
      let values = Array.isArray(props.defaultValue) ? props.defaultValue : [props.defaultValue, props.defaultValue];
      values = values.map((v2) => startOfDay(v2));
      if (isValidRangeDate(values)) {
        return values;
      }
      return [/* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()].map((v2) => startOfDay(v2));
    });
    const innerValue = ref([/* @__PURE__ */ new Date(NaN), /* @__PURE__ */ new Date(NaN)]);
    watchEffect(() => {
      if (isValidRangeDate(props.value)) {
        innerValue.value = props.value;
      }
    });
    const handlePick = (date, type) => {
      var _a2;
      const [startValue, endValue] = innerValue.value;
      if (isValidDate(startValue) && !isValidDate(endValue)) {
        if (startValue.getTime() > date.getTime()) {
          innerValue.value = [date, startValue];
        } else {
          innerValue.value = [startValue, date];
        }
        (_a2 = props["onUpdate:value"]) == null ? void 0 : _a2.call(props, innerValue.value, type);
      } else {
        innerValue.value = [date, /* @__PURE__ */ new Date(NaN)];
      }
    };
    const defaultCalendars = ref([/* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()]);
    const calendars = computed(() => {
      return isValidRangeDate(props.calendar) ? props.calendar : defaultCalendars.value;
    });
    const calendarMinDiff = computed(() => {
      if (props.type === "year")
        return 10 * 12;
      if (props.type === "month")
        return 1 * 12;
      return 1;
    });
    const updateCalendars = (dates, index2) => {
      var _a2;
      const diff = diffCalendarMonths(dates[0], dates[1]);
      const gap = calendarMinDiff.value - diff;
      if (gap > 0) {
        const anotherIndex = index2 === 1 ? 0 : 1;
        dates[anotherIndex] = setMonth(dates[anotherIndex], (v2) => v2 + (anotherIndex === 0 ? -gap : gap));
      }
      defaultCalendars.value = dates;
      (_a2 = props.onCalendarChange) == null ? void 0 : _a2.call(props, dates, index2);
    };
    const updateCalendarStart = (date) => {
      updateCalendars([date, calendars.value[1]], 0);
    };
    const updateCalendarEnd = (date) => {
      updateCalendars([calendars.value[0], date], 1);
    };
    watchEffect(() => {
      const dates = isValidRangeDate(props.value) ? props.value : defaultValues.value;
      updateCalendars(dates.slice(0, 2));
    });
    const hoveredValue = ref(null);
    const handleMouseEnter = (v2) => hoveredValue.value = v2;
    const handleMouseLeave = () => hoveredValue.value = null;
    const getRangeClasses = (cellDate, currentDates, classnames) => {
      const outerClasses = props.getClasses ? props.getClasses(cellDate, currentDates, classnames) : [];
      const classes = Array.isArray(outerClasses) ? outerClasses : [outerClasses];
      if (/disabled|active/.test(classnames))
        return classes;
      if (currentDates.length === 2 && inRange(cellDate, currentDates)) {
        classes.push("in-range");
      }
      if (currentDates.length === 1 && hoveredValue.value && inRange(cellDate, [currentDates[0], hoveredValue.value])) {
        return classes.concat("hover-in-range");
      }
      return classes;
    };
    return () => {
      const calendarRange = calendars.value.map((calendar, index2) => {
        const calendarProps2 = __spreadProps2(__spreadValues2({}, props), {
          calendar,
          value: innerValue.value,
          defaultValue: defaultValues.value[index2],
          getClasses: getRangeClasses,
          partialUpdate: false,
          multiple: false,
          ["onUpdate:value"]: handlePick,
          onCalendarChange: index2 === 0 ? updateCalendarStart : updateCalendarEnd,
          onDateMouseLeave: handleMouseLeave,
          onDateMouseEnter: handleMouseEnter
        });
        return createVNode(Calendar$1, calendarProps2, null);
      });
      return createVNode("div", {
        "class": `${prefixClass}-calendar-range`
      }, [calendarRange]);
    };
  }
  const calendarRangeProps = calendarProps;
  var CalendarRange$1 = defineVueComponent(CalendarRange, calendarRangeProps);
  const ScrollbarVertical = /* @__PURE__ */ defineComponent({
    setup(props, {
      slots
    }) {
      const prefixClass = usePrefixClass();
      const wrapper = ref();
      const thumbHeight = ref("");
      const thumbTop = ref("");
      const getThumbHeight = () => {
        if (!wrapper.value)
          return;
        const el = wrapper.value;
        const heightPercentage = el.clientHeight * 100 / el.scrollHeight;
        thumbHeight.value = heightPercentage < 100 ? `${heightPercentage}%` : "";
      };
      onMounted(getThumbHeight);
      const scrollbarWidth = getScrollbarWidth();
      const handleScroll = (evt) => {
        const el = evt.currentTarget;
        const {
          scrollHeight,
          scrollTop
        } = el;
        thumbTop.value = `${scrollTop * 100 / scrollHeight}%`;
      };
      let draggable = false;
      let prevY = 0;
      const handleDragstart = (evt) => {
        evt.stopImmediatePropagation();
        const el = evt.currentTarget;
        const {
          offsetTop
        } = el;
        draggable = true;
        prevY = evt.clientY - offsetTop;
      };
      const handleDraging = (evt) => {
        if (!draggable || !wrapper.value)
          return;
        const {
          clientY
        } = evt;
        const {
          scrollHeight,
          clientHeight
        } = wrapper.value;
        const offsetY = clientY - prevY;
        const top = offsetY * scrollHeight / clientHeight;
        wrapper.value.scrollTop = top;
      };
      const handleDragend = () => {
        draggable = false;
      };
      onMounted(() => {
        document.addEventListener("mousemove", handleDraging);
        document.addEventListener("mouseup", handleDragend);
      });
      onUnmounted(() => {
        document.addEventListener("mousemove", handleDraging);
        document.addEventListener("mouseup", handleDragend);
      });
      return () => {
        var _a2;
        return createVNode("div", {
          "class": `${prefixClass}-scrollbar`,
          "style": {
            position: "relative",
            overflow: "hidden"
          }
        }, [createVNode("div", {
          "ref": wrapper,
          "class": `${prefixClass}-scrollbar-wrap`,
          "style": {
            marginRight: `-${scrollbarWidth}px`
          },
          "onScroll": handleScroll
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), createVNode("div", {
          "class": `${prefixClass}-scrollbar-track`
        }, [createVNode("div", {
          "class": `${prefixClass}-scrollbar-thumb`,
          "style": {
            height: thumbHeight.value,
            top: thumbTop.value
          },
          "onMousedown": handleDragstart
        }, null)])]);
      };
    }
  });
  function Columns({
    options,
    getClasses,
    onSelect
  }) {
    const prefixClass = usePrefixClass();
    const handleSelect = (evt) => {
      const target = evt.target;
      const currentTarget = evt.currentTarget;
      if (target.tagName.toUpperCase() !== "LI")
        return;
      const type = currentTarget.getAttribute("data-type");
      const col = parseInt(currentTarget.getAttribute("data-index"), 10);
      const index2 = parseInt(target.getAttribute("data-index"), 10);
      const value = options[col].list[index2].value;
      onSelect(value, type);
    };
    return createVNode("div", {
      "class": `${prefixClass}-time-columns`
    }, [options.map((col, i2) => createVNode(ScrollbarVertical, {
      "key": col.type,
      "class": `${prefixClass}-time-column`
    }, {
      default: () => [createVNode("ul", {
        "class": `${prefixClass}-time-list`,
        "data-index": i2,
        "data-type": col.type,
        "onClick": handleSelect
      }, [col.list.map((item, j2) => createVNode("li", {
        "key": item.text,
        "data-index": j2,
        "class": [`${prefixClass}-time-item`, getClasses(item.value, col.type)]
      }, [item.text]))])]
    }))]);
  }
  function _isSlot(s2) {
    return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
  }
  function FixedList(props) {
    let _slot;
    const prefixClass = usePrefixClass();
    return createVNode(ScrollbarVertical, null, _isSlot(_slot = props.options.map((item) => createVNode("div", {
      "key": item.text,
      "class": [`${prefixClass}-time-option`, props.getClasses(item.value, "time")],
      "onClick": () => props.onSelect(item.value, "time")
    }, [item.text]))) ? _slot : {
      default: () => [_slot]
    });
  }
  function generateList({
    length,
    step = 1,
    options
  }) {
    if (Array.isArray(options)) {
      return options.filter((v2) => v2 >= 0 && v2 < length);
    }
    if (step <= 0) {
      step = 1;
    }
    const arr = [];
    for (let i2 = 0; i2 < length; i2 += step) {
      arr.push(i2);
    }
    return arr;
  }
  function getColumnOptions(date, options) {
    let { showHour, showMinute, showSecond, use12h } = options;
    const format2 = options.format || "HH:mm:ss";
    showHour = typeof showHour === "boolean" ? showHour : /[HhKk]/.test(format2);
    showMinute = typeof showMinute === "boolean" ? showMinute : /m/.test(format2);
    showSecond = typeof showSecond === "boolean" ? showSecond : /s/.test(format2);
    use12h = typeof use12h === "boolean" ? use12h : /a/i.test(format2);
    const columns = [];
    const isPM = use12h && date.getHours() >= 12;
    if (showHour) {
      columns.push({
        type: "hour",
        list: generateList({
          length: use12h ? 12 : 24,
          step: options.hourStep,
          options: options.hourOptions
        }).map((num) => {
          const text = num === 0 && use12h ? "12" : padNumber(num);
          const value = new Date(date);
          value.setHours(isPM ? num + 12 : num);
          return { value, text };
        })
      });
    }
    if (showMinute) {
      columns.push({
        type: "minute",
        list: generateList({
          length: 60,
          step: options.minuteStep,
          options: options.minuteOptions
        }).map((num) => {
          const value = new Date(date);
          value.setMinutes(num);
          return { value, text: padNumber(num) };
        })
      });
    }
    if (showSecond) {
      columns.push({
        type: "second",
        list: generateList({
          length: 60,
          step: options.secondStep,
          options: options.secondOptions
        }).map((num) => {
          const value = new Date(date);
          value.setSeconds(num);
          return { value, text: padNumber(num) };
        })
      });
    }
    if (use12h) {
      columns.push({
        type: "ampm",
        list: ["AM", "PM"].map((text, i2) => {
          const value = new Date(date);
          value.setHours(value.getHours() % 12 + i2 * 12);
          return { text, value };
        })
      });
    }
    return columns;
  }
  function parseOption(time = "") {
    const values = time.split(":");
    if (values.length >= 2) {
      const hours = parseInt(values[0], 10);
      const minutes = parseInt(values[1], 10);
      return {
        hours,
        minutes
      };
    }
    return null;
  }
  function getFixedOptions({
    date,
    option,
    format: format2,
    formatDate
  }) {
    const result = [];
    if (typeof option === "function") {
      return option() || [];
    }
    const start = parseOption(option.start);
    const end = parseOption(option.end);
    const step = parseOption(option.step);
    const fmt = option.format || format2;
    if (start && end && step) {
      const startMinutes = start.minutes + start.hours * 60;
      const endMinutes = end.minutes + end.hours * 60;
      const stepMinutes = step.minutes + step.hours * 60;
      const len = Math.floor((endMinutes - startMinutes) / stepMinutes);
      for (let i2 = 0; i2 <= len; i2++) {
        const timeMinutes = startMinutes + i2 * stepMinutes;
        const hours = Math.floor(timeMinutes / 60);
        const minutes = timeMinutes % 60;
        const value = new Date(date);
        value.setHours(hours, minutes, 0);
        result.push({
          value,
          text: formatDate(value, fmt)
        });
      }
    }
    return result;
  }
  const scrollTo = (element, to2, duration = 0) => {
    if (duration <= 0) {
      requestAnimationFrame(() => {
        element.scrollTop = to2;
      });
      return;
    }
    const difference = to2 - element.scrollTop;
    const tick = difference / duration * 10;
    requestAnimationFrame(() => {
      const scrollTop = element.scrollTop + tick;
      if (scrollTop >= to2) {
        element.scrollTop = to2;
        return;
      }
      element.scrollTop = scrollTop;
      scrollTo(element, to2, duration - 10);
    });
  };
  function TimePanel(originalProps) {
    const props = withDefault(originalProps, {
      defaultValue: startOfDay(/* @__PURE__ */ new Date()),
      format: "HH:mm:ss",
      timeTitleFormat: "YYYY-MM-DD",
      disabledTime: () => false,
      scrollDuration: 100
    });
    const prefixClass = usePrefixClass();
    const locale2 = useLocale();
    const formatDate = (date, fmt) => {
      return format(date, fmt, {
        locale: locale2.value.formatLocale
      });
    };
    const innerValue = ref(/* @__PURE__ */ new Date());
    watchEffect(() => {
      innerValue.value = getValidDate(props.value, props.defaultValue);
    });
    const isDisabledTimes = (value) => {
      if (Array.isArray(value)) {
        return value.every((v2) => props.disabledTime(new Date(v2)));
      }
      return props.disabledTime(new Date(value));
    };
    const isDisabledHour = (date) => {
      const value = new Date(date);
      return isDisabledTimes([value.getTime(), value.setMinutes(0, 0, 0), value.setMinutes(59, 59, 999)]);
    };
    const isDisabledMinute = (date) => {
      const value = new Date(date);
      return isDisabledTimes([value.getTime(), value.setSeconds(0, 0), value.setSeconds(59, 999)]);
    };
    const isDisabledAMPM = (date) => {
      const value = new Date(date);
      const minHour = value.getHours() < 12 ? 0 : 12;
      const maxHour = minHour + 11;
      return isDisabledTimes([value.getTime(), value.setHours(minHour, 0, 0, 0), value.setHours(maxHour, 59, 59, 999)]);
    };
    const isDisabled = (date, type) => {
      if (type === "hour") {
        return isDisabledHour(date);
      }
      if (type === "minute") {
        return isDisabledMinute(date);
      }
      if (type === "ampm") {
        return isDisabledAMPM(date);
      }
      return isDisabledTimes(date);
    };
    const handleSelect = (value, type) => {
      var _a2;
      if (!isDisabled(value, type)) {
        const date = new Date(value);
        innerValue.value = date;
        if (!isDisabledTimes(date)) {
          (_a2 = props["onUpdate:value"]) == null ? void 0 : _a2.call(props, date, type);
        }
      }
    };
    const getClasses = (cellDate, type) => {
      if (isDisabled(cellDate, type)) {
        return "disabled";
      }
      if (cellDate.getTime() === innerValue.value.getTime()) {
        return "active";
      }
      return "";
    };
    const container = ref();
    const scrollToSelected = (duration) => {
      if (!container.value)
        return;
      const elements = container.value.querySelectorAll(".active");
      for (let i2 = 0; i2 < elements.length; i2++) {
        const element = elements[i2];
        const scrollElement = getScrollParent(element, container.value);
        if (scrollElement) {
          const to2 = element.offsetTop;
          scrollTo(scrollElement, to2, duration);
        }
      }
    };
    onMounted(() => scrollToSelected(0));
    watch(innerValue, () => scrollToSelected(props.scrollDuration), {
      flush: "post"
    });
    return () => {
      let content;
      if (props.timePickerOptions) {
        content = createVNode(FixedList, {
          "onSelect": handleSelect,
          "getClasses": getClasses,
          "options": getFixedOptions({
            date: innerValue.value,
            format: props.format,
            option: props.timePickerOptions,
            formatDate
          })
        }, null);
      } else {
        content = createVNode(Columns, {
          "options": getColumnOptions(innerValue.value, props),
          "onSelect": handleSelect,
          "getClasses": getClasses
        }, null);
      }
      return createVNode("div", {
        "class": `${prefixClass}-time`,
        "ref": container
      }, [props.showTimeHeader && createVNode("div", {
        "class": `${prefixClass}-time-header`
      }, [createVNode("button", {
        "type": "button",
        "class": `${prefixClass}-btn ${prefixClass}-btn-text ${prefixClass}-time-header-title`,
        "onClick": props.onClickTitle
      }, [formatDate(innerValue.value, props.timeTitleFormat)])]), createVNode("div", {
        "class": `${prefixClass}-time-content`
      }, [content])]);
    };
  }
  const timePanelProps = keys()(["value", "defaultValue", "format", "timeTitleFormat", "showTimeHeader", "disabledTime", "timePickerOptions", "hourOptions", "minuteOptions", "secondOptions", "hourStep", "minuteStep", "secondStep", "showHour", "showMinute", "showSecond", "use12h", "scrollDuration", "onClickTitle", "onUpdate:value"]);
  var TimePanel$1 = defineVueComponent(TimePanel, timePanelProps);
  function TimeRange(originalProps) {
    const props = withDefault(originalProps, {
      defaultValue: startOfDay(/* @__PURE__ */ new Date()),
      disabledTime: () => false
    });
    const prefixClass = usePrefixClass();
    const innerValue = ref([/* @__PURE__ */ new Date(NaN), /* @__PURE__ */ new Date(NaN)]);
    watchEffect(() => {
      if (isValidRangeDate(props.value)) {
        innerValue.value = props.value;
      } else {
        innerValue.value = [/* @__PURE__ */ new Date(NaN), /* @__PURE__ */ new Date(NaN)];
      }
    });
    const emitChange = (type, index2) => {
      var _a2;
      (_a2 = props["onUpdate:value"]) == null ? void 0 : _a2.call(props, innerValue.value, type === "time" ? "time-range" : type, index2);
    };
    const handleSelectStart = (date, type) => {
      innerValue.value[0] = date;
      if (!(innerValue.value[1].getTime() >= date.getTime())) {
        innerValue.value[1] = date;
      }
      emitChange(type, 0);
    };
    const handleSelectEnd = (date, type) => {
      innerValue.value[1] = date;
      if (!(innerValue.value[0].getTime() <= date.getTime())) {
        innerValue.value[0] = date;
      }
      emitChange(type, 1);
    };
    const disabledStartTime = (date) => {
      return props.disabledTime(date, 0);
    };
    const disabledEndTime = (date) => {
      return date.getTime() < innerValue.value[0].getTime() || props.disabledTime(date, 1);
    };
    return () => {
      const defaultValues = Array.isArray(props.defaultValue) ? props.defaultValue : [props.defaultValue, props.defaultValue];
      return createVNode("div", {
        "class": `${prefixClass}-time-range`
      }, [createVNode(TimePanel$1, __spreadProps2(__spreadValues2({}, props), {
        ["onUpdate:value"]: handleSelectStart,
        "value": innerValue.value[0],
        "defaultValue": defaultValues[0],
        "disabledTime": disabledStartTime
      }), null), createVNode(TimePanel$1, __spreadProps2(__spreadValues2({}, props), {
        ["onUpdate:value"]: handleSelectEnd,
        "value": innerValue.value[1],
        "defaultValue": defaultValues[1],
        "disabledTime": disabledEndTime
      }), null)]);
    };
  }
  const timeRangeProps = timePanelProps;
  var TimeRange$1 = defineVueComponent(TimeRange, timeRangeProps);
  function useTimePanelVisible(props) {
    const defaultTimeVisible = ref(false);
    const closeTimePanel = () => {
      var _a2;
      defaultTimeVisible.value = false;
      (_a2 = props.onShowTimePanelChange) == null ? void 0 : _a2.call(props, false);
    };
    const openTimePanel = () => {
      var _a2;
      defaultTimeVisible.value = true;
      (_a2 = props.onShowTimePanelChange) == null ? void 0 : _a2.call(props, true);
    };
    const timeVisible = computed(() => {
      return typeof props.showTimePanel === "boolean" ? props.showTimePanel : defaultTimeVisible.value;
    });
    return { timeVisible, openTimePanel, closeTimePanel };
  }
  function DateTime(originalProps) {
    const props = withDefault(originalProps, {
      disabledTime: () => false,
      defaultValue: startOfDay(/* @__PURE__ */ new Date())
    });
    const currentValue = ref(props.value);
    watchEffect(() => {
      currentValue.value = props.value;
    });
    const {
      openTimePanel,
      closeTimePanel,
      timeVisible
    } = useTimePanelVisible(props);
    const handleSelect = (date, type) => {
      var _a2;
      if (type === "date") {
        openTimePanel();
      }
      let datetime = assignTime(date, getValidDate(props.value, props.defaultValue));
      if (props.disabledTime(new Date(datetime))) {
        datetime = assignTime(date, props.defaultValue);
        if (props.disabledTime(new Date(datetime))) {
          currentValue.value = datetime;
          return;
        }
      }
      (_a2 = props["onUpdate:value"]) == null ? void 0 : _a2.call(props, datetime, type);
    };
    return () => {
      const prefixClass = usePrefixClass();
      const calendarProp = __spreadProps2(__spreadValues2({}, pick(props, calendarProps)), {
        multiple: false,
        type: "date",
        value: currentValue.value,
        ["onUpdate:value"]: handleSelect
      });
      const timeProps = __spreadProps2(__spreadValues2({}, pick(props, timePanelProps)), {
        showTimeHeader: true,
        value: currentValue.value,
        ["onUpdate:value"]: props["onUpdate:value"],
        onClickTitle: closeTimePanel
      });
      return createVNode("div", {
        "class": `${prefixClass}-date-time`
      }, [createVNode(Calendar$1, calendarProp, null), timeVisible.value && createVNode(TimePanel$1, timeProps, null)]);
    };
  }
  const datetimeBaseProps = keys()(["showTimePanel", "onShowTimePanelChange"]);
  const datetimeProps = [...datetimeBaseProps, ...calendarProps, ...timePanelProps];
  var DateTime$1 = defineVueComponent(DateTime, datetimeProps);
  function DateTimeRange(originalProps) {
    const props = withDefault(originalProps, {
      defaultValue: startOfDay(/* @__PURE__ */ new Date()),
      disabledTime: () => false
    });
    const currentValue = ref(props.value);
    watchEffect(() => {
      currentValue.value = props.value;
    });
    const {
      openTimePanel,
      closeTimePanel,
      timeVisible
    } = useTimePanelVisible(props);
    const handleSelect = (dates, type) => {
      var _a2;
      if (type === "date") {
        openTimePanel();
      }
      const defaultValues = Array.isArray(props.defaultValue) ? props.defaultValue : [props.defaultValue, props.defaultValue];
      let datetimes = dates.map((date, i2) => {
        const time = isValidRangeDate(props.value) ? props.value[i2] : defaultValues[i2];
        return assignTime(date, time);
      });
      if (datetimes[1].getTime() < datetimes[0].getTime()) {
        datetimes = [datetimes[0], datetimes[0]];
      }
      if (datetimes.some(props.disabledTime)) {
        datetimes = dates.map((date, i2) => assignTime(date, defaultValues[i2]));
        if (datetimes.some(props.disabledTime)) {
          currentValue.value = datetimes;
          return;
        }
      }
      (_a2 = props["onUpdate:value"]) == null ? void 0 : _a2.call(props, datetimes, type);
    };
    return () => {
      const prefixClass = usePrefixClass();
      const calendarProp = __spreadProps2(__spreadValues2({}, pick(props, calendarRangeProps)), {
        type: "date",
        value: currentValue.value,
        ["onUpdate:value"]: handleSelect
      });
      const timeProps = __spreadProps2(__spreadValues2({}, pick(props, timeRangeProps)), {
        showTimeHeader: true,
        value: currentValue.value,
        ["onUpdate:value"]: props["onUpdate:value"],
        onClickTitle: closeTimePanel
      });
      return createVNode("div", {
        "class": `${prefixClass}-date-time-range`
      }, [createVNode(CalendarRange$1, calendarProp, null), timeVisible.value && createVNode(TimeRange$1, timeProps, null)]);
    };
  }
  const datetimeRangeProps = [...datetimeBaseProps, ...timeRangeProps, ...calendarRangeProps];
  var DateTimeRange$1 = defineVueComponent(DateTimeRange, datetimeRangeProps);
  const booleanKeys = keys()(["range", "open", "appendToBody", "clearable", "confirm", "disabled", "editable", "multiple", "partialUpdate", "showHour", "showMinute", "showSecond", "showTimeHeader", "showTimePanel", "showWeekNumber", "use12h"]);
  const formatMap = {
    date: "YYYY-MM-DD",
    datetime: "YYYY-MM-DD HH:mm:ss",
    year: "YYYY",
    month: "YYYY-MM",
    time: "HH:mm:ss",
    week: "w"
  };
  function DatePicker(originalProps, {
    slots
  }) {
    const type = originalProps.type || "date";
    const format2 = originalProps.format || formatMap[type] || formatMap.date;
    const props = __spreadProps2(__spreadValues2({}, resolveProps(originalProps, booleanKeys)), {
      type,
      format: format2
    });
    return createVNode(Picker$1, pick(props, Picker$1.props), __spreadValues2({
      content: (slotProps) => {
        if (props.range) {
          const Content = type === "time" ? TimeRange$1 : type === "datetime" ? DateTimeRange$1 : CalendarRange$1;
          return h$4(Content, pick(__spreadValues2(__spreadValues2({}, props), slotProps), Content.props));
        } else {
          const Content = type === "time" ? TimePanel$1 : type === "datetime" ? DateTime$1 : Calendar$1;
          return h$4(Content, pick(__spreadValues2(__spreadValues2({}, props), slotProps), Content.props));
        }
      },
      ["icon-calendar"]: () => type === "time" ? createVNode(render, null, null) : createVNode(render$2, null, null)
    }, slots));
  }
  const api = {
    locale,
    install: (app) => {
      app.component("DatePicker", DatePicker);
    }
  };
  var index = Object.assign(DatePicker, api, {
    Calendar: Calendar$1,
    CalendarRange: CalendarRange$1,
    TimePanel: TimePanel$1,
    TimeRange: TimeRange$1,
    DateTime: DateTime$1,
    DateTimeRange: DateTimeRange$1
  });
  function safeJsonParse(jsonString, returnValue = {}) {
    if (!jsonString || "" === jsonString || "[]" === jsonString || "{}" === jsonString) {
      return returnValue;
    }
    try {
      return JSON.parse(jsonString);
    } catch (e) {
      console.error("JSON Parse error - " + e + "; jsonString - " + jsonString);
      return returnValue;
    }
  }
  const useGameStore = /* @__PURE__ */ defineStore("game", () => {
    var _a2;
    const l10n = window.anwpMatch.l10n;
    const finished = ref(window.anwpMatch.finished || "0");
    const special_status = ref(window.anwpMatch.special_status || "");
    const datetime = ref(window.anwpMatch.datetime || "");
    const stadium = ref(Number(window.anwpMatch.stadium) || "");
    const attendance = ref(Number(window.anwpMatch.attendance) || "");
    const aggtext = ref(window.anwpMatch.aggtext || "");
    const competitionType = ref(window.anwpMatch.competitionType || "round-robin");
    const matchWeek = ref(Number(window.anwpMatch.matchWeek) || "");
    const extraTime = ref(window.anwpMatch.extraTime || "");
    const penalty = ref(window.anwpMatch.penalty || "");
    const stats = reactive(window.anwpMatch.stats || {});
    const tempPlayers = ref(safeJsonParse(window.anwpMatch.tempPlayers, []) || []);
    const tempPlayerID = ref(1);
    const matchEvents = ref(safeJsonParse(window.anwpMatch.matchEvents, []) || []);
    const customNumbers = reactive(safeJsonParse(window.anwpMatch.customNumbers, {}) || {});
    const missingPlayers = ref(safeJsonParse(window.anwpMatch.missingPlayers, []) || []);
    const referee = ref(null);
    const assistant_1 = ref(null);
    const assistant_2 = ref(null);
    const referee_fourth = ref(null);
    const additional_referees = ref([]);
    const coachHome = ref("");
    const coachAway = ref("");
    const captainHome = reactive({});
    const captainAway = reactive({});
    const tempReferees = reactive(window.anwpMatch.tempReferees || {
      "referee": {},
      "assistant_1": {},
      "assistant_2": {},
      "referee_fourth": {},
      "additional_referees": {}
    });
    const tempCoach = reactive({
      "coachHome": {},
      "coachAway": {}
    });
    const clubHome = reactive(Object.assign({}, {
      "id": "",
      "title": "",
      "logo": ""
    }, window.anwpMatch.clubHome));
    const clubAway = reactive(Object.assign({}, {
      "id": "",
      "title": "",
      "logo": ""
    }, window.anwpMatch.clubAway));
    const tempPlayer = reactive({
      name: "",
      position: "",
      country: ""
    });
    const appConfig = {
      specialStatuses: window.anwpMatch.optionsSpecialStatus || {},
      stadiums: window.anwpMatch.optionsStadium || [],
      stadiumDefault: window.anwpMatch.stadiumDefault || "",
      players: window.anwpMatch.optionsPlayers || [],
      default_photo: window.anwpMatch.default_photo || [],
      clubsMap: window.anwpMatch.optionsClubMap || [],
      classPosition: {
        g: "anwp-bg-blue-400",
        d: "anwp-bg-green-400",
        m: "anwp-bg-orange-400",
        f: "anwp-bg-red-400"
      },
      positions: window.anwpMatch.optionsPositions,
      countries: window.anwpMatch.optionsCountries,
      squadHomeNumbers: window.anwpMatch.squadHomeNumbers,
      squadAwayNumbers: window.anwpMatch.squadAwayNumbers,
      squadHomeOrder: window.anwpMatch.squadHomeOrder,
      squadAwayOrder: window.anwpMatch.squadAwayOrder,
      events: [
        { label: l10n.goal.toLowerCase(), value: "goal" },
        { label: l10n.card.toLowerCase(), value: "card" },
        { label: l10n.substitute.toLowerCase(), value: "substitute" },
        { label: l10n.missed_penalty.toLowerCase(), value: "missed_penalty" },
        { label: l10n.penalty_shootout.toLowerCase(), value: "penalty_shootout" }
      ],
      referees: window.anwpMatch.optionsReferees,
      coaches: window.anwpMatch.optionsStaff,
      staffHome: window.anwpMatch.staffHomeAll,
      staffAway: window.anwpMatch.staffAwayAll
    };
    const active = reactive({
      playersHomeStart: [],
      playersHomeSubs: [],
      playersHomeMissing: [],
      playersAwayStart: [],
      playersAwaySubs: [],
      playersAwayMissing: []
    });
    ["playersHomeStart", "playersHomeSubs", "playersAwayStart", "playersAwaySubs"].forEach((pl) => {
      if (window.anwpMatch[pl]) {
        window.anwpMatch[pl].split(",").forEach((playerID) => {
          let playerObj = {};
          if (playerID.toString().includes("temp__")) {
            let tempPlayerObj = tempPlayers.value.find((p2) => playerID === p2.id);
            if (tempPlayerObj) {
              playerObj = {
                id: tempPlayerObj.id,
                birthdate: "",
                club_id: tempPlayerObj.club_id ? Number(tempPlayerObj.club_id) : "",
                country: tempPlayerObj.country,
                position: tempPlayerObj.position,
                photo: "",
                name: tempPlayerObj.name
              };
            }
          } else {
            playerObj = appConfig.players.find((pl2) => pl2.id === Number(playerID));
          }
          if (playerObj) {
            active[pl].push(playerObj);
          }
        });
      }
    });
    if (tempPlayers.value.length) {
      tempPlayerID.value = Math.max.apply(Math, tempPlayers.value.map((o2) => Number(o2.id.substring(6)))) + 1;
    }
    const captainHomeId = window.anwpMatch.captainHomeId;
    const captainAwayId = window.anwpMatch.captainAwayId;
    if (captainHomeId.toString().includes("temp__")) {
      let tempPlayerObj = tempPlayers.value.find((p2) => captainHomeId === p2.id);
      if (tempPlayerObj) {
        Object.assign(captainHome, {
          id: tempPlayerObj.id,
          birthdate: "",
          club_id: tempPlayerObj.club_id ? Number(tempPlayerObj.club_id) : "",
          country: tempPlayerObj.country,
          position: tempPlayerObj.position,
          photo: "",
          name: tempPlayerObj.name
        });
      }
    } else if (captainHomeId) {
      let playerObj = appConfig.players.find((p2) => Number(p2.id) === Number(captainHomeId));
      if (playerObj) {
        Object.assign(captainHome, playerObj);
      }
    }
    if (captainAwayId.toString().includes("temp__")) {
      let tempPlayerObj = tempPlayers.value.find((p2) => captainAwayId === p2.id);
      if (tempPlayerObj) {
        Object.assign(captainAway, {
          id: tempPlayerObj.id,
          birthdate: "",
          club_id: tempPlayerObj.club_id ? Number(tempPlayerObj.club_id) : "",
          country: tempPlayerObj.country,
          position: tempPlayerObj.position,
          photo: "",
          name: tempPlayerObj.name
        });
      }
    } else if (captainAwayId) {
      let playerObj = appConfig.players.find((p2) => Number(p2.id) === Number(captainAwayId));
      if (playerObj) {
        Object.assign(captainAway, playerObj);
      }
    }
    if (window.anwpMatch.tempCoach) {
      Object.assign(tempCoach, window.anwpMatch.tempCoach);
    }
    if (window.anwpMatch.coachHome && (appConfig.coaches.find((o2) => Number(o2.id) === Number(window.anwpMatch.coachHome)) || "temp" === window.anwpMatch.coachHome)) {
      coachHome.value = "temp" === window.anwpMatch.coachHome ? tempCoach.coachHome : appConfig.coaches.find((o2) => Number(o2.id) === Number(window.anwpMatch.coachHome));
    }
    if (window.anwpMatch.coachAway && (appConfig.coaches.find((o2) => Number(o2.id) === Number(window.anwpMatch.coachAway)) || "temp" === window.anwpMatch.coachAway)) {
      coachAway.value = "temp" === window.anwpMatch.coachAway ? tempCoach.coachAway : appConfig.coaches.find((o2) => Number(o2.id) === Number(window.anwpMatch.coachAway));
    }
    matchEvents.value.forEach((me2) => {
      if (me2.player && me2.player.toString().includes("temp__")) {
        me2.playerObj = tempPlayers.value.find((p2) => me2.player === p2.id);
      } else {
        me2.playerObj = me2.player ? appConfig.players.find((pl) => pl.id === Number(me2.player)) : void 0;
      }
      if ("substitute" === me2.type) {
        if (me2.playerOut.toString().includes("temp__")) {
          me2.player2Obj = tempPlayers.value.find((p2) => me2.playerOut === p2.id);
        } else {
          me2.player2Obj = me2.playerOut ? appConfig.players.find((pl) => pl.id === Number(me2.playerOut)) : void 0;
        }
      } else {
        if (me2.assistant.toString().includes("temp__")) {
          me2.player2Obj = tempPlayers.value.find((p2) => me2.assistant === p2.id);
        } else {
          me2.player2Obj = me2.assistant ? appConfig.players.find((pl) => pl.id === Number(me2.assistant)) : void 0;
        }
      }
    });
    missingPlayers.value.forEach((mp) => {
      mp.playerObj = mp.player ? appConfig.players.find((pl) => pl.id === Number(mp.player)) : void 0;
      if (Number(mp.club) === Number(clubHome.id) && mp.playerObj) {
        active.playersHomeMissing.push(mp);
      } else if (Number(mp.club) === Number(clubAway.id) && mp.playerObj) {
        active.playersAwayMissing.push(mp);
      }
    });
    if (window.anwpMatch.referee && (appConfig.referees.find((o2) => Number(o2.id) === Number(window.anwpMatch.referee)) || "temp" === window.anwpMatch.referee)) {
      referee.value = "temp" === window.anwpMatch.referee ? tempReferees.referee : appConfig.referees.find((o2) => Number(o2.id) === Number(window.anwpMatch.referee));
    }
    if (window.anwpMatch.assistant_1 && (appConfig.referees.find((o2) => Number(o2.id) === Number(window.anwpMatch.assistant_1)) || "temp" === window.anwpMatch.assistant_1)) {
      assistant_1.value = "temp" === window.anwpMatch.assistant_1 ? tempReferees.assistant_1 : appConfig.referees.find((o2) => Number(o2.id) === Number(window.anwpMatch.assistant_1));
    }
    if (window.anwpMatch.assistant_2 && (appConfig.referees.find((o2) => Number(o2.id) === Number(window.anwpMatch.assistant_2)) || "temp" === window.anwpMatch.assistant_2)) {
      assistant_2.value = "temp" === window.anwpMatch.assistant_2 ? tempReferees.assistant_2 : appConfig.referees.find((o2) => Number(o2.id) === Number(window.anwpMatch.assistant_2));
    }
    if (window.anwpMatch.referee_fourth && (appConfig.referees.find((o2) => Number(o2.id) === Number(window.anwpMatch.referee_fourth)) || "temp" === window.anwpMatch.referee_fourth)) {
      referee_fourth.value = "temp" === window.anwpMatch.referee_fourth ? tempReferees.referee_fourth : appConfig.referees.find((o2) => Number(o2.id) === Number(window.anwpMatch.referee_fourth));
    }
    if ((_a2 = window.anwpMatch.additional_referees) == null ? void 0 : _a2.length) {
      window.anwpMatch.additional_referees.forEach((r2) => {
        let referee2 = null;
        if (r2._anwpfl_referee && r2._anwpfl_referee.toString().includes("temp__")) {
          referee2 = tempReferees.additional_referees[r2._anwpfl_referee.toString().substring(6)];
        } else if (r2._anwpfl_referee) {
          referee2 = appConfig.referees.find((o2) => Number(o2.id) === Number(r2._anwpfl_referee));
        }
        additional_referees.value.push(
          {
            role: r2.role ? r2.role : "",
            id: r2.id ? r2.id : nextIdAdditionalReferee.value,
            referee: referee2
          }
        );
      });
    }
    const playerNumber = computed(() => {
      const customNumbersFiltered = {};
      Object.keys(customNumbers).forEach((playerId) => {
        if (customNumbers[playerId]) {
          customNumbersFiltered[playerId] = customNumbers[playerId];
        }
      });
      return Object.assign({}, appConfig.squadHomeNumbers, appConfig.squadAwayNumbers, customNumbersFiltered);
    });
    const openAddPlayerModal = (context) => {
      modalData.playerContext = context;
      if ("home-missing" === modalData.playerContext || "away-missing" === modalData.playerContext) {
        modalData.playerActiveActions = "club_squad";
      } else {
        tempPlayer.name = "";
        tempPlayer.position = "";
        tempPlayer.country = "";
      }
      modals.addPlayer = true;
    };
    const openModalCoachSelector = (side) => {
      var _a3;
      modalData.coachSide = side;
      modalData.tempCoach = Object.assign({}, tempCoach[side]);
      modalData.modalCoachMode = ((_a3 = tempCoach[side]) == null ? void 0 : _a3.id) ? "temp" : "saved";
      modals.addCoach = true;
    };
    const openModalCaptainSelector = (side) => {
      modalData.captainSide = side;
      modals.addCaptain = true;
    };
    const playersInModal = computed(() => {
      let players = [];
      const positionMap2 = {
        "g": 1,
        "d": 2,
        "m": 3,
        "f": 4
      };
      if ("home" === modalData.playerContext) {
        players = appConfig.players.filter((p2) => !playersHomeIds.value.includes(Number(p2.id)));
        if (modalData.playerAddSorting) {
          switch (modalData.playerAddSorting) {
            case "position":
              players.sort((a2, b2) => (positionMap2[a2.position] ? positionMap2[a2.position] : 5) - (positionMap2[b2.position] ? positionMap2[b2.position] : 5));
              break;
            case "squad_order":
              players.sort((a2, b2) => (-1 !== appConfig.squadHomeOrder.indexOf(a2.id) ? appConfig.squadHomeOrder.indexOf(a2.id) : 9999) - (-1 !== appConfig.squadHomeOrder.indexOf(b2.id) ? appConfig.squadHomeOrder.indexOf(b2.id) : 9999));
              break;
            case "squad_number":
              players.sort((a2, b2) => (appConfig.squadHomeNumbers[a2.id] ? appConfig.squadHomeNumbers[a2.id] : 9999) - (appConfig.squadHomeNumbers[b2.id] ? appConfig.squadHomeNumbers[b2.id] : 9999));
              break;
          }
        }
        if ("club_squad" === modalData.playerActiveActions) {
          return players.filter((p2) => Object.keys(appConfig.squadHomeNumbers).map(Number).includes(Number(p2.id)));
        } else if ("club_players" === modalData.playerActiveActions) {
          return players.filter((p2) => Number(p2.club_id) === Number(clubHome.id));
        } else if ("search_by_name" === modalData.playerActiveActions && "" !== modalData.playerSearch.trim()) {
          return players.filter((p2) => p2.name.toLowerCase().indexOf(modalData.playerSearch.toLowerCase()) > -1);
        }
      } else if ("away" === modalData.playerContext) {
        players = appConfig.players.filter((p2) => !playersAwayIds.value.includes(Number(p2.id)));
        if (modalData.playerAddSorting) {
          switch (modalData.playerAddSorting) {
            case "position":
              players.sort((a2, b2) => (positionMap2[a2.position] ? positionMap2[a2.position] : 5) - (positionMap2[b2.position] ? positionMap2[b2.position] : 5));
              break;
            case "squad_order":
              players.sort((a2, b2) => (-1 !== appConfig.squadAwayOrder.indexOf(a2.id) ? appConfig.squadAwayOrder.indexOf(a2.id) : 9999) - (-1 !== appConfig.squadAwayOrder.indexOf(b2.id) ? appConfig.squadAwayOrder.indexOf(b2.id) : 9999));
              break;
            case "squad_number":
              players.sort((a2, b2) => (appConfig.squadAwayNumbers[a2.id] ? appConfig.squadAwayNumbers[a2.id] : 9999) - (appConfig.squadAwayNumbers[b2.id] ? appConfig.squadAwayNumbers[b2.id] : 9999));
              break;
          }
        }
        if ("club_squad" === modalData.playerActiveActions) {
          return players.filter((p2) => Object.keys(appConfig.squadAwayNumbers).map(Number).includes(Number(p2.id)));
        } else if ("club_players" === modalData.playerActiveActions) {
          return players.filter((p2) => Number(p2.club_id) === Number(clubAway.id));
        } else if ("search_by_name" === modalData.playerActiveActions && "" !== modalData.playerSearch.trim()) {
          return players.filter((p2) => p2.name.toLowerCase().indexOf(modalData.playerSearch.toLowerCase()) > -1);
        }
      } else if ("home-missing" === modalData.playerContext) {
        players = appConfig.players.filter((p2) => !playersHomeMissingIds.value.includes(Number(p2.id)));
        if ("club_squad" === modalData.playerActiveActions) {
          return players.filter((p2) => Object.keys(appConfig.squadHomeNumbers).map(Number).includes(Number(p2.id)));
        } else if ("club_players" === modalData.playerActiveActions) {
          return players.filter((p2) => Number(p2.club_id) === Number(clubHome.id));
        } else if ("search_by_name" === modalData.playerActiveActions && "" !== modalData.playerSearch.trim()) {
          return players.filter((p2) => p2.name.toLowerCase().indexOf(modalData.playerSearch.toLowerCase()) > -1);
        }
      } else if ("away-missing" === modalData.playerContext) {
        players = appConfig.players.filter((p2) => !playersAwayMissingIds.value.includes(Number(p2.id)));
        if ("club_squad" === modalData.playerActiveActions) {
          return players.filter((p2) => Object.keys(appConfig.squadAwayNumbers).map(Number).includes(Number(p2.id)));
        } else if ("club_players" === modalData.playerActiveActions) {
          return players.filter((p2) => Number(p2.club_id) === Number(clubAway.id));
        } else if ("search_by_name" === modalData.playerActiveActions && "" !== modalData.playerSearch.trim()) {
          return players.filter((p2) => p2.name.toLowerCase().indexOf(modalData.playerSearch.toLowerCase()) > -1);
        }
      }
      return players;
    });
    const playersInModalPages = computed(() => {
      return playersInModal.value.length ? Math.ceil(playersInModal.value.length / 10) : 0;
    });
    const playersInModalPaginated = computed(() => {
      if (!playersInModal.value.length) {
        return [];
      }
      return playersInModal.value.slice((modalData.playerPageNumber - 1) * 10, modalData.playerPageNumber * 10);
    });
    const playersHomeAvailable = computed(() => {
      return appConfig.players.filter((p2) => playersHomeStartIds.value.includes(Number(p2.id)));
    });
    const playersAwayAvailable = computed(() => {
      return appConfig.players.filter((p2) => playersAwayStartIds.value.includes(Number(p2.id)));
    });
    const playersHomeStartIds = computed(() => {
      return active.playersHomeStart.map((p2) => p2.id.toString().includes("temp__") ? p2.id : Number(p2.id));
    });
    const playersHomeSubsIds = computed(() => {
      return active.playersHomeSubs.map((p2) => p2.id.toString().includes("temp__") ? p2.id : Number(p2.id));
    });
    const playersHomeIds = computed(() => {
      return playersHomeStartIds.value.concat(playersHomeSubsIds.value);
    });
    const playersAwayStartIds = computed(() => {
      return active.playersAwayStart.map((p2) => p2.id.toString().includes("temp__") ? p2.id : Number(p2.id));
    });
    const playersAwaySubsIds = computed(() => {
      return active.playersAwaySubs.map((p2) => p2.id.toString().includes("temp__") ? p2.id : Number(p2.id));
    });
    const playersAwayIds = computed(() => {
      return playersAwayStartIds.value.concat(playersAwaySubsIds.value);
    });
    const playersHomeMissingIds = computed(() => {
      return active.playersHomeMissing.map((p2) => Number(p2.player));
    });
    const playersAwayMissingIds = computed(() => {
      return active.playersAwayMissing.map((p2) => Number(p2.player));
    });
    const nextIdAdditionalReferee = computed(() => {
      return additional_referees.value.length ? Math.max.apply(Math, additional_referees.value.map((o2) => Number(o2.id))) + 1 : 1;
    });
    const modals = reactive({
      changeCustomNumber: false,
      addPlayer: false,
      deleteEvent: false,
      editEvent: false,
      addEventPlayer: false,
      addReferee: false,
      addCaptain: false,
      addCoach: false
    });
    const modalData = reactive({
      playerContext: "",
      customNumberPlayerId: false,
      playerActions: [
        { name: l10n.club_squad.toLowerCase(), value: "club_squad" },
        { name: l10n.club_players, value: "club_players" },
        { name: l10n.search_by_name, value: "search_by_name" }
      ],
      playerAddSorting: "",
      playerActiveActions: "club_squad",
      playerAppendStart: true,
      playerPageNumber: 1,
      playerPageCount: 0,
      playerSearch: "",
      eventRemoveIndex: false,
      eventInModal: {},
      eventPlayersFilter: "match",
      eventPlayerModalContext: "",
      refereeField: null,
      refereeFieldIndex: 0,
      tempReferee: {},
      modalRefereeMode: "saved",
      modalPlayerMode: "saved",
      captainSide: "home",
      coachSide: "coachHome",
      modalCoachMode: "saved",
      tempCoach: {}
    });
    return {
      active,
      additional_referees,
      aggtext,
      appConfig,
      assistant_1,
      assistant_2,
      attendance,
      captainAway,
      captainHome,
      clubAway,
      clubHome,
      coachAway,
      coachHome,
      competitionType,
      customNumbers,
      datetime,
      extraTime,
      finished,
      matchEvents,
      matchWeek,
      missingPlayers,
      modalData,
      modals,
      nextIdAdditionalReferee,
      openAddPlayerModal,
      openModalCaptainSelector,
      openModalCoachSelector,
      penalty,
      playerNumber,
      playersAwayAvailable,
      playersAwayIds,
      playersAwayMissingIds,
      playersAwayStartIds,
      playersAwaySubsIds,
      playersHomeAvailable,
      playersHomeIds,
      playersHomeMissingIds,
      playersHomeStartIds,
      playersHomeSubsIds,
      playersInModal,
      playersInModalPages,
      playersInModalPaginated,
      referee,
      referee_fourth,
      special_status,
      stadium,
      stats,
      tempCoach,
      tempPlayer,
      tempPlayerID,
      tempPlayers,
      tempReferees
    };
  });
  const _hoisted_1$H = {
    class: "anwp-border anwp-border-gray-500",
    id: "anwp-fl-general-metabox"
  };
  const _hoisted_2$C = { class: "bg-white p-3 pb-4 d-sm-flex flex-wrap align-items-start" };
  const _hoisted_3$B = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_4$A = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-match-status"
  };
  const _hoisted_5$y = { value: "0" };
  const _hoisted_6$x = { value: "1" };
  const _hoisted_7$u = {
    key: 0,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_8$r = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-match-special-status"
  };
  const _hoisted_9$m = { value: "" };
  const _hoisted_10$l = ["value"];
  const _hoisted_11$k = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_12$k = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-kickoff_time"
  };
  const _hoisted_13$j = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_14$j = {
    class: "mb-1 anwp-text-gray-800 d-flex",
    for: "anwp-fl-input-stadium"
  };
  const _hoisted_15$i = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_16$i = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-attendance"
  };
  const _hoisted_17$h = ["disabled"];
  const _hoisted_18$g = {
    key: 1,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_19$g = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-matchweek"
  };
  const _hoisted_20$e = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_21$e = {
    class: "mb-1 anwp-text-gray-800 d-flex",
    for: "anwp-fl-input-agg-text"
  };
  const _hoisted_22$e = { class: "ml-auto" };
  const _hoisted_23$c = ["value"];
  const _sfc_main$H = {
    __name: "AppGeneral",
    setup(__props) {
      const gameStore = useGameStore();
      const l10n = window.anwpMatch.l10n;
      const l10n_datepicker = window.anwpMatch.l10n_datepicker;
      const setDefaultStadium = () => {
        if (gameStore.appConfig.stadiumDefault && gameStore.appConfig.stadiums.length) {
          gameStore.stadium = Number(gameStore.appConfig.stadiumDefault);
        }
      };
      return (_ctx, _cache) => {
        const _component_v_select = resolveComponent("v-select");
        const _directive_tooltip = resolveDirective("tooltip");
        return openBlock(), createElementBlock("div", _hoisted_1$H, [
          createVNode(AppBlockHeader, { icon: "#icon-gear" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).basic_info), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$C, [
            createBaseVNode("div", _hoisted_3$B, [
              createBaseVNode("label", _hoisted_4$A, toDisplayString(unref(l10n).status), 1),
              withDirectives(createBaseVNode("select", {
                id: "anwpfl-match-status",
                class: "anwp-w-min-100",
                name: "_fl_finished",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(gameStore).finished = $event)
              }, [
                createBaseVNode("option", _hoisted_5$y, toDisplayString(unref(l10n).fixture), 1),
                createBaseVNode("option", _hoisted_6$x, toDisplayString(unref(l10n).result), 1)
              ], 512), [
                [vModelSelect, unref(gameStore).finished]
              ])
            ]),
            1 !== Number(unref(gameStore).finished) ? (openBlock(), createElementBlock("div", _hoisted_7$u, [
              createBaseVNode("label", _hoisted_8$r, toDisplayString(unref(l10n).special_status), 1),
              withDirectives(createBaseVNode("select", {
                id: "anwpfl-match-special-status",
                class: "anwp-w-min-150",
                name: "_anwpfl_special_status",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(gameStore).special_status = $event)
              }, [
                createBaseVNode("option", _hoisted_9$m, "- " + toDisplayString(unref(l10n).none) + " -", 1),
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).appConfig.specialStatuses, (specialStatusText, specialStatusSlug) => {
                  return openBlock(), createElementBlock("option", {
                    value: specialStatusSlug,
                    key: specialStatusSlug
                  }, toDisplayString(specialStatusText), 9, _hoisted_10$l);
                }), 128))
              ], 512), [
                [vModelSelect, unref(gameStore).special_status]
              ])
            ])) : createCommentVNode("", true),
            _cache[8] || (_cache[8] = createBaseVNode("div", { class: "w-100" }, null, -1)),
            createBaseVNode("div", _hoisted_11$k, [
              createBaseVNode("label", _hoisted_12$k, toDisplayString(unref(l10n).kickoff_time), 1),
              createVNode(unref(index), {
                id: "anwp-fl-input-kickoff_time",
                class: "anwp-w-min-100",
                type: "datetime",
                format: "YYYY-MM-DD HH:mm",
                "value-type": "YYYY-MM-DD HH:mm:ss",
                "show-second": false,
                lang: unref(l10n_datepicker),
                "input-attr": { name: "_anwpfl_datetime" },
                "minute-step": 5,
                value: unref(gameStore).datetime,
                "onUpdate:value": _cache[2] || (_cache[2] = ($event) => unref(gameStore).datetime = $event)
              }, null, 8, ["lang", "value"])
            ]),
            createBaseVNode("div", _hoisted_13$j, [
              createBaseVNode("label", _hoisted_14$j, [
                createTextVNode(toDisplayString(unref(l10n).stadium) + " ", 1),
                unref(gameStore).appConfig.stadiumDefault ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  class: "small ml-auto",
                  href: "#",
                  onClick: withModifiers(setDefaultStadium, ["prevent"])
                }, toDisplayString(unref(l10n).set_default), 1)) : createCommentVNode("", true)
              ]),
              createVNode(_component_v_select, {
                class: "anwp-w-min-200",
                id: "anwp-fl-input-stadium",
                label: "title",
                modelValue: unref(gameStore).stadium,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(gameStore).stadium = $event),
                options: unref(gameStore).appConfig.stadiums,
                clearable: true,
                filterable: true,
                searchable: true,
                placeholder: unref(l10n).select_stadium,
                reduce: (o2) => o2.id
              }, null, 8, ["modelValue", "options", "placeholder", "reduce"])
            ]),
            createBaseVNode("div", _hoisted_15$i, [
              createBaseVNode("label", _hoisted_16$i, toDisplayString(unref(l10n).attendance), 1),
              withDirectives(createBaseVNode("input", {
                name: "_anwpfl_attendance",
                type: "number",
                disabled: !Number(unref(gameStore).finished),
                id: "anwp-fl-input-attendance",
                class: "anwp-w-100 anwp-w-min-100",
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(gameStore).attendance = $event)
              }, null, 8, _hoisted_17$h), [
                [
                  vModelText,
                  unref(gameStore).attendance,
                  void 0,
                  { number: true }
                ]
              ])
            ]),
            _cache[9] || (_cache[9] = createBaseVNode("div", { class: "w-100" }, null, -1)),
            "round-robin" === unref(gameStore).competitionType ? (openBlock(), createElementBlock("div", _hoisted_18$g, [
              createBaseVNode("label", _hoisted_19$g, toDisplayString(unref(l10n).match_week), 1),
              withDirectives(createBaseVNode("input", {
                name: "_anwpfl_matchweek",
                type: "number",
                max: "255",
                min: "1",
                id: "anwp-fl-input-matchweek",
                class: "anwp-w-100 anwp-w-min-100",
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(gameStore).matchWeek = $event)
              }, null, 512), [
                [
                  vModelText,
                  unref(gameStore).matchWeek,
                  void 0,
                  { number: true }
                ]
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_20$e, [
              createBaseVNode("label", _hoisted_21$e, [
                createTextVNode(toDisplayString(unref(l10n).aggtext) + " ", 1),
                withDirectives((openBlock(), createElementBlock("span", _hoisted_22$e, [..._cache[7] || (_cache[7] = [
                  createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s14" }, [
                    createBaseVNode("use", { "xlink:href": "#icon-info" })
                  ], -1)
                ])])), [
                  [_directive_tooltip, unref(l10n).aggtext_hint]
                ])
              ]),
              withDirectives(createBaseVNode("input", {
                name: "_anwpfl_aggtext",
                type: "text",
                id: "anwp-fl-input-agg-text",
                class: "anwp-w-min-150",
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(gameStore).aggtext = $event)
              }, null, 512), [
                [vModelText, unref(gameStore).aggtext]
              ])
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_stadium",
            value: unref(gameStore).stadium
          }, null, 8, _hoisted_23$c)
        ]);
      };
    }
  };
  const _hoisted_1$G = ["src"];
  const _hoisted_2$B = { class: "anwp-text-xl anwp-text-gray-800" };
  const _hoisted_3$A = { class: "anwp-text-xl anwp-text-gray-800 ml-auto" };
  const _hoisted_4$z = ["src"];
  const _sfc_main$G = {
    __name: "AppTeamHeader",
    props: {
      logo: {
        type: String,
        default: ""
      },
      title: {
        type: String,
        default: ""
      },
      wrapperClass: {
        type: String,
        default: ""
      },
      isHome: {
        type: Boolean,
        default: true
      }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["d-flex align-items-center anwp-border anwp-border-gray-400 p-2 anwp-bg-gray-100", __props.wrapperClass])
        }, [
          __props.isHome ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            __props.logo ? (openBlock(), createElementBlock("img", {
              key: 0,
              src: __props.logo,
              alt: "club logo",
              class: "anwp-w-60 anwp-h-60 anwp-object-contain mr-3"
            }, null, 8, _hoisted_1$G)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_2$B, toDisplayString(__props.title), 1)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createBaseVNode("div", _hoisted_3$A, toDisplayString(__props.title), 1),
            __props.logo ? (openBlock(), createElementBlock("img", {
              key: 0,
              src: __props.logo,
              alt: "club logo",
              class: "anwp-w-60 anwp-h-60 anwp-object-contain ml-3"
            }, null, 8, _hoisted_4$z)) : createCommentVNode("", true)
          ], 64))
        ], 2);
      };
    }
  };
  const _hoisted_1$F = {
    class: "anwp-border anwp-border-gray-500 my-4",
    id: "anwp-fl-game-statistics-metabox"
  };
  const _hoisted_2$A = { class: "bg-white p-3 pb-4" };
  const _hoisted_3$z = { class: "d-flex flex-wrap justify-content-end" };
  const _hoisted_4$y = { class: "d-flex flex-column m-sm-2 px-2 ml-auto" };
  const _hoisted_5$x = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-input-extra-time"
  };
  const _hoisted_6$w = { value: "" };
  const _hoisted_7$t = { value: "yes" };
  const _hoisted_8$q = { class: "d-flex flex-column m-sm-2 px-2" };
  const _hoisted_9$l = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-input-penalty"
  };
  const _hoisted_10$k = { value: "" };
  const _hoisted_11$j = { value: "yes" };
  const _hoisted_12$j = { class: "table table-sm anwp-match-stats-table my-3" };
  const _hoisted_13$i = {
    scope: "row",
    colspan: "2",
    class: "bg-secondary text-white"
  };
  const _hoisted_14$i = { class: "anwp-bg-green-100" };
  const _hoisted_15$h = { scope: "row" };
  const _hoisted_16$h = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_17$g = { key: 0 };
  const _hoisted_18$f = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_19$f = { key: 1 };
  const _hoisted_20$d = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_21$d = { key: 2 };
  const _hoisted_22$d = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_23$b = {
    class: "bg-secondary text-white",
    scope: "row",
    colspan: "2"
  };
  const _hoisted_24$a = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_25$8 = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_26$8 = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_27$8 = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_28$8 = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_29$8 = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_30$8 = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_31$8 = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_32$8 = {
    scope: "row",
    class: "table-secondary"
  };
  const _hoisted_33$8 = {
    key: 1,
    class: "my-2"
  };
  const _hoisted_34$7 = {
    class: "alert alert-info mb-0",
    role: "alert"
  };
  const _hoisted_35$7 = ["value"];
  const _hoisted_36$7 = ["value"];
  const _sfc_main$F = {
    __name: "AppGameStats",
    setup(__props) {
      const gameStore = useGameStore();
      const l10n = window.anwpMatch.l10n;
      const extraTimeValue = computed(() => {
        if ("yes" === gameStore.extraTime) {
          return "yes" === gameStore.penalty ? 2 : 1;
        }
        return "yes" === gameStore.penalty ? 3 : 0;
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$F, [
          createVNode(AppBlockHeader, { icon: "#icon-graph" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).match_stats), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$A, [
            Number(unref(gameStore).finished) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_3$z, [
                createBaseVNode("div", _hoisted_4$y, [
                  createBaseVNode("label", _hoisted_5$x, toDisplayString(unref(l10n).extra_time), 1),
                  withDirectives(createBaseVNode("select", {
                    id: "anwpfl-input-extra-time",
                    class: "anwp-w-min-150",
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(gameStore).extraTime = $event)
                  }, [
                    createBaseVNode("option", _hoisted_6$w, toDisplayString(unref(l10n).no), 1),
                    createBaseVNode("option", _hoisted_7$t, toDisplayString(unref(l10n).yes), 1)
                  ], 512), [
                    [vModelSelect, unref(gameStore).extraTime]
                  ])
                ]),
                createBaseVNode("div", _hoisted_8$q, [
                  createBaseVNode("label", _hoisted_9$l, toDisplayString(unref(l10n).penalty), 1),
                  withDirectives(createBaseVNode("select", {
                    id: "anwpfl-input-penalty",
                    class: "anwp-w-min-150",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(gameStore).penalty = $event)
                  }, [
                    createBaseVNode("option", _hoisted_10$k, toDisplayString(unref(l10n).no), 1),
                    createBaseVNode("option", _hoisted_11$j, toDisplayString(unref(l10n).yes), 1)
                  ], 512), [
                    [vModelSelect, unref(gameStore).penalty]
                  ])
                ])
              ]),
              createBaseVNode("table", _hoisted_12$j, [
                createBaseVNode("thead", null, [
                  createBaseVNode("tr", null, [
                    _cache[30] || (_cache[30] = createBaseVNode("td", { class: "anwp-opacity-0" }, null, -1)),
                    createBaseVNode("td", null, [
                      createVNode(_sfc_main$G, {
                        logo: unref(gameStore).clubHome.logo,
                        title: unref(gameStore).clubHome.title,
                        "is-home": true,
                        "wrapper-class": "justify-content-center"
                      }, null, 8, ["logo", "title"])
                    ]),
                    createBaseVNode("td", null, [
                      createVNode(_sfc_main$G, {
                        logo: unref(gameStore).clubAway.logo,
                        title: unref(gameStore).clubAway.title,
                        "is-home": true,
                        "wrapper-class": "justify-content-center"
                      }, null, 8, ["logo", "title"])
                    ])
                  ])
                ]),
                createBaseVNode("tbody", null, [
                  createBaseVNode("tr", null, [
                    _cache[31] || (_cache[31] = createBaseVNode("th", { class: "anwp-opacity-0" }, null, -1)),
                    createBaseVNode("th", _hoisted_13$i, toDisplayString(unref(l10n).goals), 1)
                  ]),
                  createBaseVNode("tr", _hoisted_14$i, [
                    createBaseVNode("th", _hoisted_15$h, toDisplayString(unref(l10n).final_score), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 py-2 d-block anwp-bg-green-100 h-auto anwp-leading-1",
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(gameStore).stats.home_goals = $event),
                        style: { "max-height": "none", "font-size": "32px" }
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_goals,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 py-2 d-block anwp-bg-green-100 h-auto anwp-leading-1",
                        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(gameStore).stats.away_goals = $event),
                        style: { "max-height": "none", "font-size": "32px" }
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_goals,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_16$h, toDisplayString(unref(l10n).half_time), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(gameStore).stats.home_goals_half = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_goals_half,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(gameStore).stats.away_goals_half = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_goals_half,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  "yes" === unref(gameStore).extraTime ? (openBlock(), createElementBlock("tr", _hoisted_17$g, [
                    createBaseVNode("th", _hoisted_18$f, toDisplayString(unref(l10n).full_time), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(gameStore).stats.home_goals_ft = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_goals_ft,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(gameStore).stats.away_goals_ft = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_goals_ft,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ])) : createCommentVNode("", true),
                  "yes" === unref(gameStore).extraTime ? (openBlock(), createElementBlock("tr", _hoisted_19$f, [
                    createBaseVNode("th", _hoisted_20$d, toDisplayString(unref(l10n).extra_time), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => unref(gameStore).stats.home_goals_e = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_goals_e,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => unref(gameStore).stats.away_goals_e = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_goals_e,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ])) : createCommentVNode("", true),
                  "yes" === unref(gameStore).penalty ? (openBlock(), createElementBlock("tr", _hoisted_21$d, [
                    createBaseVNode("th", _hoisted_22$d, toDisplayString(unref(l10n).penalty), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => unref(gameStore).stats.home_goals_p = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_goals_p,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => unref(gameStore).stats.away_goals_p = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_goals_p,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ])) : createCommentVNode("", true),
                  createBaseVNode("tr", null, [
                    _cache[32] || (_cache[32] = createBaseVNode("th", { class: "anwp-opacity-0" }, null, -1)),
                    createBaseVNode("th", _hoisted_23$b, toDisplayString(unref(l10n).stats), 1)
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_24$a, toDisplayString(unref(l10n).yellow_cards), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => unref(gameStore).stats.home_cards_y = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_cards_y,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => unref(gameStore).stats.away_cards_y = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_cards_y,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_25$8, toDisplayString(unref(l10n).yellow_reds), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => unref(gameStore).stats.home_cards_yr = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_cards_yr,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => unref(gameStore).stats.away_cards_yr = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_cards_yr,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_26$8, toDisplayString(unref(l10n).red_cards), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => unref(gameStore).stats.home_cards_r = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_cards_r,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => unref(gameStore).stats.away_cards_r = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_cards_r,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_27$8, toDisplayString(unref(l10n).corner_kicks), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => unref(gameStore).stats.home_corners = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_corners,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => unref(gameStore).stats.away_corners = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_corners,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_28$8, toDisplayString(unref(l10n).fouls), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => unref(gameStore).stats.home_fouls = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_fouls,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => unref(gameStore).stats.away_fouls = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_fouls,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_29$8, toDisplayString(unref(l10n).offsides), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => unref(gameStore).stats.home_offsides = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_offsides,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => unref(gameStore).stats.away_offsides = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_offsides,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_30$8, toDisplayString(unref(l10n).ball_possession), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[24] || (_cache[24] = ($event) => unref(gameStore).stats.home_possession = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_possession,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => unref(gameStore).stats.away_possession = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_possession,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_31$8, toDisplayString(unref(l10n).shots), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[26] || (_cache[26] = ($event) => unref(gameStore).stats.home_shots = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_shots,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[27] || (_cache[27] = ($event) => unref(gameStore).stats.away_shots = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_shots,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ]),
                  createBaseVNode("tr", null, [
                    createBaseVNode("th", _hoisted_32$8, toDisplayString(unref(l10n).shots_on_goal), 1),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => unref(gameStore).stats.home_shots_on_goal = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.home_shots_on_goal,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("td", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "w-100 text-center",
                        "onUpdate:modelValue": _cache[29] || (_cache[29] = ($event) => unref(gameStore).stats.away_shots_on_goal = $event)
                      }, null, 512), [
                        [
                          vModelText,
                          unref(gameStore).stats.away_shots_on_goal,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ])
                ])
              ])
            ], 64)) : (openBlock(), createElementBlock("div", _hoisted_33$8, [
              createBaseVNode("div", _hoisted_34$7, toDisplayString(unref(l10n).set_stat_only_finished), 1)
            ]))
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_stats",
            value: JSON.stringify(unref(gameStore).stats)
          }, null, 8, _hoisted_35$7),
          createBaseVNode("input", {
            type: "hidden",
            name: "_fl_extra",
            value: extraTimeValue.value
          }, null, 8, _hoisted_36$7)
        ]);
      };
    }
  };
  const _hoisted_1$E = { class: "anwp-border anwp-border-gray-400 anwp-bg-gray-100" };
  const _hoisted_2$z = { class: "position-relative anwp-cursor-pointer ml-2 anwp-w-50" };
  const _hoisted_3$y = {
    key: 1,
    class: "px-1 py-1 align-middle anwp-w-10"
  };
  const _hoisted_4$x = ["src"];
  const _hoisted_5$w = { class: "mt-1" };
  const _hoisted_6$v = {
    key: 0,
    class: "options__flag f16 align-middle mr-1",
    style: { "line-height": "12px" }
  };
  const _hoisted_7$s = {
    key: 1,
    class: "anwp-text-xs anwp-text-gray-600"
  };
  const _sfc_main$E = {
    __name: "AppMatchPlayer",
    props: {
      className: {
        type: String,
        default: "align-middle"
      },
      classRemove: {
        type: String,
        default: "align-middle"
      },
      player: {
        type: Object,
        required: true
      },
      classPosition: {},
      defaultPhoto: {
        type: String
      },
      squadNumbers: {
        type: Object,
        default: function() {
          return {};
        }
      },
      customNumbers: {
        type: Object,
        default: function() {
          return {};
        }
      },
      displayNumber: {
        type: Boolean,
        default: true
      },
      displayPhoto: {
        type: Boolean,
        default: true
      },
      l10n: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        const _directive_tooltip = resolveDirective("tooltip");
        return openBlock(), createElementBlock("tr", _hoisted_1$E, [
          _cache[4] || (_cache[4] = createBaseVNode("td", { class: "anwp-drag-handler anwp-w-30 anwp-text-center pt-1 px-2" }, [
            createBaseVNode("svg", { class: "anwp-icon anwp-icon--s24 anwp-icon--octi mr-0" }, [
              createBaseVNode("use", { "xlink:href": "#icon-grabber" })
            ])
          ], -1)),
          createBaseVNode("td", {
            class: normalizeClass(["p-1 anwp-w-15 anwp-text-center text-uppercase align-middle anwp-text-lg text-white anwp-font-bold anwp-leading-1 anwp-opacity-60", __props.player.position && __props.classPosition[__props.player.position] ? __props.classPosition[__props.player.position] : ""])
          }, toDisplayString(__props.player.position ? __props.player.position.charAt(0) : ""), 3),
          __props.displayNumber ? withDirectives((openBlock(), createElementBlock("td", {
            key: 0,
            class: "py-0 px-2 anwp-text-center align-middle anwp-w-10",
            onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$emit("open-number-modal"), ["prevent"]))
          }, [
            createBaseVNode("div", _hoisted_2$z, [
              _cache[2] || (_cache[2] = createBaseVNode("svg", { class: "anwp-icon anwp-fl-icon--shirt" }, [
                createBaseVNode("use", { "xlink:href": "#icon-shirt" })
              ], -1)),
              createBaseVNode("div", {
                class: normalizeClass(["anwp-fl-icon--shirt-number", { "anwp-text-orange-500": __props.customNumbers[__props.player.id] > 0 }])
              }, toDisplayString(__props.customNumbers[__props.player.id] > 0 ? __props.customNumbers[__props.player.id] : __props.squadNumbers[__props.player.id] ? __props.squadNumbers[__props.player.id] : ""), 3)
            ])
          ])), [
            [_directive_tooltip, __props.l10n.edit_player_number]
          ]) : createCommentVNode("", true),
          __props.displayPhoto ? (openBlock(), createElementBlock("td", _hoisted_3$y, [
            createBaseVNode("img", {
              class: "anwp-h-45 anwp-w-45 anwp-object-contain my-0 anwp-border anwp-border-gray-400",
              style: { "border-radius": "10px", "padding": "2px" },
              src: __props.player.photo ? __props.player.photo : __props.defaultPhoto,
              alt: "player photo"
            }, null, 8, _hoisted_4$x)
          ])) : createCommentVNode("", true),
          createBaseVNode("td", {
            class: normalizeClass(["p-2 anwp-text-base anwp-leading-1", __props.className])
          }, [
            createTextVNode(toDisplayString(__props.player.name) + " ", 1),
            createBaseVNode("div", _hoisted_5$w, [
              __props.player.country ? (openBlock(), createElementBlock("span", _hoisted_6$v, [
                createBaseVNode("span", {
                  class: normalizeClass(["flag", __props.player.country])
                }, null, 2)
              ])) : createCommentVNode("", true),
              __props.player.birthdate ? (openBlock(), createElementBlock("span", _hoisted_7$s, toDisplayString(__props.player.birthdate), 1)) : createCommentVNode("", true)
            ])
          ], 2),
          renderSlot(_ctx.$slots, "default"),
          createBaseVNode("td", {
            class: normalizeClass(["p-2 anwp-w-10 anwp-text-center", __props.classRemove])
          }, [
            createBaseVNode("button", {
              type: "button",
              class: "anwp-cursor-pointer d-flex align-items-center justify-content-center my-1 button anwp-border-red-600 anwp-hide-sortable-drag",
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.$emit("remove-player"), ["prevent"]))
            }, [..._cache[3] || (_cache[3] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])])
          ], 2)
        ]);
      };
    }
  };
  const _hoisted_1$D = { class: "mr-3" };
  const _hoisted_2$y = ["src"];
  const _hoisted_3$x = { class: "anwp-text-base anwp-leading-1" };
  const _hoisted_4$w = { class: "mt-1" };
  const _hoisted_5$v = {
    key: 0,
    class: "options__flag f16 align-middle mr-1",
    style: { "line-height": "12px" }
  };
  const _hoisted_6$u = {
    key: 1,
    class: "anwp-text-xs anwp-text-gray-600"
  };
  const _sfc_main$D = {
    __name: "AppMatchCoach",
    props: {
      coach: {
        type: Object,
        required: true
      },
      defaultPhoto: {
        type: String
      }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: "d-flex align-items-center anwp-cursor-pointer anwp-border anwp-border-gray-400 rounded px-3 py-2 anwp-bg-gray-100",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$emit("click-coach"), ["prevent"]))
        }, [
          createBaseVNode("div", _hoisted_1$D, [
            createBaseVNode("img", {
              class: "anwp-h-45 anwp-w-45 anwp-object-contain my-0 anwp-border anwp-border-gray-400",
              style: { "border-radius": "10px", "padding": "2px" },
              src: __props.coach.photo || __props.defaultPhoto,
              alt: "coach photo"
            }, null, 8, _hoisted_2$y)
          ]),
          createBaseVNode("div", _hoisted_3$x, [
            createTextVNode(toDisplayString(__props.coach.name) + " ", 1),
            createBaseVNode("div", _hoisted_4$w, [
              __props.coach.country ? (openBlock(), createElementBlock("span", _hoisted_5$v, [
                createBaseVNode("span", {
                  class: normalizeClass(["flag", __props.coach.country])
                }, null, 2)
              ])) : createCommentVNode("", true),
              __props.coach.birthdate ? (openBlock(), createElementBlock("span", _hoisted_6$u, toDisplayString(__props.coach.birthdate), 1)) : createCommentVNode("", true)
            ])
          ])
        ]);
      };
    }
  };
  const _hoisted_1$C = { class: "my-3" };
  const _hoisted_2$x = {
    key: 0,
    class: "d-flex flex-wrap align-items-start"
  };
  const _sfc_main$C = {
    __name: "AppMatchCoachInput",
    props: {
      l10n: {
        type: Object
      },
      coach: {},
      defaultPhoto: {
        type: String
      }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$C, [
          __props.coach ? (openBlock(), createElementBlock("div", _hoisted_2$x, [
            createVNode(_sfc_main$D, {
              onClickCoach: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("open-modal-coach-selector")),
              coach: __props.coach,
              defaultPhoto: __props.defaultPhoto
            }, null, 8, ["coach", "defaultPhoto"]),
            createBaseVNode("button", {
              type: "button",
              class: "anwp-flex-none ml-2 anwp-cursor-pointer d-flex align-items-center justify-content-center button anwp-border-red-600",
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.$emit("click-remove"), ["prevent"]))
            }, [..._cache[3] || (_cache[3] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])])
          ])) : (openBlock(), createElementBlock("button", {
            key: 1,
            type: "button",
            class: "button button-secondary px-4 py-1",
            onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.$emit("open-modal-coach-selector"), ["prevent"]))
          }, toDisplayString(__props.l10n.select_coach), 1))
        ]);
      };
    }
  };
  const _hoisted_1$B = {
    key: 1,
    class: "mr-3 anwp-text-center position-relative"
  };
  const _hoisted_2$w = {
    class: "anwp-fl-icon--shirt-number",
    style: { "top": "10px", "left": "0" }
  };
  const _hoisted_3$w = {
    key: 2,
    class: "mr-3"
  };
  const _hoisted_4$v = ["src"];
  const _hoisted_5$u = { class: "anwp-text-base anwp-leading-1" };
  const _hoisted_6$t = {
    key: 0,
    class: "mt-1"
  };
  const _hoisted_7$r = {
    key: 0,
    class: "options__flag f16 align-middle mr-1",
    style: { "line-height": "12px" }
  };
  const _hoisted_8$p = {
    key: 1,
    class: "anwp-text-xs anwp-text-gray-600"
  };
  const _sfc_main$B = {
    __name: "AppMatchPlayerAlt",
    props: {
      displayPosition: {
        type: Boolean,
        default: true
      },
      displayNumber: {
        type: Boolean,
        default: true
      },
      displayPhoto: {
        type: Boolean,
        default: true
      },
      displayPlayerMeta: {
        type: Boolean,
        default: true
      },
      player: {
        type: Object,
        required: true
      },
      classPosition: {},
      defaultPhoto: {
        type: String
      },
      playerNumber: {
        type: Object,
        default: function() {
          return {};
        }
      }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: "d-flex align-items-center anwp-cursor-pointer anwp-border anwp-border-gray-400 rounded px-3 py-2 anwp-bg-gray-100",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$emit("click-player"), ["prevent"]))
        }, [
          __props.displayPosition ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold mr-3", __props.player.position ? __props.classPosition[__props.player.position] : "anwp-bg-gray-500"])
          }, toDisplayString(__props.player.position ? __props.player.position.charAt(0) : "?"), 3)) : createCommentVNode("", true),
          __props.displayNumber ? (openBlock(), createElementBlock("div", _hoisted_1$B, [
            _cache[1] || (_cache[1] = createBaseVNode("svg", { class: "anwp-icon anwp-fl-icon--shirt" }, [
              createBaseVNode("use", { "xlink:href": "#icon-shirt" })
            ], -1)),
            createBaseVNode("div", _hoisted_2$w, toDisplayString(__props.playerNumber[__props.player.id] > 0 ? __props.playerNumber[__props.player.id] : ""), 1)
          ])) : createCommentVNode("", true),
          __props.displayPhoto ? (openBlock(), createElementBlock("div", _hoisted_3$w, [
            createBaseVNode("img", {
              class: "anwp-h-45 anwp-w-45 anwp-object-contain my-0 anwp-border anwp-border-gray-400",
              style: { "border-radius": "10px", "padding": "2px" },
              src: __props.player.photo ? __props.player.photo : __props.defaultPhoto,
              alt: "player photo"
            }, null, 8, _hoisted_4$v)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_5$u, [
            createTextVNode(toDisplayString(__props.player.name) + " ", 1),
            __props.displayPlayerMeta ? (openBlock(), createElementBlock("div", _hoisted_6$t, [
              __props.player.country ? (openBlock(), createElementBlock("span", _hoisted_7$r, [
                createBaseVNode("span", {
                  class: normalizeClass(["flag", __props.player.country])
                }, null, 2)
              ])) : createCommentVNode("", true),
              __props.player.birthdate ? (openBlock(), createElementBlock("span", _hoisted_8$p, toDisplayString(__props.player.birthdate), 1)) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ])
        ]);
      };
    }
  };
  const _hoisted_1$A = {
    class: "anwp-border anwp-border-gray-500 my-4",
    id: "anwp-fl-players-metabox"
  };
  const _hoisted_2$v = { class: "px-3 pb-4 bg-white" };
  const _hoisted_3$v = { class: "anwp-row" };
  const _hoisted_4$u = { class: "anwp-col-xl-6" };
  const _hoisted_5$t = { class: "mb-2 py-1 px-2 anwp-text-base d-flex anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" };
  const _hoisted_6$s = { class: "ml-auto" };
  const _hoisted_7$q = { class: "table-responsive" };
  const _hoisted_8$o = { class: "table table-sm anwp-border-collapse w-100 anwp-overflow-scroll anwp-user-select-none anwp-leading-1" };
  const _hoisted_9$k = { class: "mb-2 py-1 px-2 anwp-text-base d-flex anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" };
  const _hoisted_10$j = { class: "ml-auto" };
  const _hoisted_11$i = { class: "table-responsive" };
  const _hoisted_12$i = { class: "table table-sm anwp-border-collapse w-100 anwp-overflow-scroll anwp-user-select-none anwp-leading-1" };
  const _hoisted_13$h = { class: "mb-2 py-1 px-2 anwp-text-base d-flex anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" };
  const _hoisted_14$h = { class: "mb-2 mt-3 py-1 px-2 anwp-text-base d-flex anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" };
  const _hoisted_15$g = {
    key: 0,
    class: "d-flex flex-wrap align-items-start"
  };
  const _hoisted_16$g = { class: "anwp-col-xl-6" };
  const _hoisted_17$f = { class: "mb-2 py-1 px-2 anwp-text-base d-flex anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" };
  const _hoisted_18$e = { class: "ml-auto" };
  const _hoisted_19$e = { class: "table-responsive" };
  const _hoisted_20$c = { class: "table table-sm anwp-border-collapse w-100 anwp-overflow-scroll anwp-user-select-none anwp-leading-1" };
  const _hoisted_21$c = { class: "mb-2 py-1 px-2 anwp-text-base d-flex anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" };
  const _hoisted_22$c = { class: "ml-auto" };
  const _hoisted_23$a = { class: "table-responsive" };
  const _hoisted_24$9 = { class: "table table-sm anwp-border-collapse w-100 anwp-overflow-scroll anwp-user-select-none anwp-leading-1" };
  const _hoisted_25$7 = { class: "mb-2 py-1 px-2 anwp-text-base d-flex anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" };
  const _hoisted_26$7 = { class: "mb-2 mt-3 py-1 px-2 anwp-text-base d-flex anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" };
  const _hoisted_27$7 = {
    key: 0,
    class: "d-flex flex-wrap align-items-start"
  };
  const _hoisted_28$7 = ["value"];
  const _hoisted_29$7 = ["value"];
  const _hoisted_30$7 = ["value"];
  const _hoisted_31$7 = ["value"];
  const _hoisted_32$7 = ["value"];
  const _hoisted_33$7 = ["value"];
  const _hoisted_34$6 = ["value"];
  const _hoisted_35$6 = ["value"];
  const _hoisted_36$6 = ["value"];
  const _hoisted_37$6 = ["value"];
  const _hoisted_38$5 = ["value"];
  const _sfc_main$A = {
    __name: "AppPlayers",
    setup(__props) {
      const gameStore = useGameStore();
      const l10n = window.anwpMatch.l10n;
      const openCustomNumberModal = (playerId) => {
        gameStore.modalData.customNumberPlayerId = playerId;
        gameStore.modals.changeCustomNumber = true;
      };
      return (_ctx, _cache) => {
        var _a2, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k;
        const _component_draggable = resolveComponent("draggable");
        return openBlock(), createElementBlock("div", _hoisted_1$A, [
          createVNode(AppBlockHeader, { icon: "#icon-jersey" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).players), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$v, [
            createBaseVNode("div", _hoisted_3$v, [
              createBaseVNode("div", _hoisted_4$u, [
                createVNode(_sfc_main$G, {
                  logo: unref(gameStore).clubHome.logo,
                  title: unref(gameStore).clubHome.title,
                  "is-home": true,
                  "wrapper-class": "mt-4"
                }, null, 8, ["logo", "title"]),
                createBaseVNode("button", {
                  class: "button d-flex align-items-center mx-auto my-4 px-5",
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = withModifiers(($event) => unref(gameStore).openAddPlayerModal("home"), ["prevent"]))
                }, [
                  _cache[16] || (_cache[16] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16 mr-2" }, [
                    createBaseVNode("use", { "xlink:href": "#icon-plus" })
                  ], -1)),
                  createTextVNode(" " + toDisplayString(unref(l10n).add_player), 1)
                ]),
                createBaseVNode("div", _hoisted_5$t, [
                  createTextVNode(toDisplayString(unref(l10n).starting_line_up) + " ", 1),
                  createBaseVNode("span", _hoisted_6$s, "(" + toDisplayString(((_a2 = unref(gameStore).active.playersHomeStart) == null ? void 0 : _a2.length) || 0) + ")", 1)
                ]),
                createBaseVNode("div", _hoisted_7$q, [
                  createBaseVNode("table", _hoisted_8$o, [
                    createVNode(_component_draggable, {
                      modelValue: unref(gameStore).active.playersHomeStart,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(gameStore).active.playersHomeStart = $event),
                      handle: ".anwp-drag-handler",
                      tag: "tbody",
                      "force-fallback": true
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersHomeStart, (player, index2) => {
                          return openBlock(), createBlock(_sfc_main$E, {
                            key: player.id,
                            player,
                            defaultPhoto: unref(gameStore).appConfig.default_photo,
                            classPosition: unref(gameStore).appConfig.classPosition,
                            squadNumbers: unref(gameStore).appConfig.squadHomeNumbers,
                            customNumbers: unref(gameStore).customNumbers,
                            onOpenNumberModal: ($event) => openCustomNumberModal(player.id),
                            onRemovePlayer: ($event) => unref(gameStore).active.playersHomeStart.splice(index2, 1),
                            l10n: unref(l10n)
                          }, null, 8, ["player", "defaultPhoto", "classPosition", "squadNumbers", "customNumbers", "onOpenNumberModal", "onRemovePlayer", "l10n"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_9$k, [
                  createTextVNode(toDisplayString(unref(l10n).substitutes) + " ", 1),
                  createBaseVNode("span", _hoisted_10$j, "(" + toDisplayString(((_b2 = unref(gameStore).active.playersHomeSubs) == null ? void 0 : _b2.length) || 0) + ")", 1)
                ]),
                createBaseVNode("div", _hoisted_11$i, [
                  createBaseVNode("table", _hoisted_12$i, [
                    createVNode(_component_draggable, {
                      modelValue: unref(gameStore).active.playersHomeSubs,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(gameStore).active.playersHomeSubs = $event),
                      handle: ".anwp-drag-handler",
                      tag: "tbody",
                      "force-fallback": true
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersHomeSubs, (player, index2) => {
                          return openBlock(), createBlock(_sfc_main$E, {
                            key: player.id,
                            player,
                            defaultPhoto: unref(gameStore).appConfig.default_photo,
                            classPosition: unref(gameStore).appConfig.classPosition,
                            squadNumbers: unref(gameStore).appConfig.squadHomeNumbers,
                            customNumbers: unref(gameStore).customNumbers,
                            onOpenNumberModal: ($event) => openCustomNumberModal(player.id),
                            onRemovePlayer: ($event) => unref(gameStore).active.playersHomeSubs.splice(index2, 1),
                            l10n: unref(l10n)
                          }, null, 8, ["player", "defaultPhoto", "classPosition", "squadNumbers", "customNumbers", "onOpenNumberModal", "onRemovePlayer", "l10n"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_13$h, toDisplayString(unref(l10n).coach), 1),
                createVNode(_sfc_main$C, {
                  l10n: unref(l10n),
                  "default-photo": unref(gameStore).appConfig.default_photo,
                  coach: unref(gameStore).coachHome,
                  onOpenModalCoachSelector: _cache[3] || (_cache[3] = ($event) => unref(gameStore).openModalCoachSelector("coachHome")),
                  onClickRemove: _cache[4] || (_cache[4] = ($event) => unref(gameStore).coachHome = null)
                }, null, 8, ["l10n", "default-photo", "coach"]),
                createBaseVNode("div", _hoisted_14$h, toDisplayString(unref(l10n).captain), 1),
                ((_c = unref(gameStore).captainHome) == null ? void 0 : _c.id) ? (openBlock(), createElementBlock("div", _hoisted_15$g, [
                  createVNode(_sfc_main$B, {
                    onClickPlayer: _cache[5] || (_cache[5] = ($event) => unref(gameStore).openModalCaptainSelector("home")),
                    player: unref(gameStore).captainHome,
                    defaultPhoto: unref(gameStore).appConfig.default_photo,
                    playerNumber: unref(gameStore).playerNumber,
                    displayPosition: false
                  }, null, 8, ["player", "defaultPhoto", "playerNumber"]),
                  createBaseVNode("button", {
                    type: "button",
                    class: "anwp-flex-none ml-2 anwp-cursor-pointer d-flex align-items-center justify-content-center button anwp-border-red-600",
                    onClick: _cache[6] || (_cache[6] = withModifiers(($event) => {
                      unref(gameStore).captainHome = "";
                    }, ["prevent"]))
                  }, [..._cache[17] || (_cache[17] = [
                    createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                      createBaseVNode("use", { "xlink:href": "#icon-x" })
                    ], -1)
                  ])])
                ])) : (openBlock(), createElementBlock("button", {
                  key: 1,
                  type: "button",
                  class: "button button-secondary px-4 py-1 d-block my-3",
                  onClick: _cache[7] || (_cache[7] = withModifiers(($event) => unref(gameStore).openModalCaptainSelector("home"), ["prevent"]))
                }, toDisplayString(unref(l10n).select_player), 1))
              ]),
              createBaseVNode("div", _hoisted_16$g, [
                createVNode(_sfc_main$G, {
                  logo: unref(gameStore).clubAway.logo,
                  title: unref(gameStore).clubAway.title,
                  "is-home": false,
                  "wrapper-class": "mt-4"
                }, null, 8, ["logo", "title"]),
                createBaseVNode("button", {
                  class: "button d-flex align-items-center mx-auto my-4 px-5",
                  type: "button",
                  onClick: _cache[8] || (_cache[8] = withModifiers(($event) => unref(gameStore).openAddPlayerModal("away"), ["prevent"]))
                }, [
                  _cache[18] || (_cache[18] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16 mr-2" }, [
                    createBaseVNode("use", { "xlink:href": "#icon-plus" })
                  ], -1)),
                  createTextVNode(" " + toDisplayString(unref(l10n).add_player), 1)
                ]),
                createBaseVNode("div", _hoisted_17$f, [
                  createTextVNode(toDisplayString(unref(l10n).starting_line_up) + " ", 1),
                  createBaseVNode("span", _hoisted_18$e, "(" + toDisplayString(((_d = unref(gameStore).active.playersAwayStart) == null ? void 0 : _d.length) || 0) + ")", 1)
                ]),
                createBaseVNode("div", _hoisted_19$e, [
                  createBaseVNode("table", _hoisted_20$c, [
                    createVNode(_component_draggable, {
                      modelValue: unref(gameStore).active.playersAwayStart,
                      "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => unref(gameStore).active.playersAwayStart = $event),
                      handle: ".anwp-drag-handler",
                      tag: "tbody",
                      "force-fallback": true
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersAwayStart, (player, index2) => {
                          return openBlock(), createBlock(_sfc_main$E, {
                            key: player.id,
                            player,
                            defaultPhoto: unref(gameStore).appConfig.default_photo,
                            classPosition: unref(gameStore).appConfig.classPosition,
                            squadNumbers: unref(gameStore).appConfig.squadAwayNumbers,
                            customNumbers: unref(gameStore).customNumbers,
                            onOpenNumberModal: ($event) => openCustomNumberModal(player.id),
                            onRemovePlayer: ($event) => unref(gameStore).active.playersAwayStart.splice(index2, 1),
                            l10n: unref(l10n)
                          }, null, 8, ["player", "defaultPhoto", "classPosition", "squadNumbers", "customNumbers", "onOpenNumberModal", "onRemovePlayer", "l10n"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_21$c, [
                  createTextVNode(toDisplayString(unref(l10n).substitutes) + " ", 1),
                  createBaseVNode("span", _hoisted_22$c, "(" + toDisplayString(((_f = (_e2 = unref(gameStore).active) == null ? void 0 : _e2.playersAwaySubs) == null ? void 0 : _f.length) || 0) + ")", 1)
                ]),
                createBaseVNode("div", _hoisted_23$a, [
                  createBaseVNode("table", _hoisted_24$9, [
                    createVNode(_component_draggable, {
                      modelValue: unref(gameStore).active.playersAwaySubs,
                      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => unref(gameStore).active.playersAwaySubs = $event),
                      handle: ".anwp-drag-handler",
                      tag: "tbody",
                      "force-fallback": true
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersAwaySubs, (player, index2) => {
                          return openBlock(), createBlock(_sfc_main$E, {
                            key: player.id,
                            player,
                            defaultPhoto: unref(gameStore).appConfig.default_photo,
                            classPosition: unref(gameStore).appConfig.classPosition,
                            squadNumbers: unref(gameStore).appConfig.squadAwayNumbers,
                            customNumbers: unref(gameStore).customNumbers,
                            onOpenNumberModal: ($event) => openCustomNumberModal(player.id),
                            onRemovePlayer: ($event) => unref(gameStore).active.playersAwaySubs.splice(index2, 1),
                            l10n: unref(l10n)
                          }, null, 8, ["player", "defaultPhoto", "classPosition", "squadNumbers", "customNumbers", "onOpenNumberModal", "onRemovePlayer", "l10n"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_25$7, toDisplayString(unref(l10n).coach), 1),
                createVNode(_sfc_main$C, {
                  l10n: unref(l10n),
                  "default-photo": unref(gameStore).appConfig.default_photo,
                  coach: unref(gameStore).coachAway,
                  onOpenModalCoachSelector: _cache[11] || (_cache[11] = ($event) => unref(gameStore).openModalCoachSelector("coachAway")),
                  onClickRemove: _cache[12] || (_cache[12] = ($event) => unref(gameStore).coachAway = null)
                }, null, 8, ["l10n", "default-photo", "coach"]),
                createBaseVNode("div", _hoisted_26$7, toDisplayString(unref(l10n).captain), 1),
                ((_g = unref(gameStore).captainAway) == null ? void 0 : _g.id) ? (openBlock(), createElementBlock("div", _hoisted_27$7, [
                  createVNode(_sfc_main$B, {
                    onClickPlayer: _cache[13] || (_cache[13] = ($event) => unref(gameStore).openModalCaptainSelector("away")),
                    player: unref(gameStore).captainAway,
                    defaultPhoto: unref(gameStore).appConfig.default_photo,
                    playerNumber: unref(gameStore).playerNumber,
                    displayPosition: false
                  }, null, 8, ["player", "defaultPhoto", "playerNumber"]),
                  createBaseVNode("button", {
                    type: "button",
                    class: "anwp-flex-none ml-2 anwp-cursor-pointer d-flex align-items-center justify-content-center button anwp-border-red-600",
                    onClick: _cache[14] || (_cache[14] = withModifiers(($event) => {
                      unref(gameStore).captainAway = "";
                    }, ["prevent"]))
                  }, [..._cache[19] || (_cache[19] = [
                    createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                      createBaseVNode("use", { "xlink:href": "#icon-x" })
                    ], -1)
                  ])])
                ])) : (openBlock(), createElementBlock("button", {
                  key: 1,
                  type: "button",
                  class: "button button-secondary px-4 py-1 d-block my-3",
                  onClick: _cache[15] || (_cache[15] = withModifiers(($event) => unref(gameStore).openModalCaptainSelector("away"), ["prevent"]))
                }, toDisplayString(unref(l10n).select_player), 1))
              ])
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_coach_home",
            value: ((_h = unref(gameStore).coachHome) == null ? void 0 : _h.id) || ""
          }, null, 8, _hoisted_28$7),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_coach_away",
            value: ((_i = unref(gameStore).coachAway) == null ? void 0 : _i.id) || ""
          }, null, 8, _hoisted_29$7),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_temp_coach",
            value: JSON.stringify(unref(gameStore).tempCoach)
          }, null, 8, _hoisted_30$7),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_captain_home",
            value: ((_j = unref(gameStore).captainHome) == null ? void 0 : _j.id) || ""
          }, null, 8, _hoisted_31$7),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_captain_away",
            value: ((_k = unref(gameStore).captainAway) == null ? void 0 : _k.id) || ""
          }, null, 8, _hoisted_32$7),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_custom_numbers",
            value: JSON.stringify(unref(gameStore).customNumbers)
          }, null, 8, _hoisted_33$7),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_temp_players",
            value: JSON.stringify(unref(gameStore).tempPlayers)
          }, null, 8, _hoisted_34$6),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_players_home_line_up",
            value: unref(gameStore).playersHomeStartIds.join(",")
          }, null, 8, _hoisted_35$6),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_players_home_subs",
            value: unref(gameStore).playersHomeSubsIds.join(",")
          }, null, 8, _hoisted_36$6),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_players_away_line_up",
            value: unref(gameStore).playersAwayStartIds.join(",")
          }, null, 8, _hoisted_37$6),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_players_away_subs",
            value: unref(gameStore).playersAwaySubsIds.join(",")
          }, null, 8, _hoisted_38$5)
        ]);
      };
    }
  };
  const _hoisted_1$z = { class: "anwp-vfm-admin-modal__title d-flex flex-wrap align-items-center" };
  const _hoisted_2$u = { class: "my-0 mr-3" };
  const _hoisted_3$u = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$t = { class: "d-md-flex" };
  const _hoisted_5$s = { class: "col-md-6 bg-light py-3" };
  const _hoisted_6$r = { class: "mb-2 py-1 px-2 anwp-bg-gray-200 anwp-text-base anwp-border anwp-border-gray-400 d-flex" };
  const _hoisted_7$p = { class: "ml-auto" };
  const _hoisted_8$n = { class: "px-3 anwp-text-base" };
  const _hoisted_9$j = { class: "mb-2 py-1 px-2 anwp-bg-gray-200 anwp-text-base anwp-border anwp-border-gray-400 d-flex" };
  const _hoisted_10$i = { class: "ml-auto" };
  const _hoisted_11$h = { class: "px-3 anwp-text-base" };
  const _hoisted_12$h = { class: "mb-2 py-1 px-2 anwp-bg-gray-200 anwp-text-base anwp-border anwp-border-gray-400 d-flex" };
  const _hoisted_13$g = { class: "ml-auto" };
  const _hoisted_14$g = { class: "px-3 anwp-text-base" };
  const _hoisted_15$f = { class: "mb-2 py-1 px-2 anwp-bg-gray-200 anwp-text-base anwp-border anwp-border-gray-400 d-flex" };
  const _hoisted_16$f = { class: "ml-auto" };
  const _hoisted_17$e = { class: "px-3 anwp-text-base" };
  const _hoisted_18$d = { class: "px-3 anwp-text-base" };
  const _hoisted_19$d = { class: "px-3 anwp-text-base" };
  const _hoisted_20$b = { class: "col-md-6 py-0 anwp-h-min-300" };
  const _hoisted_21$b = {
    key: 0,
    class: "d-flex mb-4 anwp-fl-tabs-wrapper"
  };
  const _hoisted_22$b = { class: "anwp-text-base" };
  const _hoisted_23$9 = { class: "anwp-text-xs mt-2" };
  const _hoisted_24$8 = { class: "anwp-text-base" };
  const _hoisted_25$6 = { class: "anwp-text-xs mt-2" };
  const _hoisted_26$6 = { class: "d-flex flex-column mt-4" };
  const _hoisted_27$6 = { class: "d-flex flex-column mt-3" };
  const _hoisted_28$6 = ["value"];
  const _hoisted_29$6 = { class: "d-flex flex-column mt-3" };
  const _hoisted_30$6 = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-temp-country"
  };
  const _hoisted_31$6 = ["value"];
  const _hoisted_32$6 = {
    key: 0,
    class: "anwp-bg-gray-200 px-2 mx-n2 anwp-text-gray-800"
  };
  const _hoisted_33$6 = { class: "d-flex flex-column" };
  const _hoisted_34$5 = ["onClick"];
  const _hoisted_35$5 = {
    key: 1,
    class: "anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold anwp-bg-gray-300"
  };
  const _hoisted_36$5 = { class: "pl-3 align-middle" };
  const _hoisted_37$5 = {
    class: "options__flag f32 align-middle",
    style: { "line-height": "12px" }
  };
  const _hoisted_38$4 = { class: "px-3 d-flex flex-column" };
  const _hoisted_39$4 = { class: "anwp-text-base anwp-leading-1" };
  const _hoisted_40$4 = { class: "anwp-text-gray-600 d-flex align-items-center anwp-text-xs" };
  const _hoisted_41$4 = {
    key: 0,
    class: "mx-2"
  };
  const _hoisted_42$3 = { class: "ml-auto anwp-text-center position-relative" };
  const _hoisted_43$3 = {
    class: "anwp-fl-icon--shirt-number",
    style: { "top": "10px", "left": "0" }
  };
  const _hoisted_44$3 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_45$3 = { class: "d-flex align-items-center" };
  const _hoisted_46$3 = { value: true };
  const _hoisted_47$3 = { value: false };
  const _sfc_main$z = {
    __name: "AppModalAddPlayer",
    setup(__props) {
      const notyf2 = new Notyf({ duration: 5e3 });
      const l10n = window.anwpMatch.l10n;
      const gameStore = useGameStore();
      const modalPlayerSearch = ref(null);
      const onSelectedModalPlayersActions = (selected) => {
        gameStore.modalData.playerPageNumber = 1;
        if ("search_by_name" === selected.value) {
          setTimeout(() => {
            modalPlayerSearch.value.focus();
          }, 0);
        }
      };
      const addTempPlayerTo = () => {
        if (!gameStore.tempPlayer.name) {
          notyf2.error("Empty name not allowed");
          return false;
        }
        let playerObj = {
          id: `temp__${gameStore.tempPlayerID}`,
          birthdate: "",
          club_id: "home" === gameStore.modalData.playerContext ? Number(gameStore.clubHome.id) : Number(gameStore.clubAway.id),
          country: gameStore.tempPlayer.country,
          position: gameStore.tempPlayer.position,
          photo: "",
          name: gameStore.tempPlayer.name
        };
        if ("home" === gameStore.modalData.playerContext) {
          gameStore.modalData.playerAppendStart ? gameStore.active.playersHomeStart.push(playerObj) : gameStore.active.playersHomeSubs.push(playerObj);
        } else {
          gameStore.modalData.playerAppendStart ? gameStore.active.playersAwayStart.push(playerObj) : gameStore.active.playersAwaySubs.push(playerObj);
        }
        gameStore.tempPlayers.push({
          id: playerObj.id,
          club_id: "home" === gameStore.modalData.playerContext ? gameStore.clubHome.id : gameStore.clubAway.id,
          country: gameStore.tempPlayer.country,
          position: gameStore.tempPlayer.position,
          name: gameStore.tempPlayer.name,
          context: gameStore.modalData.playerContext
        });
        gameStore.tempPlayerID++;
        gameStore.tempPlayer.name = "";
        gameStore.tempPlayer.position = "";
        gameStore.tempPlayer.country = "";
      };
      const addPlayerTo = (player) => {
        if ("home" === gameStore.modalData.playerContext || "away" === gameStore.modalData.playerContext) {
          let playerObj = {
            id: player.id,
            birthdate: player.birthdate,
            club_id: player.club_id,
            country: player.country,
            position: player.position,
            photo: player.photo,
            name: player.name
          };
          if ("home" === gameStore.modalData.playerContext) {
            gameStore.modalData.playerAppendStart ? gameStore.active.playersHomeStart.push(playerObj) : gameStore.active.playersHomeSubs.push(playerObj);
            if (Number(gameStore.appConfig.squadHomeNumbers[player.id])) {
              gameStore.customNumbers[player.id] = Number(gameStore.appConfig.squadHomeNumbers[player.id]);
            }
          } else {
            gameStore.modalData.playerAppendStart ? gameStore.active.playersAwayStart.push(playerObj) : gameStore.active.playersAwaySubs.push(playerObj);
            if (Number(gameStore.appConfig.squadAwayNumbers[player.id])) {
              gameStore.customNumbers[player.id] = Number(gameStore.appConfig.squadAwayNumbers[player.id]);
            }
          }
        } else if ("home-missing" === gameStore.modalData.playerContext || "away-missing" === gameStore.modalData.playerContext) {
          let missing = {
            reason: "injured",
            club: "",
            player: player.id,
            comment: "",
            playerObj: player
          };
          if ("home-missing" === gameStore.modalData.playerContext) {
            missing.club = gameStore.clubHome.id;
            gameStore.active.playersHomeMissing.push(missing);
          } else {
            missing.club = gameStore.clubAway.id;
            gameStore.active.playersAwayMissing.push(missing);
          }
        }
      };
      return (_ctx, _cache) => {
        const _component_v_select = resolveComponent("v-select");
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(gameStore).modals.addPlayer,
          "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => unref(gameStore).modals.addPlayer = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--top"
        }, {
          default: withCtx(() => {
            var _a2, _b2, _c, _d;
            return [
              createBaseVNode("button", {
                class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
                type: "button",
                onClick: _cache[0] || (_cache[0] = ($event) => unref(gameStore).modals.addPlayer = false)
              }, [..._cache[15] || (_cache[15] = [
                createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-x" })
                ], -1)
              ])]),
              createBaseVNode("div", _hoisted_1$z, [
                createBaseVNode("h4", _hoisted_2$u, toDisplayString(unref(l10n).add_player), 1),
                ("home" === unref(gameStore).modalData.playerContext || "away" === unref(gameStore).modalData.playerContext) && "temp" !== unref(gameStore).modalData.modalPlayerMode ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _cache[17] || (_cache[17] = createBaseVNode("div", { class: "ml-auto mr-2" }, "Sort By", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(gameStore).modalData.playerAddSorting = $event),
                    class: "mr-4"
                  }, [..._cache[16] || (_cache[16] = [
                    createBaseVNode("option", { value: "" }, "name", -1),
                    createBaseVNode("option", { value: "position" }, "position", -1),
                    createBaseVNode("option", { value: "squad_number" }, "squad number", -1),
                    createBaseVNode("option", { value: "squad_order" }, "squad order", -1)
                  ])], 512), [
                    [vModelSelect, unref(gameStore).modalData.playerAddSorting]
                  ])
                ], 64)) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_3$u, [
                createBaseVNode("div", _hoisted_4$t, [
                  createBaseVNode("div", _hoisted_5$s, [
                    "home" === unref(gameStore).modalData.playerContext ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createBaseVNode("div", _hoisted_6$r, [
                        createTextVNode(toDisplayString(unref(l10n).starting_line_up) + " ", 1),
                        createBaseVNode("span", _hoisted_7$p, "(" + toDisplayString(((_a2 = unref(gameStore).active.playersHomeStart) == null ? void 0 : _a2.length) || 0) + ")", 1)
                      ]),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersHomeStart, (player) => {
                        return openBlock(), createElementBlock("div", {
                          class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white",
                          key: player.id
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold", player.position ? unref(gameStore).appConfig.classPosition[player.position] : ""])
                          }, toDisplayString(player.position ? player.position.charAt(0) : ""), 3),
                          createBaseVNode("div", _hoisted_8$n, toDisplayString(player.name), 1)
                        ]);
                      }), 128)),
                      createBaseVNode("div", _hoisted_9$j, [
                        createTextVNode(toDisplayString(unref(l10n).substitutes) + " ", 1),
                        createBaseVNode("span", _hoisted_10$i, "(" + toDisplayString(((_b2 = unref(gameStore).active.playersHomeSubs) == null ? void 0 : _b2.length) || 0) + ")", 1)
                      ]),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersHomeSubs, (player) => {
                        return openBlock(), createElementBlock("div", {
                          class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white",
                          key: player.id
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold", player.position ? unref(gameStore).appConfig.classPosition[player.position] : ""])
                          }, toDisplayString(player.position ? player.position.charAt(0) : ""), 3),
                          createBaseVNode("div", _hoisted_11$h, toDisplayString(player.name), 1)
                        ]);
                      }), 128))
                    ], 64)) : "away" === unref(gameStore).modalData.playerContext ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createBaseVNode("div", _hoisted_12$h, [
                        createTextVNode(toDisplayString(unref(l10n).starting_line_up) + " ", 1),
                        createBaseVNode("span", _hoisted_13$g, "(" + toDisplayString(((_c = unref(gameStore).active.playersAwayStart) == null ? void 0 : _c.length) || 0) + ")", 1)
                      ]),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersAwayStart, (player) => {
                        return openBlock(), createElementBlock("div", {
                          class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white",
                          key: player.id
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold", player.position ? unref(gameStore).appConfig.classPosition[player.position] : ""])
                          }, toDisplayString(player.position ? player.position.charAt(0) : ""), 3),
                          createBaseVNode("div", _hoisted_14$g, toDisplayString(player.name), 1)
                        ]);
                      }), 128)),
                      createBaseVNode("div", _hoisted_15$f, [
                        createTextVNode(toDisplayString(unref(l10n).substitutes) + " ", 1),
                        createBaseVNode("span", _hoisted_16$f, "(" + toDisplayString(((_d = unref(gameStore).active.playersAwaySubs) == null ? void 0 : _d.length) || 0) + ")", 1)
                      ]),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersAwaySubs, (player) => {
                        return openBlock(), createElementBlock("div", {
                          class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white",
                          key: player.id
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold", player.position ? unref(gameStore).appConfig.classPosition[player.position] : ""])
                          }, toDisplayString(player.position ? player.position.charAt(0) : ""), 3),
                          createBaseVNode("div", _hoisted_17$e, toDisplayString(player.name), 1)
                        ]);
                      }), 128))
                    ], 64)) : "home-missing" === unref(gameStore).modalData.playerContext ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(unref(gameStore).active.playersHomeMissing, (missing) => {
                      return openBlock(), createElementBlock("div", {
                        class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white",
                        key: missing.player
                      }, [
                        createBaseVNode("div", {
                          class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold", missing.playerObj.position ? unref(gameStore).appConfig.classPosition[missing.playerObj.position] : ""])
                        }, toDisplayString(missing.playerObj.position ? missing.playerObj.position.charAt(0) : ""), 3),
                        createBaseVNode("div", _hoisted_18$d, toDisplayString(missing.playerObj.name), 1)
                      ]);
                    }), 128)) : "away-missing" === unref(gameStore).modalData.playerContext ? (openBlock(true), createElementBlock(Fragment, { key: 3 }, renderList(unref(gameStore).active.playersAwayMissing, (missing) => {
                      return openBlock(), createElementBlock("div", {
                        class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white",
                        key: missing.player
                      }, [
                        createBaseVNode("div", {
                          class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold", missing.playerObj.position ? unref(gameStore).appConfig.classPosition[missing.playerObj.position] : ""])
                        }, toDisplayString(missing.playerObj.position ? missing.playerObj.position.charAt(0) : ""), 3),
                        createBaseVNode("div", _hoisted_19$d, toDisplayString(missing.playerObj.name), 1)
                      ]);
                    }), 128)) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_20$b, [
                    "home" === unref(gameStore).modalData.playerContext || "away" === unref(gameStore).modalData.playerContext ? (openBlock(), createElementBlock("div", _hoisted_21$b, [
                      createBaseVNode("div", {
                        class: normalizeClass(["anwp-tab-item anwp-flex-1 mr-1", unref(gameStore).modalData.modalPlayerMode === "saved" ? "anwp-tab-item--active" : ""]),
                        onClick: _cache[2] || (_cache[2] = withModifiers(($event) => unref(gameStore).modalData.modalPlayerMode = "saved", ["prevent"]))
                      }, [
                        createBaseVNode("div", _hoisted_22$b, toDisplayString(unref(l10n).saved_players), 1),
                        createBaseVNode("div", _hoisted_23$9, toDisplayString(unref(l10n).select_saved_players), 1)
                      ], 2),
                      createBaseVNode("div", {
                        class: normalizeClass(["anwp-tab-item anwp-flex-1 ml-1", unref(gameStore).modalData.modalPlayerMode === "temp" ? "anwp-tab-item--active" : ""]),
                        onClick: _cache[3] || (_cache[3] = withModifiers(($event) => unref(gameStore).modalData.modalPlayerMode = "temp", ["prevent"]))
                      }, [
                        createBaseVNode("div", _hoisted_24$8, toDisplayString(unref(l10n).temporary_players), 1),
                        createBaseVNode("div", _hoisted_25$6, toDisplayString(unref(l10n).add_player_as_text), 1)
                      ], 2)
                    ])) : createCommentVNode("", true),
                    "temp" === unref(gameStore).modalData.modalPlayerMode ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createBaseVNode("div", _hoisted_26$6, [
                        _cache[18] || (_cache[18] = createBaseVNode("label", {
                          class: "mb-1 anwp-text-gray-800",
                          for: "anwp-fl-input-temp-name"
                        }, "Player Name", -1)),
                        withDirectives(createBaseVNode("input", {
                          name: "_anwpfl_attendance",
                          type: "text",
                          id: "anwp-fl-input-temp-name",
                          class: "w-100 anwp-w-min-100",
                          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(gameStore).tempPlayer.name = $event)
                        }, null, 512), [
                          [vModelText, unref(gameStore).tempPlayer.name]
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_27$6, [
                        _cache[19] || (_cache[19] = createBaseVNode("label", {
                          class: "mb-1 anwp-text-gray-800",
                          for: "anwp-fl-input-temp-position"
                        }, "Position", -1)),
                        withDirectives(createBaseVNode("select", {
                          id: "anwp-fl-input-temp-position",
                          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(gameStore).tempPlayer.position = $event)
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).appConfig.positions, (positionName, positionSlug) => {
                            return openBlock(), createElementBlock("option", { value: positionSlug }, toDisplayString(positionName), 9, _hoisted_28$6);
                          }), 256))
                        ], 512), [
                          [vModelSelect, unref(gameStore).tempPlayer.position]
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_29$6, [
                        createBaseVNode("label", _hoisted_30$6, toDisplayString(unref(l10n).nationality), 1),
                        withDirectives(createBaseVNode("select", {
                          id: "anwp-fl-input-temp-country",
                          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(gameStore).tempPlayer.country = $event)
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).appConfig.countries, (countryName, countryCode) => {
                            return openBlock(), createElementBlock("option", { value: countryCode }, toDisplayString(countryName), 9, _hoisted_31$6);
                          }), 256))
                        ], 512), [
                          [vModelSelect, unref(gameStore).tempPlayer.country]
                        ])
                      ]),
                      createBaseVNode("button", {
                        class: "button button-primary d-flex align-items-center mt-4 w-100 justify-content-center py-1 px-4",
                        type: "button",
                        onClick: _cache[7] || (_cache[7] = withModifiers(($event) => addTempPlayerTo(), ["prevent"]))
                      }, "Add Temporary Player")
                    ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                      createVNode(_component_v_select, {
                        label: "name",
                        modelValue: unref(gameStore).modalData.playerActiveActions,
                        "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => unref(gameStore).modalData.playerActiveActions = $event),
                        options: unref(gameStore).modalData.playerActions,
                        clearable: false,
                        filterable: false,
                        searchable: false,
                        "onOption:selected": onSelectedModalPlayersActions,
                        selectable: (option) => !option.hasOwnProperty("group"),
                        reduce: (o2) => o2.value
                      }, {
                        option: withCtx(({ group, name }) => [
                          group ? (openBlock(), createElementBlock("div", _hoisted_32$6, toDisplayString(group), 1)) : createCommentVNode("", true),
                          createTextVNode(" " + toDisplayString(name), 1)
                        ]),
                        _: 1
                      }, 8, ["modelValue", "options", "selectable", "reduce"]),
                      withDirectives(createBaseVNode("div", null, [
                        _cache[20] || (_cache[20] = createBaseVNode("hr", null, null, -1)),
                        createBaseVNode("div", _hoisted_33$6, [
                          withDirectives(createBaseVNode("input", {
                            type: "text",
                            "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => unref(gameStore).modalData.playerSearch = $event),
                            onInput: _cache[10] || (_cache[10] = ($event) => unref(gameStore).modalData.playerPageNumber = 1),
                            class: "w-100",
                            ref_key: "modalPlayerSearch",
                            ref: modalPlayerSearch
                          }, null, 544), [
                            [vModelText, unref(gameStore).modalData.playerSearch]
                          ])
                        ])
                      ], 512), [
                        [vShow, "search_by_name" === unref(gameStore).modalData.playerActiveActions]
                      ]),
                      _cache[22] || (_cache[22] = createBaseVNode("hr", null, null, -1)),
                      unref(gameStore).playersInModal.length ? (openBlock(), createBlock(unref(Paginate), {
                        key: 0,
                        class: "anwp-user-select-none mb-2 mb-0",
                        modelValue: unref(gameStore).modalData.playerPageNumber,
                        "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => unref(gameStore).modalData.playerPageNumber = $event),
                        "page-count": unref(gameStore).playersInModalPages,
                        "prev-text": unref(l10n).prev,
                        "next-text": unref(l10n).next,
                        "container-class": "anwp-pagination",
                        "page-class": "anwp-page-item",
                        "prev-class": "anwp-page-item",
                        "next-class": "anwp-page-item",
                        "next-link-class": "anwp-page-link",
                        "prev-link-class": "anwp-page-link",
                        "page-link-class": "anwp-page-link"
                      }, null, 8, ["modelValue", "page-count", "prev-text", "next-text"])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).playersInModalPaginated, (player) => {
                        return openBlock(), createElementBlock("div", {
                          class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white",
                          key: player.id
                        }, [
                          createBaseVNode("button", {
                            class: "button d-flex align-items-center mr-3",
                            type: "button",
                            onClick: withModifiers(($event) => addPlayerTo(player), ["prevent"])
                          }, "+", 8, _hoisted_34$5),
                          player.position ? (openBlock(), createElementBlock("div", {
                            key: 0,
                            class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold", unref(gameStore).appConfig.classPosition[player.position]])
                          }, toDisplayString(player.position ? player.position.charAt(0) : ""), 3)) : (openBlock(), createElementBlock("div", _hoisted_35$5, " ? ")),
                          createBaseVNode("div", _hoisted_36$5, [
                            createBaseVNode("span", _hoisted_37$5, [
                              createBaseVNode("span", {
                                class: normalizeClass(["flag", player.country])
                              }, null, 2)
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_38$4, [
                            createBaseVNode("div", _hoisted_39$4, toDisplayString(player.name), 1),
                            createBaseVNode("div", _hoisted_40$4, [
                              createBaseVNode("div", null, toDisplayString(unref(gameStore).appConfig.clubsMap[player.club_id] ? unref(gameStore).appConfig.clubsMap[player.club_id] : ""), 1),
                              unref(gameStore).appConfig.clubsMap[player.club_id] && player.birthdate ? (openBlock(), createElementBlock("div", _hoisted_41$4, " - ")) : createCommentVNode("", true),
                              createBaseVNode("div", null, toDisplayString(player.birthdate), 1)
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_42$3, [
                            _cache[21] || (_cache[21] = createBaseVNode("svg", { class: "anwp-icon anwp-fl-icon--shirt" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-shirt" })
                            ], -1)),
                            createBaseVNode("div", _hoisted_43$3, [
                              "home" === unref(gameStore).modalData.playerContext ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                createTextVNode(toDisplayString(unref(gameStore).appConfig.squadHomeNumbers[player.id] ? unref(gameStore).appConfig.squadHomeNumbers[player.id] : ""), 1)
                              ], 64)) : "away" === unref(gameStore).modalData.playerContext ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                createTextVNode(toDisplayString(unref(gameStore).appConfig.squadAwayNumbers[player.id] ? unref(gameStore).appConfig.squadAwayNumbers[player.id] : ""), 1)
                              ], 64)) : createCommentVNode("", true)
                            ])
                          ])
                        ]);
                      }), 128))
                    ], 64))
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_44$3, [
                createBaseVNode("div", _hoisted_45$3, [
                  "home" === unref(gameStore).modalData.playerContext || "away" === unref(gameStore).modalData.playerContext ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    _cache[23] || (_cache[23] = createBaseVNode("div", { class: "mr-2" }, "Append To", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => unref(gameStore).modalData.playerAppendStart = $event)
                    }, [
                      createBaseVNode("option", _hoisted_46$3, toDisplayString(unref(l10n).starting_line_up), 1),
                      createBaseVNode("option", _hoisted_47$3, toDisplayString(unref(l10n).substitutes), 1)
                    ], 512), [
                      [vModelSelect, unref(gameStore).modalData.playerAppendStart]
                    ])
                  ], 64)) : createCommentVNode("", true),
                  createBaseVNode("button", {
                    type: "button",
                    class: "button button-secondary text-capitalize ml-auto",
                    onClick: _cache[13] || (_cache[13] = ($event) => unref(gameStore).modals.addPlayer = false)
                  }, toDisplayString(unref(l10n).close), 1)
                ])
              ])
            ];
          }),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$y = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$t = { class: "my-0" };
  const _hoisted_3$t = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$s = { class: "anwp-text-center" };
  const _hoisted_5$r = { class: "mb-1" };
  const _hoisted_6$q = { class: "mb-1 mt-3" };
  const _hoisted_7$o = ["value"];
  const _hoisted_8$m = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_9$i = { class: "d-flex flex-row-reverse" };
  const _sfc_main$y = {
    __name: "AppModalCustomNumber",
    setup(__props) {
      const gameStore = useGameStore();
      const changeCustomNumberInput = ref(null);
      const l10n = window.anwpMatch.l10n;
      const focusNumber = () => {
        changeCustomNumberInput.value.focus();
        changeCustomNumberInput.value.select();
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(gameStore).modals.changeCustomNumber,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(gameStore).modals.changeCustomNumber = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          onOpened: focusNumber,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(gameStore).modals.changeCustomNumber = false)
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            unref(gameStore).modalData.customNumberPlayerId ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_1$y, [
                createBaseVNode("h4", _hoisted_2$t, [
                  createTextVNode(toDisplayString(unref(l10n).edit_player_number) + " ", 1),
                  unref(gameStore).modalData.customNumberPlayerId.toString().includes("temp__") ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(" - " + toDisplayString(unref(gameStore).tempPlayers.find((p2) => unref(gameStore).modalData.customNumberPlayerId === `temp__${p2.id}`) ? unref(gameStore).tempPlayers.find((p2) => unref(gameStore).modalData.customNumberPlayerId === `temp__${p2.id}`).name : ""), 1)
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(" - " + toDisplayString(unref(gameStore).appConfig.players.find((p2) => p2.id === unref(gameStore).modalData.customNumberPlayerId) ? unref(gameStore).appConfig.players.find((p2) => p2.id === unref(gameStore).modalData.customNumberPlayerId).name : ""), 1)
                  ], 64))
                ])
              ]),
              createBaseVNode("div", _hoisted_3$t, [
                createBaseVNode("div", _hoisted_4$s, [
                  createBaseVNode("div", _hoisted_5$r, toDisplayString(unref(l10n).custom_number), 1),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    class: "anwp-w-50 anwp-text-xl anwp-text-center",
                    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => unref(gameStore).modals.changeCustomNumber = false, ["prevent"]), ["enter"])),
                    ref_key: "changeCustomNumberInput",
                    ref: changeCustomNumberInput,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(gameStore).customNumbers[unref(gameStore).modalData.customNumberPlayerId] = $event)
                  }, null, 544), [
                    [vModelText, unref(gameStore).customNumbers[unref(gameStore).modalData.customNumberPlayerId]]
                  ]),
                  createBaseVNode("div", _hoisted_6$q, toDisplayString(unref(l10n).squad_number), 1),
                  createBaseVNode("input", {
                    type: "text",
                    disabled: "",
                    class: "anwp-w-50 anwp-text-xl anwp-text-center",
                    value: unref(gameStore).appConfig.squadHomeNumbers[unref(gameStore).modalData.customNumberPlayerId] ? unref(gameStore).appConfig.squadHomeNumbers[unref(gameStore).modalData.customNumberPlayerId] : unref(gameStore).appConfig.squadAwayNumbers[unref(gameStore).modalData.customNumberPlayerId]
                  }, null, 8, _hoisted_7$o)
                ])
              ])
            ], 64)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_8$m, [
              createBaseVNode("div", _hoisted_9$i, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button",
                  onClick: _cache[3] || (_cache[3] = ($event) => unref(gameStore).modals.changeCustomNumber = false)
                }, toDisplayString(unref(l10n).close), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$x = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$s = { class: "my-0 mr-4" };
  const _hoisted_3$s = { class: "anwp-vfm-admin-modal__content anwp-h-min-300" };
  const _hoisted_4$r = { class: "d-flex mb-4 anwp-fl-tabs-wrapper" };
  const _hoisted_5$q = { class: "anwp-text-base" };
  const _hoisted_6$p = { class: "anwp-text-xs mt-2" };
  const _hoisted_7$n = { class: "anwp-text-base" };
  const _hoisted_8$l = { class: "anwp-text-xs mt-2" };
  const _hoisted_9$h = { class: "d-flex flex-column mt-4" };
  const _hoisted_10$h = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-temp-name"
  };
  const _hoisted_11$g = { class: "d-flex flex-column mt-3" };
  const _hoisted_12$g = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-temp-country"
  };
  const _hoisted_13$f = ["value"];
  const _hoisted_14$f = { class: "d-flex flex-column" };
  const _hoisted_15$e = {
    for: "anwp-fl-modal-coach-search",
    class: "mb-1"
  };
  const _hoisted_16$e = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_17$d = { class: "d-flex align-items-center" };
  const _sfc_main$x = {
    __name: "AppModalCoachSelector",
    setup(__props) {
      const gameStore = useGameStore();
      const l10n = window.anwpMatch.l10n;
      const pageNumber = ref(1);
      const search = ref("");
      const activeAction = ref("club_squad");
      const modalCoachSearch = ref(null);
      const coachActions = [
        { name: l10n.club_squad.toLowerCase(), value: "club_squad" },
        { name: l10n.club_coach, value: "club_coach" },
        { name: l10n.search_by_name, value: "search_by_name" }
      ];
      const onSelectedModalCoachActions = (selected) => {
        pageNumber.value = 1;
        if ("search_by_name" === selected.value) {
          setTimeout(() => {
            modalCoachSearch.value.focus();
          }, 0);
        }
      };
      const coachesInModal = computed(() => {
        let coaches = gameStore.appConfig.coaches;
        if ("club_squad" === activeAction.value) {
          return coaches.filter((p2) => squadIds.value.map(Number).includes(Number(p2.id)));
        } else if ("club_coach" === activeAction.value) {
          return coaches.filter((p2) => Number(p2.club_id) === Number("coachHome" === gameStore.modalData.coachSide ? gameStore.clubHome.id : gameStore.clubAway.id));
        } else if ("search_by_name" === activeAction.value && "" !== search.value.trim()) {
          return coaches.filter((p2) => p2.name.toLowerCase().indexOf(search.value.toLowerCase()) > -1);
        }
        return coaches;
      });
      const coachesInModalPaginated = computed(() => {
        if (!coachesInModal.value.length) {
          return [];
        }
        return coachesInModal.value.slice((pageNumber.value - 1) * 10, pageNumber.value * 10);
      });
      const coachesPages = computed(() => {
        return coachesInModal.value.length ? Math.ceil(coachesInModal.value.length / 10) : 0;
      });
      const squadIds = computed(() => {
        return "coachHome" === gameStore.modalData.coachSide ? gameStore.appConfig.staffHome : gameStore.appConfig.staffAway;
      });
      const addCoach = (coachObj) => {
        if ("coachHome" === gameStore.modalData.coachSide) {
          gameStore.coachHome = coachObj;
        } else {
          gameStore.coachAway = coachObj;
        }
        gameStore.modals.addCoach = false;
      };
      const addTempCoach = (coachObj) => {
        coachObj.id = "temp";
        gameStore.tempCoach[gameStore.modalData.coachSide] = coachObj;
        if ("coachHome" === gameStore.modalData.coachSide) {
          gameStore.coachHome = coachObj;
        } else {
          gameStore.coachAway = coachObj;
        }
        gameStore.modals.addCoach = false;
      };
      return (_ctx, _cache) => {
        const _component_v_select = resolveComponent("v-select");
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(gameStore).modals.addCoach,
          "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => unref(gameStore).modals.addCoach = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          onBeforeOpen: _cache[12] || (_cache[12] = ($event) => activeAction.value = "club_squad"),
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--top anwp-vfm-admin-modal__wrapper--medium"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(gameStore).modals.addCoach = false)
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$x, [
              createBaseVNode("h4", _hoisted_2$s, toDisplayString(unref(l10n).add_coach), 1)
            ]),
            createBaseVNode("div", _hoisted_3$s, [
              createBaseVNode("div", _hoisted_4$r, [
                createBaseVNode("div", {
                  class: normalizeClass(["anwp-tab-item anwp-flex-1 mr-1", unref(gameStore).modalData.modalCoachMode === "saved" ? "anwp-tab-item--active" : ""]),
                  onClick: _cache[1] || (_cache[1] = withModifiers(($event) => unref(gameStore).modalData.modalCoachMode = "saved", ["prevent"]))
                }, [
                  createBaseVNode("div", _hoisted_5$q, toDisplayString(unref(l10n).saved_coaches), 1),
                  createBaseVNode("div", _hoisted_6$p, toDisplayString(unref(l10n).select_saved_coach), 1)
                ], 2),
                createBaseVNode("div", {
                  class: normalizeClass(["anwp-tab-item anwp-flex-1 ml-1", unref(gameStore).modalData.modalCoachMode === "temp" ? "anwp-tab-item--active" : ""]),
                  onClick: _cache[2] || (_cache[2] = withModifiers(($event) => unref(gameStore).modalData.modalCoachMode = "temp", ["prevent"]))
                }, [
                  createBaseVNode("div", _hoisted_7$n, toDisplayString(unref(l10n).temporary_coach), 1),
                  createBaseVNode("div", _hoisted_8$l, toDisplayString(unref(l10n).add_coach_as_text), 1)
                ], 2)
              ]),
              "temp" === unref(gameStore).modalData.modalCoachMode ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_9$h, [
                  createBaseVNode("label", _hoisted_10$h, toDisplayString(unref(l10n).coach_name), 1),
                  withDirectives(createBaseVNode("input", {
                    name: "_anwpfl_attendance",
                    type: "text",
                    id: "anwp-fl-input-temp-name",
                    class: "w-100 anwp-w-min-100",
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(gameStore).modalData.tempCoach.name = $event)
                  }, null, 512), [
                    [vModelText, unref(gameStore).modalData.tempCoach.name]
                  ])
                ]),
                createBaseVNode("div", _hoisted_11$g, [
                  createBaseVNode("label", _hoisted_12$g, toDisplayString(unref(l10n).nationality), 1),
                  withDirectives(createBaseVNode("select", {
                    id: "anwp-fl-input-temp-country",
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(gameStore).modalData.tempCoach.country = $event)
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).appConfig.countries, (countryName, countryCode) => {
                      return openBlock(), createElementBlock("option", { value: countryCode }, toDisplayString(countryName), 9, _hoisted_13$f);
                    }), 256))
                  ], 512), [
                    [vModelSelect, unref(gameStore).modalData.tempCoach.country]
                  ])
                ]),
                createBaseVNode("button", {
                  class: "button button-primary d-flex align-items-center mt-4 w-100 justify-content-center py-1 px-4",
                  type: "button",
                  onClick: _cache[5] || (_cache[5] = withModifiers(($event) => addTempCoach(unref(gameStore).modalData.tempCoach), ["prevent"]))
                }, toDisplayString(unref(l10n).add_temporary_coach), 1)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createVNode(_component_v_select, {
                  label: "name",
                  modelValue: activeAction.value,
                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => activeAction.value = $event),
                  options: coachActions,
                  clearable: false,
                  filterable: false,
                  searchable: false,
                  "onOption:selected": onSelectedModalCoachActions,
                  reduce: (o2) => o2.value
                }, null, 8, ["modelValue", "reduce"]),
                withDirectives(createBaseVNode("div", null, [
                  _cache[14] || (_cache[14] = createBaseVNode("hr", null, null, -1)),
                  createBaseVNode("div", _hoisted_14$f, [
                    createBaseVNode("label", _hoisted_15$e, toDisplayString(unref(l10n).search_by_name), 1),
                    withDirectives(createBaseVNode("input", {
                      id: "anwp-fl-modal-coach-search",
                      type: "text",
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => search.value = $event),
                      onInput: _cache[8] || (_cache[8] = ($event) => pageNumber.value = 1),
                      class: "w-100",
                      ref_key: "modalCoachSearch",
                      ref: modalCoachSearch
                    }, null, 544), [
                      [vModelText, search.value]
                    ])
                  ])
                ], 512), [
                  [vShow, "search_by_name" === activeAction.value]
                ]),
                _cache[15] || (_cache[15] = createBaseVNode("hr", null, null, -1)),
                coachesInModal.value.length ? (openBlock(), createBlock(unref(Paginate), {
                  key: 0,
                  class: "anwp-user-select-none mb-2 mb-0",
                  modelValue: pageNumber.value,
                  "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => pageNumber.value = $event),
                  "page-count": coachesPages.value,
                  "prev-text": unref(l10n).prev,
                  "next-text": unref(l10n).next,
                  "container-class": "anwp-pagination",
                  "page-class": "anwp-page-item",
                  "prev-class": "anwp-page-item",
                  "next-class": "anwp-page-item",
                  "next-link-class": "anwp-page-link",
                  "prev-link-class": "anwp-page-link",
                  "page-link-class": "anwp-page-link"
                }, null, 8, ["modelValue", "page-count", "prev-text", "next-text"])) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(coachesInModalPaginated.value, (coach) => {
                  return openBlock(), createBlock(_sfc_main$D, {
                    onClickCoach: ($event) => addCoach(coach),
                    class: "my-2",
                    key: coach.id,
                    coach,
                    defaultPhoto: unref(gameStore).appConfig.default_photo
                  }, null, 8, ["onClickCoach", "coach", "defaultPhoto"]);
                }), 128))
              ], 64))
            ]),
            createBaseVNode("div", _hoisted_16$e, [
              createBaseVNode("div", _hoisted_17$d, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary text-capitalize ml-auto",
                  onClick: _cache[10] || (_cache[10] = ($event) => unref(gameStore).modals.addCoach = false)
                }, toDisplayString(unref(l10n).close), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$w = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$r = { class: "my-0" };
  const _hoisted_3$r = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$q = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_5$p = { class: "d-flex" };
  const _sfc_main$w = {
    __name: "AppModalAddCaptain",
    setup(__props) {
      const gameStore = useGameStore();
      const l10n = window.anwpMatch.l10n;
      const captainModalList = computed(() => {
        let players = [];
        if ("home" === gameStore.modalData.captainSide) {
          players = gameStore.appConfig.players.filter((p2) => gameStore.playersHomeIds.includes(Number(p2.id)));
          if (gameStore.tempPlayers.length && gameStore.tempPlayers.filter((p2) => "home" === p2.context)) {
            players = players.concat(gameStore.tempPlayers.filter((p2) => "home" === p2.context));
          }
        } else {
          players = gameStore.appConfig.players.filter((p2) => gameStore.playersAwayIds.includes(Number(p2.id)));
          if (gameStore.tempPlayers.length && gameStore.tempPlayers.filter((p2) => "away" === p2.context)) {
            players = players.concat(gameStore.tempPlayers.filter((p2) => "away" === p2.context));
          }
        }
        if (players.length) {
          players = players.slice().sort((a2, b2) => {
            let a_number = gameStore.playerNumber[a2.id] > 0 ? gameStore.playerNumber[a2.id] : 9999;
            let b_number = gameStore.playerNumber[b2.id] > 0 ? gameStore.playerNumber[b2.id] : 9999;
            return a_number - b_number;
          });
        }
        return players;
      });
      const addModalCaptain = (playerObj) => {
        if ("home" === gameStore.modalData.captainSide) {
          gameStore.captainHome = playerObj;
        } else {
          gameStore.captainAway = playerObj;
        }
        gameStore.modals.addCaptain = false;
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(gameStore).modals.addCaptain,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(gameStore).modals.addCaptain = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--medium"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(gameStore).modals.addCaptain = false)
            }, [..._cache[3] || (_cache[3] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$w, [
              createBaseVNode("h4", _hoisted_2$r, toDisplayString(unref(l10n).select_player), 1)
            ]),
            createBaseVNode("div", _hoisted_3$r, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(captainModalList.value, (player) => {
                return openBlock(), createBlock(_sfc_main$B, {
                  onClickPlayer: ($event) => addModalCaptain(player),
                  class: "my-2",
                  key: player.id,
                  player,
                  defaultPhoto: unref(gameStore).appConfig.default_photo,
                  playerNumber: unref(gameStore).playerNumber,
                  classPosition: unref(gameStore).appConfig.classPosition
                }, null, 8, ["onClickPlayer", "player", "defaultPhoto", "playerNumber", "classPosition"]);
              }), 128))
            ]),
            createBaseVNode("div", _hoisted_4$q, [
              createBaseVNode("div", _hoisted_5$p, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary text-capitalize",
                  onClick: _cache[1] || (_cache[1] = ($event) => unref(gameStore).modals.addCaptain = false)
                }, toDisplayString(unref(l10n).close), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$v = {
    class: "anwp-border anwp-border-gray-500 my-4",
    id: "anwp-fl-game-events-metabox"
  };
  const _hoisted_2$q = { class: "p-4 bg-white" };
  const _hoisted_3$q = {
    key: 0,
    class: "table-responsive"
  };
  const _hoisted_4$p = { class: "table table-sm anwp-border-collapse anwp-overflow-scroll anwp-user-select-none anwp-leading-1 anwp-border anwp-border-gray-400 w-auto" };
  const _hoisted_5$o = { class: "anwp-w-40 anwp-text-center py-1 px-2 align-top anwp-bg-gray-200" };
  const _hoisted_6$o = { class: "anwp-text-base anwp-font-semibold pl-1" };
  const _hoisted_7$m = {
    key: 0,
    class: "anwp-border anwp-border-gray-200 pl-1"
  };
  const _hoisted_8$k = { class: "anwp-w-60 anwp-text-center px-3 pt-3 pb-1 align-top" };
  const _hoisted_9$g = {
    key: 0,
    "xlink:href": "#icon-ball_penalty"
  };
  const _hoisted_10$g = {
    key: 1,
    "xlink:href": "#icon-ball"
  };
  const _hoisted_11$f = {
    key: 1,
    class: "icon__substitute anwp-w-20 anwp-h-20"
  };
  const _hoisted_12$f = {
    key: 2,
    class: "icon__card anwp-w-20 anwp-h-20"
  };
  const _hoisted_13$e = ["xlink:href"];
  const _hoisted_14$e = {
    key: 3,
    class: "icon__ball anwp-w-20 anwp-h-20"
  };
  const _hoisted_15$d = { class: "anwp-text-left py-2 px-1 align-top" };
  const _hoisted_16$d = { class: "anwp-text-gray-800 anwp-text-base text-uppercase text-nowrap" };
  const _hoisted_17$c = { key: 0 };
  const _hoisted_18$c = { key: 1 };
  const _hoisted_19$c = { key: 1 };
  const _hoisted_20$a = {
    key: 0,
    class: "anwp-text-xs text-nowrap anwp-text-gray-600"
  };
  const _hoisted_21$a = { class: "anwp-w-80 anwp-text-center py-2 pl-3 pr-0 align-top" };
  const _hoisted_22$a = ["src"];
  const _hoisted_23$8 = ["src"];
  const _hoisted_24$7 = { class: "py-2 px-1 anwp-w-10 anwp-text-center align-top" };
  const _hoisted_25$5 = {
    key: 0,
    class: "position-relative anwp-cursor-pointer ml-2 anwp-w-50"
  };
  const _hoisted_26$5 = { class: "anwp-fl-icon--shirt-number" };
  const _hoisted_27$5 = { class: "p-2 anwp-text-base anwp-leading-1 align-top" };
  const _hoisted_28$5 = { class: "anwp-text-gray-600 anwp-text-xs anwp-leading-1 mb-1" };
  const _hoisted_29$5 = { class: "py-2 px-1 anwp-w-10 anwp-text-center align-top" };
  const _hoisted_30$5 = {
    key: 0,
    class: "position-relative anwp-cursor-pointer ml-2 anwp-w-50"
  };
  const _hoisted_31$5 = { class: "anwp-fl-icon--shirt-number" };
  const _hoisted_32$5 = { class: "p-2 anwp-text-base anwp-leading-1 align-top" };
  const _hoisted_33$5 = { class: "anwp-text-gray-600 anwp-text-xs anwp-leading-1 mb-1" };
  const _hoisted_34$4 = { class: "anwp-text-left p-2 align-top d-none" };
  const _hoisted_35$4 = ["innerHTML"];
  const _hoisted_36$4 = { class: "p-2 anwp-w-10 anwp-text-center align-top" };
  const _hoisted_37$4 = ["onClick"];
  const _hoisted_38$3 = { class: "p-2 anwp-w-10 anwp-text-center align-top" };
  const _hoisted_39$3 = ["onClick"];
  const _hoisted_40$3 = { class: "mt-3" };
  const _hoisted_41$3 = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_42$2 = { class: "my-0" };
  const _hoisted_43$2 = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_44$2 = { class: "anwp-text-center" };
  const _hoisted_45$2 = { class: "anwp-text-lg anwp-font-bold" };
  const _hoisted_46$2 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_47$2 = { class: "d-flex flex-row-reverse" };
  const _hoisted_48$2 = { class: "anwp-vfm-admin-modal__content d-sm-flex flex-wrap" };
  const _hoisted_49$1 = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_50$1 = { class: "mb-1 anwp-text-gray-800" };
  const _hoisted_51$1 = ["value"];
  const _hoisted_52$1 = {
    key: 0,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_53 = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-input-event-card"
  };
  const _hoisted_54 = { value: "y" };
  const _hoisted_55 = { value: "yr" };
  const _hoisted_56 = { value: "r" };
  const _hoisted_57 = {
    key: 1,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_58 = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-input-own-goal"
  };
  const _hoisted_59 = { value: "" };
  const _hoisted_60 = { value: "yes" };
  const _hoisted_61 = {
    key: 2,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_62 = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-input-from-penalty"
  };
  const _hoisted_63 = { value: "" };
  const _hoisted_64 = { value: "yes" };
  const _hoisted_65 = {
    key: 3,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_66 = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-input-shootout-scored"
  };
  const _hoisted_67 = { value: "" };
  const _hoisted_68 = { value: "yes" };
  const _hoisted_69 = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_70 = { class: "mb-1 anwp-text-gray-800" };
  const _hoisted_71 = { class: "d-flex align-items-center" };
  const _hoisted_72 = ["src"];
  const _hoisted_73 = { class: "d-flex align-items-center" };
  const _hoisted_74 = ["src"];
  const _hoisted_75 = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_76 = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-event-minute"
  };
  const _hoisted_77 = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_78 = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-event-minute-add"
  };
  const _hoisted_79 = { class: "d-flex flex-column mb-4 m-sm-2 px-2" };
  const _hoisted_80 = { class: "mb-1 anwp-text-gray-800" };
  const _hoisted_81 = {
    key: 0,
    class: "d-flex flex-wrap align-items-start"
  };
  const _hoisted_82 = {
    key: 4,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_83 = { class: "mb-1 anwp-text-gray-800" };
  const _hoisted_84 = {
    key: 0,
    class: "d-flex flex-wrap align-items-start"
  };
  const _hoisted_85 = {
    key: 5,
    class: "d-flex flex-column mb-4 m-sm-2 px-2"
  };
  const _hoisted_86 = { class: "mb-1 anwp-text-gray-800" };
  const _hoisted_87 = {
    key: 0,
    class: "d-flex flex-wrap align-items-start"
  };
  const _hoisted_88 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_89 = { class: "d-flex" };
  const _hoisted_90 = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_91 = { class: "my-0" };
  const _hoisted_92 = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_93 = {
    key: 0,
    class: "anwp-bg-yellow-100 anwp-border anwp-border-yellow-600 py-2 px-3 anwp-text-yellow-800"
  };
  const _hoisted_94 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_95 = { class: "d-flex" };
  const _hoisted_96 = { class: "mr-auto" };
  const _hoisted_97 = {
    for: "anwp-input-filter-players-by",
    class: "mb-0 mr-2"
  };
  const _hoisted_98 = { value: "match" };
  const _hoisted_99 = { value: "squad" };
  const _hoisted_100 = ["value"];
  const _sfc_main$v = {
    __name: "AppGameEvents",
    setup(__props) {
      const gameStore = useGameStore();
      const l10n = window.anwpMatch.l10n;
      const modalOpenEventDeleteConfirm = (eventIndex) => {
        gameStore.modalData.eventRemoveIndex = eventIndex;
        gameStore.modals.deleteEvent = true;
      };
      const removeEvent = () => {
        if (false !== gameStore.modalData.eventRemoveIndex) {
          gameStore.matchEvents.splice(gameStore.modalData.eventRemoveIndex, 1);
        }
        gameStore.modalData.eventRemoveIndex = false;
        gameStore.modals.deleteEvent = false;
      };
      const addEvent = () => {
        let eventObj = {
          type: "goal",
          club: "",
          minute: "",
          minuteAdd: "",
          player: "",
          assistant: "",
          playerOut: "",
          card: "y",
          ownGoal: "",
          fromPenalty: "",
          scored: "",
          playerObj: {},
          player2Obj: {},
          id: (/* @__PURE__ */ new Date()).getTime()
        };
        gameStore.matchEvents.push(eventObj);
        gameStore.modalData.eventInModal = eventObj;
        gameStore.modals.editEvent = true;
      };
      const editEvent = (eventObj) => {
        gameStore.modalData.eventInModal = eventObj;
        gameStore.modals.editEvent = true;
      };
      const openModalEventPlayerSelector = (context) => {
        gameStore.modalData.eventPlayerModalContext = context;
        gameStore.modals.addEventPlayer = true;
      };
      const addModalEventPlayer = (playerObj) => {
        if ("player" === gameStore.modalData.eventPlayerModalContext) {
          gameStore.modalData.eventInModal.playerObj = playerObj;
          gameStore.modalData.eventInModal.player = playerObj.id;
        } else if ("assistant" === gameStore.modalData.eventPlayerModalContext) {
          gameStore.modalData.eventInModal.player2Obj = playerObj;
          gameStore.modalData.eventInModal.assistant = playerObj.id;
        } else if ("playerOut" === gameStore.modalData.eventPlayerModalContext) {
          gameStore.modalData.eventInModal.player2Obj = playerObj;
          gameStore.modalData.eventInModal.playerOut = playerObj.id;
        }
        gameStore.modalData.eventPlayerModalContext = "";
        gameStore.modals.addEventPlayer = false;
      };
      const matchEventsCompact = computed(() => {
        return gameStore.matchEvents.map((_a2) => {
          var _b2 = _a2, { playerObj, player2Obj } = _b2, a2 = __objRest(_b2, ["playerObj", "player2Obj"]);
          return a2;
        });
      });
      const playersInEventModal = computed(() => {
        let players = [];
        let isOwnGoal = !!("goal" === gameStore.modalData.eventInModal.type && "yes" === gameStore.modalData.eventInModal.ownGoal);
        let isHomeTeam = Number(gameStore.modalData.eventInModal.club) === Number(gameStore.clubHome.id);
        let isAwayTeam = Number(gameStore.modalData.eventInModal.club) === Number(gameStore.clubAway.id);
        let playerContext = "player" === gameStore.modalData.eventPlayerModalContext;
        if (!gameStore.modalData.eventInModal.club) {
          return [];
        }
        if (isHomeTeam && !(playerContext && isOwnGoal) || isOwnGoal && isAwayTeam && playerContext) {
          if ("match" === gameStore.modalData.eventPlayersFilter) {
            players = gameStore.appConfig.players.filter((p2) => gameStore.playersHomeIds.includes(Number(p2.id)));
          } else if ("squad" === gameStore.modalData.eventPlayersFilter) {
            players = gameStore.appConfig.players.filter((p2) => Object.keys(gameStore.appConfig.squadHomeNumbers).map(Number).includes(Number(p2.id)));
          }
          if (gameStore.tempPlayers.length && gameStore.tempPlayers.filter((p2) => "home" === p2.context)) {
            players = players.concat(gameStore.tempPlayers.filter((p2) => "home" === p2.context));
          }
        } else {
          if ("match" === gameStore.modalData.eventPlayersFilter) {
            players = gameStore.appConfig.players.filter((p2) => gameStore.playersAwayIds.includes(Number(p2.id)));
          } else if ("squad" === gameStore.modalData.eventPlayersFilter) {
            players = gameStore.appConfig.players.filter((p2) => Object.keys(gameStore.appConfig.squadAwayNumbers).map(Number).includes(Number(p2.id)));
          }
          if (gameStore.tempPlayers.length && gameStore.tempPlayers.filter((p2) => "away" === p2.context)) {
            players = players.concat(gameStore.tempPlayers.filter((p2) => "away" === p2.context));
          }
        }
        if (players.length) {
          players = players.slice().sort((a2, b2) => {
            let a_number = gameStore.playerNumber[a2.id] > 0 ? gameStore.playerNumber[a2.id] : 9999;
            let b_number = gameStore.playerNumber[b2.id] > 0 ? gameStore.playerNumber[b2.id] : 9999;
            return a_number - b_number;
          });
        }
        return players;
      });
      return (_ctx, _cache) => {
        const _component_draggable = resolveComponent("draggable");
        const _component_v_select = resolveComponent("v-select");
        return openBlock(), createElementBlock("div", _hoisted_1$v, [
          createVNode(AppBlockHeader, { icon: "#icon-graph" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).match_events), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$q, [
            unref(gameStore).matchEvents.length ? (openBlock(), createElementBlock("div", _hoisted_3$q, [
              createBaseVNode("table", _hoisted_4$p, [
                createVNode(_component_draggable, {
                  modelValue: unref(gameStore).matchEvents,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(gameStore).matchEvents = $event),
                  handle: ".anwp-drag-handler",
                  tag: "tbody",
                  "force-fallback": true
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).matchEvents, (gameEvent, index2) => {
                      return openBlock(), createElementBlock("tr", {
                        class: "anwp-border anwp-border-gray-400 anwp-bg-gray-100",
                        key: gameEvent.id
                      }, [
                        _cache[35] || (_cache[35] = createBaseVNode("td", { class: "anwp-drag-handler anwp-w-30 anwp-text-center pt-1 px-2" }, [
                          createBaseVNode("svg", { class: "anwp-icon anwp-icon--s24 anwp-icon--octi mr-0" }, [
                            createBaseVNode("use", { "xlink:href": "#icon-grabber" })
                          ])
                        ], -1)),
                        createBaseVNode("td", _hoisted_5$o, [
                          createBaseVNode("div", _hoisted_6$o, toDisplayString(gameEvent.minute ? gameEvent.minute + "'" : ""), 1),
                          gameEvent.minuteAdd ? (openBlock(), createElementBlock("div", _hoisted_7$m, "+" + toDisplayString(gameEvent.minuteAdd), 1)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_8$k, [
                          "goal" === gameEvent.type ? (openBlock(), createElementBlock("svg", {
                            key: 0,
                            class: normalizeClass([{ "icon__ball--own": "yes" === gameEvent.ownGoal }, "icon__ball anwp-w-20 anwp-h-20"])
                          }, [
                            "yes" === gameEvent.fromPenalty ? (openBlock(), createElementBlock("use", _hoisted_9$g)) : (openBlock(), createElementBlock("use", _hoisted_10$g))
                          ], 2)) : "substitute" === gameEvent.type ? (openBlock(), createElementBlock("svg", _hoisted_11$f, [..._cache[29] || (_cache[29] = [
                            createBaseVNode("use", { "xlink:href": "#icon-substitute" }, null, -1)
                          ])])) : "card" === gameEvent.type ? (openBlock(), createElementBlock("svg", _hoisted_12$f, [
                            createBaseVNode("use", {
                              "xlink:href": "#icon-card_" + gameEvent.card
                            }, null, 8, _hoisted_13$e)
                          ])) : "missed_penalty" === gameEvent.type ? (openBlock(), createElementBlock("svg", _hoisted_14$e, [..._cache[30] || (_cache[30] = [
                            createBaseVNode("use", { "xlink:href": "#icon-ball_canceled" }, null, -1)
                          ])])) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_15$d, [
                          createBaseVNode("div", _hoisted_16$d, [
                            createTextVNode(toDisplayString(unref(l10n)[gameEvent.type] || gameEvent.type) + " ", 1),
                            "goal" === gameEvent.type ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                              "yes" === gameEvent.ownGoal ? (openBlock(), createElementBlock("span", _hoisted_17$c, "- Own Goal")) : createCommentVNode("", true),
                              "yes" === gameEvent.fromPenalty ? (openBlock(), createElementBlock("span", _hoisted_18$c, "- From Penalty")) : createCommentVNode("", true)
                            ], 64)) : "card" === gameEvent.type ? (openBlock(), createElementBlock("span", _hoisted_19$c, toDisplayString("y" === gameEvent.card ? unref(l10n).yellow : "yr" === gameEvent.card ? unref(l10n).yellow_red : unref(l10n).red), 1)) : "penalty_shootout" === gameEvent.type ? (openBlock(), createElementBlock("span", {
                              key: 2,
                              class: normalizeClass("yes" === gameEvent.scored ? "text-success" : "text-danger")
                            }, "Scored: " + toDisplayString("yes" === gameEvent.scored ? unref(l10n).yes : unref(l10n).no), 3)) : createCommentVNode("", true)
                          ]),
                          Number(gameEvent.club) === Number(unref(gameStore).clubHome.id) || Number(gameEvent.club) === Number(unref(gameStore).clubAway.id) ? (openBlock(), createElementBlock("div", _hoisted_20$a, toDisplayString(Number(gameEvent.club) === Number(unref(gameStore).clubHome.id) ? unref(gameStore).clubHome.title : unref(gameStore).clubAway.title), 1)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_21$a, [
                          Number(gameEvent.club) === Number(unref(gameStore).clubHome.id) && unref(gameStore).clubHome.logo ? (openBlock(), createElementBlock("img", {
                            key: 0,
                            src: unref(gameStore).clubHome.logo,
                            alt: "club logo",
                            class: "anwp-h-35 anwp-w-35 anwp-object-contain my-0 anwp-border anwp-border-gray-400 mt-1 bg-white p-1 rounded"
                          }, null, 8, _hoisted_22$a)) : Number(gameEvent.club) === Number(unref(gameStore).clubAway.id) && unref(gameStore).clubAway.logo ? (openBlock(), createElementBlock("img", {
                            key: 1,
                            src: unref(gameStore).clubAway.logo,
                            alt: "club logo",
                            class: "anwp-h-35 anwp-w-35 anwp-object-contain my-0 anwp-border anwp-border-gray-400 mt-1 bg-white p-1 rounded"
                          }, null, 8, _hoisted_23$8)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_24$7, [
                          gameEvent.playerObj && gameEvent.playerObj.id ? (openBlock(), createElementBlock("div", _hoisted_25$5, [
                            _cache[31] || (_cache[31] = createBaseVNode("svg", { class: "anwp-icon anwp-fl-icon--shirt" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-shirt" })
                            ], -1)),
                            createBaseVNode("div", _hoisted_26$5, toDisplayString(unref(gameStore).playerNumber[gameEvent.player] > 0 ? unref(gameStore).playerNumber[gameEvent.player] : ""), 1)
                          ])) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_27$5, [
                          gameEvent.playerObj && gameEvent.playerObj.id ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createBaseVNode("div", _hoisted_28$5, toDisplayString("substitute" === gameEvent.type ? "In:" : "Player:"), 1),
                            createTextVNode(" " + toDisplayString(gameEvent.playerObj.name), 1)
                          ], 64)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_29$5, [
                          gameEvent.player2Obj && gameEvent.player2Obj.id ? (openBlock(), createElementBlock("div", _hoisted_30$5, [
                            _cache[32] || (_cache[32] = createBaseVNode("svg", { class: "anwp-icon anwp-fl-icon--shirt" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-shirt" })
                            ], -1)),
                            createBaseVNode("div", _hoisted_31$5, toDisplayString(unref(gameStore).playerNumber[gameEvent.player2Obj.id] > 0 ? unref(gameStore).playerNumber[gameEvent.player2Obj.id] : ""), 1)
                          ])) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_32$5, [
                          gameEvent.player2Obj && gameEvent.player2Obj.id ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createBaseVNode("div", _hoisted_33$5, [
                              "substitute" === gameEvent.type ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                createTextVNode("Out:")
                              ], 64)) : "goal" === gameEvent.type ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                createTextVNode("Assistant:")
                              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                                createTextVNode("Player:")
                              ], 64))
                            ]),
                            createTextVNode(" " + toDisplayString(gameEvent.player2Obj.name), 1)
                          ], 64)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_34$4, [
                          gameEvent.comment ? (openBlock(), createElementBlock("div", {
                            key: 0,
                            class: "small",
                            innerHTML: gameEvent.comment
                          }, null, 8, _hoisted_35$4)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_36$4, [
                          createBaseVNode("button", {
                            type: "button",
                            class: "anwp-cursor-pointer d-flex align-items-center justify-content-center my-1 button anwp-hide-sortable-drag",
                            onClick: withModifiers(($event) => editEvent(gameEvent), ["prevent"])
                          }, [..._cache[33] || (_cache[33] = [
                            createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-gear" })
                            ], -1)
                          ])], 8, _hoisted_37$4)
                        ]),
                        createBaseVNode("td", _hoisted_38$3, [
                          createBaseVNode("button", {
                            type: "button",
                            class: "anwp-cursor-pointer d-flex align-items-center justify-content-center my-1 button anwp-border-red-600 anwp-hide-sortable-drag",
                            onClick: withModifiers(($event) => modalOpenEventDeleteConfirm(index2), ["prevent"])
                          }, [..._cache[34] || (_cache[34] = [
                            createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-x" })
                            ], -1)
                          ])], 8, _hoisted_39$3)
                        ])
                      ]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_40$3, [
              createBaseVNode("button", {
                class: "button button-secondary anwp-cursor-pointer px-4 py-1",
                onClick: _cache[1] || (_cache[1] = withModifiers(($event) => addEvent(), ["prevent"]))
              }, toDisplayString(unref(l10n).add_event), 1)
            ])
          ]),
          createVNode(unref(Ro), {
            modelValue: unref(gameStore).modals.deleteEvent,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(gameStore).modals.deleteEvent = $event),
            "z-index-fn": () => 100060,
            "focus-trap": false,
            "teleport-to": false,
            class: "anwp-vfm-admin-modal",
            "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
          }, {
            default: withCtx(() => [
              createBaseVNode("button", {
                class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0",
                onClick: _cache[2] || (_cache[2] = ($event) => unref(gameStore).modals.deleteEvent = false),
                type: "button"
              }, [..._cache[36] || (_cache[36] = [
                createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-x" })
                ], -1)
              ])]),
              createBaseVNode("div", _hoisted_41$3, [
                createBaseVNode("h4", _hoisted_42$2, toDisplayString(unref(l10n).confirm_delete), 1)
              ]),
              createBaseVNode("div", _hoisted_43$2, [
                createBaseVNode("div", _hoisted_44$2, [
                  createBaseVNode("div", _hoisted_45$2, toDisplayString(unref(l10n).are_you_sure), 1),
                  createBaseVNode("p", null, toDisplayString(unref(l10n).want_to_delete_event), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_46$2, [
                createBaseVNode("div", _hoisted_47$2, [
                  createBaseVNode("button", {
                    type: "button",
                    class: "button",
                    onClick: _cache[3] || (_cache[3] = ($event) => unref(gameStore).modals.deleteEvent = false)
                  }, toDisplayString(unref(l10n).close), 1),
                  createBaseVNode("button", {
                    onClick: withModifiers(removeEvent, ["prevent"]),
                    type: "button",
                    class: "button button-link-delete anwp-mx-2"
                  }, toDisplayString(unref(l10n).delete_event), 1)
                ])
              ])
            ]),
            _: 1
          }, 8, ["modelValue"]),
          createVNode(unref(Ro), {
            modelValue: unref(gameStore).modals.editEvent,
            "onUpdate:modelValue": _cache[24] || (_cache[24] = ($event) => unref(gameStore).modals.editEvent = $event),
            "z-index-fn": () => 100060,
            "focus-trap": false,
            "teleport-to": false,
            class: "anwp-vfm-admin-modal",
            "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--medium"
          }, {
            default: withCtx(() => [
              createBaseVNode("button", {
                class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0",
                onClick: _cache[5] || (_cache[5] = ($event) => unref(gameStore).modals.editEvent = false),
                type: "button"
              }, [..._cache[37] || (_cache[37] = [
                createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-x" })
                ], -1)
              ])]),
              _cache[45] || (_cache[45] = createBaseVNode("div", { class: "anwp-vfm-admin-modal__title" }, [
                createBaseVNode("h3", { class: "text-capitalize my-0" }, "Edit Event")
              ], -1)),
              createBaseVNode("div", _hoisted_48$2, [
                createBaseVNode("div", _hoisted_49$1, [
                  createBaseVNode("label", _hoisted_50$1, toDisplayString(unref(l10n).select_event), 1),
                  withDirectives(createBaseVNode("select", {
                    class: "anwp-w-min-150",
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(gameStore).modalData.eventInModal.type = $event)
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).appConfig.events, (event) => {
                      return openBlock(), createElementBlock("option", {
                        value: event.value
                      }, toDisplayString(event.label), 9, _hoisted_51$1);
                    }), 256))
                  ], 512), [
                    [vModelSelect, unref(gameStore).modalData.eventInModal.type]
                  ])
                ]),
                "card" === unref(gameStore).modalData.eventInModal.type ? (openBlock(), createElementBlock("div", _hoisted_52$1, [
                  createBaseVNode("label", _hoisted_53, toDisplayString(unref(l10n).card_type), 1),
                  withDirectives(createBaseVNode("select", {
                    id: "anwpfl-input-event-card",
                    class: "anwp-w-min-150",
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(gameStore).modalData.eventInModal.card = $event)
                  }, [
                    createBaseVNode("option", _hoisted_54, toDisplayString(unref(l10n).yellow), 1),
                    createBaseVNode("option", _hoisted_55, toDisplayString(unref(l10n).yellow_red), 1),
                    createBaseVNode("option", _hoisted_56, toDisplayString(unref(l10n).red), 1)
                  ], 512), [
                    [vModelSelect, unref(gameStore).modalData.eventInModal.card]
                  ])
                ])) : createCommentVNode("", true),
                "goal" === unref(gameStore).modalData.eventInModal.type ? (openBlock(), createElementBlock("div", _hoisted_57, [
                  createBaseVNode("label", _hoisted_58, toDisplayString(unref(l10n).own_goal), 1),
                  withDirectives(createBaseVNode("select", {
                    id: "anwpfl-input-own-goal",
                    class: "anwp-w-min-150",
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => unref(gameStore).modalData.eventInModal.ownGoal = $event)
                  }, [
                    createBaseVNode("option", _hoisted_59, toDisplayString(unref(l10n).no), 1),
                    createBaseVNode("option", _hoisted_60, toDisplayString(unref(l10n).yes), 1)
                  ], 512), [
                    [vModelSelect, unref(gameStore).modalData.eventInModal.ownGoal]
                  ])
                ])) : createCommentVNode("", true),
                "goal" === unref(gameStore).modalData.eventInModal.type ? (openBlock(), createElementBlock("div", _hoisted_61, [
                  createBaseVNode("label", _hoisted_62, toDisplayString(unref(l10n).goal_from_penalty), 1),
                  withDirectives(createBaseVNode("select", {
                    id: "anwpfl-input-from-penalty",
                    class: "anwp-w-min-150",
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => unref(gameStore).modalData.eventInModal.fromPenalty = $event)
                  }, [
                    createBaseVNode("option", _hoisted_63, toDisplayString(unref(l10n).no), 1),
                    createBaseVNode("option", _hoisted_64, toDisplayString(unref(l10n).yes), 1)
                  ], 512), [
                    [vModelSelect, unref(gameStore).modalData.eventInModal.fromPenalty]
                  ])
                ])) : createCommentVNode("", true),
                "penalty_shootout" === unref(gameStore).modalData.eventInModal.type ? (openBlock(), createElementBlock("div", _hoisted_65, [
                  createBaseVNode("label", _hoisted_66, toDisplayString(unref(l10n).shootout_scored), 1),
                  withDirectives(createBaseVNode("select", {
                    id: "anwpfl-input-shootout-scored",
                    class: "anwp-w-min-150",
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => unref(gameStore).modalData.eventInModal.scored = $event)
                  }, [
                    createBaseVNode("option", _hoisted_67, toDisplayString(unref(l10n).no), 1),
                    createBaseVNode("option", _hoisted_68, toDisplayString(unref(l10n).yes), 1)
                  ], 512), [
                    [vModelSelect, unref(gameStore).modalData.eventInModal.scored]
                  ])
                ])) : createCommentVNode("", true),
                _cache[41] || (_cache[41] = createBaseVNode("div", { class: "w-100 mb-2" }, null, -1)),
                createBaseVNode("div", _hoisted_69, [
                  createBaseVNode("label", _hoisted_70, toDisplayString(unref(l10n).club), 1),
                  createVNode(_component_v_select, {
                    class: "anwp-w-min-200 anwp-h-min-35",
                    options: [unref(gameStore).clubHome, unref(gameStore).clubAway],
                    clearable: false,
                    filterable: false,
                    searchable: false,
                    reduce: (t) => t.id,
                    modelValue: unref(gameStore).modalData.eventInModal.club,
                    "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => unref(gameStore).modalData.eventInModal.club = $event)
                  }, {
                    option: withCtx(({ title, logo }) => [
                      createBaseVNode("div", _hoisted_71, [
                        logo ? (openBlock(), createElementBlock("img", {
                          key: 0,
                          src: logo,
                          alt: "club logo",
                          class: "anwp-w-25 anwp-h-25 anwp-object-contain pr-2"
                        }, null, 8, _hoisted_72)) : createCommentVNode("", true),
                        createBaseVNode("span", null, toDisplayString(title), 1)
                      ])
                    ]),
                    "selected-option": withCtx(({ title, logo }) => [
                      createBaseVNode("div", _hoisted_73, [
                        logo ? (openBlock(), createElementBlock("img", {
                          key: 0,
                          src: logo,
                          alt: "club logo",
                          class: "anwp-w-20 anwp-h-20 anwp-object-contain pr-2"
                        }, null, 8, _hoisted_74)) : createCommentVNode("", true),
                        createBaseVNode("span", null, toDisplayString(title), 1)
                      ])
                    ]),
                    _: 1
                  }, 8, ["options", "reduce", "modelValue"])
                ]),
                _cache[42] || (_cache[42] = createBaseVNode("div", { class: "w-100 mb-2" }, null, -1)),
                createBaseVNode("div", _hoisted_75, [
                  createBaseVNode("label", _hoisted_76, toDisplayString(unref(l10n).minute), 1),
                  withDirectives(createBaseVNode("input", {
                    type: "number",
                    id: "anwp-fl-input-event-minute",
                    class: "anwp-w-100 anwp-w-min-100",
                    "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => unref(gameStore).modalData.eventInModal.minute = $event)
                  }, null, 512), [
                    [
                      vModelText,
                      unref(gameStore).modalData.eventInModal.minute,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("div", _hoisted_77, [
                  createBaseVNode("label", _hoisted_78, toDisplayString(unref(l10n).additional_minute), 1),
                  withDirectives(createBaseVNode("input", {
                    type: "number",
                    id: "anwp-fl-input-event-minute-add",
                    class: "anwp-w-100 anwp-w-min-100",
                    "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => unref(gameStore).modalData.eventInModal.minuteAdd = $event)
                  }, null, 512), [
                    [
                      vModelText,
                      unref(gameStore).modalData.eventInModal.minuteAdd,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                _cache[43] || (_cache[43] = createBaseVNode("div", { class: "w-100 mb-2" }, null, -1)),
                createBaseVNode("div", _hoisted_79, [
                  createBaseVNode("label", _hoisted_80, toDisplayString("substitute" === unref(gameStore).modalData.eventInModal.type ? unref(l10n).player_in : unref(l10n).player), 1),
                  unref(gameStore).modalData.eventInModal.player ? (openBlock(), createElementBlock("div", _hoisted_81, [
                    createVNode(_sfc_main$B, {
                      onClickPlayer: _cache[14] || (_cache[14] = ($event) => openModalEventPlayerSelector("player")),
                      player: unref(gameStore).modalData.eventInModal.playerObj,
                      defaultPhoto: unref(gameStore).appConfig.default_photo,
                      playerNumber: unref(gameStore).playerNumber,
                      displayPosition: false,
                      classPosition: unref(gameStore).appConfig.classPosition
                    }, null, 8, ["player", "defaultPhoto", "playerNumber", "classPosition"]),
                    createBaseVNode("button", {
                      type: "button",
                      class: "anwp-flex-none ml-2 anwp-cursor-pointer d-flex align-items-center justify-content-center button anwp-border-red-600",
                      onClick: _cache[15] || (_cache[15] = withModifiers(($event) => {
                        unref(gameStore).modalData.eventInModal.playerObj = {};
                        unref(gameStore).modalData.eventInModal.player = "";
                      }, ["prevent"]))
                    }, [..._cache[38] || (_cache[38] = [
                      createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                        createBaseVNode("use", { "xlink:href": "#icon-x" })
                      ], -1)
                    ])])
                  ])) : (openBlock(), createElementBlock("button", {
                    key: 1,
                    type: "button",
                    class: "button button-secondary px-4 py-1",
                    onClick: _cache[16] || (_cache[16] = withModifiers(($event) => openModalEventPlayerSelector("player"), ["prevent"]))
                  }, toDisplayString(unref(l10n).select_player), 1))
                ]),
                _cache[44] || (_cache[44] = createBaseVNode("div", { class: "w-100 mb-2" }, null, -1)),
                "goal" === unref(gameStore).modalData.eventInModal.type ? (openBlock(), createElementBlock("div", _hoisted_82, [
                  createBaseVNode("label", _hoisted_83, toDisplayString(unref(l10n).assistant), 1),
                  unref(gameStore).modalData.eventInModal.assistant ? (openBlock(), createElementBlock("div", _hoisted_84, [
                    createVNode(_sfc_main$B, {
                      onClickPlayer: _cache[17] || (_cache[17] = ($event) => openModalEventPlayerSelector("assistant")),
                      player: unref(gameStore).modalData.eventInModal.player2Obj,
                      defaultPhoto: unref(gameStore).appConfig.default_photo,
                      playerNumber: unref(gameStore).playerNumber,
                      displayPosition: false,
                      classPosition: unref(gameStore).appConfig.classPosition
                    }, null, 8, ["player", "defaultPhoto", "playerNumber", "classPosition"]),
                    createBaseVNode("button", {
                      type: "button",
                      class: "anwp-flex-none ml-2 anwp-cursor-pointer d-flex align-items-center justify-content-center button anwp-border-red-600",
                      onClick: _cache[18] || (_cache[18] = withModifiers(($event) => {
                        unref(gameStore).modalData.eventInModal.player2Obj = {};
                        unref(gameStore).modalData.eventInModal.assistant = "";
                      }, ["prevent"]))
                    }, [..._cache[39] || (_cache[39] = [
                      createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                        createBaseVNode("use", { "xlink:href": "#icon-x" })
                      ], -1)
                    ])])
                  ])) : (openBlock(), createElementBlock("button", {
                    key: 1,
                    type: "button",
                    class: "button button-secondary px-4 py-1",
                    onClick: _cache[19] || (_cache[19] = withModifiers(($event) => openModalEventPlayerSelector("assistant"), ["prevent"]))
                  }, toDisplayString(unref(l10n).select_player), 1))
                ])) : createCommentVNode("", true),
                "substitute" === unref(gameStore).modalData.eventInModal.type ? (openBlock(), createElementBlock("div", _hoisted_85, [
                  createBaseVNode("label", _hoisted_86, toDisplayString(unref(l10n).player_out), 1),
                  unref(gameStore).modalData.eventInModal.playerOut ? (openBlock(), createElementBlock("div", _hoisted_87, [
                    createVNode(_sfc_main$B, {
                      onClickPlayer: _cache[20] || (_cache[20] = ($event) => openModalEventPlayerSelector("playerOut")),
                      player: unref(gameStore).modalData.eventInModal.player2Obj,
                      defaultPhoto: unref(gameStore).appConfig.default_photo,
                      playerNumber: unref(gameStore).playerNumber,
                      displayPosition: false,
                      classPosition: unref(gameStore).appConfig.classPosition
                    }, null, 8, ["player", "defaultPhoto", "playerNumber", "classPosition"]),
                    createBaseVNode("button", {
                      type: "button",
                      class: "anwp-flex-none ml-2 anwp-cursor-pointer d-flex align-items-center justify-content-center button anwp-border-red-600",
                      onClick: _cache[21] || (_cache[21] = withModifiers(($event) => {
                        unref(gameStore).modalData.eventInModal.player2Obj = {};
                        unref(gameStore).modalData.eventInModal.playerOut = "";
                      }, ["prevent"]))
                    }, [..._cache[40] || (_cache[40] = [
                      createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                        createBaseVNode("use", { "xlink:href": "#icon-x" })
                      ], -1)
                    ])])
                  ])) : (openBlock(), createElementBlock("button", {
                    key: 1,
                    type: "button",
                    class: "button button-secondary px-4 py-1",
                    onClick: _cache[22] || (_cache[22] = withModifiers(($event) => openModalEventPlayerSelector("playerOut"), ["prevent"]))
                  }, toDisplayString(unref(l10n).select_player), 1))
                ])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_88, [
                createBaseVNode("div", _hoisted_89, [
                  createBaseVNode("button", {
                    type: "button",
                    class: "button",
                    onClick: _cache[23] || (_cache[23] = ($event) => unref(gameStore).modals.editEvent = false)
                  }, toDisplayString(unref(l10n).close), 1)
                ])
              ])
            ]),
            _: 1
          }, 8, ["modelValue"]),
          createVNode(unref(Ro), {
            modelValue: unref(gameStore).modals.addEventPlayer,
            "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => unref(gameStore).modals.addEventPlayer = $event),
            "z-index-fn": () => 100060,
            "focus-trap": false,
            "teleport-to": false,
            class: "anwp-vfm-admin-modal",
            "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--medium"
          }, {
            default: withCtx(() => [
              createBaseVNode("button", {
                class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0",
                onClick: _cache[25] || (_cache[25] = ($event) => unref(gameStore).modals.addEventPlayer = false),
                type: "button"
              }, [..._cache[46] || (_cache[46] = [
                createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-x" })
                ], -1)
              ])]),
              createBaseVNode("div", _hoisted_90, [
                createBaseVNode("h4", _hoisted_91, toDisplayString(unref(l10n).select_player), 1)
              ]),
              createBaseVNode("div", _hoisted_92, [
                !unref(gameStore).modalData.eventInModal.club ? (openBlock(), createElementBlock("div", _hoisted_93, " Event Club is not selected! ")) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(playersInEventModal.value, (player) => {
                  return openBlock(), createBlock(_sfc_main$B, {
                    onClickPlayer: ($event) => addModalEventPlayer(player),
                    class: "my-2",
                    key: player.id,
                    player,
                    defaultPhoto: unref(gameStore).appConfig.default_photo,
                    playerNumber: unref(gameStore).playerNumber,
                    classPosition: unref(gameStore).appConfig.classPosition
                  }, null, 8, ["onClickPlayer", "player", "defaultPhoto", "playerNumber", "classPosition"]);
                }), 128))
              ]),
              createBaseVNode("div", _hoisted_94, [
                createBaseVNode("div", _hoisted_95, [
                  createBaseVNode("div", _hoisted_96, [
                    createBaseVNode("label", _hoisted_97, toDisplayString(unref(l10n).filter_players_by), 1),
                    withDirectives(createBaseVNode("select", {
                      tabindex: "-1",
                      id: "anwp-input-filter-players-by",
                      "onUpdate:modelValue": _cache[26] || (_cache[26] = ($event) => unref(gameStore).modalData.eventPlayersFilter = $event)
                    }, [
                      createBaseVNode("option", _hoisted_98, toDisplayString(unref(l10n).match), 1),
                      createBaseVNode("option", _hoisted_99, toDisplayString(unref(l10n).squad), 1)
                    ], 512), [
                      [vModelSelect, unref(gameStore).modalData.eventPlayersFilter]
                    ])
                  ]),
                  createBaseVNode("button", {
                    type: "button",
                    class: "button",
                    onClick: _cache[27] || (_cache[27] = ($event) => unref(gameStore).modals.addEventPlayer = false)
                  }, toDisplayString(unref(l10n).close), 1)
                ])
              ])
            ]),
            _: 1
          }, 8, ["modelValue"]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_match_events",
            value: JSON.stringify(matchEventsCompact.value)
          }, null, 8, _hoisted_100)
        ]);
      };
    }
  };
  const _hoisted_1$u = {
    class: "anwp-border anwp-border-gray-500 my-4",
    id: "anwp-fl-game-sidelines-metabox"
  };
  const _hoisted_2$p = { class: "px-3 pb-4 bg-white" };
  const _hoisted_3$p = { class: "anwp-row" };
  const _hoisted_4$o = { class: "anwp-col-xl-6" };
  const _hoisted_5$n = {
    key: 0,
    class: "table-responsive"
  };
  const _hoisted_6$n = { class: "table table-sm anwp-border-collapse w-100 anwp-overflow-scroll anwp-user-select-none anwp-leading-1 anwp-border anwp-border-gray-400" };
  const _hoisted_7$l = { class: "px-1 py-2 align-middle" };
  const _hoisted_8$j = ["onUpdate:modelValue"];
  const _hoisted_9$f = { value: "injured" };
  const _hoisted_10$f = { value: "suspended" };
  const _hoisted_11$e = { value: "other" };
  const _hoisted_12$e = ["onUpdate:modelValue"];
  const _hoisted_13$d = { class: "anwp-col-xl-6" };
  const _hoisted_14$d = {
    key: 0,
    class: "table-responsive"
  };
  const _hoisted_15$c = { class: "table table-sm anwp-border-collapse w-100 anwp-overflow-scroll anwp-user-select-none anwp-leading-1 anwp-border anwp-border-gray-400" };
  const _hoisted_16$c = { class: "px-1 py-2 align-middle" };
  const _hoisted_17$b = ["onUpdate:modelValue"];
  const _hoisted_18$b = { value: "injured" };
  const _hoisted_19$b = { value: "suspended" };
  const _hoisted_20$9 = { value: "other" };
  const _hoisted_21$9 = ["onUpdate:modelValue"];
  const _hoisted_22$9 = ["value"];
  const _sfc_main$u = {
    __name: "AppGameSidelines",
    setup(__props) {
      const gameStore = useGameStore();
      const l10n = window.anwpMatch.l10n;
      const missingPlayersCompact = computed(() => {
        return gameStore.active.playersHomeMissing.concat(gameStore.active.playersAwayMissing).map((_a2) => {
          var _b2 = _a2, { playerObj } = _b2, a2 = __objRest(_b2, ["playerObj"]);
          return a2;
        });
      });
      return (_ctx, _cache) => {
        const _component_draggable = resolveComponent("draggable");
        return openBlock(), createElementBlock("div", _hoisted_1$u, [
          createVNode(AppBlockHeader, { icon: "#icon-x" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).match_sidelines), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$p, [
            createBaseVNode("div", _hoisted_3$p, [
              createBaseVNode("div", _hoisted_4$o, [
                createVNode(_sfc_main$G, {
                  logo: unref(gameStore).clubHome.logo,
                  title: unref(gameStore).clubHome.title,
                  "is-home": true,
                  "wrapper-class": "mt-4"
                }, null, 8, ["logo", "title"]),
                createBaseVNode("button", {
                  class: "button d-flex align-items-center mx-auto my-4 px-5",
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = withModifiers(($event) => unref(gameStore).openAddPlayerModal("home-missing"), ["prevent"]))
                }, [
                  _cache[4] || (_cache[4] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16 mr-2" }, [
                    createBaseVNode("use", { "xlink:href": "#icon-plus" })
                  ], -1)),
                  createTextVNode(" " + toDisplayString(unref(l10n).add_sideline), 1)
                ]),
                unref(gameStore).active.playersHomeMissing.length ? (openBlock(), createElementBlock("div", _hoisted_5$n, [
                  createBaseVNode("table", _hoisted_6$n, [
                    _cache[5] || (_cache[5] = createBaseVNode("thead", null, [
                      createBaseVNode("tr", { class: "anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" }, [
                        createBaseVNode("td"),
                        createBaseVNode("td"),
                        createBaseVNode("td", { class: "py-1 px-2" }, "Missing Player"),
                        createBaseVNode("td", { class: "py-1 px-2" }, "Reason & Comment"),
                        createBaseVNode("td")
                      ])
                    ], -1)),
                    createVNode(_component_draggable, {
                      modelValue: unref(gameStore).active.playersHomeMissing,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(gameStore).active.playersHomeMissing = $event),
                      handle: ".anwp-drag-handler",
                      tag: "tbody",
                      "force-fallback": true
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersHomeMissing, (missing, index2) => {
                          return openBlock(), createBlock(_sfc_main$E, {
                            key: index2,
                            player: missing.playerObj,
                            displayNumber: false,
                            displayPhoto: false,
                            className: "align-top",
                            classRemove: "align-top",
                            classPosition: unref(gameStore).appConfig.classPosition,
                            onRemovePlayer: ($event) => unref(gameStore).active.playersHomeMissing.splice(index2, 1),
                            l10n: unref(l10n)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("td", _hoisted_7$l, [
                                withDirectives(createBaseVNode("select", {
                                  class: "w-auto",
                                  "onUpdate:modelValue": ($event) => missing.reason = $event
                                }, [
                                  createBaseVNode("option", _hoisted_9$f, toDisplayString(unref(l10n).injured), 1),
                                  createBaseVNode("option", _hoisted_10$f, toDisplayString(unref(l10n).suspended), 1),
                                  createBaseVNode("option", _hoisted_11$e, toDisplayString(unref(l10n).other), 1)
                                ], 8, _hoisted_8$j), [
                                  [vModelSelect, missing.reason]
                                ]),
                                withDirectives(createBaseVNode("textarea", {
                                  class: "d-block mt-1 w-100",
                                  cols: "30",
                                  rows: "2",
                                  "onUpdate:modelValue": ($event) => missing.comment = $event
                                }, null, 8, _hoisted_12$e), [
                                  [vModelText, missing.comment]
                                ])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["player", "classPosition", "onRemovePlayer", "l10n"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ])
                ])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_13$d, [
                createVNode(_sfc_main$G, {
                  logo: unref(gameStore).clubAway.logo,
                  title: unref(gameStore).clubAway.title,
                  "is-home": false,
                  "wrapper-class": "mt-4"
                }, null, 8, ["logo", "title"]),
                createBaseVNode("button", {
                  class: "button d-flex align-items-center mx-auto my-4 px-5",
                  type: "button",
                  onClick: _cache[2] || (_cache[2] = withModifiers(($event) => unref(gameStore).openAddPlayerModal("away-missing"), ["prevent"]))
                }, [
                  _cache[6] || (_cache[6] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16 mr-2" }, [
                    createBaseVNode("use", { "xlink:href": "#icon-plus" })
                  ], -1)),
                  createTextVNode(" " + toDisplayString(unref(l10n).add_sideline), 1)
                ]),
                unref(gameStore).active.playersAwayMissing.length ? (openBlock(), createElementBlock("div", _hoisted_14$d, [
                  createBaseVNode("table", _hoisted_15$c, [
                    _cache[7] || (_cache[7] = createBaseVNode("thead", null, [
                      createBaseVNode("tr", { class: "anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900" }, [
                        createBaseVNode("td"),
                        createBaseVNode("td"),
                        createBaseVNode("td", { class: "py-1 px-2" }, "Missing Player"),
                        createBaseVNode("td", { class: "py-1 px-2" }, "Reason & Comment"),
                        createBaseVNode("td")
                      ])
                    ], -1)),
                    createVNode(_component_draggable, {
                      modelValue: unref(gameStore).active.playersAwayMissing,
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(gameStore).active.playersAwayMissing = $event),
                      handle: ".anwp-drag-handler",
                      tag: "tbody",
                      "force-fallback": true
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).active.playersAwayMissing, (missing, index2) => {
                          return openBlock(), createBlock(_sfc_main$E, {
                            key: index2,
                            player: missing.playerObj,
                            displayNumber: false,
                            displayPhoto: false,
                            className: "align-top",
                            classRemove: "align-top",
                            classPosition: unref(gameStore).appConfig.classPosition,
                            onRemovePlayer: ($event) => unref(gameStore).active.playersAwayMissing.splice(index2, 1),
                            l10n: unref(l10n)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("td", _hoisted_16$c, [
                                withDirectives(createBaseVNode("select", {
                                  class: "w-auto",
                                  "onUpdate:modelValue": ($event) => missing.reason = $event
                                }, [
                                  createBaseVNode("option", _hoisted_18$b, toDisplayString(unref(l10n).injured), 1),
                                  createBaseVNode("option", _hoisted_19$b, toDisplayString(unref(l10n).suspended), 1),
                                  createBaseVNode("option", _hoisted_20$9, toDisplayString(unref(l10n).other), 1)
                                ], 8, _hoisted_17$b), [
                                  [vModelSelect, missing.reason]
                                ]),
                                withDirectives(createBaseVNode("textarea", {
                                  class: "d-block mt-1 w-100",
                                  cols: "30",
                                  rows: "2",
                                  "onUpdate:modelValue": ($event) => missing.comment = $event
                                }, null, 8, _hoisted_21$9), [
                                  [vModelText, missing.comment]
                                ])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["player", "classPosition", "onRemovePlayer", "l10n"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ])
                ])) : createCommentVNode("", true)
              ])
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_missing_players",
            value: JSON.stringify(missingPlayersCompact.value)
          }, null, 8, _hoisted_22$9)
        ]);
      };
    }
  };
  const _hoisted_1$t = { class: "mr-3" };
  const _hoisted_2$o = ["src"];
  const _hoisted_3$o = { class: "anwp-text-base anwp-leading-1" };
  const _hoisted_4$n = { class: "mt-1" };
  const _hoisted_5$m = {
    key: 0,
    class: "options__flag f16 align-middle mr-1",
    style: { "line-height": "12px" }
  };
  const _hoisted_6$m = {
    key: 1,
    class: "anwp-text-xs anwp-text-gray-600"
  };
  const _sfc_main$t = {
    __name: "AppMatchReferee",
    props: {
      referee: {
        type: Object,
        required: true
      },
      defaultPhoto: {
        type: String
      }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: "d-flex align-items-center anwp-cursor-pointer anwp-border anwp-border-gray-400 rounded px-3 py-2 anwp-bg-gray-100",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$emit("click-referee"), ["prevent"]))
        }, [
          createBaseVNode("div", _hoisted_1$t, [
            createBaseVNode("img", {
              class: "anwp-h-45 anwp-w-45 anwp-object-contain my-0 anwp-border anwp-border-gray-400",
              style: { "border-radius": "10px", "padding": "2px" },
              src: __props.referee.photo ? __props.referee.photo : __props.defaultPhoto,
              alt: "player photo"
            }, null, 8, _hoisted_2$o)
          ]),
          createBaseVNode("div", _hoisted_3$o, [
            createTextVNode(toDisplayString(__props.referee.name) + " ", 1),
            createBaseVNode("div", _hoisted_4$n, [
              __props.referee.country ? (openBlock(), createElementBlock("span", _hoisted_5$m, [
                createBaseVNode("span", {
                  class: normalizeClass(["flag", __props.referee.country])
                }, null, 2)
              ])) : createCommentVNode("", true),
              __props.referee.birthdate ? (openBlock(), createElementBlock("span", _hoisted_6$m, toDisplayString(__props.referee.birthdate), 1)) : createCommentVNode("", true)
            ])
          ])
        ]);
      };
    }
  };
  const _hoisted_1$s = { class: "d-flex flex-column mb-4 m-sm-2 px-2 mr-sm-4" };
  const _hoisted_2$n = { class: "mb-1 anwp-text-gray-800" };
  const _hoisted_3$n = {
    key: 0,
    class: "d-flex flex-wrap align-items-start"
  };
  const _sfc_main$s = {
    __name: "AppMatchRefereeInput",
    props: {
      l10n: {
        type: Object
      },
      textReferee: {
        type: String,
        default: ""
      },
      referee: {},
      defaultPhoto: {
        type: String
      }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$s, [
          createBaseVNode("label", _hoisted_2$n, toDisplayString(__props.textReferee), 1),
          __props.referee ? (openBlock(), createElementBlock("div", _hoisted_3$n, [
            createVNode(_sfc_main$t, {
              onClickReferee: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("open-modal-referee-selector")),
              referee: __props.referee,
              defaultPhoto: __props.defaultPhoto
            }, null, 8, ["referee", "defaultPhoto"]),
            createBaseVNode("button", {
              type: "button",
              class: "anwp-flex-none ml-2 anwp-cursor-pointer d-flex align-items-center justify-content-center button anwp-border-red-600",
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.$emit("click-remove"), ["prevent"]))
            }, [..._cache[3] || (_cache[3] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])])
          ])) : (openBlock(), createElementBlock("button", {
            key: 1,
            type: "button",
            class: "button button-secondary px-4 py-1",
            onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.$emit("open-modal-referee-selector"), ["prevent"]))
          }, toDisplayString(__props.l10n.select) + " " + toDisplayString(__props.textReferee), 1))
        ]);
      };
    }
  };
  const _hoisted_1$r = {
    class: "anwp-border anwp-border-gray-500 my-4",
    id: "anwp-fl-referee-metabox"
  };
  const _hoisted_2$m = { class: "bg-white p-3 pb-4 d-sm-flex flex-wrap align-items-start" };
  const _hoisted_3$m = { class: "w-100 mt-4 ml-3 py-1 px-2 anwp-text-base d-flex anwp-border anwp-border-gray-400 anwp-bg-gray-300 anwp-text-gray-900 anwp-w-400" };
  const _hoisted_4$m = { class: "d-flex flex-column" };
  const _hoisted_5$l = { class: "d-flex" };
  const _hoisted_6$l = { class: "d-flex flex-column mr-4" };
  const _hoisted_7$k = ["disabled", "onClick"];
  const _hoisted_8$i = ["disabled", "onClick"];
  const _hoisted_9$e = { class: "d-flex flex-column mr-4" };
  const _hoisted_10$e = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwpfl-add-ref-role"
  };
  const _hoisted_11$d = ["onUpdate:modelValue"];
  const _hoisted_12$d = { class: "anwp-flex-none" };
  const _hoisted_13$c = ["onClick"];
  const _hoisted_14$c = { class: "px-2 py-3 mx-sm-2 mt-2" };
  const _hoisted_15$b = ["value"];
  const _hoisted_16$b = ["value"];
  const _hoisted_17$a = ["value"];
  const _hoisted_18$a = ["value"];
  const _hoisted_19$a = ["value"];
  const _hoisted_20$8 = ["value"];
  const _hoisted_21$8 = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_22$8 = { class: "my-0" };
  const _hoisted_23$7 = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_24$6 = { class: "d-flex mb-4 anwp-fl-tabs-wrapper" };
  const _hoisted_25$4 = { class: "anwp-text-base" };
  const _hoisted_26$4 = { class: "anwp-text-xs mt-2" };
  const _hoisted_27$4 = { class: "anwp-text-base" };
  const _hoisted_28$4 = { class: "anwp-text-xs mt-2" };
  const _hoisted_29$4 = { class: "d-flex flex-column" };
  const _hoisted_30$4 = {
    for: "anwp-fl-modal-referee-search",
    class: "mb-1"
  };
  const _hoisted_31$4 = { class: "d-flex flex-column mt-4" };
  const _hoisted_32$4 = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-temp-name"
  };
  const _hoisted_33$4 = { class: "d-flex flex-column mt-3" };
  const _hoisted_34$3 = {
    class: "mb-1 anwp-text-gray-800",
    for: "anwp-fl-input-temp-country"
  };
  const _hoisted_35$3 = ["value"];
  const _hoisted_36$3 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_37$3 = { class: "d-flex flex-row-reverse" };
  const _sfc_main$r = {
    __name: "AppGameReferees",
    setup(__props) {
      const gameStore = useGameStore();
      const pageNumber = ref(1);
      const search = ref("");
      const l10n = window.anwpMatch.l10n;
      const openModalRefereeSelector = (refereeField, refereeFieldIndex = null) => {
        var _a2, _b2, _c, _d, _e2, _f;
        gameStore.modalData.refereeField = refereeField;
        gameStore.modalData.refereeFieldIndex = refereeFieldIndex;
        if (null !== refereeFieldIndex) {
          gameStore.modalData.tempReferee = Object.assign({}, ((_b2 = (_a2 = gameStore.tempReferees) == null ? void 0 : _a2.additional_referees) == null ? void 0 : _b2[gameStore.additional_referees[refereeFieldIndex].id]) || {});
          gameStore.modalData.modalRefereeMode = ((_e2 = (_d = (_c = gameStore.tempReferees) == null ? void 0 : _c.additional_referees) == null ? void 0 : _d[gameStore.additional_referees[refereeFieldIndex].id]) == null ? void 0 : _e2.id) ? "temp" : "saved";
        } else {
          gameStore.modalData.tempReferee = Object.assign({}, gameStore.tempReferees[refereeField]);
          gameStore.modalData.modalRefereeMode = ((_f = gameStore.tempReferees[refereeField]) == null ? void 0 : _f.id) ? "temp" : "saved";
        }
        gameStore.modals.addReferee = true;
      };
      const additionalRefereesCompact = computed(() => {
        return gameStore.additional_referees ? gameStore.additional_referees.map((a2) => {
          var _a2;
          return {
            "role": a2.role,
            "id": a2.id,
            "_anwpfl_referee": ((_a2 = a2.referee) == null ? void 0 : _a2.id) ? a2.referee.id : null
          };
        }) : [];
      });
      const refereesInModal = computed(() => {
        if ("" !== search.value.trim()) {
          return gameStore.appConfig.referees.filter((p2) => p2.name.toLowerCase().indexOf(search.value.toLowerCase()) > -1);
        }
        return gameStore.appConfig.referees;
      });
      const refereesPages = computed(() => {
        return refereesInModal.value.length ? Math.ceil(refereesInModal.value.length / 10) : 0;
      });
      const refereesInModalPaginated = computed(() => {
        if (!refereesInModal.value.length) {
          return [];
        }
        return refereesInModal.value.slice((pageNumber.value - 1) * 10, pageNumber.value * 10);
      });
      const swapAdditionalReferees = (direction, refIndex) => {
        if ("up" === direction && 0 === refIndex || "down" === direction && refIndex === gameStore.additional_referees.length - 1) {
          return false;
        }
        let currentReferee = gameStore.additional_referees[refIndex];
        let swapIndex = "up" === direction ? refIndex - 1 : refIndex + 1;
        gameStore.additional_referees.splice(refIndex, 1, gameStore.additional_referees[swapIndex]);
        gameStore.additional_referees.splice(swapIndex, 1, currentReferee);
      };
      const addReferee = (refereeObj) => {
        if (null !== gameStore.modalData.refereeFieldIndex) {
          gameStore.additional_referees[gameStore.modalData.refereeFieldIndex].referee = refereeObj;
        } else {
          gameStore[gameStore.modalData.refereeField] = refereeObj;
        }
        gameStore.modals.addReferee = false;
      };
      const addTempReferee = (refereeObj) => {
        if (null !== gameStore.modalData.refereeFieldIndex) {
          refereeObj.id = `temp__${gameStore.additional_referees[gameStore.modalData.refereeFieldIndex].id}`;
          gameStore.additional_referees[gameStore.modalData.refereeFieldIndex].referee = refereeObj;
          gameStore.tempReferees.additional_referees[gameStore.additional_referees[gameStore.modalData.refereeFieldIndex].id] = refereeObj;
        } else {
          refereeObj.id = "temp";
          gameStore.tempReferees[gameStore.modalData.refereeField] = gameStore[gameStore.modalData.refereeField] = refereeObj;
        }
        gameStore.modals.addReferee = false;
      };
      const addAdditionalReferee = () => {
        gameStore.additional_referees.push(
          {
            role: "",
            id: gameStore.nextIdAdditionalReferee,
            referee: null
          }
        );
      };
      return (_ctx, _cache) => {
        var _a2, _b2, _c, _d;
        return openBlock(), createElementBlock("div", _hoisted_1$r, [
          createVNode(AppBlockHeader, { icon: "#icon-organization" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).referee), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$m, [
            createVNode(_sfc_main$s, {
              l10n: unref(l10n),
              "default-photo": unref(gameStore).appConfig.default_photo,
              referee: unref(gameStore).referee,
              "text-referee": unref(l10n).referee,
              onOpenModalRefereeSelector: _cache[0] || (_cache[0] = ($event) => openModalRefereeSelector("referee")),
              onClickRemove: _cache[1] || (_cache[1] = ($event) => unref(gameStore).referee = null)
            }, null, 8, ["l10n", "default-photo", "referee", "text-referee"]),
            createVNode(_sfc_main$s, {
              l10n: unref(l10n),
              "default-photo": unref(gameStore).appConfig.default_photo,
              referee: unref(gameStore).assistant_1,
              "text-referee": unref(l10n).assistant_1,
              onOpenModalRefereeSelector: _cache[2] || (_cache[2] = ($event) => openModalRefereeSelector("assistant_1")),
              onClickRemove: _cache[3] || (_cache[3] = ($event) => unref(gameStore).assistant_1 = null)
            }, null, 8, ["l10n", "default-photo", "referee", "text-referee"]),
            createVNode(_sfc_main$s, {
              l10n: unref(l10n),
              "default-photo": unref(gameStore).appConfig.default_photo,
              referee: unref(gameStore).assistant_2,
              "text-referee": unref(l10n).assistant_2,
              onOpenModalRefereeSelector: _cache[4] || (_cache[4] = ($event) => openModalRefereeSelector("assistant_2")),
              onClickRemove: _cache[5] || (_cache[5] = ($event) => unref(gameStore).assistant_2 = null)
            }, null, 8, ["l10n", "default-photo", "referee", "text-referee"]),
            _cache[22] || (_cache[22] = createBaseVNode("div", { class: "w-100" }, null, -1)),
            createVNode(_sfc_main$s, {
              class: "mt-sm-4",
              l10n: unref(l10n),
              "default-photo": unref(gameStore).appConfig.default_photo,
              referee: unref(gameStore).referee_fourth,
              "text-referee": unref(l10n).referee_fourth,
              onOpenModalRefereeSelector: _cache[6] || (_cache[6] = ($event) => openModalRefereeSelector("referee_fourth")),
              onClickRemove: _cache[7] || (_cache[7] = ($event) => unref(gameStore).referee_fourth = null)
            }, null, 8, ["l10n", "default-photo", "referee", "text-referee"]),
            createBaseVNode("div", _hoisted_3$m, toDisplayString(unref(l10n).additional_referees), 1),
            createVNode(TransitionGroup, {
              name: "fl-sortable-list",
              class: "w-100"
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).additional_referees, (add_ref, ref_index) => {
                  return openBlock(), createElementBlock("div", {
                    class: "w-100 d-flex flex-wrap align-items-start my-2 ml-3 py-3 anwp-border-bottom anwp-border-gray-300",
                    key: add_ref.id
                  }, [
                    createBaseVNode("div", _hoisted_4$m, [
                      createBaseVNode("div", _hoisted_5$l, [
                        createBaseVNode("div", _hoisted_6$l, [
                          createBaseVNode("button", {
                            type: "button",
                            disabled: !ref_index,
                            class: "mb-2 anwp-cursor-pointer d-flex align-items-center justify-content-center button",
                            onClick: withModifiers(($event) => swapAdditionalReferees("up", ref_index), ["prevent"])
                          }, [
                            (openBlock(), createElementBlock("svg", {
                              class: normalizeClass(["anwp-icon anwp-icon--octi d-inline-block anwp-icon--s16", ref_index ? "" : "anwp-opacity-50"])
                            }, [..._cache[20] || (_cache[20] = [
                              createBaseVNode("use", { "xlink:href": "#icon-chevron-top" }, null, -1)
                            ])], 2))
                          ], 8, _hoisted_7$k),
                          createBaseVNode("button", {
                            type: "button",
                            disabled: ref_index === unref(gameStore).additional_referees.length - 1,
                            class: "anwp-cursor-pointer d-flex align-items-center justify-content-center button",
                            onClick: withModifiers(($event) => swapAdditionalReferees("down", ref_index), ["prevent"])
                          }, [
                            (openBlock(), createElementBlock("svg", {
                              class: normalizeClass(["anwp-icon anwp-icon--octi d-inline-block anwp-icon--s16", ref_index === unref(gameStore).additional_referees.length - 1 ? "anwp-opacity-50" : ""])
                            }, [..._cache[21] || (_cache[21] = [
                              createBaseVNode("use", { "xlink:href": "#icon-chevron-bottom" }, null, -1)
                            ])], 2))
                          ], 8, _hoisted_8$i)
                        ]),
                        createBaseVNode("div", _hoisted_9$e, [
                          createBaseVNode("label", _hoisted_10$e, toDisplayString(unref(l10n).role), 1),
                          withDirectives(createBaseVNode("input", {
                            id: "anwpfl-add-ref-role",
                            type: "text",
                            class: "anwp-w-min-200",
                            "onUpdate:modelValue": ($event) => add_ref.role = $event
                          }, null, 8, _hoisted_11$d), [
                            [vModelText, add_ref.role]
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_12$d, [
                        createBaseVNode("button", {
                          type: "button",
                          style: { "line-height": "1.7 !important" },
                          class: "anwp-cursor-pointer d-flex align-items-center justify-content-center button anwp-text-red-600 anwp-border-red-600 anwp-min-height-unset mt-3",
                          onClick: withModifiers(($event) => unref(gameStore).additional_referees.splice(ref_index, 1), ["prevent"])
                        }, toDisplayString(unref(l10n).remove_referee), 9, _hoisted_13$c)
                      ])
                    ]),
                    createVNode(_sfc_main$s, {
                      class: "mr-4",
                      style: { "margin-top": "0 !important" },
                      l10n: unref(l10n),
                      "default-photo": unref(gameStore).appConfig.default_photo,
                      referee: add_ref.referee,
                      "text-referee": unref(l10n).referee,
                      onOpenModalRefereeSelector: ($event) => openModalRefereeSelector("add_ref", ref_index),
                      onClickRemove: ($event) => add_ref.referee = null
                    }, null, 8, ["l10n", "default-photo", "referee", "text-referee", "onOpenModalRefereeSelector", "onClickRemove"])
                  ]);
                }), 128))
              ]),
              _: 1
            }),
            createBaseVNode("div", _hoisted_14$c, [
              createBaseVNode("button", {
                type: "button",
                class: "button button-secondary px-4 py-1",
                onClick: _cache[8] || (_cache[8] = withModifiers(($event) => addAdditionalReferee(), ["prevent"]))
              }, toDisplayString(unref(l10n).add_another_referee), 1)
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_referee",
            value: ((_a2 = unref(gameStore).referee) == null ? void 0 : _a2.id) || ""
          }, null, 8, _hoisted_15$b),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_assistant_1",
            value: ((_b2 = unref(gameStore).assistant_1) == null ? void 0 : _b2.id) || ""
          }, null, 8, _hoisted_16$b),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_assistant_2",
            value: ((_c = unref(gameStore).assistant_2) == null ? void 0 : _c.id) || ""
          }, null, 8, _hoisted_17$a),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_referee_fourth",
            value: ((_d = unref(gameStore).referee_fourth) == null ? void 0 : _d.id) || ""
          }, null, 8, _hoisted_18$a),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_additional_referees",
            value: JSON.stringify(additionalRefereesCompact.value)
          }, null, 8, _hoisted_19$a),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_temp_referees",
            value: JSON.stringify(unref(gameStore).tempReferees)
          }, null, 8, _hoisted_20$8),
          createVNode(unref(Ro), {
            modelValue: unref(gameStore).modals.addReferee,
            "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => unref(gameStore).modals.addReferee = $event),
            "z-index-fn": () => 100060,
            "focus-trap": false,
            "teleport-to": false,
            class: "anwp-vfm-admin-modal",
            "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--medium anwp-vfm-admin-modal__wrapper--top"
          }, {
            default: withCtx(() => [
              createBaseVNode("button", {
                class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
                type: "button",
                onClick: _cache[9] || (_cache[9] = ($event) => unref(gameStore).modals.addReferee = false)
              }, [..._cache[23] || (_cache[23] = [
                createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-x" })
                ], -1)
              ])]),
              createBaseVNode("div", _hoisted_21$8, [
                createBaseVNode("h4", _hoisted_22$8, toDisplayString(unref(gameStore).select_referee), 1)
              ]),
              createBaseVNode("div", _hoisted_23$7, [
                createBaseVNode("div", _hoisted_24$6, [
                  createBaseVNode("div", {
                    class: normalizeClass(["anwp-tab-item anwp-flex-1 mr-1", unref(gameStore).modalData.modalRefereeMode === "saved" ? "anwp-tab-item--active" : ""]),
                    onClick: _cache[10] || (_cache[10] = withModifiers(($event) => unref(gameStore).modalData.modalRefereeMode = "saved", ["prevent"]))
                  }, [
                    createBaseVNode("div", _hoisted_25$4, toDisplayString(unref(l10n).saved_referees), 1),
                    createBaseVNode("div", _hoisted_26$4, toDisplayString(unref(l10n).select_saved_site), 1)
                  ], 2),
                  createBaseVNode("div", {
                    class: normalizeClass(["anwp-tab-item anwp-flex-1 ml-1", unref(gameStore).modalData.modalRefereeMode === "temp" ? "anwp-tab-item--active" : ""]),
                    onClick: _cache[11] || (_cache[11] = withModifiers(($event) => unref(gameStore).modalData.modalRefereeMode = "temp", ["prevent"]))
                  }, [
                    createBaseVNode("div", _hoisted_27$4, toDisplayString(unref(l10n).temporary_referee), 1),
                    createBaseVNode("div", _hoisted_28$4, toDisplayString(unref(l10n).add_referee_as_text), 1)
                  ], 2)
                ]),
                "saved" === unref(gameStore).modalData.modalRefereeMode ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createBaseVNode("div", _hoisted_29$4, [
                    createBaseVNode("label", _hoisted_30$4, toDisplayString(unref(l10n).search_by_name), 1),
                    withDirectives(createBaseVNode("input", {
                      id: "anwp-fl-modal-referee-search",
                      type: "text",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => search.value = $event),
                      onInput: _cache[13] || (_cache[13] = ($event) => pageNumber.value = 1),
                      class: "w-100"
                    }, null, 544), [
                      [vModelText, search.value]
                    ])
                  ]),
                  _cache[24] || (_cache[24] = createBaseVNode("hr", null, null, -1)),
                  refereesInModal.value.length ? (openBlock(), createBlock(unref(Paginate), {
                    key: 0,
                    class: "anwp-user-select-none mb-2 mb-0",
                    modelValue: pageNumber.value,
                    "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => pageNumber.value = $event),
                    "page-count": refereesPages.value,
                    "prev-text": unref(l10n).prev,
                    "next-text": unref(l10n).next,
                    "container-class": "anwp-pagination",
                    "page-class": "anwp-page-item",
                    "prev-class": "anwp-page-item",
                    "next-class": "anwp-page-item",
                    "next-link-class": "anwp-page-link",
                    "prev-link-class": "anwp-page-link",
                    "page-link-class": "anwp-page-link"
                  }, null, 8, ["modelValue", "page-count", "prev-text", "next-text"])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(refereesInModalPaginated.value, (referee) => {
                    return openBlock(), createBlock(_sfc_main$t, {
                      onClickReferee: ($event) => addReferee(referee),
                      class: "my-2",
                      key: referee.id,
                      referee,
                      defaultPhoto: unref(gameStore).appConfig.default_photo
                    }, null, 8, ["onClickReferee", "referee", "defaultPhoto"]);
                  }), 128))
                ], 64)) : createCommentVNode("", true),
                "temp" === unref(gameStore).modalData.modalRefereeMode ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createBaseVNode("div", _hoisted_31$4, [
                    createBaseVNode("label", _hoisted_32$4, toDisplayString(unref(l10n).referee_name), 1),
                    withDirectives(createBaseVNode("input", {
                      name: "_anwpfl_attendance",
                      type: "text",
                      id: "anwp-fl-input-temp-name",
                      class: "w-100 anwp-w-min-100",
                      "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => unref(gameStore).modalData.tempReferee.name = $event)
                    }, null, 512), [
                      [vModelText, unref(gameStore).modalData.tempReferee.name]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_33$4, [
                    createBaseVNode("label", _hoisted_34$3, toDisplayString(unref(l10n).nationality), 1),
                    withDirectives(createBaseVNode("select", {
                      id: "anwp-fl-input-temp-country",
                      "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => unref(gameStore).modalData.tempReferee.country = $event)
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameStore).appConfig.countries, (countryName, countryCode) => {
                        return openBlock(), createElementBlock("option", { value: countryCode }, toDisplayString(countryName), 9, _hoisted_35$3);
                      }), 256))
                    ], 512), [
                      [vModelSelect, unref(gameStore).modalData.tempReferee.country]
                    ])
                  ]),
                  createBaseVNode("button", {
                    class: "button button-primary d-flex align-items-center my-4 w-100 justify-content-center py-1 px-4",
                    type: "button",
                    onClick: _cache[17] || (_cache[17] = withModifiers(($event) => addTempReferee(unref(gameStore).modalData.tempReferee), ["prevent"]))
                  }, toDisplayString(unref(l10n).add_temporary_referee), 1)
                ], 64)) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_36$3, [
                createBaseVNode("div", _hoisted_37$3, [
                  createBaseVNode("button", {
                    type: "button",
                    class: "button button-secondary text-capitalize",
                    onClick: _cache[18] || (_cache[18] = withModifiers(($event) => unref(gameStore).modals.addReferee = false, ["prevent"]))
                  }, toDisplayString(unref(l10n).close), 1)
                ])
              ])
            ]),
            _: 1
          }, 8, ["modelValue"])
        ]);
      };
    }
  };
  const _hoisted_1$q = { class: "anwp-vue-match-wrapper anwp-b-wrap anwp-vue-wrapper-ready" };
  const _sfc_main$q = {
    __name: "AppMatch",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$q, [
          createVNode(_sfc_main$H),
          createVNode(_sfc_main$F),
          createVNode(_sfc_main$A),
          createVNode(_sfc_main$v),
          createVNode(_sfc_main$u),
          createVNode(_sfc_main$r),
          createVNode(unref(Wo)),
          createVNode(_sfc_main$z),
          createVNode(_sfc_main$w),
          createVNode(_sfc_main$y),
          createVNode(_sfc_main$x)
        ]);
      };
    }
  };
  const _hoisted_1$p = { class: "anwp-vue-standing-setup-wrapper anwp-b-wrap anwp-vue-wrapper-ready" };
  const _hoisted_2$l = { class: "anwp-border anwp-border-gray-500 bg-white" };
  const _hoisted_3$l = { class: "px-4" };
  const _hoisted_4$l = { class: "d-flex flex-column my-4" };
  const _hoisted_5$k = {
    class: "mb-1 anwp-text-gray-800 d-flex",
    for: "anwpfl-input-competition"
  };
  const _hoisted_6$k = { class: "w-100 d-flex align-items-center" };
  const _hoisted_7$j = ["src"];
  const _hoisted_8$h = { class: "anwp-opacity-70 anwp-text-xs anwp-leading-1-25" };
  const _hoisted_9$d = { class: "w-100 d-flex align-items-center" };
  const _hoisted_10$d = ["src"];
  const _hoisted_11$c = { class: "anwp-opacity-70 anwp-text-xs anwp-leading-1-25" };
  const _hoisted_12$c = { class: "d-flex flex-column my-4" };
  const _hoisted_13$b = {
    class: "mb-1 anwp-text-gray-800 d-flex",
    for: "anwpfl-input-competition-group"
  };
  const _hoisted_14$b = { class: "d-flex flex-column" };
  const _hoisted_15$a = { class: "anwp-text-lg mb-2 mt-1" };
  const _hoisted_16$a = ["src"];
  const _hoisted_17$9 = { class: "d-flex flex-column" };
  const _hoisted_18$9 = { class: "anwp-text-lg mb-2 mt-1" };
  const _hoisted_19$9 = ["src"];
  const _hoisted_20$7 = {
    key: 0,
    class: "my-4"
  };
  const _hoisted_21$7 = {
    type: "submit",
    class: "button button-primary px-4 py-1"
  };
  const _hoisted_22$7 = {
    key: 1,
    class: "my-4"
  };
  const _hoisted_23$6 = ["value"];
  const _hoisted_24$5 = ["value"];
  const _sfc_main$p = {
    __name: "AppStandingSetup",
    setup(__props) {
      const l10n = Object.assign({}, window._AnWP_FL_Standing_Setup.l10n);
      const options = {
        clubs: window._AnWP_FL_Standing_Setup.optionsClub,
        competitions: window._AnWP_FL_Competitions
      };
      const cloned = ref(window._AnWP_FL_Standing_Setup.cloned || "");
      const competitionId = ref("");
      const competitionGroup = ref("");
      const groupOptions = computed(() => {
        var _a2, _b2;
        if (!competitionId.value) {
          return [];
        }
        const groupOptions2 = (_b2 = (_a2 = options.competitions.find((c2) => Number(c2.id) === Number(competitionId.value))) == null ? void 0 : _a2.groups) == null ? void 0 : _b2.map((groupData, groupIndex) => {
          const clubs = groupData.clubs.map((cl) => options.clubs.find((c2) => Number(c2.id) === Number(cl)));
          return {
            id: groupData.id,
            title: (groupData == null ? void 0 : groupData.title) || l10n.group + " #" + (groupIndex + 1),
            clubs: clubs ? clubs.sort((a2, b2) => a2.title > b2.title ? 1 : b2.title > a2.title ? -1 : 0) : []
          };
        });
        return groupOptions2 || [];
      });
      watch(competitionId, () => {
        if (!competitionId.value) {
          competitionGroup.value = "";
        }
      });
      return (_ctx, _cache) => {
        const _component_v_select = resolveComponent("v-select");
        return openBlock(), createElementBlock("div", _hoisted_1$p, [
          createBaseVNode("div", _hoisted_2$l, [
            createVNode(AppBlockHeader, { icon: "#icon-gear" }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(l10n).select_competition_group), 1)
              ]),
              _: 1
            }),
            createBaseVNode("div", _hoisted_3$l, [
              createBaseVNode("div", _hoisted_4$l, [
                createBaseVNode("label", _hoisted_5$k, toDisplayString(unref(l10n).competition), 1),
                createVNode(_component_v_select, {
                  id: "anwpfl-input-competition",
                  modelValue: competitionId.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => competitionId.value = $event),
                  class: "anwp-w-400 anwp-max-width-100",
                  options: options.competitions,
                  label: "title_full",
                  clearable: true,
                  filterable: true,
                  searchable: true,
                  reduce: (o2) => o2.id
                }, {
                  option: withCtx(({ title_full, logo, league_text, season_text }) => [
                    createBaseVNode("div", _hoisted_6$k, [
                      logo ? (openBlock(), createElementBlock("img", {
                        key: 0,
                        class: "anwp-object-contain anwp-w-30 anwp-h-30 mr-2",
                        src: logo,
                        alt: "competition logo"
                      }, null, 8, _hoisted_7$j)) : createCommentVNode("", true),
                      createBaseVNode("div", null, [
                        createTextVNode(toDisplayString(title_full), 1),
                        _cache[2] || (_cache[2] = createBaseVNode("br", null, null, -1)),
                        createBaseVNode("span", _hoisted_8$h, toDisplayString(league_text) + " | " + toDisplayString(season_text), 1)
                      ])
                    ])
                  ]),
                  "selected-option": withCtx(({ title_full, logo, league_text, season_text }) => [
                    createBaseVNode("div", _hoisted_9$d, [
                      logo ? (openBlock(), createElementBlock("img", {
                        key: 0,
                        class: "anwp-object-contain anwp-w-30 anwp-h-30 mr-2",
                        src: logo,
                        alt: "competition logo"
                      }, null, 8, _hoisted_10$d)) : createCommentVNode("", true),
                      createBaseVNode("div", null, [
                        createTextVNode(toDisplayString(title_full), 1),
                        _cache[3] || (_cache[3] = createBaseVNode("br", null, null, -1)),
                        createBaseVNode("span", _hoisted_11$c, toDisplayString(league_text) + " | " + toDisplayString(season_text), 1)
                      ])
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue", "options", "reduce"])
              ]),
              createBaseVNode("div", _hoisted_12$c, [
                createBaseVNode("label", _hoisted_13$b, toDisplayString(unref(l10n).group), 1),
                createVNode(_component_v_select, {
                  id: "anwpfl-input-competition-group",
                  modelValue: competitionGroup.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => competitionGroup.value = $event),
                  class: "anwp-w-400 anwp-max-width-100",
                  options: groupOptions.value,
                  disabled: !groupOptions.value.length,
                  label: "title",
                  clearable: true,
                  filterable: true,
                  searchable: true,
                  reduce: (o2) => o2.id
                }, {
                  option: withCtx(({ title, clubs }) => [
                    createBaseVNode("div", _hoisted_14$b, [
                      createBaseVNode("div", _hoisted_15$a, toDisplayString(title), 1),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(clubs, (club) => {
                        return openBlock(), createElementBlock("div", {
                          key: club.id,
                          class: "d-flex align-items-center mb-1"
                        }, [
                          club.logo ? (openBlock(), createElementBlock("img", {
                            key: 0,
                            src: club.logo,
                            alt: "club logo",
                            class: "mr-2 anwp-object-contain anwp-w-20 anwp-h-20"
                          }, null, 8, _hoisted_16$a)) : createCommentVNode("", true),
                          createTextVNode(" " + toDisplayString(club.title), 1)
                        ]);
                      }), 128))
                    ])
                  ]),
                  "selected-option": withCtx(({ title, clubs }) => [
                    createBaseVNode("div", _hoisted_17$9, [
                      createBaseVNode("div", _hoisted_18$9, toDisplayString(title), 1),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(clubs, (club) => {
                        return openBlock(), createElementBlock("div", {
                          key: club.id,
                          class: "d-flex align-items-center mb-1"
                        }, [
                          club.logo ? (openBlock(), createElementBlock("img", {
                            key: 0,
                            src: club.logo,
                            alt: "club logo",
                            class: "mr-2 anwp-object-contain anwp-w-20 anwp-h-20"
                          }, null, 8, _hoisted_19$9)) : createCommentVNode("", true),
                          createTextVNode(" " + toDisplayString(club.title), 1)
                        ]);
                      }), 128))
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue", "options", "disabled", "reduce"])
              ]),
              competitionGroup.value ? (openBlock(), createElementBlock("div", _hoisted_20$7, [
                createBaseVNode("button", _hoisted_21$7, toDisplayString(unref(l10n).save_continue), 1)
              ])) : createCommentVNode("", true),
              cloned.value ? (openBlock(), createElementBlock("div", _hoisted_22$7, " * " + toDisplayString(unref(l10n).some_options_will_be_copied_from) + " " + toDisplayString(cloned.value), 1)) : createCommentVNode("", true)
            ])
          ]),
          _cache[4] || (_cache[4] = createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_fixed_setup",
            value: "yes"
          }, null, -1)),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_competition",
            value: competitionId.value
          }, null, 8, _hoisted_23$6),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_competition_group",
            value: competitionGroup.value
          }, null, 8, _hoisted_24$5)
        ]);
      };
    }
  };
  const useStStore = /* @__PURE__ */ defineStore("st", () => {
    var _a2;
    const activeRequest = ref("");
    const pointsInitial = reactive(safeJsonParse(window._AnWP_FL_Standing_Data.pointsInitial, {}) || {});
    const isInitialDataActive = ref(!!window._AnWP_FL_Standing_Data.is_initial_data_active);
    const tableInitial = reactive(window._AnWP_FL_Standing_Data.table_initial);
    const tableColors = reactive(safeJsonParse(window._AnWP_FL_Standing_Data.tableColors, {}) || {});
    const tableNotes = ref(window._AnWP_FL_Standing_Data.tableNotes || "");
    const manualOrdering = ref("yes" === window._AnWP_FL_Standing_Data.manualOrdering);
    const tableMain = ref(safeJsonParse(window._AnWP_FL_Standing_Data.tableMain, []) || []);
    const l10n = window._AnWP_FL_Standing_Data.l10n;
    const pointsWin = ref(Number(window._AnWP_FL_Standing_Data.pointsWin));
    const pointsDraw = ref(Number(window._AnWP_FL_Standing_Data.pointsDraw));
    const pointsLoss = ref(Number(window._AnWP_FL_Standing_Data.pointsLoss));
    const rankingRulesCurrent = ref(window._AnWP_FL_Standing_Data.rankingRulesCurrent ? window._AnWP_FL_Standing_Data.rankingRulesCurrent.split(",") : []);
    const rankingRulesMap = reactive({
      "goals_difference": l10n.goals_difference,
      "wins": l10n.wins,
      "goals_scored": l10n.goals_scored
    });
    const appConfig = reactive({
      clubs: window._AnWP_FL_Clubs,
      standings: ((_a2 = window._AnWP_FL_Standing_Data) == null ? void 0 : _a2.optionStandings) || [],
      spinnerUrl: window._AnWP_FL_Standing_Data.spinner_url || ""
    });
    const initializeInitialTable = () => {
      if (!isInitialDataActive.value) {
        return;
      }
      Object.values(appConfig.clubs).forEach((c2) => {
        if (!tableInitial[c2.id]) {
          tableInitial[c2.id] = {
            played: "",
            won: "",
            drawn: "",
            lost: "",
            gf: "",
            ga: "",
            gd: "",
            points: ""
          };
        }
      });
    };
    initializeInitialTable();
    const modals = reactive({
      initialPoints: false,
      colorModal: false,
      initialLoadFrom: false
    });
    const modalData = reactive({
      pointsInitialClub: "",
      pointsInitialNumber: 0,
      modalColorType: "place",
      modalColorClub: "",
      modalColorPlace: "",
      modalColor: "",
      standingLoadFrom: "",
      loadingPoints: false,
      predefinedColors: true
    });
    return {
      activeRequest,
      appConfig,
      initializeInitialTable,
      isInitialDataActive,
      manualOrdering,
      modalData,
      modals,
      pointsDraw,
      pointsInitial,
      pointsLoss,
      pointsWin,
      rankingRulesCurrent,
      rankingRulesMap,
      tableColors,
      tableInitial,
      tableMain,
      tableNotes
    };
  });
  const _hoisted_1$o = { class: "anwp-border anwp-border-gray-500" };
  const _hoisted_2$k = { class: "bg-white p-3" };
  const _hoisted_3$k = { class: "my-1 border-bottom font-weight-normal" };
  const _hoisted_4$k = {
    key: 0,
    class: "d-flex flex-column my-4"
  };
  const _hoisted_5$j = { class: "mr-2 bg-secondary text-white anwp-standing__club-points d-inline-block anwp-text-base" };
  const _hoisted_6$j = { class: "d-inline-block" };
  const _hoisted_7$i = ["onClick"];
  const _hoisted_8$g = {
    key: 1,
    class: "my-4"
  };
  const _hoisted_9$c = { class: "my-1 border-bottom font-weight-normal" };
  const _hoisted_10$c = { class: "my-3" };
  const _hoisted_11$b = { class: "table-responsive" };
  const _hoisted_12$b = { class: "table-bordered table-sm anwp-standing-table anwp-standing-table__vue-editable anwp-fl-input-table" };
  const _hoisted_13$a = { scope: "col" };
  const _hoisted_14$a = { scope: "col" };
  const _hoisted_15$9 = { scope: "col" };
  const _hoisted_16$9 = { scope: "col" };
  const _hoisted_17$8 = { scope: "col" };
  const _hoisted_18$8 = { scope: "col" };
  const _hoisted_19$8 = { scope: "col" };
  const _hoisted_20$6 = { scope: "col" };
  const _hoisted_21$6 = { scope: "col" };
  const _hoisted_22$6 = { class: "text-left px-2" };
  const _hoisted_23$5 = { class: "p-1" };
  const _hoisted_24$4 = ["onUpdate:modelValue"];
  const _hoisted_25$3 = { class: "p-1" };
  const _hoisted_26$3 = ["onUpdate:modelValue"];
  const _hoisted_27$3 = { class: "p-1" };
  const _hoisted_28$3 = ["onUpdate:modelValue"];
  const _hoisted_29$3 = { class: "p-1" };
  const _hoisted_30$3 = ["onUpdate:modelValue"];
  const _hoisted_31$3 = { class: "p-1" };
  const _hoisted_32$3 = ["onUpdate:modelValue"];
  const _hoisted_33$3 = { class: "p-1" };
  const _hoisted_34$2 = ["onUpdate:modelValue"];
  const _hoisted_35$2 = { class: "p-1" };
  const _hoisted_36$2 = ["onUpdate:modelValue"];
  const _hoisted_37$2 = { class: "p-1" };
  const _hoisted_38$2 = ["onUpdate:modelValue"];
  const _hoisted_39$2 = ["value"];
  const _hoisted_40$2 = ["value"];
  const _hoisted_41$2 = ["value"];
  const _sfc_main$o = {
    __name: "AppInitial",
    setup(__props) {
      const stStore = useStStore();
      const l10n = window._AnWP_FL_Standing_Data.l10n;
      const openInitialPointsSelector = () => {
        stStore.modalData.pointsInitialClub = "";
        stStore.modalData.pointsInitialNumber = 0;
        stStore.modals.initialPoints = true;
      };
      const openLoadInitialPointsModal = () => {
        stStore.modalData.standingLoadFrom = "";
        stStore.modals.initialLoadFrom = true;
      };
      return (_ctx, _cache) => {
        const _component_toggle = resolveComponent("toggle");
        return openBlock(), createElementBlock("div", _hoisted_1$o, [
          createVNode(AppBlockHeader, { icon: "#icon-gear" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).initial_standing_table_data), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$k, [
            createBaseVNode("h3", _hoisted_3$k, toDisplayString(unref(l10n).initial_points), 1),
            Object.keys(unref(stStore).pointsInitial).length ? (openBlock(), createElementBlock("div", _hoisted_4$k, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stStore).pointsInitial, (points, clubId) => {
                var _a2;
                return openBlock(), createElementBlock("div", {
                  class: "pr-2 bg-light text-dark d-flex align-items-center justify-content-between anwp-w-300",
                  key: clubId
                }, [
                  createBaseVNode("div", null, [
                    createBaseVNode("span", _hoisted_5$j, toDisplayString(points), 1),
                    createBaseVNode("span", _hoisted_6$j, toDisplayString(((_a2 = unref(stStore).appConfig.clubs[clubId]) == null ? void 0 : _a2.title) || ""), 1)
                  ]),
                  createBaseVNode("a", {
                    class: "button d-flex align-items-center",
                    href: "#",
                    onClick: withModifiers(($event) => delete unref(stStore).pointsInitial[clubId], ["prevent"])
                  }, [..._cache[4] || (_cache[4] = [
                    createBaseVNode("svg", { class: "anwp-icon anwp-icon--s14" }, [
                      createBaseVNode("use", { "xlink:href": "#icon-close" })
                    ], -1)
                  ])], 8, _hoisted_7$i)
                ]);
              }), 128))
            ])) : (openBlock(), createElementBlock("div", _hoisted_8$g, "- " + toDisplayString(unref(l10n).not_specified) + " -", 1)),
            createBaseVNode("a", {
              href: "#",
              class: "button mb-4",
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => openInitialPointsSelector(), ["prevent"]))
            }, toDisplayString(unref(l10n).add_remove_points), 1),
            createBaseVNode("h3", _hoisted_9$c, toDisplayString(unref(l10n).initial_standing_table_data), 1),
            createBaseVNode("div", _hoisted_10$c, [
              createVNode(_component_toggle, {
                modelValue: unref(stStore).isInitialDataActive,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(stStore).isInitialDataActive = $event),
                "on-label": unref(l10n).enable,
                "off-label": unref(l10n).disable,
                onChange: _cache[2] || (_cache[2] = ($event) => unref(stStore).initializeInitialTable()),
                class: "anwp-toggle-w-80"
              }, null, 8, ["modelValue", "on-label", "off-label"])
            ]),
            unref(stStore).isInitialDataActive ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createBaseVNode("div", _hoisted_11$b, [
                createBaseVNode("table", _hoisted_12$b, [
                  createBaseVNode("thead", null, [
                    createBaseVNode("tr", null, [
                      createBaseVNode("th", _hoisted_13$a, toDisplayString(unref(l10n).club), 1),
                      createBaseVNode("th", _hoisted_14$a, toDisplayString(unref(l10n).played), 1),
                      createBaseVNode("th", _hoisted_15$9, toDisplayString(unref(l10n).won), 1),
                      createBaseVNode("th", _hoisted_16$9, toDisplayString(unref(l10n).drawn), 1),
                      createBaseVNode("th", _hoisted_17$8, toDisplayString(unref(l10n).lost), 1),
                      createBaseVNode("th", _hoisted_18$8, toDisplayString(unref(l10n).gf), 1),
                      createBaseVNode("th", _hoisted_19$8, toDisplayString(unref(l10n).ga), 1),
                      createBaseVNode("th", _hoisted_20$6, toDisplayString(unref(l10n).gd), 1),
                      createBaseVNode("th", _hoisted_21$6, toDisplayString(unref(l10n).points), 1)
                    ])
                  ]),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stStore).tableInitial, (row, clubID) => {
                    var _a2;
                    return openBlock(), createElementBlock("tr", { key: clubID }, [
                      createBaseVNode("td", _hoisted_22$6, toDisplayString(((_a2 = unref(stStore).appConfig.clubs[clubID]) == null ? void 0 : _a2.title) || ""), 1),
                      createBaseVNode("td", _hoisted_23$5, [
                        withDirectives(createBaseVNode("input", {
                          class: "text-center anwp-w-70",
                          type: "number",
                          "onUpdate:modelValue": ($event) => row.played = $event
                        }, null, 8, _hoisted_24$4), [
                          [
                            vModelText,
                            row.played,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ]),
                      createBaseVNode("td", _hoisted_25$3, [
                        withDirectives(createBaseVNode("input", {
                          class: "text-center anwp-w-70",
                          type: "number",
                          "onUpdate:modelValue": ($event) => row.won = $event
                        }, null, 8, _hoisted_26$3), [
                          [
                            vModelText,
                            row.won,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ]),
                      createBaseVNode("td", _hoisted_27$3, [
                        withDirectives(createBaseVNode("input", {
                          class: "text-center anwp-w-70",
                          type: "number",
                          "onUpdate:modelValue": ($event) => row.drawn = $event
                        }, null, 8, _hoisted_28$3), [
                          [
                            vModelText,
                            row.drawn,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ]),
                      createBaseVNode("td", _hoisted_29$3, [
                        withDirectives(createBaseVNode("input", {
                          class: "text-center anwp-w-70",
                          type: "number",
                          "onUpdate:modelValue": ($event) => row.lost = $event
                        }, null, 8, _hoisted_30$3), [
                          [
                            vModelText,
                            row.lost,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ]),
                      createBaseVNode("td", _hoisted_31$3, [
                        withDirectives(createBaseVNode("input", {
                          class: "text-center anwp-w-70",
                          type: "number",
                          "onUpdate:modelValue": ($event) => row.gf = $event
                        }, null, 8, _hoisted_32$3), [
                          [
                            vModelText,
                            row.gf,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ]),
                      createBaseVNode("td", _hoisted_33$3, [
                        withDirectives(createBaseVNode("input", {
                          class: "text-center anwp-w-70",
                          type: "number",
                          "onUpdate:modelValue": ($event) => row.ga = $event
                        }, null, 8, _hoisted_34$2), [
                          [
                            vModelText,
                            row.ga,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ]),
                      createBaseVNode("td", _hoisted_35$2, [
                        withDirectives(createBaseVNode("input", {
                          class: "text-center anwp-w-70",
                          type: "number",
                          "onUpdate:modelValue": ($event) => row.gd = $event
                        }, null, 8, _hoisted_36$2), [
                          [
                            vModelText,
                            row.gd,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ]),
                      createBaseVNode("td", _hoisted_37$2, [
                        withDirectives(createBaseVNode("input", {
                          class: "text-center anwp-w-70",
                          type: "number",
                          "onUpdate:modelValue": ($event) => row.points = $event
                        }, null, 8, _hoisted_38$2), [
                          [
                            vModelText,
                            row.points,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ])
                    ]);
                  }), 128))
                ])
              ]),
              createBaseVNode("a", {
                href: "#",
                class: "button mt-3",
                onClick: _cache[3] || (_cache[3] = withModifiers(($event) => openLoadInitialPointsModal(), ["prevent"]))
              }, toDisplayString(unref(l10n).load_initial_data_another), 1)
            ], 64)) : createCommentVNode("", true),
            createBaseVNode("input", {
              type: "hidden",
              name: "_anwpfl_is_initial_data_active",
              value: unref(stStore).isInitialDataActive
            }, null, 8, _hoisted_39$2),
            createBaseVNode("input", {
              type: "hidden",
              name: "_anwpfl_table_initial",
              value: JSON.stringify(unref(stStore).tableInitial)
            }, null, 8, _hoisted_40$2),
            createBaseVNode("input", {
              type: "hidden",
              name: "_anwpfl_points_initial",
              value: JSON.stringify(unref(stStore).pointsInitial)
            }, null, 8, _hoisted_41$2)
          ])
        ]);
      };
    }
  };
  const _hoisted_1$n = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$j = { class: "my-0" };
  const _hoisted_3$j = { class: "anwp-vfm-admin-modal__content d-flex flex-column" };
  const _hoisted_4$j = {
    for: "anwpfl-input-initial-points-club",
    class: "mb-1"
  };
  const _hoisted_5$i = ["value"];
  const _hoisted_6$i = {
    for: "anwpfl-input-initial-points",
    class: "mb-1 mt-3"
  };
  const _hoisted_7$h = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_8$f = { class: "d-flex flex-row-reverse" };
  const _sfc_main$n = {
    __name: "AppModalInitialPoints",
    setup(__props) {
      const stStore = useStStore();
      const l10n = window._AnWP_FL_Standing_Data.l10n;
      const addInitialPoints = () => {
        if (stStore.modalData.pointsInitialClub && stStore.modalData.pointsInitialNumber) {
          stStore.pointsInitial[stStore.modalData.pointsInitialClub] = stStore.modalData.pointsInitialNumber;
        }
        stStore.modals.initialPoints = false;
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(stStore).modals.initialPoints,
          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(stStore).modals.initialPoints = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(stStore).modals.initialPoints = false)
            }, [..._cache[6] || (_cache[6] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$n, [
              createBaseVNode("h4", _hoisted_2$j, toDisplayString(unref(l10n).add_initial_points), 1)
            ]),
            createBaseVNode("div", _hoisted_3$j, [
              createBaseVNode("label", _hoisted_4$j, toDisplayString(unref(l10n).select_club), 1),
              withDirectives(createBaseVNode("select", {
                id: "anwpfl-input-initial-points-club",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(stStore).modalData.pointsInitialClub = $event)
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stStore).appConfig.clubs, (club, clubId) => {
                  return openBlock(), createElementBlock("option", {
                    value: clubId,
                    key: clubId
                  }, toDisplayString(club.title), 9, _hoisted_5$i);
                }), 128))
              ], 512), [
                [vModelSelect, unref(stStore).modalData.pointsInitialClub]
              ]),
              createBaseVNode("label", _hoisted_6$i, toDisplayString(unref(l10n).club_initial_points), 1),
              withDirectives(createBaseVNode("input", {
                id: "anwpfl-input-initial-points",
                class: "anwp-w-70 anwp-text-xl anwp-text-center",
                type: "number",
                step: "1",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(stStore).modalData.pointsInitialNumber = $event)
              }, null, 512), [
                [vModelText, unref(stStore).modalData.pointsInitialNumber]
              ])
            ]),
            createBaseVNode("div", _hoisted_7$h, [
              createBaseVNode("div", _hoisted_8$f, [
                createBaseVNode("button", {
                  onClick: _cache[3] || (_cache[3] = withModifiers(($event) => addInitialPoints(), ["prevent"])),
                  type: "button",
                  class: "button button-primary ml-2 text-capitalize"
                }, toDisplayString(unref(l10n).save_changes), 1),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary text-capitalize",
                  onClick: _cache[4] || (_cache[4] = ($event) => unref(stStore).modals.initialPoints = false)
                }, toDisplayString(unref(l10n).close), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$m = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$i = { class: "my-0" };
  const _hoisted_3$i = { class: "anwp-vfm-admin-modal__content d-flex flex-column" };
  const _hoisted_4$i = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_5$h = { class: "d-flex flex-row-reverse" };
  const _hoisted_6$h = ["disabled"];
  const _hoisted_7$g = ["src"];
  const _hoisted_8$e = ["disabled"];
  const _sfc_main$m = {
    __name: "AppModalInitialLoadFrom",
    setup(__props) {
      const notyf2 = new Notyf({ duration: 5e3 });
      const stStore = useStStore();
      const l10n = window._AnWP_FL_Standing_Data.l10n;
      const AppAxios = axios.create({
        baseURL: window._AnWP_FL_Standing_Data.rest_root,
        headers: {
          "X-WP-Nonce": window._AnWP_FL_Standing_Data.rest_nonce
        }
      });
      const loadInitialPoints = () => {
        if (stStore.modalData.loadingPoints) {
          return false;
        }
        if (!stStore.modalData.standingLoadFrom) {
          notyf2.error(l10n.standing_table_not_selected);
          return false;
        }
        stStore.modalData.loadingPoints = true;
        AppAxios.get(
          `anwpfl/helper/load-standing-data`,
          { params: { from: stStore.modalData.standingLoadFrom, to: window._AnWP_FL_Standing_Data.standing_id } }
        ).then((response) => {
          var _a2;
          Object.assign(stStore.tableInitial, ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.initialData) || []);
          stStore.modalData.loadingPoints = false;
          stStore.modals.initialLoadFrom = false;
        }).catch((error) => {
          notyf2.error(error);
          stStore.modalData.loadingPoints = false;
        });
      };
      return (_ctx, _cache) => {
        const _component_v_select = resolveComponent("v-select");
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(stStore).modals.initialLoadFrom,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(stStore).modals.initialLoadFrom = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(stStore).modals.initialLoadFrom = false)
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$m, [
              createBaseVNode("h4", _hoisted_2$i, toDisplayString(unref(l10n).load_initial_data_another), 1)
            ]),
            createBaseVNode("div", _hoisted_3$i, [
              createVNode(_component_v_select, {
                class: "anwp-w-400 anwp-max-width-100",
                label: "title",
                modelValue: unref(stStore).modalData.standingLoadFrom,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(stStore).modalData.standingLoadFrom = $event),
                options: unref(stStore).appConfig.standings,
                clearable: true,
                filterable: true,
                searchable: true,
                appendToBody: true,
                reduce: (o2) => o2.id
              }, null, 8, ["modelValue", "options", "reduce"])
            ]),
            createBaseVNode("div", _hoisted_4$i, [
              createBaseVNode("div", _hoisted_5$h, [
                createBaseVNode("button", {
                  disabled: unref(stStore).modalData.loadingPoints,
                  onClick: _cache[2] || (_cache[2] = withModifiers(($event) => loadInitialPoints(), ["prevent"])),
                  type: "button",
                  class: "button button-primary ml-2 text-capitalize d-flex align-items-center"
                }, [
                  createTextVNode(toDisplayString(unref(l10n).Load_data) + " ", 1),
                  unref(stStore).modalData.loadingPoints ? (openBlock(), createElementBlock("img", {
                    key: 0,
                    class: "ml-2",
                    src: unref(stStore).appConfig.spinnerUrl,
                    alt: "spinner"
                  }, null, 8, _hoisted_7$g)) : createCommentVNode("", true)
                ], 8, _hoisted_6$h),
                createBaseVNode("button", {
                  disabled: unref(stStore).modalData.loadingPoints,
                  type: "button",
                  class: "button button-secondary anwp-text-capitalize",
                  onClick: _cache[3] || (_cache[3] = withModifiers(($event) => unref(stStore).modals.initialLoadFrom = false, ["prevent"]))
                }, toDisplayString(unref(l10n).close), 9, _hoisted_8$e)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$l = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$h = { class: "my-0" };
  const _hoisted_3$h = { class: "anwp-vfm-admin-modal__content d-flex flex-column" };
  const _hoisted_4$h = { for: "anwpfl-input-color-type mb-1" };
  const _hoisted_5$g = { value: "place" };
  const _hoisted_6$g = { value: "club" };
  const _hoisted_7$f = {
    for: "anwpfl-input-color-club",
    class: "mb-1"
  };
  const _hoisted_8$d = ["value"];
  const _hoisted_9$b = {
    for: "anwpfl-input-color-place",
    class: "mb-1"
  };
  const _hoisted_10$b = {
    for: "anwpfl-input-color",
    class: "mt-3"
  };
  const _hoisted_11$a = { class: "mb-3 mt-1" };
  const _hoisted_12$a = { class: "table mt-2" };
  const _hoisted_13$9 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_14$9 = { class: "d-flex flex-row-reverse" };
  const _sfc_main$l = {
    __name: "AppModalColor",
    setup(__props) {
      const notyf2 = new Notyf({ duration: 5e3 });
      const stStore = useStStore();
      const l10n = window._AnWP_FL_Standing_Data.l10n;
      const addNewColor = () => {
        if (!stStore.modalData.modalColor) {
          notyf2.error("Color Is Not Selected");
          return false;
        }
        let colorValue = "";
        if ("club" === stStore.modalData.modalColorType) {
          if (stStore.modalData.modalColorClub) {
            colorValue = "c" + stStore.modalData.modalColorClub;
          } else {
            notyf2.error("Club Is Not Set");
            return false;
          }
        } else if ("place" === stStore.modalData.modalColorType) {
          if (stStore.modalData.modalColorPlace) {
            colorValue = "p" + stStore.modalData.modalColorPlace;
          } else {
            notyf2.error("Place Is Not Set");
            return false;
          }
        }
        if (colorValue) {
          stStore.tableColors[colorValue] = stStore.modalData.modalColor;
        }
        stStore.modals.colorModal = false;
      };
      return (_ctx, _cache) => {
        const _component_toggle = resolveComponent("toggle");
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(stStore).modals.colorModal,
          "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => unref(stStore).modals.colorModal = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(stStore).modals.colorModal = false)
            }, [..._cache[11] || (_cache[11] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$l, [
              createBaseVNode("h4", _hoisted_2$h, toDisplayString(unref(l10n).add_table_color), 1)
            ]),
            createBaseVNode("div", _hoisted_3$h, [
              createBaseVNode("label", _hoisted_4$h, toDisplayString(unref(l10n).color_by), 1),
              withDirectives(createBaseVNode("select", {
                id: "anwpfl-input-color-type",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(stStore).modalData.modalColorType = $event),
                class: "mb-3"
              }, [
                createBaseVNode("option", _hoisted_5$g, toDisplayString(unref(l10n).place), 1),
                createBaseVNode("option", _hoisted_6$g, toDisplayString(unref(l10n).club), 1)
              ], 512), [
                [vModelSelect, unref(stStore).modalData.modalColorType]
              ]),
              "club" === unref(stStore).modalData.modalColorType ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("label", _hoisted_7$f, toDisplayString(unref(l10n).select_club), 1),
                withDirectives(createBaseVNode("select", {
                  id: "anwpfl-input-color-club",
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(stStore).modalData.modalColorClub = $event)
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stStore).appConfig.clubs, (club) => {
                    return openBlock(), createElementBlock("option", {
                      value: club.id
                    }, toDisplayString(club.title), 9, _hoisted_8$d);
                  }), 256))
                ], 512), [
                  [vModelSelect, unref(stStore).modalData.modalColorClub]
                ])
              ], 64)) : createCommentVNode("", true),
              "place" === unref(stStore).modalData.modalColorType ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("label", _hoisted_9$b, "# " + toDisplayString(unref(l10n).place), 1),
                withDirectives(createBaseVNode("input", {
                  id: "anwpfl-input-color-place",
                  class: "anwp-input-number-medium",
                  type: "number",
                  min: "1",
                  step: "1",
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(stStore).modalData.modalColorPlace = $event)
                }, null, 512), [
                  [
                    vModelText,
                    unref(stStore).modalData.modalColorPlace,
                    void 0,
                    { number: true }
                  ]
                ])
              ], 64)) : createCommentVNode("", true),
              createBaseVNode("label", _hoisted_10$b, toDisplayString(unref(l10n).color), 1),
              createBaseVNode("div", _hoisted_11$a, [
                createVNode(_component_toggle, {
                  modelValue: unref(stStore).modalData.predefinedColors,
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(stStore).modalData.predefinedColors = $event),
                  "on-label": unref(l10n).predefined,
                  "off-label": unref(l10n).custom,
                  onChange: _cache[5] || (_cache[5] = ($event) => unref(stStore).modalData.modalColor = ""),
                  class: "anwp-toggle-w-100"
                }, null, 8, ["modelValue", "on-label", "off-label"])
              ]),
              withDirectives(createBaseVNode("select", {
                id: "anwpfl-input-color",
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(stStore).modalData.modalColor = $event)
              }, [..._cache[12] || (_cache[12] = [
                createBaseVNode("option", { value: "primary" }, "primary", -1),
                createBaseVNode("option", { value: "secondary" }, "secondary", -1),
                createBaseVNode("option", { value: "success" }, "success", -1),
                createBaseVNode("option", { value: "danger" }, "danger", -1),
                createBaseVNode("option", { value: "warning" }, "warning", -1),
                createBaseVNode("option", { value: "info" }, "info", -1)
              ])], 512), [
                [vShow, unref(stStore).modalData.predefinedColors],
                [vModelSelect, unref(stStore).modalData.modalColor]
              ]),
              withDirectives(createBaseVNode("div", null, [
                withDirectives(createBaseVNode("input", {
                  type: "color",
                  "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(stStore).modalData.modalColor = $event)
                }, null, 512), [
                  [vModelText, unref(stStore).modalData.modalColor]
                ])
              ], 512), [
                [vShow, !unref(stStore).modalData.predefinedColors]
              ]),
              createBaseVNode("table", _hoisted_12$a, [
                createBaseVNode("tr", {
                  class: normalizeClass(["w-100", [unref(stStore).modalData.modalColor.startsWith("#") ? "" : "table-" + unref(stStore).modalData.modalColor]]),
                  style: normalizeStyle({ backgroundColor: unref(stStore).modalData.modalColor.startsWith("#") ? unref(stStore).modalData.modalColor : "" })
                }, [..._cache[13] || (_cache[13] = [
                  createBaseVNode("td", { class: "py-3" }, null, -1)
                ])], 6)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$9, [
              createBaseVNode("div", _hoisted_14$9, [
                createBaseVNode("button", {
                  onClick: _cache[8] || (_cache[8] = withModifiers(($event) => addNewColor(), ["prevent"])),
                  type: "button",
                  class: "button button-primary ml-2 text-capitalize"
                }, toDisplayString(unref(l10n).save_changes), 1),
                createBaseVNode("button", {
                  type: "button",
                  class: "button",
                  onClick: _cache[9] || (_cache[9] = ($event) => unref(stStore).modals.colorModal = false)
                }, toDisplayString(unref(l10n).close), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$k = { class: "anwp-border anwp-border-gray-500 my-4" };
  const _hoisted_2$g = { class: "bg-white p-3 pb-4" };
  const _hoisted_3$g = {
    key: 0,
    class: "table-bordered"
  };
  const _hoisted_4$g = { key: 0 };
  const _hoisted_5$f = { key: 1 };
  const _hoisted_6$f = {
    class: "p-0",
    style: { "width": "30px" }
  };
  const _hoisted_7$e = ["onClick"];
  const _hoisted_8$c = { key: 1 };
  const _hoisted_9$a = { class: "bg-light anwp-fl-border anwp-border-top anwp-border-gray-400 px-3 py-2" };
  const _hoisted_10$a = ["value"];
  const _sfc_main$k = {
    __name: "AppTableColors",
    setup(__props) {
      const stStore = useStStore();
      const l10n = window._AnWP_FL_Standing_Data.l10n;
      const openColorSelector = () => {
        stStore.modalData.modalColorType = "place";
        stStore.modalData.predefinedColors = true;
        stStore.modalData.modalColorClub = "";
        stStore.modalData.modalColorPlace = "";
        stStore.modalData.modalColor = "";
        stStore.modals.colorModal = true;
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$k, [
          createVNode(AppBlockHeader, { icon: "#icon-gear" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).standing_table_colors), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$g, [
            Object.keys(unref(stStore).tableColors).length ? (openBlock(), createElementBlock("table", _hoisted_3$g, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stStore).tableColors, (colorClass, cValue) => {
                var _a2;
                return openBlock(), createElementBlock("tr", { key: cValue }, [
                  createBaseVNode("td", {
                    class: normalizeClass(["px-4 py-1 align-middle", [colorClass.startsWith("#") ? "" : "table-" + colorClass]]),
                    style: normalizeStyle([{ backgroundColor: colorClass.startsWith("#") ? colorClass : "" }, { "width": "250px" }])
                  }, [
                    "p" === cValue[0] ? (openBlock(), createElementBlock("span", _hoisted_4$g, toDisplayString(unref(l10n).place) + ": #" + toDisplayString(cValue.substring(1)), 1)) : (openBlock(), createElementBlock("span", _hoisted_5$f, toDisplayString(unref(l10n).club) + ": " + toDisplayString(((_a2 = unref(stStore).appConfig.clubs[cValue.substring(1)]) == null ? void 0 : _a2.title) || ""), 1))
                  ], 6),
                  createBaseVNode("td", _hoisted_6$f, [
                    createBaseVNode("button", {
                      class: "button d-flex align-items-center",
                      type: "button",
                      onClick: withModifiers(($event) => delete unref(stStore).tableColors[cValue], ["prevent"])
                    }, [..._cache[1] || (_cache[1] = [
                      createBaseVNode("svg", { class: "anwp-icon anwp-icon--s14 pr-0" }, [
                        createBaseVNode("use", { "xlink:href": "#icon-close" })
                      ], -1)
                    ])], 8, _hoisted_7$e)
                  ])
                ]);
              }), 128))
            ])) : (openBlock(), createElementBlock("span", _hoisted_8$c, "- " + toDisplayString(unref(l10n).not_specified) + " - ", 1))
          ]),
          createBaseVNode("div", _hoisted_9$a, [
            createBaseVNode("a", {
              href: "#",
              class: "button",
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => openColorSelector(), ["prevent"]))
            }, toDisplayString(unref(l10n).add_remove_color), 1)
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_table_colors",
            value: JSON.stringify(unref(stStore).tableColors)
          }, null, 8, _hoisted_10$a)
        ]);
      };
    }
  };
  const _hoisted_1$j = { class: "anwp-border anwp-border-gray-500 my-4" };
  const _hoisted_2$f = { class: "bg-white p-3 pb-4" };
  const _hoisted_3$f = { class: "bg-light anwp-fl-border anwp-border-top anwp-border-gray-400 px-3 py-2" };
  const _hoisted_4$f = { class: "my-1" };
  const _hoisted_5$e = { class: "d-flex flex-wrap mt-1" };
  const _hoisted_6$e = { class: "mr-4" };
  const _hoisted_7$d = ["value"];
  const _sfc_main$j = {
    __name: "AppTableNotes",
    setup(__props) {
      const stStore = useStStore();
      const l10n = window._AnWP_FL_Standing_Data.l10n;
      const customTableColors = computed(() => {
        return Object.values(stStore.tableColors).filter((c2) => c2.startsWith("#"));
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$j, [
          createVNode(AppBlockHeader, { icon: "#icon-note" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).notes_below_table), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$f, [
            withDirectives(createBaseVNode("textarea", {
              class: "w-100",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(stStore).tableNotes = $event),
              cols: "30",
              rows: "2"
            }, null, 512), [
              [vModelText, unref(stStore).tableNotes]
            ])
          ]),
          createBaseVNode("div", _hoisted_3$f, [
            createBaseVNode("h4", _hoisted_4$f, toDisplayString(unref(l10n).available_placeholders), 1),
            _cache[1] || (_cache[1] = createStaticVNode('<div class="d-flex flex-wrap"><span class="border mr-2 px-3 table-primary"></span> %primary% <span class="ml-4 border mr-2 px-3 table-secondary"></span> %secondary% <span class="ml-4 border mr-2 px-3 table-success"></span> %success% <span class="ml-4 border mr-2 px-3 table-warning"></span> %warning% <span class="ml-4 border mr-2 px-3 table-danger"></span> %danger% <span class="ml-4 border mr-2 px-3 table-info"></span> %info% </div>', 1)),
            createBaseVNode("div", _hoisted_5$e, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(customTableColors.value, (color2) => {
                return openBlock(), createElementBlock("div", _hoisted_6$e, [
                  createBaseVNode("span", {
                    class: "border mr-2 px-3",
                    style: normalizeStyle({ backgroundColor: color2 })
                  }, null, 4),
                  createTextVNode(" %" + toDisplayString(color2) + "% ", 1)
                ]);
              }), 256))
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_table_notes",
            value: unref(stStore).tableNotes
          }, null, 8, _hoisted_7$d)
        ]);
      };
    }
  };
  const _hoisted_1$i = { class: "anwp-border anwp-border-gray-500 my-4" };
  const _hoisted_2$e = { class: "bg-white p-3 pb-4" };
  const _hoisted_3$e = { class: "d-flex flex-wrap" };
  const _hoisted_4$e = { class: "d-flex flex-column mr-3 mb-2" };
  const _hoisted_5$d = { for: "anwpfl-input-pointsWin" };
  const _hoisted_6$d = { class: "d-flex flex-column mr-3 mb-2" };
  const _hoisted_7$c = { for: "anwpfl-input-pointsDraw" };
  const _hoisted_8$b = { class: "d-flex flex-column" };
  const _hoisted_9$9 = { for: "anwpfl-input-pointsLoss" };
  const _hoisted_10$9 = ["value"];
  const _hoisted_11$9 = ["value"];
  const _hoisted_12$9 = ["value"];
  const _sfc_main$i = {
    __name: "AppPoints",
    setup(__props) {
      const stStore = useStStore();
      const l10n = window._AnWP_FL_Standing_Data.l10n;
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$i, [
          createVNode(AppBlockHeader, { icon: "#icon-gear" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).points), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$e, [
            createBaseVNode("div", _hoisted_3$e, [
              createBaseVNode("div", _hoisted_4$e, [
                createBaseVNode("label", _hoisted_5$d, toDisplayString(unref(l10n).points_for_a_win), 1),
                withDirectives(createBaseVNode("input", {
                  id: "anwpfl-input-pointsWin",
                  type: "number",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(stStore).pointsWin = $event),
                  min: "0",
                  max: "99",
                  step: "1"
                }, null, 512), [
                  [
                    vModelText,
                    unref(stStore).pointsWin,
                    void 0,
                    { number: true }
                  ]
                ])
              ]),
              createBaseVNode("div", _hoisted_6$d, [
                createBaseVNode("label", _hoisted_7$c, toDisplayString(unref(l10n).points_for_a_draw), 1),
                withDirectives(createBaseVNode("input", {
                  id: "anwpfl-input-pointsDraw",
                  type: "number",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(stStore).pointsDraw = $event),
                  min: "0",
                  max: "99",
                  step: "1"
                }, null, 512), [
                  [
                    vModelText,
                    unref(stStore).pointsDraw,
                    void 0,
                    { number: true }
                  ]
                ])
              ]),
              createBaseVNode("div", _hoisted_8$b, [
                createBaseVNode("label", _hoisted_9$9, toDisplayString(unref(l10n).points_for_a_loss), 1),
                withDirectives(createBaseVNode("input", {
                  id: "anwpfl-input-pointsLoss",
                  type: "number",
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(stStore).pointsLoss = $event),
                  min: "0",
                  max: "99",
                  step: "1"
                }, null, 512), [
                  [
                    vModelText,
                    unref(stStore).pointsLoss,
                    void 0,
                    { number: true }
                  ]
                ])
              ])
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_points_win",
            value: unref(stStore).pointsWin
          }, null, 8, _hoisted_10$9),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_points_draw",
            value: unref(stStore).pointsDraw
          }, null, 8, _hoisted_11$9),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_points_loss",
            value: unref(stStore).pointsLoss
          }, null, 8, _hoisted_12$9)
        ]);
      };
    }
  };
  const _hoisted_1$h = { class: "anwp-border anwp-border-gray-500 my-4" };
  const _hoisted_2$d = { class: "anwp-fl-admin-metabox__content" };
  const _hoisted_3$d = { class: "anwp-row" };
  const _hoisted_4$d = { class: "anwp-col-md-6" };
  const _hoisted_5$c = { class: "anwp-col-md-6" };
  const _hoisted_6$c = { class: "p-2 mt-2 border border-secondary anwp-standing-rule bg-light d-flex align-items-center" };
  const _hoisted_7$b = ["onChange", "id"];
  const _hoisted_8$a = ["for"];
  const _hoisted_9$8 = ["onClick"];
  const _hoisted_10$8 = ["onClick"];
  const _hoisted_11$8 = { key: 0 };
  const _hoisted_12$8 = {
    key: 1,
    class: "d-block mt-3"
  };
  const _hoisted_13$8 = { class: "d-flex align-items-center" };
  const _hoisted_14$8 = ["onChange", "id"];
  const _hoisted_15$8 = ["for"];
  const _hoisted_16$8 = ["value"];
  const _sfc_main$h = {
    __name: "AppRankingRules",
    setup(__props) {
      const stStore = useStStore();
      const l10n = window._AnWP_FL_Standing_Data.l10n;
      const rankingRulesInactive = computed(() => {
        return Object.entries(stStore.rankingRulesMap).filter(([key, val]) => !stStore.rankingRulesCurrent.includes(key)).map(([key, val]) => key);
      });
      const changeRulesOrder = (ruleIndex, direction) => {
        if (0 === ruleIndex && "up" === direction || stStore.rankingRulesCurrent.length - 1 === ruleIndex && "down" === direction) {
          return;
        }
        if ("up" === direction) {
          [stStore.rankingRulesCurrent[ruleIndex - 1], stStore.rankingRulesCurrent[ruleIndex]] = [stStore.rankingRulesCurrent[ruleIndex], stStore.rankingRulesCurrent[ruleIndex - 1]];
        }
        if ("down" === direction) {
          [stStore.rankingRulesCurrent[ruleIndex + 1], stStore.rankingRulesCurrent[ruleIndex]] = [stStore.rankingRulesCurrent[ruleIndex], stStore.rankingRulesCurrent[ruleIndex + 1]];
        }
        return false;
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$h, [
          createVNode(AppBlockHeader, { icon: "#icon-gear" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).ranking_rules), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$d, [
            createBaseVNode("div", _hoisted_3$d, [
              createBaseVNode("div", _hoisted_4$d, [
                createBaseVNode("p", null, toDisplayString(unref(l10n).ranking_rules_notes_1), 1),
                createBaseVNode("p", null, toDisplayString(unref(l10n).ranking_rules_notes_2), 1)
              ]),
              createBaseVNode("div", _hoisted_5$c, [
                createBaseVNode("label", null, toDisplayString(unref(l10n).current_ranking_rules), 1),
                createBaseVNode("div", _hoisted_6$c, [
                  _cache[0] || (_cache[0] = createBaseVNode("span", { class: "ml-2 my-1" }, "1", -1)),
                  createTextVNode("::" + toDisplayString(unref(l10n).points), 1)
                ]),
                createVNode(TransitionGroup, {
                  name: "anwp-standing-rules",
                  tag: "div"
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stStore).rankingRulesCurrent, (ruleSlug, ruleIndex) => {
                      return openBlock(), createElementBlock("div", {
                        class: "p-2 mt-2 border border-info anwp-standing-rule d-flex align-items-center w-100",
                        key: ruleSlug
                      }, [
                        createBaseVNode("input", {
                          class: "mb-n1 mr-2 ml-1",
                          checked: "",
                          onChange: ($event) => unref(stStore).rankingRulesCurrent.splice(ruleIndex, 1),
                          type: "checkbox",
                          id: "anwpfl-input-rules-a-" + ruleSlug
                        }, null, 40, _hoisted_7$b),
                        createBaseVNode("label", {
                          for: "anwpfl-input-rules-a-" + ruleSlug,
                          class: "mb-0"
                        }, toDisplayString(ruleIndex + 2) + "::" + toDisplayString(unref(stStore).rankingRulesMap[ruleSlug]), 9, _hoisted_8$a),
                        createBaseVNode("a", {
                          class: "button d-flex align-items-center ml-auto",
                          href: "#",
                          onClick: withModifiers(($event) => changeRulesOrder(ruleIndex, "up"), ["prevent"])
                        }, [
                          (openBlock(), createElementBlock("svg", {
                            class: normalizeClass(["anwp-icon anwp-icon--s14", { "text-secondary": ruleIndex === 0 }])
                          }, [..._cache[1] || (_cache[1] = [
                            createBaseVNode("use", { "xlink:href": "#icon-chevron-top" }, null, -1)
                          ])], 2))
                        ], 8, _hoisted_9$8),
                        createBaseVNode("a", {
                          class: "button d-flex align-items-center ml-2",
                          href: "#",
                          onClick: withModifiers(($event) => changeRulesOrder(ruleIndex, "down"), ["prevent"])
                        }, [
                          (openBlock(), createElementBlock("svg", {
                            class: normalizeClass(["anwp-icon anwp-icon--s14", { "text-secondary": ruleIndex === unref(stStore).rankingRulesCurrent.length - 1 }])
                          }, [..._cache[2] || (_cache[2] = [
                            createBaseVNode("use", { "xlink:href": "#icon-chevron-bottom" }, null, -1)
                          ])], 2))
                        ], 8, _hoisted_10$8)
                      ]);
                    }), 128))
                  ]),
                  _: 1
                }),
                !unref(stStore).rankingRulesCurrent.length ? (openBlock(), createElementBlock("p", _hoisted_11$8, toDisplayString(unref(l10n).select_rules_from_list), 1)) : createCommentVNode("", true),
                rankingRulesInactive.value.length ? (openBlock(), createElementBlock("label", _hoisted_12$8, toDisplayString(unref(l10n).available_rules), 1)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(rankingRulesInactive.value, (ruleSlug) => {
                  return openBlock(), createElementBlock("div", {
                    class: "p-2 mt-2 bg-light anwp-standing__rule d-inline-block mr-2",
                    key: ruleSlug
                  }, [
                    createBaseVNode("div", _hoisted_13$8, [
                      createBaseVNode("input", {
                        class: "mb-n1 mr-2 ml-1",
                        onChange: ($event) => unref(stStore).rankingRulesCurrent.push(ruleSlug),
                        type: "checkbox",
                        id: "anwpfl-input-rules-" + ruleSlug
                      }, null, 40, _hoisted_14$8),
                      createBaseVNode("label", {
                        for: "anwpfl-input-rules-" + ruleSlug
                      }, toDisplayString(unref(stStore).rankingRulesMap[ruleSlug]), 9, _hoisted_15$8)
                    ])
                  ]);
                }), 128))
              ])
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_ranking_rules_current",
            value: unref(stStore).rankingRulesCurrent.join(",")
          }, null, 8, _hoisted_16$8)
        ]);
      };
    }
  };
  const _hoisted_1$g = { class: "anwp-border anwp-border-gray-500 my-4" };
  const _hoisted_2$c = { class: "bg-light anwp-border-gray-400 anwp-fl-border anwp-border-bottom p-3" };
  const _hoisted_3$c = { class: "d-flex align-items-center" };
  const _hoisted_4$c = { class: "bg-white p-3 pb-4" };
  const _hoisted_5$b = { class: "table-responsive" };
  const _hoisted_6$b = {
    key: 0,
    class: "table-bordered table-sm anwp-standing-table"
  };
  const _hoisted_7$a = { scope: "col" };
  const _hoisted_8$9 = { scope: "col" };
  const _hoisted_9$7 = { scope: "col" };
  const _hoisted_10$7 = { scope: "col" };
  const _hoisted_11$7 = { scope: "col" };
  const _hoisted_12$7 = { scope: "col" };
  const _hoisted_13$7 = { scope: "col" };
  const _hoisted_14$7 = { scope: "col" };
  const _hoisted_15$7 = { scope: "col" };
  const _hoisted_16$7 = {
    key: 0,
    scope: "col"
  };
  const _hoisted_17$7 = {
    key: 1,
    scope: "col"
  };
  const _hoisted_18$7 = { class: "text-left" };
  const _hoisted_19$7 = { key: 0 };
  const _hoisted_20$5 = ["onClick"];
  const _hoisted_21$5 = { key: 1 };
  const _hoisted_22$5 = ["onClick"];
  const _hoisted_23$4 = ["value"];
  const _hoisted_24$3 = ["value"];
  const _sfc_main$g = {
    __name: "AppTableMain",
    setup(__props) {
      const stStore = useStStore();
      const l10n = window._AnWP_FL_Standing_Data.l10n;
      const changeTableOrder = (index2, direction) => {
        if (0 === index2 && "up" === direction || stStore.tableMain.length - 1 === index2 && "down" === direction) {
          return;
        }
        let tempData = stStore.tableMain[index2];
        if ("up" === direction) {
          stStore.tableMain.splice(index2, 1, stStore.tableMain[index2 - 1]);
          stStore.tableMain.splice(index2 - 1, 1, tempData);
          stStore.tableMain[index2].place = index2 + 1;
          stStore.tableMain[index2 - 1].place = index2;
        }
        if ("down" === direction) {
          stStore.tableMain.splice(index2, 1, stStore.tableMain[index2 + 1]);
          stStore.tableMain.splice(index2 + 1, 1, tempData);
          stStore.tableMain[index2].place = index2 + 1;
          stStore.tableMain[index2 + 1].place = index2 + 2;
        }
        return false;
      };
      return (_ctx, _cache) => {
        const _component_toggle = resolveComponent("toggle");
        return openBlock(), createElementBlock("div", _hoisted_1$g, [
          createVNode(AppBlockHeader, { icon: "#icon-gear" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).standing_table), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$c, [
            createBaseVNode("div", _hoisted_3$c, [
              createTextVNode(toDisplayString(unref(l10n).automatic_pos_calculation) + " ", 1),
              createVNode(_component_toggle, {
                modelValue: unref(stStore).manualOrdering,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(stStore).manualOrdering = $event),
                "on-label": unref(l10n).disable,
                "off-label": unref(l10n).enable,
                classes: { toggleOn: "toggle-off", toggleOff: "toggle-on", handleOn: "toggle-handle-off", handleOff: "toggle-handle-on" },
                class: "anwp-toggle-w-80 ml-2"
              }, null, 8, ["modelValue", "on-label", "off-label"])
            ])
          ]),
          createBaseVNode("div", _hoisted_4$c, [
            createBaseVNode("div", _hoisted_5$b, [
              unref(stStore).tableMain.length ? (openBlock(), createElementBlock("table", _hoisted_6$b, [
                createBaseVNode("thead", null, [
                  createBaseVNode("tr", null, [
                    _cache[1] || (_cache[1] = createBaseVNode("th", { scope: "col" }, "#", -1)),
                    createBaseVNode("th", _hoisted_7$a, toDisplayString(unref(l10n).club), 1),
                    createBaseVNode("th", _hoisted_8$9, toDisplayString(unref(l10n).played), 1),
                    createBaseVNode("th", _hoisted_9$7, toDisplayString(unref(l10n).won), 1),
                    createBaseVNode("th", _hoisted_10$7, toDisplayString(unref(l10n).drawn), 1),
                    createBaseVNode("th", _hoisted_11$7, toDisplayString(unref(l10n).lost), 1),
                    createBaseVNode("th", _hoisted_12$7, toDisplayString(unref(l10n).gf), 1),
                    createBaseVNode("th", _hoisted_13$7, toDisplayString(unref(l10n).ga), 1),
                    createBaseVNode("th", _hoisted_14$7, toDisplayString(unref(l10n).gd), 1),
                    createBaseVNode("th", _hoisted_15$7, toDisplayString(unref(l10n).points), 1),
                    unref(stStore).manualOrdering ? (openBlock(), createElementBlock("th", _hoisted_16$7)) : createCommentVNode("", true),
                    unref(stStore).manualOrdering ? (openBlock(), createElementBlock("th", _hoisted_17$7)) : createCommentVNode("", true)
                  ])
                ]),
                createVNode(TransitionGroup, {
                  name: "anwp-standing-rules",
                  tag: "tbody"
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stStore).tableMain, (row, index2) => {
                      var _a2;
                      return openBlock(), createElementBlock("tr", {
                        key: row.club_id
                      }, [
                        createBaseVNode("td", null, toDisplayString(row.place), 1),
                        createBaseVNode("td", _hoisted_18$7, toDisplayString(((_a2 = unref(stStore).appConfig.clubs[row.club_id]) == null ? void 0 : _a2.title) || ""), 1),
                        createBaseVNode("td", null, toDisplayString(row.played), 1),
                        createBaseVNode("td", null, toDisplayString(row.won), 1),
                        createBaseVNode("td", null, toDisplayString(row.drawn), 1),
                        createBaseVNode("td", null, toDisplayString(row.lost), 1),
                        createBaseVNode("td", null, toDisplayString(row.gf), 1),
                        createBaseVNode("td", null, toDisplayString(row.ga), 1),
                        createBaseVNode("td", null, toDisplayString(row.gd), 1),
                        createBaseVNode("td", null, toDisplayString(row.points), 1),
                        unref(stStore).manualOrdering ? (openBlock(), createElementBlock("td", _hoisted_19$7, [
                          createBaseVNode("a", {
                            class: "button d-flex align-items-center justify-content-center",
                            href: "#",
                            onClick: withModifiers(($event) => changeTableOrder(index2, "up"), ["prevent"])
                          }, [
                            (openBlock(), createElementBlock("svg", {
                              class: normalizeClass(["anwp-icon anwp-icon--s14", { "text-secondary": index2 === 0 }])
                            }, [..._cache[2] || (_cache[2] = [
                              createBaseVNode("use", { "xlink:href": "#icon-chevron-top" }, null, -1)
                            ])], 2))
                          ], 8, _hoisted_20$5)
                        ])) : createCommentVNode("", true),
                        unref(stStore).manualOrdering ? (openBlock(), createElementBlock("td", _hoisted_21$5, [
                          createBaseVNode("a", {
                            class: "button d-flex align-items-center justify-content-center",
                            href: "#",
                            onClick: withModifiers(($event) => changeTableOrder(index2, "down"), ["prevent"])
                          }, [
                            (openBlock(), createElementBlock("svg", {
                              class: normalizeClass(["anwp-icon anwp-icon--s14", { "text-secondary": index2 === unref(stStore).tableMain.length - 1 }])
                            }, [..._cache[3] || (_cache[3] = [
                              createBaseVNode("use", { "xlink:href": "#icon-chevron-bottom" }, null, -1)
                            ])], 2))
                          ], 8, _hoisted_22$5)
                        ])) : createCommentVNode("", true)
                      ]);
                    }), 128))
                  ]),
                  _: 1
                })
              ])) : createCommentVNode("", true)
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_manual_ordering",
            value: unref(stStore).manualOrdering
          }, null, 8, _hoisted_23$4),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_table_main",
            value: JSON.stringify(unref(stStore).tableMain)
          }, null, 8, _hoisted_24$3)
        ]);
      };
    }
  };
  const _hoisted_1$f = { class: "anwp-vue-standing-wrapper anwp-b-wrap anwp-vue-wrapper-ready" };
  const _sfc_main$f = {
    __name: "AppStanding",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$f, [
          createVNode(_sfc_main$o),
          createVNode(_sfc_main$k),
          createVNode(_sfc_main$j),
          createVNode(_sfc_main$i),
          createVNode(_sfc_main$h),
          createVNode(_sfc_main$g),
          createVNode(unref(Wo)),
          createVNode(_sfc_main$n),
          createVNode(_sfc_main$m),
          createVNode(_sfc_main$l),
          _cache[0] || (_cache[0] = createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_fixed",
            value: "true"
          }, null, -1))
        ]);
      };
    }
  };
  const notyf$2 = new Notyf({ duration: 5e3 });
  const useSquadStore = /* @__PURE__ */ defineStore("squad", () => {
    const AppAxios = axios.create({
      baseURL: window._AnWP_FL_Squad_Data.rest_root,
      headers: {
        "X-WP-Nonce": window._AnWP_FL_Squad_Data.rest_nonce
      }
    });
    const clubSquad = reactive(safeJsonParse(window._AnWP_FL_Squad_Data.club_squad, {}) || {});
    const clubSquadDisplay = reactive(safeJsonParse(window._AnWP_FL_Squad_Data.club_squad_display, {}) || {});
    const clubStaff = reactive(safeJsonParse(window._AnWP_FL_Squad_Data.club_staff, {}) || {});
    const activeSquad = ref([]);
    const activeStaff = ref([]);
    const deleteData = reactive({
      playerIndex: null,
      playerObject: {},
      staffIndex: null,
      staffObject: {}
    });
    const active = reactive({
      club: window._AnWP_FL_Squad_Data.currentClub,
      season: "",
      season_title: "",
      loading: false
    });
    const appConfig = {
      seasons: window._AnWP_FL_Squad_Data.seasons_list,
      positions: window._AnWP_FL_Squad_Data.positions,
      clubsMap: window._AnWP_FL_Squad_Data.clubs_map,
      players: window._AnWP_FL_Squad_Data.players,
      loader: window._AnWP_FL_Squad_Data.loader,
      staff: window._AnWP_FL_Squad_Data.staffs,
      classPosition: {
        g: "anwp-bg-blue-400",
        d: "anwp-bg-green-400",
        m: "anwp-bg-orange-400",
        f: "anwp-bg-red-400"
      },
      default_photo: window._AnWP_FL_Squad_Data.default_photo,
      transfers_available: "yes" === window._AnWP_FL_Squad_Data.transfers_available
    };
    const playersInActiveSquadIds = computed(() => {
      return activeSquad.value.map((p2) => Number(p2.id));
    });
    const staffInActiveSquadIds = computed(() => {
      return activeStaff.value.map((p2) => Number(p2.id));
    });
    const modalPlayers = reactive({
      pageNumber: 1,
      pageCount: 0,
      search: "",
      activeAction: "club_players",
      appendToTop: false
    });
    const modalStaff = reactive({
      pageNumber: 1,
      pageCount: 0,
      search: "",
      activeAction: "club_staff",
      appendToTop: false
    });
    const modalActions = reactive({
      playerIndex: null,
      playerObject: {},
      loading: false,
      active_request: "",
      mode: "",
      change_club_id: "",
      player_data: {}
    });
    const modals = reactive({
      playerDeleteConfirm: false,
      playerAttachToSquad: false,
      staffDeleteConfirm: false,
      staffAttachToSquad: false,
      playerActions: false
    });
    watch(activeSquad, (squad) => {
      if (active.season) {
        clubSquad["s:" + active.season] = squad;
      }
    });
    watch(activeStaff, (staff) => {
      if (active.season) {
        clubStaff["s:" + active.season] = staff;
      }
    });
    const extendPlayerObject = (playerObject) => {
      const playerData = appConfig.players.find((pl) => Number(pl.id) === Number(playerObject.id));
      if (playerData) {
        ["name", "photo", "country", "birthdate", "club_id"].forEach((o2) => playerObject[o2] = playerData[o2] || "");
      }
      return playerObject;
    };
    const extendStaffObject = (staffObject) => {
      const staffData = appConfig.staff.find((pl) => Number(pl.id) === Number(staffObject.id));
      if (staffData) {
        ["name", "photo", "country", "birthdate"].forEach((o2) => staffObject[o2] = staffData[o2] || "");
      }
      return staffObject;
    };
    onMounted(() => {
      if (appConfig.seasons[0].id) {
        active.season = appConfig.seasons[0].id.toString();
        changeActiveSeason();
      }
    });
    const changeActiveSeason = () => {
      let id = active.season;
      active.loading = true;
      let activeSeasonObj = appConfig.seasons.find((s2) => Number(s2.id) === Number(id));
      active.season_title = (activeSeasonObj == null ? void 0 : activeSeasonObj.title) || "";
      if (!clubSquad.hasOwnProperty("s:" + id)) {
        clubSquad["s:" + id] = [];
      }
      if (!clubSquadDisplay.hasOwnProperty(id)) {
        clubSquadDisplay[id] = { group: true };
      }
      if (!clubStaff.hasOwnProperty("s:" + id)) {
        clubStaff["s:" + id] = [];
      }
      activeSquad.value = clubSquad["s:" + id].map((p2) => extendPlayerObject(p2));
      activeStaff.value = clubStaff["s:" + id].map((p2) => extendStaffObject(p2));
      if (activeSquad.value.length) {
        setTimeout(() => active.loading = false, 500);
      } else {
        active.loading = false;
      }
    };
    const updatePlayerData = () => {
      modalActions.loading = true;
      AppAxios.get(
        `anwpfl/player/get-player-data`,
        {
          params: {
            player_id: modalActions.playerObject.id,
            club_id: active.club
          }
        }
      ).then((response) => {
        var _a2;
        if ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.player_data) {
          modalActions.player_data = Object.assign({}, modalActions.player_data, response.data.player_data);
        }
      }).catch(() => {
        notyf$2.error("Data Error");
      }).finally(() => {
        modalActions.loading = false;
      });
    };
    return {
      active,
      activeSquad,
      activeStaff,
      appConfig,
      changeActiveSeason,
      clubSquad,
      clubSquadDisplay,
      clubStaff,
      deleteData,
      extendPlayerObject,
      extendStaffObject,
      modalActions,
      modalPlayers,
      modals,
      modalStaff,
      playersInActiveSquadIds,
      staffInActiveSquadIds,
      updatePlayerData
    };
  });
  const _hoisted_1$e = {
    id: "anwp-fl-squad-metabox",
    class: "anwp-border anwp-border-gray-500"
  };
  const _hoisted_2$b = { class: "p-3 d-flex align-items-center flex-wrap bg-white" };
  const _hoisted_3$b = {
    for: "anwpfl-input-season",
    class: "mr-2"
  };
  const _hoisted_4$b = ["value"];
  const _hoisted_5$a = { class: "ml-auto" };
  const _hoisted_6$a = { class: "font-weight-bold" };
  const _hoisted_7$9 = { class: "bg-white py-4 px-3" };
  const _hoisted_8$8 = { class: "mb-3" };
  const _hoisted_9$6 = {
    key: 0,
    class: "d-flex align-items-center py-5 my-5 justify-content-center"
  };
  const _hoisted_10$6 = ["src"];
  const _hoisted_11$6 = { class: "table-responsive" };
  const _hoisted_12$6 = { class: "table table-sm anwp-border-collapse w-100 anwp-overflow-scroll anwp-user-select-none" };
  const _hoisted_13$6 = { class: "anwp-border anwp-border-gray-400 anwp-bg-gray-200" };
  const _hoisted_14$6 = { class: "py-1 px-3" };
  const _hoisted_15$6 = { class: "py-1 px-2" };
  const _hoisted_16$6 = { class: "py-1 px-2" };
  const _hoisted_17$6 = { class: "py-1 px-2" };
  const _hoisted_18$6 = { class: "py-1 px-2" };
  const _hoisted_19$6 = { class: "py-1 px-2" };
  const _hoisted_20$4 = { class: "py-1 px-3 align-middle anwp-w-10" };
  const _hoisted_21$4 = ["src"];
  const _hoisted_22$4 = { class: "py-1 align-middle anwp-w-10" };
  const _hoisted_23$3 = {
    class: "options__flag f32 align-middle",
    style: { "line-height": "12px" }
  };
  const _hoisted_24$2 = { class: "px-3 align-middle anwp-text-base anwp-leading-1" };
  const _hoisted_25$2 = {
    key: 0,
    class: "d-block anwp-text-xs anwp-text-gray-600"
  };
  const _hoisted_26$2 = { class: "py-1 px-2 anwp-w-10" };
  const _hoisted_27$2 = ["onUpdate:modelValue"];
  const _hoisted_28$2 = { class: "py-1 px-2 anwp-w-10" };
  const _hoisted_29$2 = ["onUpdate:modelValue"];
  const _hoisted_30$2 = { value: "" };
  const _hoisted_31$2 = ["value"];
  const _hoisted_32$2 = { class: "py-1 px-2 anwp-w-10" };
  const _hoisted_33$2 = ["onUpdate:modelValue"];
  const _hoisted_34$1 = { value: "" };
  const _hoisted_35$1 = { value: "on loan" };
  const _hoisted_36$1 = { value: "left" };
  const _hoisted_37$1 = { value: "on trial" };
  const _hoisted_38$1 = ["value"];
  const _hoisted_39$1 = { class: "anwp-w-10 py-1 px-2 anwp-text-center" };
  const _hoisted_40$1 = ["onClick"];
  const _hoisted_41$1 = { class: "anwp-w-10 py-1 px-2 anwp-text-center" };
  const _hoisted_42$1 = ["onClick"];
  const _hoisted_43$1 = { class: "anwp-border anwp-border-gray-400 anwp-bg-gray-200" };
  const _hoisted_44$1 = { class: "py-1 px-2" };
  const _hoisted_45$1 = { class: "py-1 px-2" };
  const _hoisted_46$1 = { class: "py-1 px-2" };
  const _hoisted_47$1 = { class: "py-1 px-2" };
  const _hoisted_48$1 = { class: "py-1 px-2" };
  const _hoisted_49 = { class: "py-1 px-2" };
  const _hoisted_50 = {
    key: 1,
    class: "d-flex justify-content-end align-items-center flex-wrap mt-2"
  };
  const _hoisted_51 = ["value"];
  const _hoisted_52 = ["value"];
  const _sfc_main$e = {
    __name: "AppPlayers",
    setup(__props) {
      const squadStore = useSquadStore();
      const l10n = window._AnWP_FL_Squad_Data.l10n;
      const squadStatuses = window._AnWP_FL_Squad_Data.squad_status;
      const openAttachToSquadPlayersModal = () => {
        squadStore.modalPlayers.pageNumber = 1;
        squadStore.modalPlayers.search = "";
        squadStore.modalPlayers.activeAction = "club_players";
        squadStore.modals.playerAttachToSquad = true;
      };
      const openActionsModaal = (index2, playerObj) => {
        squadStore.modalActions.mode = "";
        squadStore.modalActions.change_club_id = squadStore.active.club;
        squadStore.modalActions.player_data = {};
        squadStore.modalActions.playerIndex = index2;
        squadStore.modalActions.playerObject = playerObj;
        squadStore.modals.playerActions = true;
        squadStore.updatePlayerData();
      };
      const openDeletePlayerModaal = (index2, playerObj) => {
        squadStore.deleteData.playerIndex = index2;
        squadStore.deleteData.playerObject = playerObj;
        squadStore.modals.playerDeleteConfirm = true;
      };
      const clubSquadCompact = computed(() => {
        let output = {};
        if (squadStore.clubSquad) {
          Object.keys(squadStore.clubSquad).forEach((key) => {
            output[key] = squadStore.clubSquad[key].map((_a2) => {
              var _b2 = _a2, {
                name,
                photo,
                country,
                birthdate,
                club_id
              } = _b2, pl = __objRest(_b2, [
                "name",
                "photo",
                "country",
                "birthdate",
                "club_id"
              ]);
              return pl;
            });
          });
        }
        return output;
      });
      return (_ctx, _cache) => {
        var _a2;
        const _component_draggable = resolveComponent("draggable");
        const _component_toggle = resolveComponent("toggle");
        return openBlock(), createElementBlock("div", _hoisted_1$e, [
          createVNode(AppBlockHeader, { icon: "#icon-jersey" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).club_squad), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$b, [
            createBaseVNode("label", _hoisted_3$b, toDisplayString(unref(l10n).season), 1),
            withDirectives(createBaseVNode("select", {
              id: "anwpfl-input-season",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(squadStore).active.season = $event),
              class: "mr-4",
              onChange: _cache[1] || (_cache[1] = (...args) => unref(squadStore).changeActiveSeason && unref(squadStore).changeActiveSeason(...args))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(squadStore).appConfig.seasons, (s2) => {
                return openBlock(), createElementBlock("option", {
                  key: s2.id,
                  value: s2.id
                }, toDisplayString(s2.title), 9, _hoisted_4$b);
              }), 128))
            ], 544), [
              [vModelSelect, unref(squadStore).active.season]
            ]),
            createBaseVNode("div", _hoisted_5$a, [
              createTextVNode(toDisplayString(unref(l10n).number_of_players_in_squad) + ": ", 1),
              createBaseVNode("span", _hoisted_6$a, toDisplayString(((_a2 = unref(squadStore).activeSquad) == null ? void 0 : _a2.length) || 0), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$9, [
            createBaseVNode("div", _hoisted_8$8, [
              createBaseVNode("button", {
                class: "button d-flex align-items-center",
                type: "button",
                onClick: _cache[2] || (_cache[2] = withModifiers(($event) => openAttachToSquadPlayersModal(), ["prevent"]))
              }, [
                _cache[5] || (_cache[5] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16 mr-2" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-plus" })
                ], -1)),
                createTextVNode(" " + toDisplayString(unref(l10n).attach_player_to_squad), 1)
              ])
            ]),
            unref(squadStore).active.loading ? (openBlock(), createElementBlock("div", _hoisted_9$6, [
              createBaseVNode("img", {
                src: unref(squadStore).appConfig.loader,
                alt: "loader"
              }, null, 8, _hoisted_10$6)
            ])) : createCommentVNode("", true),
            withDirectives(createBaseVNode("div", _hoisted_11$6, [
              withDirectives(createBaseVNode("table", _hoisted_12$6, [
                createBaseVNode("thead", null, [
                  createBaseVNode("tr", _hoisted_13$6, [
                    _cache[6] || (_cache[6] = createBaseVNode("td", null, null, -1)),
                    _cache[7] || (_cache[7] = createBaseVNode("td", null, null, -1)),
                    _cache[8] || (_cache[8] = createBaseVNode("td", null, null, -1)),
                    _cache[9] || (_cache[9] = createBaseVNode("td", null, null, -1)),
                    createBaseVNode("td", _hoisted_14$6, toDisplayString(unref(l10n).player_name), 1),
                    createBaseVNode("td", _hoisted_15$6, toDisplayString(unref(l10n).number), 1),
                    createBaseVNode("td", _hoisted_16$6, toDisplayString(unref(l10n).position), 1),
                    createBaseVNode("td", _hoisted_17$6, toDisplayString(unref(l10n).status), 1),
                    createBaseVNode("td", _hoisted_18$6, toDisplayString(unref(l10n).actions), 1),
                    createBaseVNode("td", _hoisted_19$6, toDisplayString(unref(l10n).remove), 1)
                  ])
                ]),
                createVNode(_component_draggable, {
                  modelValue: unref(squadStore).activeSquad,
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(squadStore).activeSquad = $event),
                  handle: ".anwp-drag-handler",
                  tag: "tbody",
                  "force-fallback": true
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(squadStore).activeSquad, (player, index2) => {
                      return openBlock(), createElementBlock("tr", {
                        key: player.id,
                        class: "anwp-border anwp-border-gray-400"
                      }, [
                        _cache[12] || (_cache[12] = createBaseVNode("td", { class: "anwp-drag-handler anwp-w-30 anwp-text-center pt-1 px-2" }, [
                          createBaseVNode("svg", { class: "anwp-icon anwp-icon--s24 anwp-icon--octi mr-0" }, [
                            createBaseVNode("use", { "xlink:href": "#icon-grabber" })
                          ])
                        ], -1)),
                        createBaseVNode("td", {
                          class: normalizeClass(["py-1 px-2 anwp-w-30 anwp-text-center text-uppercase align-middle anwp-text-lg text-white anwp-font-bold", player.position ? unref(squadStore).appConfig.classPosition[player.position] : ""])
                        }, toDisplayString(player.position ? player.position.charAt(0) : ""), 3),
                        createBaseVNode("td", _hoisted_20$4, [
                          createBaseVNode("img", {
                            class: "anwp-h-40 anwp-w-40 anwp-object-contain",
                            src: player.photo ? player.photo : unref(squadStore).appConfig.default_photo,
                            alt: "player photo"
                          }, null, 8, _hoisted_21$4)
                        ]),
                        createBaseVNode("td", _hoisted_22$4, [
                          createBaseVNode("span", _hoisted_23$3, [
                            createBaseVNode("span", {
                              class: normalizeClass(["flag", player.country])
                            }, null, 2)
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_24$2, [
                          createTextVNode(toDisplayString(player.name) + " ", 1),
                          player.birthdate ? (openBlock(), createElementBlock("span", _hoisted_25$2, toDisplayString(player.birthdate), 1)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_26$2, [
                          withDirectives(createBaseVNode("input", {
                            "onUpdate:modelValue": ($event) => player.number = $event,
                            class: "my-1 anwp-border-gray-300 anwp-w-80",
                            type: "number",
                            min: "0",
                            step: "1"
                          }, null, 8, _hoisted_27$2), [
                            [
                              vModelText,
                              player.number,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_28$2, [
                          withDirectives(createBaseVNode("select", {
                            "onUpdate:modelValue": ($event) => player.position = $event,
                            class: "anwp-w-120 my-1"
                          }, [
                            createBaseVNode("option", _hoisted_30$2, "- " + toDisplayString(unref(l10n).select) + " -", 1),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(squadStore).appConfig.positions, (positionTitle, positionCode) => {
                              return openBlock(), createElementBlock("option", {
                                key: positionCode,
                                value: positionCode
                              }, toDisplayString(positionTitle), 9, _hoisted_31$2);
                            }), 128))
                          ], 8, _hoisted_29$2), [
                            [vModelSelect, player.position]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_32$2, [
                          withDirectives(createBaseVNode("select", {
                            "onUpdate:modelValue": ($event) => player.status = $event,
                            class: "anwp-w-120 my-1"
                          }, [
                            createBaseVNode("option", _hoisted_34$1, toDisplayString(unref(l10n).in_club), 1),
                            createBaseVNode("option", _hoisted_35$1, toDisplayString(unref(l10n).on_loan), 1),
                            createBaseVNode("option", _hoisted_36$1, toDisplayString(unref(l10n).left_club), 1),
                            createBaseVNode("option", _hoisted_37$1, toDisplayString(unref(l10n).on_trial), 1),
                            unref(squadStatuses) && unref(squadStatuses).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(squadStatuses), (sStatus) => {
                              return openBlock(), createElementBlock("option", {
                                key: sStatus,
                                value: sStatus
                              }, toDisplayString(sStatus), 9, _hoisted_38$1);
                            }), 128)) : createCommentVNode("", true)
                          ], 8, _hoisted_33$2), [
                            [vModelSelect, player.status]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_39$1, [
                          createBaseVNode("button", {
                            type: "button",
                            class: normalizeClass(["anwp-cursor-pointer d-flex align-items-center justify-content-center my-1 anwp-w-50 button", Number(player.club_id) !== Number(unref(squadStore).active.club) ? "anwp-bg-orange-200" : ""]),
                            onClick: withModifiers(($event) => openActionsModaal(index2, player), ["prevent"])
                          }, [..._cache[10] || (_cache[10] = [
                            createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-person-outline" })
                            ], -1)
                          ])], 10, _hoisted_40$1)
                        ]),
                        createBaseVNode("td", _hoisted_41$1, [
                          createBaseVNode("button", {
                            type: "button",
                            class: "anwp-cursor-pointer d-flex align-items-center justify-content-center my-1 anwp-w-50 button anwp-border-red-600",
                            onClick: withModifiers(($event) => openDeletePlayerModaal(index2, player), ["prevent"])
                          }, [..._cache[11] || (_cache[11] = [
                            createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-x" })
                            ], -1)
                          ])], 8, _hoisted_42$1)
                        ])
                      ]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                createBaseVNode("tfoot", null, [
                  createBaseVNode("tr", _hoisted_43$1, [
                    _cache[13] || (_cache[13] = createBaseVNode("td", null, null, -1)),
                    _cache[14] || (_cache[14] = createBaseVNode("td", null, null, -1)),
                    _cache[15] || (_cache[15] = createBaseVNode("td", null, null, -1)),
                    _cache[16] || (_cache[16] = createBaseVNode("td", null, null, -1)),
                    createBaseVNode("td", _hoisted_44$1, toDisplayString(unref(l10n).player_name), 1),
                    createBaseVNode("td", _hoisted_45$1, toDisplayString(unref(l10n).number), 1),
                    createBaseVNode("td", _hoisted_46$1, toDisplayString(unref(l10n).position), 1),
                    createBaseVNode("td", _hoisted_47$1, toDisplayString(unref(l10n).status), 1),
                    createBaseVNode("td", _hoisted_48$1, toDisplayString(unref(l10n).actions), 1),
                    createBaseVNode("td", _hoisted_49, toDisplayString(unref(l10n).remove), 1)
                  ])
                ])
              ], 512), [
                [vShow, unref(squadStore).activeSquad.length]
              ])
            ], 512), [
              [vShow, !unref(squadStore).active.loading]
            ]),
            unref(squadStore).clubSquadDisplay[unref(squadStore).active.season] ? (openBlock(), createElementBlock("div", _hoisted_50, [
              createTextVNode(toDisplayString(unref(l10n).group_player_ignore_without) + " ", 1),
              createVNode(_component_toggle, {
                modelValue: unref(squadStore).clubSquadDisplay[unref(squadStore).active.season].group,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(squadStore).clubSquadDisplay[unref(squadStore).active.season].group = $event),
                "on-label": unref(l10n).yes,
                "off-label": unref(l10n).no,
                class: "anwp-toggle-w-60 ml-2 my-2"
              }, null, 8, ["modelValue", "on-label", "off-label"])
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_squad",
            value: JSON.stringify(clubSquadCompact.value)
          }, null, 8, _hoisted_51),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_squad_display",
            value: JSON.stringify(unref(squadStore).clubSquadDisplay)
          }, null, 8, _hoisted_52)
        ]);
      };
    }
  };
  const _hoisted_1$d = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$a = { class: "my-0" };
  const _hoisted_3$a = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$a = { class: "anwp-text-center" };
  const _hoisted_5$9 = { class: "anwp-text-lg anwp-font-bold" };
  const _hoisted_6$9 = { class: "anwp-text-base" };
  const _hoisted_7$8 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_8$7 = { class: "d-flex flex-row-reverse" };
  const _sfc_main$d = {
    __name: "AppModalPlayerDeleteConfirm",
    setup(__props) {
      const squadStore = useSquadStore();
      const l10n = window._AnWP_FL_Squad_Data.l10n;
      const removePlayerFromSquad = () => {
        if (null !== squadStore.deleteData.playerIndex) {
          squadStore.activeSquad.splice(squadStore.deleteData.playerIndex, 1);
        }
        squadStore.modals.playerDeleteConfirm = false;
        squadStore.deleteData.playerIndex = null;
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(squadStore).modals.playerDeleteConfirm,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(squadStore).modals.playerDeleteConfirm = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(squadStore).modals.playerDeleteConfirm = false)
            }, [..._cache[4] || (_cache[4] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$d, [
              createBaseVNode("h4", _hoisted_2$a, toDisplayString(unref(l10n).confirm_delete), 1)
            ]),
            createBaseVNode("div", _hoisted_3$a, [
              createBaseVNode("div", _hoisted_4$a, [
                createBaseVNode("div", _hoisted_5$9, toDisplayString(unref(l10n).are_you_sure), 1),
                createBaseVNode("p", null, toDisplayString(unref(l10n).really_want_delete_from_squad), 1),
                createBaseVNode("div", _hoisted_6$9, toDisplayString(unref(squadStore).deleteData.playerObject.name), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_7$8, [
              createBaseVNode("div", _hoisted_8$7, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button",
                  onClick: _cache[1] || (_cache[1] = ($event) => unref(squadStore).modals.playerDeleteConfirm = false)
                }, toDisplayString(unref(l10n).close), 1),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-link-delete anwp-mx-2",
                  onClick: _cache[2] || (_cache[2] = withModifiers(($event) => removePlayerFromSquad(), ["prevent"]))
                }, toDisplayString(unref(l10n).delete), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$c = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$9 = { class: "my-0" };
  const _hoisted_3$9 = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$9 = { class: "d-sm-flex" };
  const _hoisted_5$8 = { class: "col-sm-6 bg-light py-3" };
  const _hoisted_6$8 = { class: "px-3 anwp-text-base" };
  const _hoisted_7$7 = { class: "col-sm-6 py-0 anwp-h-min-300" };
  const _hoisted_8$6 = {
    key: 0,
    class: "anwp-bg-gray-200 px-2 mx-n2 anwp-text-gray-800"
  };
  const _hoisted_9$5 = { class: "d-flex flex-column" };
  const _hoisted_10$5 = {
    key: 0,
    class: "d-flex align-items-start"
  };
  const _hoisted_11$5 = ["onClick"];
  const _hoisted_12$5 = {
    key: 1,
    class: "anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold anwp-bg-gray-300"
  };
  const _hoisted_13$5 = { class: "pl-3 align-middle" };
  const _hoisted_14$5 = {
    class: "options__flag f32 align-middle",
    style: { "line-height": "12px" }
  };
  const _hoisted_15$5 = { class: "pl-3 d-flex flex-column" };
  const _hoisted_16$5 = { class: "anwp-text-base anwp-leading-1" };
  const _hoisted_17$5 = { class: "anwp-text-gray-600 d-flex align-items-center anwp-text-xs" };
  const _hoisted_18$5 = {
    key: 0,
    class: "mx-2"
  };
  const _hoisted_19$5 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_20$3 = { class: "d-flex align-items-center" };
  const _hoisted_21$3 = { class: "mr-2" };
  const _hoisted_22$3 = { value: true };
  const _hoisted_23$2 = { value: false };
  const _sfc_main$c = {
    __name: "AppModalPlayerAttachToSquad",
    setup(__props) {
      const squadStore = useSquadStore();
      const l10n = window._AnWP_FL_Squad_Data.l10n;
      const modalPlayerAttachToSquadSearch = ref(null);
      const lsPlayersPerPage = ref(localStorage.getItem("anwp-fl-admin/players-per-page") || 10);
      const updateLSPlayerPerPage = (e) => {
        localStorage.setItem("anwp-fl-admin/players-per-page", e.target.value);
      };
      const modalPlayersActions = computed(() => {
        let actions2 = [
          {
            name: l10n.club_players,
            value: "club_players"
          },
          {
            name: l10n.search_by_name,
            value: "search_by_name"
          }
        ];
        let seasons = Object.keys(squadStore.clubSquad).filter((k2) => k2 !== "s:" + squadStore.active.season);
        if (seasons.length) {
          actions2.push({
            group: l10n.other_seasons,
            name: null,
            value: ""
          });
          squadStore.appConfig.seasons.forEach((s2) => {
            if (seasons.includes("s:" + s2.id) && squadStore.clubSquad["s:" + s2.id].length) {
              actions2.push({
                name: s2.title,
                value: "s:" + s2.id
              });
            }
          });
        }
        return actions2;
      });
      const onSelectedModalPlayersActions = (selected) => {
        squadStore.modalPlayers.pageNumber = 1;
        if ("search_by_name" === selected.value) {
          setTimeout(() => {
            modalPlayerAttachToSquadSearch.value.focus();
          }, 0);
        }
      };
      const playersInModal = computed(() => {
        let players = squadStore.appConfig.players.filter((p2) => !squadStore.playersInActiveSquadIds.includes(Number(p2.id)));
        if ("club_players" === squadStore.modalPlayers.activeAction) {
          return players.filter((p2) => Number(p2.club_id) === Number(squadStore.active.club));
        } else if ("search_by_name" === squadStore.modalPlayers.activeAction && "" !== squadStore.modalPlayers.search.trim()) {
          return players.filter((p2) => p2.name.toLowerCase().indexOf(squadStore.modalPlayers.search.toLowerCase()) > -1);
        } else if (squadStore.modalPlayers.activeAction.indexOf("s:") === 0) {
          let squad = squadStore.clubSquad[squadStore.modalPlayers.activeAction];
          if (squad) {
            let squadPlayerIds = squad.map((s2) => Number(s2.id));
            return players.filter((p2) => squadPlayerIds.includes(Number(p2.id)));
          }
        }
        return players;
      });
      const playersInModalPages = computed(() => {
        return playersInModal.value.length ? Math.ceil(playersInModal.value.length / lsPlayersPerPage.value) : 0;
      });
      const playersInModalPaginated = computed(() => {
        if (!playersInModal.value.length) {
          return [];
        }
        return playersInModal.value.slice((squadStore.modalPlayers.pageNumber - 1) * lsPlayersPerPage.value, squadStore.modalPlayers.pageNumber * lsPlayersPerPage.value);
      });
      const changeModalPlayersActivePage = (pageNumber) => {
        squadStore.modalPlayers.pageNumber = pageNumber;
      };
      const addToSquad = (player) => {
        let playerObj = {
          id: player.id,
          birthdate: player.birthdate,
          club_id: player.club_id,
          country: player.country,
          position: player.position,
          photo: player.photo,
          name: player.name,
          number: "",
          status: ""
        };
        squadStore.modalPlayers.appendToTop ? squadStore.activeSquad.unshift(playerObj) : squadStore.activeSquad.push(playerObj);
      };
      return (_ctx, _cache) => {
        const _component_v_select = resolveComponent("v-select");
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(squadStore).modals.playerAttachToSquad,
          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => unref(squadStore).modals.playerAttachToSquad = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(squadStore).modals.playerAttachToSquad = false)
            }, [..._cache[10] || (_cache[10] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$c, [
              createBaseVNode("h4", _hoisted_2$9, toDisplayString(unref(l10n).attach_player_to_squad) + " - " + toDisplayString(unref(l10n).season) + " " + toDisplayString(unref(squadStore).active.season_title), 1)
            ]),
            createBaseVNode("div", _hoisted_3$9, [
              createBaseVNode("div", _hoisted_4$9, [
                createBaseVNode("div", _hoisted_5$8, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(squadStore).activeSquad, (player) => {
                    return openBlock(), createElementBlock("div", {
                      key: player.id,
                      class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white"
                    }, [
                      createBaseVNode("div", {
                        class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold", player.position ? unref(squadStore).appConfig.classPosition[player.position] : ""])
                      }, toDisplayString(player.position ? player.position.charAt(0) : ""), 3),
                      createBaseVNode("div", _hoisted_6$8, toDisplayString(player.name), 1)
                    ]);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_7$7, [
                  createVNode(_component_v_select, {
                    modelValue: unref(squadStore).modalPlayers.activeAction,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(squadStore).modalPlayers.activeAction = $event),
                    label: "name",
                    options: modalPlayersActions.value,
                    clearable: false,
                    filterable: false,
                    searchable: false,
                    selectable: (option) => !option.hasOwnProperty("group"),
                    reduce: (o2) => o2.value,
                    "onOption:selected": onSelectedModalPlayersActions
                  }, {
                    option: withCtx(({ group, name }) => [
                      group ? (openBlock(), createElementBlock("div", _hoisted_8$6, toDisplayString(group), 1)) : createCommentVNode("", true),
                      createTextVNode(" " + toDisplayString(name), 1)
                    ]),
                    _: 1
                  }, 8, ["modelValue", "options", "selectable", "reduce"]),
                  withDirectives(createBaseVNode("div", null, [
                    _cache[11] || (_cache[11] = createBaseVNode("hr", null, null, -1)),
                    createBaseVNode("div", _hoisted_9$5, [
                      withDirectives(createBaseVNode("input", {
                        ref_key: "modalPlayerAttachToSquadSearch",
                        ref: modalPlayerAttachToSquadSearch,
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(squadStore).modalPlayers.search = $event),
                        type: "text",
                        class: "w-100",
                        onInput: _cache[3] || (_cache[3] = ($event) => unref(squadStore).modalPlayers.pageNumber = 1)
                      }, null, 544), [
                        [vModelText, unref(squadStore).modalPlayers.search]
                      ])
                    ])
                  ], 512), [
                    [vShow, "search_by_name" === unref(squadStore).modalPlayers.activeAction]
                  ]),
                  _cache[13] || (_cache[13] = createBaseVNode("hr", null, null, -1)),
                  playersInModal.value.length ? (openBlock(), createElementBlock("div", _hoisted_10$5, [
                    playersInModal.value.length ? (openBlock(), createBlock(unref(Paginate), {
                      key: 0,
                      modelValue: unref(squadStore).modalPlayers.pageNumber,
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(squadStore).modalPlayers.pageNumber = $event),
                      class: "anwp-user-select-none mb-2 mb-0",
                      "page-count": playersInModalPages.value,
                      "click-handler": changeModalPlayersActivePage,
                      "prev-text": unref(l10n).prev,
                      "next-text": unref(l10n).next,
                      "container-class": "anwp-pagination",
                      "page-class": "anwp-page-item",
                      "prev-class": "anwp-page-item",
                      "next-class": "anwp-page-item",
                      "next-link-class": "anwp-page-link",
                      "prev-link-class": "anwp-page-link",
                      "page-link-class": "anwp-page-link"
                    }, null, 8, ["modelValue", "page-count", "prev-text", "next-text"])) : createCommentVNode("", true),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => lsPlayersPerPage.value = $event),
                      class: "ml-auto mt-3",
                      onChange: _cache[6] || (_cache[6] = ($event) => updateLSPlayerPerPage($event))
                    }, [..._cache[12] || (_cache[12] = [
                      createBaseVNode("option", { value: "5" }, "5", -1),
                      createBaseVNode("option", { value: "10" }, "10", -1),
                      createBaseVNode("option", { value: "20" }, "20", -1),
                      createBaseVNode("option", { value: "30" }, "30", -1),
                      createBaseVNode("option", { value: "50" }, "50", -1)
                    ])], 544), [
                      [vModelSelect, lsPlayersPerPage.value]
                    ])
                  ])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(playersInModalPaginated.value, (player) => {
                    return openBlock(), createElementBlock("div", {
                      key: player.id,
                      class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white"
                    }, [
                      createBaseVNode("button", {
                        class: "button d-flex align-items-center mr-3",
                        type: "button",
                        onClick: withModifiers(($event) => addToSquad(player), ["prevent"])
                      }, "+", 8, _hoisted_11$5),
                      player.position ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: normalizeClass(["anwp-w-30 anwp-text-center text-uppercase anwp-text-base text-white anwp-font-bold", unref(squadStore).appConfig.classPosition[player.position]])
                      }, toDisplayString(player.position ? player.position.charAt(0) : ""), 3)) : (openBlock(), createElementBlock("div", _hoisted_12$5, " ? ")),
                      createBaseVNode("div", _hoisted_13$5, [
                        createBaseVNode("span", _hoisted_14$5, [
                          createBaseVNode("span", {
                            class: normalizeClass(["flag", player.country])
                          }, null, 2)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_15$5, [
                        createBaseVNode("div", _hoisted_16$5, toDisplayString(player.name), 1),
                        createBaseVNode("div", _hoisted_17$5, [
                          createBaseVNode("div", null, toDisplayString(unref(squadStore).appConfig.clubsMap[player.club_id] || ""), 1),
                          unref(squadStore).appConfig.clubsMap[player.club_id] && player.birthdate ? (openBlock(), createElementBlock("div", _hoisted_18$5, " -")) : createCommentVNode("", true),
                          createBaseVNode("div", null, toDisplayString(player.birthdate), 1)
                        ])
                      ])
                    ]);
                  }), 128))
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_19$5, [
              createBaseVNode("div", _hoisted_20$3, [
                createBaseVNode("div", _hoisted_21$3, toDisplayString(unref(l10n).append_to_the), 1),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(squadStore).modalPlayers.appendToTop = $event)
                }, [
                  createBaseVNode("option", _hoisted_22$3, toDisplayString(unref(l10n).top), 1),
                  createBaseVNode("option", _hoisted_23$2, toDisplayString(unref(l10n).bottom), 1)
                ], 512), [
                  [vModelSelect, unref(squadStore).modalPlayers.appendToTop]
                ]),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary anwp-text-capitalize anwp-ml-auto",
                  onClick: _cache[8] || (_cache[8] = ($event) => unref(squadStore).modals.playerAttachToSquad = false)
                }, toDisplayString(unref(l10n).close), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$b = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$8 = { class: "my-0 anwp-font-semibold anwp-text-base" };
  const _hoisted_3$8 = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$8 = {
    key: 0,
    class: "d-flex flex-wrap align-items-center"
  };
  const _hoisted_5$7 = { class: "anwp-text-base mr-2" };
  const _hoisted_6$7 = { value: "" };
  const _hoisted_7$6 = ["value"];
  const _hoisted_8$5 = { class: "spinner mr-0 is-active" };
  const _hoisted_9$4 = { key: 1 };
  const _hoisted_10$4 = {
    key: 0,
    class: "d-flex align-items-center py-5 my-5 mx-auto justify-content-center"
  };
  const _hoisted_11$4 = ["src"];
  const _hoisted_12$4 = { class: "anwp-text-gray-700" };
  const _hoisted_13$4 = { class: "anwp-text-base anwp-text-blue-900 anwp-font-semibold" };
  const _hoisted_14$4 = { class: "anwp-text-gray-700 mt-3 mb-2" };
  const _hoisted_15$4 = ["innerHTML"];
  const _hoisted_16$4 = { class: "d-flex align-items-center my-3" };
  const _hoisted_17$4 = ["href"];
  const _hoisted_18$4 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_19$4 = { class: "d-flex align-items-center" };
  const _sfc_main$b = {
    __name: "AppModalPlayerActions",
    setup(__props) {
      const notyf2 = new Notyf({ duration: 5e3 });
      const squadStore = useSquadStore();
      const l10n = window._AnWP_FL_Squad_Data.l10n;
      const AppAxios = axios.create({
        baseURL: window._AnWP_FL_Squad_Data.rest_root,
        headers: {
          "X-WP-Nonce": window._AnWP_FL_Squad_Data.rest_nonce
        }
      });
      const changePlayerCurrentClub = () => {
        if ("update_current_club" === squadStore.modalActions.active_request) {
          return false;
        }
        if (!squadStore.modalActions.change_club_id) {
          notyf2.error("Invalid Club");
          return false;
        }
        squadStore.modalActions.active_request = "update_current_club";
        AppAxios.post(
          `anwpfl/player/update-player-current-club`,
          {
            post_id: squadStore.modalActions.playerObject.id,
            club_id: squadStore.modalActions.change_club_id
          }
        ).then(() => {
          squadStore.modalActions.playerObject.club_id = Number(squadStore.modalActions.change_club_id);
          squadStore.appConfig.players.find((pl) => pl.id === Number(squadStore.modalActions.playerObject.id)).club_id = Number(squadStore.modalActions.change_club_id);
          notyf2.success("Successfully Saved");
          squadStore.modalActions.mode = "";
          squadStore.updatePlayerData();
        }).catch(() => {
          notyf2.error(l10n.saving_data_error);
        }).finally(() => {
          squadStore.modalActions.active_request = "";
        });
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(squadStore).modals.playerActions,
          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(squadStore).modals.playerActions = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(squadStore).modals.playerActions = false)
            }, [..._cache[8] || (_cache[8] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$b, [
              createBaseVNode("h4", _hoisted_2$8, toDisplayString(unref(squadStore).modalActions.playerObject.name), 1)
            ]),
            createBaseVNode("div", _hoisted_3$8, [
              "change_club" === unref(squadStore).modalActions.mode ? (openBlock(), createElementBlock("div", _hoisted_4$8, [
                createBaseVNode("span", _hoisted_5$7, toDisplayString(unref(l10n).change_current_club_to), 1),
                withDirectives(createBaseVNode("select", {
                  name: "",
                  id: "",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(squadStore).modalActions.change_club_id = $event)
                }, [
                  createBaseVNode("option", _hoisted_6$7, "- " + toDisplayString(unref(l10n).none) + " -", 1),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(squadStore).appConfig.clubsMap, (clubName, clubId) => {
                    return openBlock(), createElementBlock("option", {
                      value: clubId,
                      key: clubId
                    }, toDisplayString(clubName), 9, _hoisted_7$6);
                  }), 128))
                ], 512), [
                  [vModelSelect, unref(squadStore).modalActions.change_club_id]
                ]),
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass(["button button-primary anwp-flex-none ml-auto", "update_current_club" === unref(squadStore).modalActions.active_request ? "disabled" : ""]),
                  onClick: _cache[2] || (_cache[2] = ($event) => changePlayerCurrentClub())
                }, [
                  _cache[9] || (_cache[9] = createTextVNode(" Change ", -1)),
                  withDirectives(createBaseVNode("span", _hoisted_8$5, null, 512), [
                    [vShow, "update_current_club" === unref(squadStore).modalActions.active_request]
                  ])
                ], 2)
              ])) : (openBlock(), createElementBlock("div", _hoisted_9$4, [
                unref(squadStore).modalActions.loading ? (openBlock(), createElementBlock("div", _hoisted_10$4, [
                  createBaseVNode("img", {
                    src: unref(squadStore).appConfig.loader,
                    alt: "loader"
                  }, null, 8, _hoisted_11$4)
                ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createBaseVNode("div", _hoisted_12$4, toDisplayString(unref(l10n).current_club) + ":", 1),
                  createBaseVNode("div", _hoisted_13$4, toDisplayString(unref(squadStore).modalActions.player_data.current_club), 1),
                  createBaseVNode("button", {
                    class: "button my-3",
                    type: "button",
                    onClick: _cache[3] || (_cache[3] = withModifiers(($event) => unref(squadStore).modalActions.mode = "change_club", ["prevent"]))
                  }, toDisplayString(unref(l10n).change_current_club), 1),
                  unref(squadStore).appConfig.transfers_available ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    _cache[11] || (_cache[11] = createBaseVNode("hr", { class: "w-100" }, null, -1)),
                    createBaseVNode("div", _hoisted_14$4, toDisplayString(unref(l10n).transfers_history), 1),
                    createBaseVNode("div", {
                      class: "my-2",
                      innerHTML: unref(squadStore).modalActions.player_data.transfers_history
                    }, null, 8, _hoisted_15$4),
                    createBaseVNode("div", _hoisted_16$4, [
                      createBaseVNode("a", {
                        class: "button",
                        target: "_blank",
                        href: unref(squadStore).modalActions.player_data.transfer_link
                      }, toDisplayString(unref(l10n).create_new_transfer), 9, _hoisted_17$4),
                      createBaseVNode("button", {
                        class: "button ml-2 d-flex align-items-center",
                        type: "button",
                        onClick: _cache[4] || (_cache[4] = withModifiers((...args) => unref(squadStore).updatePlayerData && unref(squadStore).updatePlayerData(...args), ["prevent"]))
                      }, [..._cache[10] || (_cache[10] = [
                        createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16 anwp-fill-current" }, [
                          createBaseVNode("use", { "xlink:href": "#icon-reload-outline" })
                        ], -1)
                      ])])
                    ])
                  ], 64)) : createCommentVNode("", true)
                ], 64))
              ]))
            ]),
            createBaseVNode("div", _hoisted_18$4, [
              createBaseVNode("div", _hoisted_19$4, [
                "" !== unref(squadStore).modalActions.mode ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  class: "button button-secondary ml-auto",
                  onClick: _cache[5] || (_cache[5] = ($event) => unref(squadStore).modalActions.mode = "")
                }, toDisplayString(unref(l10n).cancel), 1)) : (openBlock(), createElementBlock("button", {
                  key: 1,
                  type: "button",
                  class: "button button-secondary ml-auto",
                  onClick: _cache[6] || (_cache[6] = ($event) => unref(squadStore).modals.playerActions = false)
                }, toDisplayString(unref(l10n).close), 1))
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$a = {
    class: "anwp-border anwp-border-gray-500 my-4",
    id: "anwp-fl-staff-metabox"
  };
  const _hoisted_2$7 = { class: "p-3 d-flex align-items-center flex-wrap bg-white" };
  const _hoisted_3$7 = {
    for: "anwpfl-input-season-alt",
    class: "mr-2"
  };
  const _hoisted_4$7 = ["value"];
  const _hoisted_5$6 = { class: "bg-white py-4 px-3" };
  const _hoisted_6$6 = { class: "mb-3" };
  const _hoisted_7$5 = { class: "table-responsive" };
  const _hoisted_8$4 = { class: "table table-sm anwp-border-collapse w-100 anwp-overflow-scroll anwp-user-select-none" };
  const _hoisted_9$3 = { class: "anwp-border anwp-border-gray-400 anwp-bg-gray-200" };
  const _hoisted_10$3 = { class: "py-1 px-3" };
  const _hoisted_11$3 = { class: "py-1 px-2" };
  const _hoisted_12$3 = { class: "py-1 px-2" };
  const _hoisted_13$3 = { class: "py-1 px-3 align-middle anwp-w-10" };
  const _hoisted_14$3 = ["src"];
  const _hoisted_15$3 = { class: "py-1 align-middle anwp-w-10" };
  const _hoisted_16$3 = {
    class: "options__flag f32 align-middle",
    style: { "line-height": "12px" }
  };
  const _hoisted_17$3 = { class: "px-3 align-middle anwp-text-base anwp-leading-1" };
  const _hoisted_18$3 = {
    key: 0,
    class: "d-block anwp-text-xs anwp-text-gray-600"
  };
  const _hoisted_19$3 = { class: "py-1 px-2 anwp-w-10" };
  const _hoisted_20$2 = ["onUpdate:modelValue"];
  const _hoisted_21$2 = { class: "py-1 px-2 anwp-w-10" };
  const _hoisted_22$2 = ["onUpdate:modelValue"];
  const _hoisted_23$1 = { value: "no" };
  const _hoisted_24$1 = { value: "yes" };
  const _hoisted_25$1 = { class: "py-1 px-2 anwp-w-10" };
  const _hoisted_26$1 = ["disabled", "onUpdate:modelValue"];
  const _hoisted_27$1 = { class: "anwp-w-60 py-1 px-2 anwp-text-center" };
  const _hoisted_28$1 = ["onClick"];
  const _hoisted_29$1 = { class: "anwp-border anwp-border-gray-400 anwp-bg-gray-200" };
  const _hoisted_30$1 = { class: "py-1 px-3" };
  const _hoisted_31$1 = { class: "py-1 px-2" };
  const _hoisted_32$1 = { class: "py-1 px-2" };
  const _hoisted_33$1 = ["value"];
  const _sfc_main$a = {
    __name: "AppStaff",
    setup(__props) {
      const squadStore = useSquadStore();
      const l10n = window._AnWP_FL_Squad_Data.l10n;
      const openAttachToSquadStaffModal = () => {
        squadStore.modalStaff.pageNumber = 1;
        squadStore.modalStaff.search = "";
        squadStore.modalStaff.activeAction = "club_staff";
        squadStore.modals.staffAttachToSquad = true;
      };
      const openDeleteStaffModaal = (index2, staffObj) => {
        squadStore.deleteData.staffIndex = index2;
        squadStore.deleteData.staffObject = staffObj;
        squadStore.modals.staffDeleteConfirm = true;
      };
      const clubStaffCompact = computed(() => {
        let output = {};
        if (squadStore.clubStaff) {
          Object.keys(squadStore.clubStaff).forEach((key) => {
            output[key] = squadStore.clubStaff[key].map((_a2) => {
              var _b2 = _a2, { name, photo, country, birthdate } = _b2, pl = __objRest(_b2, ["name", "photo", "country", "birthdate"]);
              return pl;
            });
          });
        }
        return output;
      });
      return (_ctx, _cache) => {
        const _component_draggable = resolveComponent("draggable");
        return openBlock(), createElementBlock("div", _hoisted_1$a, [
          createVNode(AppBlockHeader, { icon: "#icon-organization" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(l10n).club_staff), 1)
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_2$7, [
            createBaseVNode("label", _hoisted_3$7, toDisplayString(unref(l10n).season), 1),
            withDirectives(createBaseVNode("select", {
              id: "anwpfl-input-season-alt",
              onChange: _cache[0] || (_cache[0] = (...args) => unref(squadStore).changeActiveSeason && unref(squadStore).changeActiveSeason(...args)),
              class: "mr-4",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(squadStore).active.season = $event)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(squadStore).appConfig.seasons, (s2) => {
                return openBlock(), createElementBlock("option", {
                  value: s2.id,
                  key: s2.id
                }, toDisplayString(s2.title), 9, _hoisted_4$7);
              }), 128))
            ], 544), [
              [vModelSelect, unref(squadStore).active.season]
            ])
          ]),
          createBaseVNode("div", _hoisted_5$6, [
            createBaseVNode("div", _hoisted_6$6, [
              createBaseVNode("button", {
                class: "button d-flex align-items-center",
                type: "button",
                onClick: withModifiers(openAttachToSquadStaffModal, ["prevent"])
              }, [
                _cache[3] || (_cache[3] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16 mr-2" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-plus" })
                ], -1)),
                createTextVNode(" " + toDisplayString(unref(l10n).attach_person_to_staff), 1)
              ])
            ]),
            withDirectives(createBaseVNode("div", _hoisted_7$5, [
              withDirectives(createBaseVNode("table", _hoisted_8$4, [
                createBaseVNode("thead", null, [
                  createBaseVNode("tr", _hoisted_9$3, [
                    _cache[4] || (_cache[4] = createBaseVNode("td", null, null, -1)),
                    _cache[5] || (_cache[5] = createBaseVNode("td", null, null, -1)),
                    _cache[6] || (_cache[6] = createBaseVNode("td", null, null, -1)),
                    createBaseVNode("td", _hoisted_10$3, toDisplayString(unref(l10n).staff_name), 1),
                    createBaseVNode("td", _hoisted_11$3, toDisplayString(unref(l10n).job), 1),
                    _cache[7] || (_cache[7] = createBaseVNode("td", { class: "py-1 px-2" }, null, -1)),
                    _cache[8] || (_cache[8] = createBaseVNode("td", { class: "py-1 px-2" }, null, -1)),
                    createBaseVNode("td", _hoisted_12$3, toDisplayString(unref(l10n).remove), 1)
                  ])
                ]),
                createVNode(_component_draggable, {
                  modelValue: unref(squadStore).activeStaff,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(squadStore).activeStaff = $event),
                  handle: ".anwp-drag-handler",
                  tag: "tbody",
                  "force-fallback": true
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(squadStore).activeStaff, (member, index2) => {
                      return openBlock(), createElementBlock("tr", {
                        class: "anwp-border anwp-border-gray-400",
                        key: member.id
                      }, [
                        _cache[10] || (_cache[10] = createBaseVNode("td", { class: "anwp-drag-handler anwp-w-30 anwp-text-center pt-1 px-2" }, [
                          createBaseVNode("svg", { class: "anwp-icon anwp-icon--s24 anwp-icon--octi mr-0" }, [
                            createBaseVNode("use", { "xlink:href": "#icon-grabber" })
                          ])
                        ], -1)),
                        createBaseVNode("td", _hoisted_13$3, [
                          createBaseVNode("img", {
                            class: "anwp-h-40 anwp-w-40 anwp-object-contain",
                            src: member.photo || unref(squadStore).appConfig.default_photo,
                            alt: "member photo"
                          }, null, 8, _hoisted_14$3)
                        ]),
                        createBaseVNode("td", _hoisted_15$3, [
                          createBaseVNode("span", _hoisted_16$3, [
                            createBaseVNode("span", {
                              class: normalizeClass(["flag", member.country])
                            }, null, 2)
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_17$3, [
                          createTextVNode(toDisplayString(member.name) + " ", 1),
                          member.birthdate ? (openBlock(), createElementBlock("span", _hoisted_18$3, toDisplayString(member.birthdate), 1)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("td", _hoisted_19$3, [
                          withDirectives(createBaseVNode("input", {
                            class: "my-1 anwp-border-gray-300 anwp-w-130",
                            type: "text",
                            "onUpdate:modelValue": ($event) => member.job = $event
                          }, null, 8, _hoisted_20$2), [
                            [vModelText, member.job]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_21$2, [
                          withDirectives(createBaseVNode("select", {
                            class: "anwp-w-200 my-1",
                            "onUpdate:modelValue": ($event) => member.grouping = $event
                          }, [
                            createBaseVNode("option", _hoisted_23$1, toDisplayString(unref(l10n).attach_to_squad), 1),
                            createBaseVNode("option", _hoisted_24$1, toDisplayString(unref(l10n).use_separate_group), 1)
                          ], 8, _hoisted_22$2), [
                            [vModelSelect, member.grouping]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_25$1, [
                          withDirectives(createBaseVNode("input", {
                            class: "anwp-w-130 my-1",
                            disabled: "yes" !== member.grouping,
                            type: "text",
                            "onUpdate:modelValue": ($event) => member.group = $event
                          }, null, 8, _hoisted_26$1), [
                            [vModelText, member.group]
                          ])
                        ]),
                        createBaseVNode("td", _hoisted_27$1, [
                          createBaseVNode("button", {
                            type: "button",
                            class: "anwp-cursor-pointer d-flex align-items-center justify-content-center my-1 anwp-w-50 button anwp-border-red-600",
                            onClick: withModifiers(($event) => openDeleteStaffModaal(index2, member), ["prevent"])
                          }, [..._cache[9] || (_cache[9] = [
                            createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-red-600" }, [
                              createBaseVNode("use", { "xlink:href": "#icon-x" })
                            ], -1)
                          ])], 8, _hoisted_28$1)
                        ])
                      ]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                createBaseVNode("tfoot", null, [
                  createBaseVNode("tr", _hoisted_29$1, [
                    _cache[11] || (_cache[11] = createBaseVNode("td", null, null, -1)),
                    _cache[12] || (_cache[12] = createBaseVNode("td", null, null, -1)),
                    _cache[13] || (_cache[13] = createBaseVNode("td", null, null, -1)),
                    createBaseVNode("td", _hoisted_30$1, toDisplayString(unref(l10n).staff_name), 1),
                    createBaseVNode("td", _hoisted_31$1, toDisplayString(unref(l10n).job), 1),
                    _cache[14] || (_cache[14] = createBaseVNode("td", { class: "py-1 px-2" }, null, -1)),
                    _cache[15] || (_cache[15] = createBaseVNode("td", { class: "py-1 px-2" }, null, -1)),
                    createBaseVNode("td", _hoisted_32$1, toDisplayString(unref(l10n).remove), 1)
                  ])
                ])
              ], 512), [
                [vShow, unref(squadStore).activeStaff.length]
              ])
            ], 512), [
              [vShow, !unref(squadStore).active.loading]
            ])
          ]),
          createBaseVNode("input", {
            type: "hidden",
            name: "_anwpfl_staff",
            value: JSON.stringify(clubStaffCompact.value)
          }, null, 8, _hoisted_33$1)
        ]);
      };
    }
  };
  const _hoisted_1$9 = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$6 = { class: "my-0" };
  const _hoisted_3$6 = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$6 = { class: "anwp-text-center" };
  const _hoisted_5$5 = { class: "anwp-text-lg anwp-font-bold" };
  const _hoisted_6$5 = { class: "anwp-text-base" };
  const _hoisted_7$4 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_8$3 = { class: "d-flex flex-row-reverse" };
  const _sfc_main$9 = {
    __name: "AppModalStaffDeleteConfirm",
    setup(__props) {
      const squadStore = useSquadStore();
      const l10n = window._AnWP_FL_Squad_Data.l10n;
      const removeMemberFromStaff = () => {
        if (null !== squadStore.deleteData.staffIndex) {
          squadStore.activeStaff.splice(squadStore.deleteData.staffIndex, 1);
        }
        squadStore.modals.staffDeleteConfirm = false;
        squadStore.deleteData.staffIndex = null;
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(squadStore).modals.staffDeleteConfirm,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(squadStore).modals.staffDeleteConfirm = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper anwp-vfm-admin-modal__wrapper--mini"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(squadStore).modals.staffDeleteConfirm = false)
            }, [..._cache[4] || (_cache[4] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$9, [
              createBaseVNode("h4", _hoisted_2$6, toDisplayString(unref(l10n).confirm_delete), 1)
            ]),
            createBaseVNode("div", _hoisted_3$6, [
              createBaseVNode("div", _hoisted_4$6, [
                createBaseVNode("div", _hoisted_5$5, toDisplayString(unref(l10n).are_you_sure), 1),
                createBaseVNode("p", null, toDisplayString(unref(l10n).really_want_delete_from_squad), 1),
                createBaseVNode("div", _hoisted_6$5, toDisplayString(unref(squadStore).deleteData.staffObject.name), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_7$4, [
              createBaseVNode("div", _hoisted_8$3, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button",
                  onClick: _cache[1] || (_cache[1] = ($event) => unref(squadStore).modals.staffDeleteConfirm = false)
                }, toDisplayString(unref(l10n).close), 1),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-link-delete anwp-mx-2",
                  onClick: _cache[2] || (_cache[2] = withModifiers(($event) => removeMemberFromStaff(), ["prevent"]))
                }, toDisplayString(unref(l10n).delete), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$8 = { class: "anwp-vfm-admin-modal__title" };
  const _hoisted_2$5 = { class: "my-0" };
  const _hoisted_3$5 = { class: "anwp-vfm-admin-modal__content" };
  const _hoisted_4$5 = { class: "d-sm-flex" };
  const _hoisted_5$4 = { class: "col-sm-6 bg-light py-3" };
  const _hoisted_6$4 = { class: "pr-3 anwp-text-base" };
  const _hoisted_7$3 = {
    key: 0,
    class: "anwp-text-gray-600"
  };
  const _hoisted_8$2 = { class: "col-sm-6 py-0 anwp-h-min-300" };
  const _hoisted_9$2 = {
    key: 0,
    class: "anwp-bg-gray-200 px-2 mx-n2 anwp-text-gray-800"
  };
  const _hoisted_10$2 = { class: "d-flex flex-column" };
  const _hoisted_11$2 = ["onClick"];
  const _hoisted_12$2 = {
    class: "options__flag f32 align-middle",
    style: { "line-height": "12px" }
  };
  const _hoisted_13$2 = { class: "pl-3 d-flex flex-column" };
  const _hoisted_14$2 = { class: "anwp-text-base anwp-leading-1" };
  const _hoisted_15$2 = {
    key: 0,
    class: "anwp-text-gray-600 anwp-text-xs"
  };
  const _hoisted_16$2 = { class: "anwp-text-gray-600 d-flex align-items-center anwp-text-xs" };
  const _hoisted_17$2 = {
    key: 0,
    class: "mx-2"
  };
  const _hoisted_18$2 = { class: "anwp-vfm-admin-modal__actions" };
  const _hoisted_19$2 = { class: "d-flex align-items-center" };
  const _hoisted_20$1 = { class: "mr-2" };
  const _hoisted_21$1 = { value: true };
  const _hoisted_22$1 = { value: false };
  const _sfc_main$8 = {
    __name: "AppModalStaffAttachToSquad",
    setup(__props) {
      const squadStore = useSquadStore();
      const l10n = window._AnWP_FL_Squad_Data.l10n;
      const modalStaffAttachToSquadSearch = ref(null);
      const staffInModal = computed(() => {
        let staffs = squadStore.appConfig.staff.filter((p2) => !squadStore.staffInActiveSquadIds.includes(Number(p2.id)));
        if ("club_staff" === squadStore.modalStaff.activeAction) {
          return staffs.filter((p2) => Number(p2.club_id) === Number(squadStore.active.club));
        } else if ("search_by_name" === squadStore.modalStaff.activeAction && "" !== squadStore.modalStaff.search.trim()) {
          return staffs.filter((p2) => p2.name.toLowerCase().indexOf(squadStore.modalStaff.search.toLowerCase()) > -1);
        } else if (squadStore.modalStaff.activeAction.indexOf("s:") === 0) {
          let squad = squadStore.clubStaff[squadStore.modalStaff.activeAction];
          if (squad) {
            let squadStaffIds = squad.map((s2) => Number(s2.id));
            return staffs.filter((p2) => squadStaffIds.includes(Number(p2.id)));
          }
        }
        return staffs;
      });
      const staffInModalPages = computed(() => {
        return staffInModal.value.length ? Math.ceil(staffInModal.value.length / 10) : 0;
      });
      const staffInModalPaginated = computed(() => {
        if (!staffInModal.value.length) {
          return [];
        }
        return staffInModal.value.slice((squadStore.modalStaff.pageNumber - 1) * 10, squadStore.modalStaff.pageNumber * 10);
      });
      const modalStaffActions = computed(() => {
        let actions2 = [
          { name: l10n.club_staff, value: "club_staff" },
          { name: l10n.search_by_name, value: "search_by_name" }
        ];
        let seasons = Object.keys(squadStore.clubStaff).filter((k2) => k2 !== "s:" + squadStore.active.season);
        if (seasons.length) {
          actions2.push({ group: l10n.other_seasons, name: null, value: "" });
          squadStore.appConfig.seasons.forEach((s2) => {
            if (seasons.includes("s:" + s2.id) && squadStore.clubStaff["s:" + s2.id].length) {
              actions2.push({ name: s2.title, value: "s:" + s2.id });
            }
          });
        }
        return actions2;
      });
      const addToStaff = (member) => {
        let staffObj = {
          id: member.id,
          birthdate: member.birthdate,
          country: member.country,
          photo: member.photo,
          name: member.name,
          job: member.job,
          grouping: "no",
          group: ""
        };
        squadStore.modalStaff.appendToTop ? squadStore.activeStaff.unshift(staffObj) : squadStore.activeStaff.push(staffObj);
      };
      const changeModalStaffActivePage = (pageNumber) => {
        squadStore.modalStaff.pageNumber = pageNumber;
      };
      const onSelectedModalStaffActions = (selected) => {
        squadStore.modalStaff.pageNumber = 1;
        if ("search_by_name" === selected.value) {
          setTimeout(() => {
            modalStaffAttachToSquadSearch.value.focus();
          }, 0);
        }
      };
      return (_ctx, _cache) => {
        const _component_v_select = resolveComponent("v-select");
        return openBlock(), createBlock(unref(Ro), {
          modelValue: unref(squadStore).modals.staffAttachToSquad,
          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(squadStore).modals.staffAttachToSquad = $event),
          "z-index-fn": () => 100060,
          "focus-trap": false,
          "teleport-to": false,
          class: "anwp-vfm-admin-modal",
          "content-class": "anwp-vfm-admin-modal__wrapper"
        }, {
          default: withCtx(() => [
            createBaseVNode("button", {
              class: "anwp-vfm-admin-modal__close button d-flex align-items-center justify-content-center anwp-cursor-pointer border-0 modal__close",
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(squadStore).modals.staffAttachToSquad = false)
            }, [..._cache[8] || (_cache[8] = [
              createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s18 anwp-fill-current anwp-text-gray-600" }, [
                createBaseVNode("use", { "xlink:href": "#icon-x" })
              ], -1)
            ])]),
            createBaseVNode("div", _hoisted_1$8, [
              createBaseVNode("h4", _hoisted_2$5, toDisplayString(unref(l10n).attach_person_to_staff) + " - " + toDisplayString(unref(l10n).season) + " " + toDisplayString(unref(squadStore).active.season_title), 1)
            ]),
            createBaseVNode("div", _hoisted_3$5, [
              createBaseVNode("div", _hoisted_4$5, [
                createBaseVNode("div", _hoisted_5$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(squadStore).activeStaff, (member) => {
                    return openBlock(), createElementBlock("div", {
                      class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white",
                      key: member.id
                    }, [
                      createBaseVNode("div", _hoisted_6$4, toDisplayString(member.name), 1),
                      member.job ? (openBlock(), createElementBlock("div", _hoisted_7$3, "(" + toDisplayString(member.job) + ")", 1)) : createCommentVNode("", true)
                    ]);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_8$2, [
                  createVNode(_component_v_select, {
                    label: "name",
                    modelValue: unref(squadStore).modalStaff.activeAction,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(squadStore).modalStaff.activeAction = $event),
                    options: modalStaffActions.value,
                    clearable: false,
                    filterable: false,
                    searchable: false,
                    "onOption:selected": onSelectedModalStaffActions,
                    selectable: (option) => !option.hasOwnProperty("group"),
                    reduce: (o2) => o2.value
                  }, {
                    option: withCtx(({ group, name }) => [
                      group ? (openBlock(), createElementBlock("div", _hoisted_9$2, toDisplayString(group), 1)) : createCommentVNode("", true),
                      createTextVNode(" " + toDisplayString(name), 1)
                    ]),
                    _: 1
                  }, 8, ["modelValue", "options", "selectable", "reduce"]),
                  withDirectives(createBaseVNode("div", null, [
                    _cache[9] || (_cache[9] = createBaseVNode("hr", null, null, -1)),
                    createBaseVNode("div", _hoisted_10$2, [
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(squadStore).modalStaff.search = $event),
                        class: "w-100",
                        onInput: _cache[3] || (_cache[3] = ($event) => unref(squadStore).modalStaff.pageNumber = 1),
                        ref_key: "modalStaffAttachToSquadSearch",
                        ref: modalStaffAttachToSquadSearch
                      }, null, 544), [
                        [vModelText, unref(squadStore).modalStaff.search]
                      ])
                    ])
                  ], 512), [
                    [vShow, "search_by_name" === unref(squadStore).modalStaff.activeAction]
                  ]),
                  _cache[10] || (_cache[10] = createBaseVNode("hr", null, null, -1)),
                  staffInModal.value.length ? (openBlock(), createBlock(unref(Paginate), {
                    key: 0,
                    class: "anwp-user-select-none mb-2 mb-0",
                    modelValue: unref(squadStore).modalStaff.pageNumber,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(squadStore).modalStaff.pageNumber = $event),
                    "page-count": staffInModalPages.value,
                    "click-handler": changeModalStaffActivePage,
                    "prev-text": unref(l10n).prev,
                    "next-text": unref(l10n).next,
                    "container-class": "anwp-pagination",
                    "page-class": "anwp-page-item",
                    "prev-class": "anwp-page-item",
                    "next-class": "anwp-page-item",
                    "next-link-class": "anwp-page-link",
                    "prev-link-class": "anwp-page-link",
                    "page-link-class": "anwp-page-link"
                  }, null, 8, ["modelValue", "page-count", "prev-text", "next-text"])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(staffInModalPaginated.value, (member) => {
                    return openBlock(), createElementBlock("div", {
                      class: "py-1 px-2 mb-1 anwp-border anwp-border-gray-200 d-flex align-items-center bg-white",
                      key: member.id
                    }, [
                      createBaseVNode("button", {
                        class: "button d-flex align-items-center mr-3",
                        type: "button",
                        onClick: withModifiers(($event) => addToStaff(member), ["prevent"])
                      }, "+", 8, _hoisted_11$2),
                      createBaseVNode("div", null, [
                        createBaseVNode("span", _hoisted_12$2, [
                          createBaseVNode("span", {
                            class: normalizeClass(["flag", member.country])
                          }, null, 2)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_13$2, [
                        createBaseVNode("div", _hoisted_14$2, [
                          createTextVNode(toDisplayString(member.name) + " ", 1),
                          member.job ? (openBlock(), createElementBlock("span", _hoisted_15$2, " - " + toDisplayString(member.job), 1)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("div", _hoisted_16$2, [
                          createBaseVNode("div", null, toDisplayString(unref(squadStore).appConfig.clubsMap[member.club_id] || ""), 1),
                          unref(squadStore).appConfig.clubsMap[member.club_id] && member.birthdate ? (openBlock(), createElementBlock("div", _hoisted_17$2, " - ")) : createCommentVNode("", true),
                          createBaseVNode("div", null, toDisplayString(member.birthdate), 1)
                        ])
                      ])
                    ]);
                  }), 128))
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_18$2, [
              createBaseVNode("div", _hoisted_19$2, [
                createBaseVNode("div", _hoisted_20$1, toDisplayString(unref(l10n).append_to_the), 1),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(squadStore).modalStaff.appendToTop = $event)
                }, [
                  createBaseVNode("option", _hoisted_21$1, toDisplayString(unref(l10n).top), 1),
                  createBaseVNode("option", _hoisted_22$1, toDisplayString(unref(l10n).bottom), 1)
                ], 512), [
                  [vModelSelect, unref(squadStore).modalStaff.appendToTop]
                ]),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary anwp-text-capitalize anwp-ml-auto",
                  onClick: _cache[6] || (_cache[6] = ($event) => unref(squadStore).modals.staffAttachToSquad = false)
                }, toDisplayString(unref(l10n).close), 1)
              ])
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  };
  const _hoisted_1$7 = { class: "anwp-vue-squad-wrapper anwp-b-wrap anwp-vue-wrapper-ready w-100" };
  const _sfc_main$7 = {
    __name: "AppSquad",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$7, [
          createVNode(_sfc_main$e),
          createVNode(_sfc_main$a),
          createVNode(unref(Wo)),
          createVNode(_sfc_main$d),
          createVNode(_sfc_main$c),
          createVNode(_sfc_main$b),
          createVNode(_sfc_main$9),
          createVNode(_sfc_main$8)
        ]);
      };
    }
  };
  const notyf$1 = new Notyf({ duration: 5e3 });
  const useAppStore = /* @__PURE__ */ defineStore("app", () => {
    const activeRequest = ref("");
    const activeProgress = ref(0);
    const activeTask = reactive({});
    const initialTasksLoaded = ref(false);
    const appLogs = ref([]);
    const appLogsLastIndex = ref(0);
    const updaterTasks = ref([]);
    const spinnerUrl = window._anwpToolbox.spinner_url || "";
    const showError = (error, addToLog = true) => {
      var _a2, _b2, _c, _d;
      const errorHeader = error.message ? error.message : "";
      const errorText = ((_b2 = (_a2 = error == null ? void 0 : error.response) == null ? void 0 : _a2.data) == null ? void 0 : _b2.message) ? error.response.data.message : "";
      const isWarning2 = "anwp_rest_warning" === ((_d = (_c = error == null ? void 0 : error.response) == null ? void 0 : _c.data) == null ? void 0 : _d.code);
      const toastMessage = errorHeader ? `<b>${errorHeader}</b><br>${errorText}` : errorText;
      if (isWarning2) {
        notyf$1.success(toastMessage);
      } else {
        notyf$1.error(toastMessage);
      }
      if (addToLog) {
        appLogs.value.unshift({
          index: appLogsLastIndex.value++,
          type: isWarning2 ? "warning" : "error",
          title: errorHeader,
          text: errorText,
          time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
        });
      }
    };
    const showSuccess = (successText = "", successHeader = "", addToLog = true) => {
      const toastMessage = successHeader ? `<b>${successHeader}</b><br>${successText}` : successText;
      notyf$1.success(toastMessage);
      if (addToLog) {
        appLogs.value.unshift({
          index: appLogsLastIndex.value++,
          type: "success",
          title: successHeader,
          text: successText,
          time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
        });
      }
    };
    return {
      showSuccess,
      showError,
      initialTasksLoaded,
      activeProgress,
      activeRequest,
      activeTask,
      appLogs,
      spinnerUrl,
      appLogsLastIndex,
      updaterTasks
    };
  });
  const _hoisted_1$6 = {
    key: 0,
    class: "anwp-bg-gray-100 p-2 mt-4"
  };
  const _hoisted_2$4 = { class: "text-nowrap d-flex" };
  const _hoisted_3$4 = { class: "d-inline-block anwp-w-100" };
  const _hoisted_4$4 = { class: "anwp-w-120 anwp-text-center mr-3" };
  const _hoisted_5$3 = {
    key: 0,
    class: "anwp-text-xs anwp-text-gray-600 mr-2"
  };
  const _hoisted_6$3 = { class: "anwp-text-sm anwp-leading-1-25" };
  const _sfc_main$6 = {
    __name: "AppTasksLog",
    setup(__props) {
      const appStore = useAppStore();
      return (_ctx, _cache) => {
        return unref(appStore).appLogs.length ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
          _cache[1] || (_cache[1] = createBaseVNode("div", { class: "anwp-text-sm anwp-text-gray-600 mb-3" }, "Tasks Log", -1)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(appStore).appLogs, (log) => {
            return openBlock(), createElementBlock("div", {
              key: log.index,
              class: "d-flex flex-wrap align-items-center anwp-border-bottom anwp-border-gray-300 pb-1 mb-1"
            }, [
              createBaseVNode("div", _hoisted_2$4, [
                _cache[0] || (_cache[0] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi d-inline-block anwp-icon--s16 anwp-fill-current anwp-text-gray-600 mr-2" }, [
                  createBaseVNode("use", { "xlink:href": "#icon-fl-pro-calendar" })
                ], -1)),
                createBaseVNode("span", _hoisted_3$4, toDisplayString(log.time), 1)
              ]),
              createBaseVNode("div", _hoisted_4$4, [
                createBaseVNode("div", {
                  class: normalizeClass(["px-2 pb-1 anwp-leading-1 rounded text-white", [{ "anwp-bg-green-600": "success" === log.type }, { "anwp-bg-red-600": "error" === log.type }, { "anwp-bg-orange-600": "warning" === log.type }]])
                }, toDisplayString(log.type), 3)
              ]),
              log.title ? (openBlock(), createElementBlock("div", _hoisted_5$3, toDisplayString(log.title), 1)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_6$3, toDisplayString(log.text), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true);
      };
    }
  };
  const _hoisted_1$5 = { class: "anwp-vue-optimizer-wrapper d-sm-flex" };
  const _hoisted_2$3 = { class: "w-100 anwp-flex-grow-1 pr-5" };
  const _hoisted_3$3 = {
    key: 0,
    class: "d-flex align-items-center"
  };
  const _hoisted_4$3 = ["src"];
  const _hoisted_5$2 = { key: 1 };
  const _hoisted_6$2 = {
    key: 2,
    class: "my-2 anwp-border anwp-border-orange-600 anwp-bg-orange-100 py-3 px-4 anwp-w-max-700"
  };
  const _hoisted_7$2 = { class: "anwp-b-wrap anwp-w-max-500" };
  const _hoisted_8$1 = { class: "my-2 anwp-border anwp-border-gray-400 py-2 px-3 bg-white d-flex" };
  const _hoisted_9$1 = { class: "anwp-flex-grow-1" };
  const _hoisted_10$1 = { class: "mt-2 mb-1" };
  const _hoisted_11$1 = {
    key: 0,
    class: "anwp-text-sx ml-3 anwp-opacity-70"
  };
  const _hoisted_12$1 = {
    key: 0,
    class: "my-2 anwp-opacity-90 font-italic"
  };
  const _hoisted_13$1 = { class: "my-0 anwp-opacity-90 font-italic" };
  const _hoisted_14$1 = ["disabled", "onClick"];
  const _hoisted_15$1 = ["src"];
  const _hoisted_16$1 = {
    key: 1,
    class: "anwp-icon anwp-icon--octi anwp-icon--s16"
  };
  const _hoisted_17$1 = {
    key: 1,
    disabled: true,
    class: "button d-flex mx-auto align-items-center justify-content-center anwp-w-40 anwp-h-30 anwp-opacity-70",
    type: "button"
  };
  const _hoisted_18$1 = {
    key: 2,
    class: "d-flex mx-auto align-items-center justify-content-center anwp-w-40 anwp-h-30 anwp-text-green-700"
  };
  const _hoisted_19$1 = { class: "flex-shrink-1 d-flex flex-column anwp-text-nowrap text-nowrap" };
  const _sfc_main$5 = {
    __name: "AppUpdater",
    setup(__props) {
      var _a2;
      const AppAxios = axios.create({
        baseURL: window._anwpToolbox.rest_root,
        headers: {
          "X-WP-Nonce": window._anwpToolbox.rest_nonce
        }
      });
      const appStore = useAppStore();
      const pageNumber = Number((_a2 = window._anwpToolbox.fl_page_num) != null ? _a2 : 10);
      const changeOrder = ref(false);
      const showIDs = ref(false);
      onMounted(() => {
        updateTasksList();
      });
      const popItems = () => {
        const items = [];
        for (let ii = 1; ii <= pageNumber; ii++) {
          if (appStore.activeTask.subtasks.length) {
            items.push(appStore.activeTask.subtasks.pop());
          }
        }
        return items;
      };
      const availableTaskToRun = computed(() => {
        var _a3;
        if (appStore.activeRequest) {
          return appStore.activeRequest;
        }
        return (_a3 = appStore.updaterTasks.find((t) => "pending" === t.status)) == null ? void 0 : _a3.slug;
      });
      const startTask = (task) => {
        if (appStore.activeRequest) {
          return false;
        }
        appStore.activeRequest = task.slug;
        appStore.activeTask = task;
        const items = popItems();
        appStore.activeProgress = items.length;
        runSubTask(items);
      };
      const skipSubtask = () => {
        if (appStore.activeRequest || !availableTaskToRun.value) {
          return false;
        }
        appStore.updaterTasks = appStore.updaterTasks.map((t) => {
          if (t.slug === availableTaskToRun.value) {
            t.subtasks = t.subtasks.slice(0, -1);
          }
          return t;
        });
      };
      const hideMigrationNotice = () => {
        AppAxios.post("anwpfl/api-toolbox-updater-hide/").then(() => {
          location.reload();
        }).catch((error) => {
          appStore.showError(error);
        });
      };
      const runSubTask = (subtasks) => {
        AppAxios.post(
          "anwpfl/api-toolbox-updater/" + appStore.activeRequest,
          { subtasks }
        ).then(() => {
          runNextSubTask();
        }).catch((error) => {
          appStore.showError(error);
          appStore.activeRequest = "";
        });
      };
      const runNextSubTask = () => {
        if (appStore.activeTask.subtasks.length) {
          const items = popItems();
          appStore.activeProgress = appStore.activeProgress + items.length;
          runSubTask(items);
        } else {
          appStore.activeRequest = "";
          appStore.showSuccess('Task: "' + appStore.activeTask.title + '" has been done successfully');
          appStore.activeTask.status = "done";
          appStore.activeTask = {};
          updateTasksList();
        }
      };
      const updateTasksList = () => {
        if (appStore.activeRequest) {
          return false;
        }
        appStore.activeRequest = "update_tasks_list";
        AppAxios.get("anwpfl/api-toolbox-updater/get_toolbox_updater_tasks").then((response) => {
          var _a3;
          if ((_a3 = response.data) == null ? void 0 : _a3.tasks) {
            appStore.updaterTasks = response.data.tasks;
            appStore.initialTasksLoaded = true;
          } else {
            appStore.showError({ message: "Response is empty!" });
          }
          appStore.activeRequest = "";
        }).catch((error) => {
          appStore.showError(error);
          appStore.activeRequest = "";
        });
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$5, [
          createBaseVNode("div", _hoisted_2$3, [
            "update_tasks_list" === unref(appStore).activeRequest ? (openBlock(), createElementBlock("div", _hoisted_3$3, [
              createBaseVNode("img", {
                src: unref(appStore).spinnerUrl,
                alt: "spinner",
                class: "mr-2"
              }, null, 8, _hoisted_4$3),
              _cache[4] || (_cache[4] = createBaseVNode("span", null, "Check database tasks to update", -1))
            ])) : createCommentVNode("", true),
            !unref(appStore).activeRequest && !unref(appStore).updaterTasks.length && unref(appStore).initialTasksLoaded ? (openBlock(), createElementBlock("div", _hoisted_5$2, " No update needed ")) : createCommentVNode("", true),
            unref(appStore).updaterTasks.length ? (openBlock(), createElementBlock("div", _hoisted_6$2, [..._cache[5] || (_cache[5] = [
              createBaseVNode("h3", { class: "my-0 anwp-text-orange-800" }, "Backup Your Database", -1),
              createBaseVNode("div", { class: "mt-2" }, " Before initiating the migration process, it is crucial to create a database backup. This ensures that you can restore your information in case of any unforeseen issues. ", -1)
            ])])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_7$2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(appStore).updaterTasks, (task) => {
                return openBlock(), createElementBlock("div", _hoisted_8$1, [
                  createBaseVNode("div", _hoisted_9$1, [
                    createBaseVNode("h4", _hoisted_10$1, [
                      createTextVNode(toDisplayString(task.title) + " ", 1),
                      unref(appStore).activeRequest === task.slug ? (openBlock(), createElementBlock("span", _hoisted_11$1, toDisplayString(unref(appStore).activeProgress), 1)) : createCommentVNode("", true),
                      createTextVNode(" - " + toDisplayString(task.total), 1)
                    ]),
                    showIDs.value ? (openBlock(), createElementBlock("p", _hoisted_12$1, toDisplayString(task.subtasks), 1)) : createCommentVNode("", true),
                    createBaseVNode("p", _hoisted_13$1, toDisplayString(task.description), 1)
                  ]),
                  createBaseVNode("div", null, [
                    "pending" === task.status && (task.slug === availableTaskToRun.value || changeOrder.value) ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      class: "button d-flex mx-auto align-items-center justify-content-center anwp-w-40 anwp-h-30",
                      type: "button",
                      disabled: "" !== unref(appStore).activeRequest,
                      onClick: withModifiers(($event) => startTask(task), ["prevent"])
                    }, [
                      unref(appStore).activeRequest === task.slug ? (openBlock(), createElementBlock("img", {
                        key: 0,
                        class: "align-text-bottom",
                        src: unref(appStore).spinnerUrl,
                        alt: "spinner"
                      }, null, 8, _hoisted_15$1)) : (openBlock(), createElementBlock("svg", _hoisted_16$1, [..._cache[6] || (_cache[6] = [
                        createBaseVNode("use", { "xlink:href": "#icon-caret-right" }, null, -1)
                      ])]))
                    ], 8, _hoisted_14$1)) : createCommentVNode("", true),
                    "pending" === task.status && task.slug !== availableTaskToRun.value && !changeOrder.value ? (openBlock(), createElementBlock("button", _hoisted_17$1, [..._cache[7] || (_cache[7] = [
                      createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s16" }, [
                        createBaseVNode("use", { "xlink:href": "#icon-caret-right" })
                      ], -1)
                    ])])) : createCommentVNode("", true),
                    "done" === task.status ? (openBlock(), createElementBlock("div", _hoisted_18$1, [..._cache[8] || (_cache[8] = [
                      createBaseVNode("svg", { class: "anwp-icon anwp-icon--octi anwp-icon--s24 anwp-fill-current" }, [
                        createBaseVNode("use", { "xlink:href": "#icon-checklist" })
                      ], -1)
                    ])])) : createCommentVNode("", true)
                  ])
                ]);
              }), 256))
            ]),
            createVNode(_sfc_main$6)
          ]),
          createBaseVNode("div", _hoisted_19$1, [
            createBaseVNode("a", {
              class: "mt-1",
              href: "#",
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => changeOrder.value = !changeOrder.value, ["prevent"]))
            }, "change migration order"),
            createBaseVNode("a", {
              class: "mt-1",
              href: "#",
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => showIDs.value = !showIDs.value, ["prevent"]))
            }, "show/hide migration ids"),
            createBaseVNode("a", {
              class: "mt-1",
              href: "#",
              onClick: _cache[2] || (_cache[2] = withModifiers(($event) => skipSubtask(), ["prevent"]))
            }, "skip current subtask"),
            createBaseVNode("a", {
              class: "mt-1",
              href: "#",
              onClick: _cache[3] || (_cache[3] = withModifiers(($event) => hideMigrationNotice(), ["prevent"]))
            }, "hide migration notice")
          ])
        ]);
      };
    }
  };
  const getNotyf = () => {
    if (typeof Notyf !== "undefined") {
      return new Notyf({ duration: 5e3 });
    }
    return null;
  };
  const notyf = getNotyf();
  function useErrorHandler(options = {}) {
    const {
      notifier = notyf,
      errorMessages = {}
    } = options;
    const defaultErrorMessages = __spreadValues({
      GENERIC_ERROR: "An unexpected error occurred",
      REQUEST_IN_PROGRESS: "Another request is in progress",
      API_KEY_REQUIRED: "API key is required",
      API_KEY_INVALID: "API key appears to be invalid",
      GAME_ID_REQUIRED: "Please select a game",
      GAME_ID_INVALID: "Please enter a valid game ID",
      MODEL_REQUIRED: "Please select a model"
    }, errorMessages);
    const getStatusMessage = (status, data) => {
      switch (status) {
        case 400:
          return data.message || "Invalid request. Please check your input.";
        case 401:
          return "Authentication failed. Please refresh the page and try again.";
        case 403:
          return "You don't have permission to perform this action.";
        case 404:
          return "The requested resource was not found.";
        case 429:
          return "Too many requests. Please wait a moment and try again.";
        case 500:
        case 502:
        case 503:
          return "Server error. Please try again later.";
        default:
          return data.message || `Request failed with status ${status}`;
      }
    };
    const handleApiError = (error, context = "") => {
      var _a2;
      let userMessage = defaultErrorMessages.GENERIC_ERROR;
      let technicalDetails = "";
      if (error.response) {
        const status = error.response.status;
        const data = error.response.data || {};
        userMessage = getStatusMessage(status, data);
        technicalDetails = data.details || data.code || "";
      } else if (error.request) {
        userMessage = "No response from server. Check your internet connection.";
        technicalDetails = "Request timeout or network error";
      } else {
        userMessage = error.message || defaultErrorMessages.GENERIC_ERROR;
        technicalDetails = error.stack || "";
      }
      console.error(`[${context}] Error:`, {
        message: userMessage,
        details: technicalDetails,
        error
      });
      if (notifier && notifier.error) {
        notifier.error(userMessage);
      }
      return {
        userMessage,
        technicalDetails,
        status: (_a2 = error.response) == null ? void 0 : _a2.status
      };
    };
    const handleValidationError = (field, message) => {
      console.warn(`Validation error (${field}):`, message);
      if (notifier && notifier.error) {
        notifier.error(message);
      }
    };
    const showSuccess = (message) => {
      if (notifier && notifier.success) {
        notifier.success(message);
      }
    };
    const showInfo = (message) => {
      console.info(message);
    };
    const getErrorMessage = (error, fallback = defaultErrorMessages.GENERIC_ERROR) => {
      var _a2, _b2;
      return ((_b2 = (_a2 = error == null ? void 0 : error.response) == null ? void 0 : _a2.data) == null ? void 0 : _b2.message) || fallback;
    };
    return {
      handleApiError,
      handleValidationError,
      showSuccess,
      showInfo,
      getErrorMessage,
      errorMessages: defaultErrorMessages
    };
  }
  function useWordPressApi(config = {}) {
    const {
      restRoot = "",
      restNonce = "",
      timeout = 6e4
    } = config;
    const { handleApiError } = useErrorHandler();
    const loading = ref(false);
    const error = ref(null);
    const validateConfig = () => {
      if (!restRoot || !restNonce) {
        const errorMsg = "WordPress API configuration missing. Please refresh the page.";
        error.value = errorMsg;
        console.error("[WordPress API] Missing configuration:", { restRoot, restNonce });
        return false;
      }
      return true;
    };
    const createAxiosInstance = () => {
      return axios.create({
        baseURL: restRoot,
        headers: {
          "X-WP-Nonce": restNonce,
          "Content-Type": "application/json"
        },
        timeout
      });
    };
    const axiosInstance = validateConfig() ? createAxiosInstance() : null;
    const post = (_0, ..._1) => __async(null, [_0, ..._1], function* (endpoint, data = {}, context = "") {
      var _a2;
      if (!validateConfig() || !axiosInstance) {
        return {
          success: false,
          data: null,
          error: "Invalid API configuration"
        };
      }
      loading.value = true;
      error.value = null;
      try {
        const response = yield axiosInstance.post(endpoint, data);
        if (((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.result) !== false) {
          return {
            success: true,
            data: response.data,
            error: null
          };
        } else {
          const errorMsg = response.data.message || "Request failed";
          handleApiError(
            { message: errorMsg, response: { data: response.data } },
            context
          );
          return {
            success: false,
            data: null,
            error: errorMsg
          };
        }
      } catch (err) {
        const errorInfo = handleApiError(err, context);
        return {
          success: false,
          data: null,
          error: errorInfo.userMessage
        };
      } finally {
        loading.value = false;
      }
    });
    const get = (_0, ..._1) => __async(null, [_0, ..._1], function* (endpoint, params = {}, context = "") {
      var _a2;
      if (!validateConfig() || !axiosInstance) {
        return {
          success: false,
          data: null,
          error: "Invalid API configuration"
        };
      }
      loading.value = true;
      error.value = null;
      try {
        const response = yield axiosInstance.get(endpoint, { params });
        if (((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.result) !== false) {
          return {
            success: true,
            data: response.data,
            error: null
          };
        } else {
          const errorMsg = response.data.message || "Request failed";
          handleApiError(
            { message: errorMsg, response: { data: response.data } },
            context
          );
          return {
            success: false,
            data: null,
            error: errorMsg
          };
        }
      } catch (err) {
        const errorInfo = handleApiError(err, context);
        return {
          success: false,
          data: null,
          error: errorInfo.userMessage
        };
      } finally {
        loading.value = false;
      }
    });
    const put = (_0, ..._1) => __async(null, [_0, ..._1], function* (endpoint, data = {}, context = "") {
      var _a2;
      if (!validateConfig() || !axiosInstance) {
        return {
          success: false,
          data: null,
          error: "Invalid API configuration"
        };
      }
      loading.value = true;
      error.value = null;
      try {
        const response = yield axiosInstance.put(endpoint, data);
        if (((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.result) !== false) {
          return {
            success: true,
            data: response.data,
            error: null
          };
        } else {
          const errorMsg = response.data.message || "Request failed";
          handleApiError(
            { message: errorMsg, response: { data: response.data } },
            context
          );
          return {
            success: false,
            data: null,
            error: errorMsg
          };
        }
      } catch (err) {
        const errorInfo = handleApiError(err, context);
        return {
          success: false,
          data: null,
          error: errorInfo.userMessage
        };
      } finally {
        loading.value = false;
      }
    });
    const del = (endpoint, context = "") => __async(null, null, function* () {
      var _a2;
      if (!validateConfig() || !axiosInstance) {
        return {
          success: false,
          data: null,
          error: "Invalid API configuration"
        };
      }
      loading.value = true;
      error.value = null;
      try {
        const response = yield axiosInstance.delete(endpoint);
        if (((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.result) !== false) {
          return {
            success: true,
            data: response.data,
            error: null
          };
        } else {
          const errorMsg = response.data.message || "Request failed";
          handleApiError(
            { message: errorMsg, response: { data: response.data } },
            context
          );
          return {
            success: false,
            data: null,
            error: errorMsg
          };
        }
      } catch (err) {
        const errorInfo = handleApiError(err, context);
        return {
          success: false,
          data: null,
          error: errorInfo.userMessage
        };
      } finally {
        loading.value = false;
      }
    });
    const isLoading = computed(() => loading.value);
    const hasError = computed(() => !!error.value);
    const clearError = () => {
      error.value = null;
    };
    return {
      // State
      loading: isLoading,
      error,
      hasError,
      // Methods
      post,
      get,
      put,
      delete: del,
      validateConfig,
      clearError
    };
  }
  class CoreFeature {
    constructor(table) {
      this.table = table;
    }
    //////////////////////////////////////////
    /////////////// DataLoad /////////////////
    //////////////////////////////////////////
    reloadData(data, silent, columnsChanged) {
      return this.table.dataLoader.load(data, void 0, void 0, void 0, silent, columnsChanged);
    }
    //////////////////////////////////////////
    ///////////// Localization ///////////////
    //////////////////////////////////////////
    langText() {
      return this.table.modules.localize.getText(...arguments);
    }
    langBind() {
      return this.table.modules.localize.bind(...arguments);
    }
    langLocale() {
      return this.table.modules.localize.getLocale(...arguments);
    }
    //////////////////////////////////////////
    ////////// Inter Table Comms /////////////
    //////////////////////////////////////////
    commsConnections() {
      return this.table.modules.comms.getConnections(...arguments);
    }
    commsSend() {
      return this.table.modules.comms.send(...arguments);
    }
    //////////////////////////////////////////
    //////////////// Layout  /////////////////
    //////////////////////////////////////////
    layoutMode() {
      return this.table.modules.layout.getMode();
    }
    layoutRefresh(force) {
      return this.table.modules.layout.layout(force);
    }
    //////////////////////////////////////////
    /////////////// Event Bus ////////////////
    //////////////////////////////////////////
    subscribe() {
      return this.table.eventBus.subscribe(...arguments);
    }
    unsubscribe() {
      return this.table.eventBus.unsubscribe(...arguments);
    }
    subscribed(key) {
      return this.table.eventBus.subscribed(key);
    }
    subscriptionChange() {
      return this.table.eventBus.subscriptionChange(...arguments);
    }
    dispatch() {
      return this.table.eventBus.dispatch(...arguments);
    }
    chain() {
      return this.table.eventBus.chain(...arguments);
    }
    confirm() {
      return this.table.eventBus.confirm(...arguments);
    }
    dispatchExternal() {
      return this.table.externalEvents.dispatch(...arguments);
    }
    subscribedExternal(key) {
      return this.table.externalEvents.subscribed(key);
    }
    subscriptionChangeExternal() {
      return this.table.externalEvents.subscriptionChange(...arguments);
    }
    //////////////////////////////////////////
    //////////////// Options /////////////////
    //////////////////////////////////////////
    options(key) {
      return this.table.options[key];
    }
    setOption(key, value) {
      if (typeof value !== "undefined") {
        this.table.options[key] = value;
      }
      return this.table.options[key];
    }
    //////////////////////////////////////////
    /////////// Deprecation Checks ///////////
    //////////////////////////////////////////
    deprecationCheck(oldOption, newOption, convert) {
      return this.table.deprecationAdvisor.check(oldOption, newOption, convert);
    }
    deprecationCheckMsg(oldOption, msg) {
      return this.table.deprecationAdvisor.checkMsg(oldOption, msg);
    }
    deprecationMsg(msg) {
      return this.table.deprecationAdvisor.msg(msg);
    }
    //////////////////////////////////////////
    //////////////// Modules /////////////////
    //////////////////////////////////////////
    module(key) {
      return this.table.module(key);
    }
  }
  class Helpers {
    static elVisible(el) {
      return !(el.offsetWidth <= 0 && el.offsetHeight <= 0);
    }
    static elOffset(el) {
      var box = el.getBoundingClientRect();
      return {
        top: box.top + window.pageYOffset - document.documentElement.clientTop,
        left: box.left + window.pageXOffset - document.documentElement.clientLeft
      };
    }
    static retrieveNestedData(separator, field, data) {
      var structure = separator ? field.split(separator) : [field], length = structure.length, output;
      for (let i2 = 0; i2 < length; i2++) {
        data = data[structure[i2]];
        output = data;
        if (!data) {
          break;
        }
      }
      return output;
    }
    static deepClone(obj, clone, list2 = []) {
      var objectProto2 = {}.__proto__, arrayProto2 = [].__proto__;
      if (!clone) {
        clone = Object.assign(Array.isArray(obj) ? [] : {}, obj);
      }
      for (var i2 in obj) {
        let subject = obj[i2], match, copy;
        if (subject != null && typeof subject === "object" && (subject.__proto__ === objectProto2 || subject.__proto__ === arrayProto2)) {
          match = list2.findIndex((item) => {
            return item.subject === subject;
          });
          if (match > -1) {
            clone[i2] = list2[match].copy;
          } else {
            copy = Object.assign(Array.isArray(subject) ? [] : {}, subject);
            list2.unshift({ subject, copy });
            clone[i2] = this.deepClone(subject, copy, list2);
          }
        }
      }
      return clone;
    }
  }
  let Popup$1 = class Popup2 extends CoreFeature {
    constructor(table, element, parent) {
      super(table);
      this.element = element;
      this.container = this._lookupContainer();
      this.parent = parent;
      this.reversedX = false;
      this.childPopup = null;
      this.blurable = false;
      this.blurCallback = null;
      this.blurEventsBound = false;
      this.renderedCallback = null;
      this.visible = false;
      this.hideable = true;
      this.element.classList.add("tabulator-popup-container");
      this.blurEvent = this.hide.bind(this, false);
      this.escEvent = this._escapeCheck.bind(this);
      this.destroyBinding = this.tableDestroyed.bind(this);
      this.destroyed = false;
    }
    tableDestroyed() {
      this.destroyed = true;
      this.hide(true);
    }
    _lookupContainer() {
      var container = this.table.options.popupContainer;
      if (typeof container === "string") {
        container = document.querySelector(container);
        if (!container) {
          console.warn("Menu Error - no container element found matching selector:", this.table.options.popupContainer, "(defaulting to document body)");
        }
      } else if (container === true) {
        container = this.table.element;
      }
      if (container && !this._checkContainerIsParent(container)) {
        container = false;
        console.warn("Menu Error - container element does not contain this table:", this.table.options.popupContainer, "(defaulting to document body)");
      }
      if (!container) {
        container = document.body;
      }
      return container;
    }
    _checkContainerIsParent(container, element = this.table.element) {
      if (container === element) {
        return true;
      } else {
        return element.parentNode ? this._checkContainerIsParent(container, element.parentNode) : false;
      }
    }
    renderCallback(callback) {
      this.renderedCallback = callback;
    }
    containerEventCoords(e) {
      var touch = !(e instanceof MouseEvent);
      var x2 = touch ? e.touches[0].pageX : e.pageX;
      var y2 = touch ? e.touches[0].pageY : e.pageY;
      if (this.container !== document.body) {
        let parentOffset = Helpers.elOffset(this.container);
        x2 -= parentOffset.left;
        y2 -= parentOffset.top;
      }
      return { x: x2, y: y2 };
    }
    elementPositionCoords(element, position = "right") {
      var offset2 = Helpers.elOffset(element), containerOffset, x2, y2;
      if (this.container !== document.body) {
        containerOffset = Helpers.elOffset(this.container);
        offset2.left -= containerOffset.left;
        offset2.top -= containerOffset.top;
      }
      switch (position) {
        case "right":
          x2 = offset2.left + element.offsetWidth;
          y2 = offset2.top - 1;
          break;
        case "bottom":
          x2 = offset2.left;
          y2 = offset2.top + element.offsetHeight;
          break;
        case "left":
          x2 = offset2.left;
          y2 = offset2.top - 1;
          break;
        case "top":
          x2 = offset2.left;
          y2 = offset2.top;
          break;
        case "center":
          x2 = offset2.left + element.offsetWidth / 2;
          y2 = offset2.top + element.offsetHeight / 2;
          break;
      }
      return { x: x2, y: y2, offset: offset2 };
    }
    show(origin2, position) {
      var x2, y2, parentEl, parentOffset, coords;
      if (this.destroyed || this.table.destroyed) {
        return this;
      }
      if (origin2 instanceof HTMLElement) {
        parentEl = origin2;
        coords = this.elementPositionCoords(origin2, position);
        parentOffset = coords.offset;
        x2 = coords.x;
        y2 = coords.y;
      } else if (typeof origin2 === "number") {
        parentOffset = { top: 0, left: 0 };
        x2 = origin2;
        y2 = position;
      } else {
        coords = this.containerEventCoords(origin2);
        x2 = coords.x;
        y2 = coords.y;
        this.reversedX = false;
      }
      this.element.style.top = y2 + "px";
      this.element.style.left = x2 + "px";
      this.container.appendChild(this.element);
      if (typeof this.renderedCallback === "function") {
        this.renderedCallback();
      }
      this._fitToScreen(x2, y2, parentEl, parentOffset, position);
      this.visible = true;
      this.subscribe("table-destroy", this.destroyBinding);
      this.element.addEventListener("mousedown", (e) => {
        e.stopPropagation();
      });
      return this;
    }
    _fitToScreen(x2, y2, parentEl, parentOffset, position) {
      var scrollTop = this.container === document.body ? document.documentElement.scrollTop : this.container.scrollTop;
      if (x2 + this.element.offsetWidth >= this.container.offsetWidth || this.reversedX) {
        this.element.style.left = "";
        if (parentEl) {
          this.element.style.right = this.container.offsetWidth - parentOffset.left + "px";
        } else {
          this.element.style.right = this.container.offsetWidth - x2 + "px";
        }
        this.reversedX = true;
      }
      let offsetHeight = Math.max(this.container.offsetHeight, scrollTop ? this.container.scrollHeight : 0);
      if (y2 + this.element.offsetHeight > offsetHeight) {
        if (parentEl) {
          switch (position) {
            case "bottom":
              this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight - parentEl.offsetHeight - 1 + "px";
              break;
            default:
              this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + parentEl.offsetHeight + 1 + "px";
          }
        } else {
          this.element.style.height = offsetHeight + "px";
        }
      }
    }
    isVisible() {
      return this.visible;
    }
    hideOnBlur(callback) {
      this.blurable = true;
      if (this.visible) {
        setTimeout(() => {
          if (this.visible) {
            this.table.rowManager.element.addEventListener("scroll", this.blurEvent);
            this.subscribe("cell-editing", this.blurEvent);
            document.body.addEventListener("click", this.blurEvent);
            document.body.addEventListener("contextmenu", this.blurEvent);
            document.body.addEventListener("mousedown", this.blurEvent);
            window.addEventListener("resize", this.blurEvent);
            document.body.addEventListener("keydown", this.escEvent);
            this.blurEventsBound = true;
          }
        }, 100);
        this.blurCallback = callback;
      }
      return this;
    }
    _escapeCheck(e) {
      if (e.keyCode == 27) {
        this.hide();
      }
    }
    blockHide() {
      this.hideable = false;
    }
    restoreHide() {
      this.hideable = true;
    }
    hide(silent = false) {
      if (this.visible && this.hideable) {
        if (this.blurable && this.blurEventsBound) {
          document.body.removeEventListener("keydown", this.escEvent);
          document.body.removeEventListener("click", this.blurEvent);
          document.body.removeEventListener("contextmenu", this.blurEvent);
          document.body.removeEventListener("mousedown", this.blurEvent);
          window.removeEventListener("resize", this.blurEvent);
          this.table.rowManager.element.removeEventListener("scroll", this.blurEvent);
          this.unsubscribe("cell-editing", this.blurEvent);
          this.blurEventsBound = false;
        }
        if (this.childPopup) {
          this.childPopup.hide();
        }
        if (this.parent) {
          this.parent.childPopup = null;
        }
        if (this.element.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
        this.visible = false;
        if (this.blurCallback && !silent) {
          this.blurCallback();
        }
        this.unsubscribe("table-destroy", this.destroyBinding);
      }
      return this;
    }
    child(element) {
      if (this.childPopup) {
        this.childPopup.hide();
      }
      this.childPopup = new Popup2(this.table, element, this);
      return this.childPopup;
    }
  };
  class Module extends CoreFeature {
    constructor(table, name) {
      super(table);
      this._handler = null;
    }
    initialize() {
    }
    ///////////////////////////////////
    ////// Options Registration ///////
    ///////////////////////////////////
    registerTableOption(key, value) {
      this.table.optionsList.register(key, value);
    }
    registerColumnOption(key, value) {
      this.table.columnManager.optionsList.register(key, value);
    }
    ///////////////////////////////////
    /// Public Function Registration ///
    ///////////////////////////////////
    registerTableFunction(name, func) {
      if (typeof this.table[name] === "undefined") {
        this.table[name] = (...args) => {
          this.table.initGuard(name);
          return func(...args);
        };
      } else {
        console.warn("Unable to bind table function, name already in use", name);
      }
    }
    registerComponentFunction(component, func, handler) {
      return this.table.componentFunctionBinder.bind(component, func, handler);
    }
    ///////////////////////////////////
    ////////// Data Pipeline //////////
    ///////////////////////////////////
    registerDataHandler(handler, priority) {
      this.table.rowManager.registerDataPipelineHandler(handler, priority);
      this._handler = handler;
    }
    registerDisplayHandler(handler, priority) {
      this.table.rowManager.registerDisplayPipelineHandler(handler, priority);
      this._handler = handler;
    }
    displayRows(adjust) {
      var index2 = this.table.rowManager.displayRows.length - 1, lookupIndex;
      if (this._handler) {
        lookupIndex = this.table.rowManager.displayPipeline.findIndex((item) => {
          return item.handler === this._handler;
        });
        if (lookupIndex > -1) {
          index2 = lookupIndex;
        }
      }
      if (adjust) {
        index2 = index2 + adjust;
      }
      if (this._handler) {
        if (index2 > -1) {
          return this.table.rowManager.getDisplayRows(index2);
        } else {
          return this.activeRows();
        }
      }
    }
    activeRows() {
      return this.table.rowManager.activeRows;
    }
    refreshData(renderInPosition, handler) {
      if (!handler) {
        handler = this._handler;
      }
      if (handler) {
        this.table.rowManager.refreshActiveData(handler, false, renderInPosition);
      }
    }
    ///////////////////////////////////
    //////// Footer Management ////////
    ///////////////////////////////////
    footerAppend(element) {
      return this.table.footerManager.append(element);
    }
    footerPrepend(element) {
      return this.table.footerManager.prepend(element);
    }
    footerRemove(element) {
      return this.table.footerManager.remove(element);
    }
    ///////////////////////////////////
    //////// Popups Management ////////
    ///////////////////////////////////
    popup(menuEl, menuContainer) {
      return new Popup$1(this.table, menuEl, menuContainer);
    }
    ///////////////////////////////////
    //////// Alert Management ////////
    ///////////////////////////////////
    alert(content, type) {
      return this.table.alertManager.alert(content, type);
    }
    clearAlert() {
      return this.table.alertManager.clear();
    }
  }
  function generateParamsList$1(data, prefix) {
    var output = [];
    prefix = prefix || "";
    if (Array.isArray(data)) {
      data.forEach((item, i2) => {
        output = output.concat(generateParamsList$1(item, prefix ? prefix + "[" + i2 + "]" : i2));
      });
    } else if (typeof data === "object") {
      for (var key in data) {
        output = output.concat(generateParamsList$1(data[key], prefix ? prefix + "[" + key + "]" : key));
      }
    } else {
      output.push({ key: prefix, value: data });
    }
    return output;
  }
  function serializeParams(params) {
    var output = generateParamsList$1(params), encoded = [];
    output.forEach(function(item) {
      encoded.push(encodeURIComponent(item.key) + "=" + encodeURIComponent(item.value));
    });
    return encoded.join("&");
  }
  function urlBuilder(url, config, params) {
    if (url) {
      if (params && Object.keys(params).length) {
        if (!config.method || config.method.toLowerCase() == "get") {
          config.method = "get";
          url += (url.includes("?") ? "&" : "?") + serializeParams(params);
        }
      }
    }
    return url;
  }
  var defaultPasteActions = {
    replace: function(data) {
      return this.table.setData(data);
    },
    update: function(data) {
      return this.table.updateOrAddData(data);
    },
    insert: function(data) {
      return this.table.addData(data);
    }
  };
  var defaultPasteParsers = {
    table: function(clipboard) {
      var data = [], headerFindSuccess = true, columns = this.table.columnManager.columns, columnMap = [], rows = [];
      clipboard = clipboard.split("\n");
      clipboard.forEach(function(row) {
        data.push(row.split("	"));
      });
      if (data.length && !(data.length === 1 && data[0].length < 2)) {
        data[0].forEach(function(value) {
          var column = columns.find(function(column2) {
            return value && column2.definition.title && value.trim() && column2.definition.title.trim() === value.trim();
          });
          if (column) {
            columnMap.push(column);
          } else {
            headerFindSuccess = false;
          }
        });
        if (!headerFindSuccess) {
          headerFindSuccess = true;
          columnMap = [];
          data[0].forEach(function(value) {
            var column = columns.find(function(column2) {
              return value && column2.field && value.trim() && column2.field.trim() === value.trim();
            });
            if (column) {
              columnMap.push(column);
            } else {
              headerFindSuccess = false;
            }
          });
          if (!headerFindSuccess) {
            columnMap = this.table.columnManager.columnsByIndex;
          }
        }
        if (headerFindSuccess) {
          data.shift();
        }
        data.forEach(function(item) {
          var row = {};
          item.forEach(function(value, i2) {
            if (columnMap[i2]) {
              row[columnMap[i2].field] = value;
            }
          });
          rows.push(row);
        });
        return rows;
      } else {
        return false;
      }
    }
  };
  var bindings$2 = {
    copyToClipboard: ["ctrl + 67", "meta + 67"]
  };
  var actions$2 = {
    copyToClipboard: function(e) {
      if (!this.table.modules.edit.currentCell) {
        if (this.table.modExists("clipboard", true)) {
          this.table.modules.clipboard.copy(false, true);
        }
      }
    }
  };
  var extensions$4 = {
    keybindings: {
      bindings: bindings$2,
      actions: actions$2
    }
  };
  const _Clipboard = class _Clipboard extends Module {
    constructor(table) {
      super(table);
      this.mode = true;
      this.pasteParser = function() {
      };
      this.pasteAction = function() {
      };
      this.customSelection = false;
      this.rowRange = false;
      this.blocked = true;
      this.registerTableOption("clipboard", false);
      this.registerTableOption("clipboardCopyStyled", true);
      this.registerTableOption("clipboardCopyConfig", false);
      this.registerTableOption("clipboardCopyFormatter", false);
      this.registerTableOption("clipboardCopyRowRange", "active");
      this.registerTableOption("clipboardPasteParser", "table");
      this.registerTableOption("clipboardPasteAction", "insert");
      this.registerColumnOption("clipboard");
      this.registerColumnOption("titleClipboard");
    }
    initialize() {
      this.mode = this.table.options.clipboard;
      this.rowRange = this.table.options.clipboardCopyRowRange;
      if (this.mode === true || this.mode === "copy") {
        this.table.element.addEventListener("copy", (e) => {
          var plain, html2, list2;
          if (!this.blocked) {
            e.preventDefault();
            if (this.customSelection) {
              plain = this.customSelection;
              if (this.table.options.clipboardCopyFormatter) {
                plain = this.table.options.clipboardCopyFormatter("plain", plain);
              }
            } else {
              list2 = this.table.modules.export.generateExportList(this.table.options.clipboardCopyConfig, this.table.options.clipboardCopyStyled, this.rowRange, "clipboard");
              html2 = this.table.modules.export.generateHTMLTable(list2);
              plain = html2 ? this.generatePlainContent(list2) : "";
              if (this.table.options.clipboardCopyFormatter) {
                plain = this.table.options.clipboardCopyFormatter("plain", plain);
                html2 = this.table.options.clipboardCopyFormatter("html", html2);
              }
            }
            if (window.clipboardData && window.clipboardData.setData) {
              window.clipboardData.setData("Text", plain);
            } else if (e.clipboardData && e.clipboardData.setData) {
              e.clipboardData.setData("text/plain", plain);
              if (html2) {
                e.clipboardData.setData("text/html", html2);
              }
            } else if (e.originalEvent && e.originalEvent.clipboardData.setData) {
              e.originalEvent.clipboardData.setData("text/plain", plain);
              if (html2) {
                e.originalEvent.clipboardData.setData("text/html", html2);
              }
            }
            this.dispatchExternal("clipboardCopied", plain, html2);
            this.reset();
          }
        });
      }
      if (this.mode === true || this.mode === "paste") {
        this.table.element.addEventListener("paste", (e) => {
          this.paste(e);
        });
      }
      this.setPasteParser(this.table.options.clipboardPasteParser);
      this.setPasteAction(this.table.options.clipboardPasteAction);
      this.registerTableFunction("copyToClipboard", this.copy.bind(this));
    }
    reset() {
      this.blocked = true;
      this.customSelection = false;
    }
    generatePlainContent(list2) {
      var output = [];
      list2.forEach((row) => {
        var rowData = [];
        row.columns.forEach((col) => {
          var value = "";
          if (col) {
            if (row.type === "group") {
              col.value = col.component.getKey();
            }
            if (col.value === null) {
              value = "";
            } else {
              switch (typeof col.value) {
                case "object":
                  value = JSON.stringify(col.value);
                  break;
                case "undefined":
                  value = "";
                  break;
                default:
                  value = col.value;
              }
            }
          }
          rowData.push(value);
        });
        output.push(rowData.join("	"));
      });
      return output.join("\n");
    }
    copy(range2, internal) {
      var sel, textRange;
      this.blocked = false;
      this.customSelection = false;
      if (this.mode === true || this.mode === "copy") {
        this.rowRange = range2 || this.table.options.clipboardCopyRowRange;
        if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
          range2 = document.createRange();
          range2.selectNodeContents(this.table.element);
          sel = window.getSelection();
          if (sel.toString() && internal) {
            this.customSelection = sel.toString();
          }
          sel.removeAllRanges();
          sel.addRange(range2);
        } else if (typeof document.selection != "undefined" && typeof document.body.createTextRange != "undefined") {
          textRange = document.body.createTextRange();
          textRange.moveToElementText(this.table.element);
          textRange.select();
        }
        document.execCommand("copy");
        if (sel) {
          sel.removeAllRanges();
        }
      }
    }
    //PASTE EVENT HANDLING
    setPasteAction(action) {
      switch (typeof action) {
        case "string":
          this.pasteAction = _Clipboard.pasteActions[action];
          if (!this.pasteAction) {
            console.warn("Clipboard Error - No such paste action found:", action);
          }
          break;
        case "function":
          this.pasteAction = action;
          break;
      }
    }
    setPasteParser(parser) {
      switch (typeof parser) {
        case "string":
          this.pasteParser = _Clipboard.pasteParsers[parser];
          if (!this.pasteParser) {
            console.warn("Clipboard Error - No such paste parser found:", parser);
          }
          break;
        case "function":
          this.pasteParser = parser;
          break;
      }
    }
    paste(e) {
      var data, rowData, rows;
      if (this.checkPasteOrigin(e)) {
        data = this.getPasteData(e);
        rowData = this.pasteParser.call(this, data);
        if (rowData) {
          e.preventDefault();
          if (this.table.modExists("mutator")) {
            rowData = this.mutateData(rowData);
          }
          rows = this.pasteAction.call(this, rowData);
          this.dispatchExternal("clipboardPasted", data, rowData, rows);
        } else {
          this.dispatchExternal("clipboardPasteError", data);
        }
      }
    }
    mutateData(data) {
      var output = [];
      if (Array.isArray(data)) {
        data.forEach((row) => {
          output.push(this.table.modules.mutator.transformRow(row, "clipboard"));
        });
      } else {
        output = data;
      }
      return output;
    }
    checkPasteOrigin(e) {
      var valid = true;
      var blocked = this.confirm("clipboard-paste", [e]);
      if (blocked || !["DIV", "SPAN"].includes(e.target.tagName)) {
        valid = false;
      }
      return valid;
    }
    getPasteData(e) {
      var data;
      if (window.clipboardData && window.clipboardData.getData) {
        data = window.clipboardData.getData("Text");
      } else if (e.clipboardData && e.clipboardData.getData) {
        data = e.clipboardData.getData("text/plain");
      } else if (e.originalEvent && e.originalEvent.clipboardData.getData) {
        data = e.originalEvent.clipboardData.getData("text/plain");
      }
      return data;
    }
  };
  __publicField(_Clipboard, "moduleName", "clipboard");
  __publicField(_Clipboard, "moduleExtensions", extensions$4);
  //load defaults
  __publicField(_Clipboard, "pasteActions", defaultPasteActions);
  __publicField(_Clipboard, "pasteParsers", defaultPasteParsers);
  let Clipboard = _Clipboard;
  class CellComponent {
    constructor(cell) {
      this._cell = cell;
      return new Proxy(this, {
        get: function(target, name, receiver) {
          if (typeof target[name] !== "undefined") {
            return target[name];
          } else {
            return target._cell.table.componentFunctionBinder.handle("cell", target._cell, name);
          }
        }
      });
    }
    getValue() {
      return this._cell.getValue();
    }
    getOldValue() {
      return this._cell.getOldValue();
    }
    getInitialValue() {
      return this._cell.initialValue;
    }
    getElement() {
      return this._cell.getElement();
    }
    getRow() {
      return this._cell.row.getComponent();
    }
    getData(transform) {
      return this._cell.row.getData(transform);
    }
    getType() {
      return "cell";
    }
    getField() {
      return this._cell.column.getField();
    }
    getColumn() {
      return this._cell.column.getComponent();
    }
    setValue(value, mutate) {
      if (typeof mutate == "undefined") {
        mutate = true;
      }
      this._cell.setValue(value, mutate);
    }
    restoreOldValue() {
      this._cell.setValueActual(this._cell.getOldValue());
    }
    restoreInitialValue() {
      this._cell.setValueActual(this._cell.initialValue);
    }
    checkHeight() {
      this._cell.checkHeight();
    }
    getTable() {
      return this._cell.table;
    }
    _getSelf() {
      return this._cell;
    }
  }
  class Cell extends CoreFeature {
    constructor(column, row) {
      super(column.table);
      this.table = column.table;
      this.column = column;
      this.row = row;
      this.element = null;
      this.value = null;
      this.initialValue;
      this.oldValue = null;
      this.modules = {};
      this.height = null;
      this.width = null;
      this.minWidth = null;
      this.component = null;
      this.loaded = false;
      this.build();
    }
    //////////////// Setup Functions /////////////////
    //generate element
    build() {
      this.generateElement();
      this.setWidth();
      this._configureCell();
      this.setValueActual(this.column.getFieldValue(this.row.data));
      this.initialValue = this.value;
    }
    generateElement() {
      this.element = document.createElement("div");
      this.element.className = "tabulator-cell";
      this.element.setAttribute("role", "gridcell");
      if (this.column.isRowHeader) {
        this.element.classList.add("tabulator-row-header");
      }
    }
    _configureCell() {
      var element = this.element, field = this.column.getField(), vertAligns = {
        top: "flex-start",
        bottom: "flex-end",
        middle: "center"
      }, hozAligns = {
        left: "flex-start",
        right: "flex-end",
        center: "center"
      };
      element.style.textAlign = this.column.hozAlign;
      if (this.column.vertAlign) {
        element.style.display = "inline-flex";
        element.style.alignItems = vertAligns[this.column.vertAlign] || "";
        if (this.column.hozAlign) {
          element.style.justifyContent = hozAligns[this.column.hozAlign] || "";
        }
      }
      if (field) {
        element.setAttribute("tabulator-field", field);
      }
      if (this.column.definition.cssClass) {
        var classNames = this.column.definition.cssClass.split(" ");
        classNames.forEach((className) => {
          element.classList.add(className);
        });
      }
      this.dispatch("cell-init", this);
      if (!this.column.visible) {
        this.hide();
      }
    }
    //generate cell contents
    _generateContents() {
      var val;
      val = this.chain("cell-format", this, null, () => {
        return this.element.innerHTML = this.value;
      });
      switch (typeof val) {
        case "object":
          if (val instanceof Node) {
            while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
            this.element.appendChild(val);
          } else {
            this.element.innerHTML = "";
            if (val != null) {
              console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", val);
            }
          }
          break;
        case "undefined":
          this.element.innerHTML = "";
          break;
        default:
          this.element.innerHTML = val;
      }
    }
    cellRendered() {
      this.dispatch("cell-rendered", this);
    }
    //////////////////// Getters ////////////////////
    getElement(containerOnly) {
      if (!this.loaded) {
        this.loaded = true;
        if (!containerOnly) {
          this.layoutElement();
        }
      }
      return this.element;
    }
    getValue() {
      return this.value;
    }
    getOldValue() {
      return this.oldValue;
    }
    //////////////////// Actions ////////////////////
    setValue(value, mutate, force) {
      var changed = this.setValueProcessData(value, mutate, force);
      if (changed) {
        this.dispatch("cell-value-updated", this);
        this.cellRendered();
        if (this.column.definition.cellEdited) {
          this.column.definition.cellEdited.call(this.table, this.getComponent());
        }
        this.dispatchExternal("cellEdited", this.getComponent());
        if (this.subscribedExternal("dataChanged")) {
          this.dispatchExternal("dataChanged", this.table.rowManager.getData());
        }
      }
    }
    setValueProcessData(value, mutate, force) {
      var changed = false;
      if (this.value !== value || force) {
        changed = true;
        if (mutate) {
          value = this.chain("cell-value-changing", [this, value], null, value);
        }
      }
      this.setValueActual(value);
      if (changed) {
        this.dispatch("cell-value-changed", this);
      }
      return changed;
    }
    setValueActual(value) {
      this.oldValue = this.value;
      this.value = value;
      this.dispatch("cell-value-save-before", this);
      this.column.setFieldValue(this.row.data, value);
      this.dispatch("cell-value-save-after", this);
      if (this.loaded) {
        this.layoutElement();
      }
    }
    layoutElement() {
      this._generateContents();
      this.dispatch("cell-layout", this);
    }
    setWidth() {
      this.width = this.column.width;
      this.element.style.width = this.column.widthStyled;
    }
    clearWidth() {
      this.width = "";
      this.element.style.width = "";
    }
    getWidth() {
      return this.width || this.element.offsetWidth;
    }
    setMinWidth() {
      this.minWidth = this.column.minWidth;
      this.element.style.minWidth = this.column.minWidthStyled;
    }
    setMaxWidth() {
      this.maxWidth = this.column.maxWidth;
      this.element.style.maxWidth = this.column.maxWidthStyled;
    }
    checkHeight() {
      this.row.reinitializeHeight();
    }
    clearHeight() {
      this.element.style.height = "";
      this.height = null;
      this.dispatch("cell-height", this, "");
    }
    setHeight() {
      this.height = this.row.height;
      this.element.style.height = this.row.heightStyled;
      this.dispatch("cell-height", this, this.row.heightStyled);
    }
    getHeight() {
      return this.height || this.element.offsetHeight;
    }
    show() {
      this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
    }
    hide() {
      this.element.style.display = "none";
    }
    delete() {
      this.dispatch("cell-delete", this);
      if (!this.table.rowManager.redrawBlock && this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
      this.element = false;
      this.column.deleteCell(this);
      this.row.deleteCell(this);
      this.calcs = {};
    }
    getIndex() {
      return this.row.getCellIndex(this);
    }
    //////////////// Object Generation /////////////////
    getComponent() {
      if (!this.component) {
        this.component = new CellComponent(this);
      }
      return this.component;
    }
  }
  class ColumnComponent {
    constructor(column) {
      this._column = column;
      this.type = "ColumnComponent";
      return new Proxy(this, {
        get: function(target, name, receiver) {
          if (typeof target[name] !== "undefined") {
            return target[name];
          } else {
            return target._column.table.componentFunctionBinder.handle("column", target._column, name);
          }
        }
      });
    }
    getElement() {
      return this._column.getElement();
    }
    getDefinition() {
      return this._column.getDefinition();
    }
    getField() {
      return this._column.getField();
    }
    getTitleDownload() {
      return this._column.getTitleDownload();
    }
    getCells() {
      var cells = [];
      this._column.cells.forEach(function(cell) {
        cells.push(cell.getComponent());
      });
      return cells;
    }
    isVisible() {
      return this._column.visible;
    }
    show() {
      if (this._column.isGroup) {
        this._column.columns.forEach(function(column) {
          column.show();
        });
      } else {
        this._column.show();
      }
    }
    hide() {
      if (this._column.isGroup) {
        this._column.columns.forEach(function(column) {
          column.hide();
        });
      } else {
        this._column.hide();
      }
    }
    toggle() {
      if (this._column.visible) {
        this.hide();
      } else {
        this.show();
      }
    }
    delete() {
      return this._column.delete();
    }
    getSubColumns() {
      var output = [];
      if (this._column.columns.length) {
        this._column.columns.forEach(function(column) {
          output.push(column.getComponent());
        });
      }
      return output;
    }
    getParentColumn() {
      return this._column.getParentComponent();
    }
    _getSelf() {
      return this._column;
    }
    scrollTo(position, ifVisible) {
      return this._column.table.columnManager.scrollToColumn(this._column, position, ifVisible);
    }
    getTable() {
      return this._column.table;
    }
    move(to2, after) {
      var toColumn = this._column.table.columnManager.findColumn(to2);
      if (toColumn) {
        this._column.table.columnManager.moveColumn(this._column, toColumn, after);
      } else {
        console.warn("Move Error - No matching column found:", toColumn);
      }
    }
    getNextColumn() {
      var nextCol = this._column.nextColumn();
      return nextCol ? nextCol.getComponent() : false;
    }
    getPrevColumn() {
      var prevCol = this._column.prevColumn();
      return prevCol ? prevCol.getComponent() : false;
    }
    updateDefinition(updates) {
      return this._column.updateDefinition(updates);
    }
    getWidth() {
      return this._column.getWidth();
    }
    setWidth(width) {
      var result;
      if (width === true) {
        result = this._column.reinitializeWidth(true);
      } else {
        result = this._column.setWidth(width);
      }
      this._column.table.columnManager.rerenderColumns(true);
      return result;
    }
  }
  var defaultColumnOptions = {
    "title": void 0,
    "field": void 0,
    "columns": void 0,
    "visible": void 0,
    "hozAlign": void 0,
    "vertAlign": void 0,
    "width": void 0,
    "minWidth": 40,
    "maxWidth": void 0,
    "maxInitialWidth": void 0,
    "cssClass": void 0,
    "variableHeight": void 0,
    "headerVertical": void 0,
    "headerHozAlign": void 0,
    "headerWordWrap": false,
    "editableTitle": void 0
  };
  const _Column = class _Column extends CoreFeature {
    constructor(def2, parent, rowHeader) {
      super(parent.table);
      this.definition = def2;
      this.parent = parent;
      this.type = "column";
      this.columns = [];
      this.cells = [];
      this.isGroup = false;
      this.isRowHeader = rowHeader;
      this.element = this.createElement();
      this.contentElement = false;
      this.titleHolderElement = false;
      this.titleElement = false;
      this.groupElement = this.createGroupElement();
      this.hozAlign = "";
      this.vertAlign = "";
      this.field = "";
      this.fieldStructure = "";
      this.getFieldValue = "";
      this.setFieldValue = "";
      this.titleDownload = null;
      this.titleFormatterRendered = false;
      this.mapDefinitions();
      this.setField(this.definition.field);
      this.modules = {};
      this.width = null;
      this.widthStyled = "";
      this.maxWidth = null;
      this.maxWidthStyled = "";
      this.maxInitialWidth = null;
      this.minWidth = null;
      this.minWidthStyled = "";
      this.widthFixed = false;
      this.visible = true;
      this.component = null;
      if (this.definition.columns) {
        this.isGroup = true;
        this.definition.columns.forEach((def3, i2) => {
          var newCol = new _Column(def3, this);
          this.attachColumn(newCol);
        });
        this.checkColumnVisibility();
      } else {
        parent.registerColumnField(this);
      }
      this._initialize();
    }
    createElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-col");
      el.setAttribute("role", "columnheader");
      el.setAttribute("aria-sort", "none");
      if (this.isRowHeader) {
        el.classList.add("tabulator-row-header");
      }
      switch (this.table.options.columnHeaderVertAlign) {
        case "middle":
          el.style.justifyContent = "center";
          break;
        case "bottom":
          el.style.justifyContent = "flex-end";
          break;
      }
      return el;
    }
    createGroupElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-col-group-cols");
      return el;
    }
    mapDefinitions() {
      var defaults2 = this.table.options.columnDefaults;
      if (defaults2) {
        for (let key in defaults2) {
          if (typeof this.definition[key] === "undefined") {
            this.definition[key] = defaults2[key];
          }
        }
      }
      this.definition = this.table.columnManager.optionsList.generate(_Column.defaultOptionList, this.definition);
    }
    checkDefinition() {
      Object.keys(this.definition).forEach((key) => {
        if (_Column.defaultOptionList.indexOf(key) === -1) {
          console.warn("Invalid column definition option in '" + (this.field || this.definition.title) + "' column:", key);
        }
      });
    }
    setField(field) {
      this.field = field;
      this.fieldStructure = field ? this.table.options.nestedFieldSeparator ? field.split(this.table.options.nestedFieldSeparator) : [field] : [];
      this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData;
      this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
    }
    //register column position with column manager
    registerColumnPosition(column) {
      this.parent.registerColumnPosition(column);
    }
    //register column position with column manager
    registerColumnField(column) {
      this.parent.registerColumnField(column);
    }
    //trigger position registration
    reRegisterPosition() {
      if (this.isGroup) {
        this.columns.forEach(function(column) {
          column.reRegisterPosition();
        });
      } else {
        this.registerColumnPosition(this);
      }
    }
    //build header element
    _initialize() {
      var def2 = this.definition;
      while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
      if (def2.headerVertical) {
        this.element.classList.add("tabulator-col-vertical");
        if (def2.headerVertical === "flip") {
          this.element.classList.add("tabulator-col-vertical-flip");
        }
      }
      this.contentElement = this._buildColumnHeaderContent();
      this.element.appendChild(this.contentElement);
      if (this.isGroup) {
        this._buildGroupHeader();
      } else {
        this._buildColumnHeader();
      }
      this.dispatch("column-init", this);
    }
    //build header element for header
    _buildColumnHeader() {
      var def2 = this.definition;
      this.dispatch("column-layout", this);
      if (typeof def2.visible != "undefined") {
        if (def2.visible) {
          this.show(true);
        } else {
          this.hide(true);
        }
      }
      if (def2.cssClass) {
        var classNames = def2.cssClass.split(" ");
        classNames.forEach((className) => {
          this.element.classList.add(className);
        });
      }
      if (def2.field) {
        this.element.setAttribute("tabulator-field", def2.field);
      }
      this.setMinWidth(parseInt(def2.minWidth));
      if (def2.maxInitialWidth) {
        this.maxInitialWidth = parseInt(def2.maxInitialWidth);
      }
      if (def2.maxWidth) {
        this.setMaxWidth(parseInt(def2.maxWidth));
      }
      this.reinitializeWidth();
      this.hozAlign = this.definition.hozAlign;
      this.vertAlign = this.definition.vertAlign;
      this.titleElement.style.textAlign = this.definition.headerHozAlign;
    }
    _buildColumnHeaderContent() {
      var contentElement = document.createElement("div");
      contentElement.classList.add("tabulator-col-content");
      this.titleHolderElement = document.createElement("div");
      this.titleHolderElement.classList.add("tabulator-col-title-holder");
      contentElement.appendChild(this.titleHolderElement);
      this.titleElement = this._buildColumnHeaderTitle();
      this.titleHolderElement.appendChild(this.titleElement);
      return contentElement;
    }
    //build title element of column
    _buildColumnHeaderTitle() {
      var def2 = this.definition;
      var titleHolderElement = document.createElement("div");
      titleHolderElement.classList.add("tabulator-col-title");
      if (def2.headerWordWrap) {
        titleHolderElement.classList.add("tabulator-col-title-wrap");
      }
      if (def2.editableTitle) {
        var titleElement = document.createElement("input");
        titleElement.classList.add("tabulator-title-editor");
        titleElement.addEventListener("click", (e) => {
          e.stopPropagation();
          titleElement.focus();
        });
        titleElement.addEventListener("mousedown", (e) => {
          e.stopPropagation();
        });
        titleElement.addEventListener("change", () => {
          def2.title = titleElement.value;
          this.dispatchExternal("columnTitleChanged", this.getComponent());
        });
        titleHolderElement.appendChild(titleElement);
        if (def2.field) {
          this.langBind("columns|" + def2.field, (text) => {
            titleElement.value = text || (def2.title || "&nbsp;");
          });
        } else {
          titleElement.value = def2.title || "&nbsp;";
        }
      } else {
        if (def2.field) {
          this.langBind("columns|" + def2.field, (text) => {
            this._formatColumnHeaderTitle(titleHolderElement, text || (def2.title || "&nbsp;"));
          });
        } else {
          this._formatColumnHeaderTitle(titleHolderElement, def2.title || "&nbsp;");
        }
      }
      return titleHolderElement;
    }
    _formatColumnHeaderTitle(el, title) {
      var contents = this.chain("column-format", [this, title, el], null, () => {
        return title;
      });
      switch (typeof contents) {
        case "object":
          if (contents instanceof Node) {
            el.appendChild(contents);
          } else {
            el.innerHTML = "";
            console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", contents);
          }
          break;
        case "undefined":
          el.innerHTML = "";
          break;
        default:
          el.innerHTML = contents;
      }
    }
    //build header element for column group
    _buildGroupHeader() {
      this.element.classList.add("tabulator-col-group");
      this.element.setAttribute("role", "columngroup");
      this.element.setAttribute("aria-title", this.definition.title);
      if (this.definition.cssClass) {
        var classNames = this.definition.cssClass.split(" ");
        classNames.forEach((className) => {
          this.element.classList.add(className);
        });
      }
      this.titleElement.style.textAlign = this.definition.headerHozAlign;
      this.element.appendChild(this.groupElement);
    }
    //flat field lookup
    _getFlatData(data) {
      return data[this.field];
    }
    //nested field lookup
    _getNestedData(data) {
      var dataObj = data, structure = this.fieldStructure, length = structure.length, output;
      for (let i2 = 0; i2 < length; i2++) {
        dataObj = dataObj[structure[i2]];
        output = dataObj;
        if (!dataObj) {
          break;
        }
      }
      return output;
    }
    //flat field set
    _setFlatData(data, value) {
      if (this.field) {
        data[this.field] = value;
      }
    }
    //nested field set
    _setNestedData(data, value) {
      var dataObj = data, structure = this.fieldStructure, length = structure.length;
      for (let i2 = 0; i2 < length; i2++) {
        if (i2 == length - 1) {
          dataObj[structure[i2]] = value;
        } else {
          if (!dataObj[structure[i2]]) {
            if (typeof value !== "undefined") {
              dataObj[structure[i2]] = {};
            } else {
              break;
            }
          }
          dataObj = dataObj[structure[i2]];
        }
      }
    }
    //attach column to this group
    attachColumn(column) {
      if (this.groupElement) {
        this.columns.push(column);
        this.groupElement.appendChild(column.getElement());
        column.columnRendered();
      } else {
        console.warn("Column Warning - Column being attached to another column instead of column group");
      }
    }
    //vertically align header in column
    verticalAlign(alignment, height) {
      var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : height || this.parent.getHeadersElement().clientHeight;
      this.element.style.height = parentHeight + "px";
      this.dispatch("column-height", this, this.element.style.height);
      if (this.isGroup) {
        this.groupElement.style.minHeight = parentHeight - this.contentElement.offsetHeight + "px";
      }
      this.columns.forEach(function(column) {
        column.verticalAlign(alignment);
      });
    }
    //clear vertical alignment
    clearVerticalAlign() {
      this.element.style.paddingTop = "";
      this.element.style.height = "";
      this.element.style.minHeight = "";
      this.groupElement.style.minHeight = "";
      this.columns.forEach(function(column) {
        column.clearVerticalAlign();
      });
      this.dispatch("column-height", this, "");
    }
    //// Retrieve Column Information ////
    //return column header element
    getElement() {
      return this.element;
    }
    //return column group element
    getGroupElement() {
      return this.groupElement;
    }
    //return field name
    getField() {
      return this.field;
    }
    getTitleDownload() {
      return this.titleDownload;
    }
    //return the first column in a group
    getFirstColumn() {
      if (!this.isGroup) {
        return this;
      } else {
        if (this.columns.length) {
          return this.columns[0].getFirstColumn();
        } else {
          return false;
        }
      }
    }
    //return the last column in a group
    getLastColumn() {
      if (!this.isGroup) {
        return this;
      } else {
        if (this.columns.length) {
          return this.columns[this.columns.length - 1].getLastColumn();
        } else {
          return false;
        }
      }
    }
    //return all columns in a group
    getColumns(traverse2) {
      var columns = [];
      if (traverse2) {
        this.columns.forEach((column) => {
          columns.push(column);
          columns = columns.concat(column.getColumns(true));
        });
      } else {
        columns = this.columns;
      }
      return columns;
    }
    //return all columns in a group
    getCells() {
      return this.cells;
    }
    //retrieve the top column in a group of columns
    getTopColumn() {
      if (this.parent.isGroup) {
        return this.parent.getTopColumn();
      } else {
        return this;
      }
    }
    //return column definition object
    getDefinition(updateBranches) {
      var colDefs = [];
      if (this.isGroup && updateBranches) {
        this.columns.forEach(function(column) {
          colDefs.push(column.getDefinition(true));
        });
        this.definition.columns = colDefs;
      }
      return this.definition;
    }
    //////////////////// Actions ////////////////////
    checkColumnVisibility() {
      var visible = false;
      this.columns.forEach(function(column) {
        if (column.visible) {
          visible = true;
        }
      });
      if (visible) {
        this.show();
        this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
      } else {
        this.hide();
      }
    }
    //show column
    show(silent, responsiveToggle) {
      if (!this.visible) {
        this.visible = true;
        this.element.style.display = "";
        if (this.parent.isGroup) {
          this.parent.checkColumnVisibility();
        }
        this.cells.forEach(function(cell) {
          cell.show();
        });
        if (!this.isGroup && this.width === null) {
          this.reinitializeWidth();
        }
        this.table.columnManager.verticalAlignHeaders();
        this.dispatch("column-show", this, responsiveToggle);
        if (!silent) {
          this.dispatchExternal("columnVisibilityChanged", this.getComponent(), true);
        }
        if (this.parent.isGroup) {
          this.parent.matchChildWidths();
        }
        if (!this.silent) {
          this.table.columnManager.rerenderColumns();
        }
      }
    }
    //hide column
    hide(silent, responsiveToggle) {
      if (this.visible) {
        this.visible = false;
        this.element.style.display = "none";
        this.table.columnManager.verticalAlignHeaders();
        if (this.parent.isGroup) {
          this.parent.checkColumnVisibility();
        }
        this.cells.forEach(function(cell) {
          cell.hide();
        });
        this.dispatch("column-hide", this, responsiveToggle);
        if (!silent) {
          this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
        }
        if (this.parent.isGroup) {
          this.parent.matchChildWidths();
        }
        if (!this.silent) {
          this.table.columnManager.rerenderColumns();
        }
      }
    }
    matchChildWidths() {
      var childWidth = 0;
      if (this.contentElement && this.columns.length) {
        this.columns.forEach(function(column) {
          if (column.visible) {
            childWidth += column.getWidth();
          }
        });
        this.contentElement.style.maxWidth = childWidth - 1 + "px";
        if (this.table.initialized) {
          this.element.style.width = childWidth + "px";
        }
        if (this.parent.isGroup) {
          this.parent.matchChildWidths();
        }
      }
    }
    removeChild(child) {
      var index2 = this.columns.indexOf(child);
      if (index2 > -1) {
        this.columns.splice(index2, 1);
      }
      if (!this.columns.length) {
        this.delete();
      }
    }
    setWidth(width) {
      this.widthFixed = true;
      this.setWidthActual(width);
    }
    setWidthActual(width) {
      if (isNaN(width)) {
        width = Math.floor(this.table.element.clientWidth / 100 * parseInt(width));
      }
      width = Math.max(this.minWidth, width);
      if (this.maxWidth) {
        width = Math.min(this.maxWidth, width);
      }
      this.width = width;
      this.widthStyled = width ? width + "px" : "";
      this.element.style.width = this.widthStyled;
      if (!this.isGroup) {
        this.cells.forEach(function(cell) {
          cell.setWidth();
        });
      }
      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }
      this.dispatch("column-width", this);
      if (this.subscribedExternal("columnWidth")) {
        this.dispatchExternal("columnWidth", this.getComponent());
      }
    }
    checkCellHeights() {
      var rows = [];
      this.cells.forEach(function(cell) {
        if (cell.row.heightInitialized) {
          if (cell.row.getElement().offsetParent !== null) {
            rows.push(cell.row);
            cell.row.clearCellHeight();
          } else {
            cell.row.heightInitialized = false;
          }
        }
      });
      rows.forEach(function(row) {
        row.calcHeight();
      });
      rows.forEach(function(row) {
        row.setCellHeight();
      });
    }
    getWidth() {
      var width = 0;
      if (this.isGroup) {
        this.columns.forEach(function(column) {
          if (column.visible) {
            width += column.getWidth();
          }
        });
      } else {
        width = this.width;
      }
      return width;
    }
    getLeftOffset() {
      var offset2 = this.element.offsetLeft;
      if (this.parent.isGroup) {
        offset2 += this.parent.getLeftOffset();
      }
      return offset2;
    }
    getHeight() {
      return Math.ceil(this.element.getBoundingClientRect().height);
    }
    setMinWidth(minWidth) {
      if (this.maxWidth && minWidth > this.maxWidth) {
        minWidth = this.maxWidth;
        console.warn("the minWidth (" + minWidth + "px) for column '" + this.field + "' cannot be bigger that its maxWidth (" + this.maxWidthStyled + ")");
      }
      this.minWidth = minWidth;
      this.minWidthStyled = minWidth ? minWidth + "px" : "";
      this.element.style.minWidth = this.minWidthStyled;
      this.cells.forEach(function(cell) {
        cell.setMinWidth();
      });
    }
    setMaxWidth(maxWidth) {
      if (this.minWidth && maxWidth < this.minWidth) {
        maxWidth = this.minWidth;
        console.warn("the maxWidth (" + maxWidth + "px) for column '" + this.field + "' cannot be smaller that its minWidth (" + this.minWidthStyled + ")");
      }
      this.maxWidth = maxWidth;
      this.maxWidthStyled = maxWidth ? maxWidth + "px" : "";
      this.element.style.maxWidth = this.maxWidthStyled;
      this.cells.forEach(function(cell) {
        cell.setMaxWidth();
      });
    }
    delete() {
      return new Promise((resolve2, reject) => {
        if (this.isGroup) {
          this.columns.forEach(function(column) {
            column.delete();
          });
        }
        this.dispatch("column-delete", this);
        var cellCount = this.cells.length;
        for (let i2 = 0; i2 < cellCount; i2++) {
          this.cells[0].delete();
        }
        if (this.element.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
        this.element = false;
        this.contentElement = false;
        this.titleElement = false;
        this.groupElement = false;
        if (this.parent.isGroup) {
          this.parent.removeChild(this);
        }
        this.table.columnManager.deregisterColumn(this);
        this.table.columnManager.rerenderColumns(true);
        this.dispatch("column-deleted", this);
        resolve2();
      });
    }
    columnRendered() {
      if (this.titleFormatterRendered) {
        this.titleFormatterRendered();
      }
      this.dispatch("column-rendered", this);
    }
    //////////////// Cell Management /////////////////
    //generate cell for this column
    generateCell(row) {
      var cell = new Cell(this, row);
      this.cells.push(cell);
      return cell;
    }
    nextColumn() {
      var index2 = this.table.columnManager.findColumnIndex(this);
      return index2 > -1 ? this._nextVisibleColumn(index2 + 1) : false;
    }
    _nextVisibleColumn(index2) {
      var column = this.table.columnManager.getColumnByIndex(index2);
      return !column || column.visible ? column : this._nextVisibleColumn(index2 + 1);
    }
    prevColumn() {
      var index2 = this.table.columnManager.findColumnIndex(this);
      return index2 > -1 ? this._prevVisibleColumn(index2 - 1) : false;
    }
    _prevVisibleColumn(index2) {
      var column = this.table.columnManager.getColumnByIndex(index2);
      return !column || column.visible ? column : this._prevVisibleColumn(index2 - 1);
    }
    reinitializeWidth(force) {
      this.widthFixed = false;
      if (typeof this.definition.width !== "undefined" && !force) {
        this.setWidth(this.definition.width);
      }
      this.dispatch("column-width-fit-before", this);
      this.fitToData(force);
      this.dispatch("column-width-fit-after", this);
    }
    //set column width to maximum cell width for non group columns
    fitToData(force) {
      if (this.isGroup) {
        return;
      }
      if (!this.widthFixed) {
        this.element.style.width = "";
        this.cells.forEach((cell) => {
          cell.clearWidth();
        });
      }
      var maxWidth = this.element.offsetWidth;
      if (!this.width || !this.widthFixed) {
        this.cells.forEach((cell) => {
          var width = cell.getWidth();
          if (width > maxWidth) {
            maxWidth = width;
          }
        });
        if (maxWidth) {
          var setTo = maxWidth + 1;
          if (force) {
            this.setWidth(setTo);
          } else {
            if (this.maxInitialWidth && !force) {
              setTo = Math.min(setTo, this.maxInitialWidth);
            }
            this.setWidthActual(setTo);
          }
        }
      }
    }
    updateDefinition(updates) {
      var definition;
      if (!this.isGroup) {
        if (!this.parent.isGroup) {
          definition = Object.assign({}, this.getDefinition());
          definition = Object.assign(definition, updates);
          return this.table.columnManager.addColumn(definition, false, this).then((column) => {
            if (definition.field == this.field) {
              this.field = false;
            }
            return this.delete().then(() => {
              return column.getComponent();
            });
          });
        } else {
          console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
          return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
        }
      } else {
        console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
        return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
      }
    }
    deleteCell(cell) {
      var index2 = this.cells.indexOf(cell);
      if (index2 > -1) {
        this.cells.splice(index2, 1);
      }
    }
    //////////////// Object Generation /////////////////
    getComponent() {
      if (!this.component) {
        this.component = new ColumnComponent(this);
      }
      return this.component;
    }
    getPosition() {
      return this.table.columnManager.getVisibleColumnsByIndex().indexOf(this) + 1;
    }
    getParentComponent() {
      return this.parent instanceof _Column ? this.parent.getComponent() : false;
    }
  };
  __publicField(_Column, "defaultOptionList", defaultColumnOptions);
  let Column = _Column;
  class RowComponent {
    constructor(row) {
      this._row = row;
      return new Proxy(this, {
        get: function(target, name, receiver) {
          if (typeof target[name] !== "undefined") {
            return target[name];
          } else {
            return target._row.table.componentFunctionBinder.handle("row", target._row, name);
          }
        }
      });
    }
    getData(transform) {
      return this._row.getData(transform);
    }
    getElement() {
      return this._row.getElement();
    }
    getCells() {
      var cells = [];
      this._row.getCells().forEach(function(cell) {
        cells.push(cell.getComponent());
      });
      return cells;
    }
    getCell(column) {
      var cell = this._row.getCell(column);
      return cell ? cell.getComponent() : false;
    }
    getIndex() {
      return this._row.getData("data")[this._row.table.options.index];
    }
    getPosition() {
      return this._row.getPosition();
    }
    watchPosition(callback) {
      return this._row.watchPosition(callback);
    }
    delete() {
      return this._row.delete();
    }
    scrollTo(position, ifVisible) {
      return this._row.table.rowManager.scrollToRow(this._row, position, ifVisible);
    }
    move(to2, after) {
      this._row.moveToRow(to2, after);
    }
    update(data) {
      return this._row.updateData(data);
    }
    normalizeHeight() {
      this._row.normalizeHeight(true);
    }
    _getSelf() {
      return this._row;
    }
    reformat() {
      return this._row.reinitialize();
    }
    getTable() {
      return this._row.table;
    }
    getNextRow() {
      var row = this._row.nextRow();
      return row ? row.getComponent() : row;
    }
    getPrevRow() {
      var row = this._row.prevRow();
      return row ? row.getComponent() : row;
    }
  }
  class Row extends CoreFeature {
    constructor(data, parent, type = "row") {
      super(parent.table);
      this.parent = parent;
      this.data = {};
      this.type = type;
      this.element = false;
      this.modules = {};
      this.cells = [];
      this.height = 0;
      this.heightStyled = "";
      this.manualHeight = false;
      this.outerHeight = 0;
      this.initialized = false;
      this.heightInitialized = false;
      this.position = 0;
      this.positionWatchers = [];
      this.component = null;
      this.created = false;
      this.setData(data);
    }
    create() {
      if (!this.created) {
        this.created = true;
        this.generateElement();
      }
    }
    createElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-row");
      el.setAttribute("role", "row");
      this.element = el;
    }
    getElement() {
      this.create();
      return this.element;
    }
    detachElement() {
      if (this.element && this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
    }
    generateElement() {
      this.createElement();
      this.dispatch("row-init", this);
    }
    generateCells() {
      this.cells = this.table.columnManager.generateCells(this);
    }
    //functions to setup on first render
    initialize(force, inFragment) {
      this.create();
      if (!this.initialized || force) {
        this.deleteCells();
        while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
        this.dispatch("row-layout-before", this);
        this.generateCells();
        this.initialized = true;
        this.table.columnManager.renderer.renderRowCells(this, inFragment);
        if (force) {
          this.normalizeHeight();
        }
        this.dispatch("row-layout", this);
        if (this.table.options.rowFormatter) {
          this.table.options.rowFormatter(this.getComponent());
        }
        this.dispatch("row-layout-after", this);
      } else {
        this.table.columnManager.renderer.rerenderRowCells(this, inFragment);
      }
    }
    rendered() {
      this.cells.forEach((cell) => {
        cell.cellRendered();
      });
    }
    reinitializeHeight() {
      this.heightInitialized = false;
      if (this.element && this.element.offsetParent !== null) {
        this.normalizeHeight(true);
      }
    }
    deinitialize() {
      this.initialized = false;
    }
    deinitializeHeight() {
      this.heightInitialized = false;
    }
    reinitialize(children) {
      this.initialized = false;
      this.heightInitialized = false;
      if (!this.manualHeight) {
        this.height = 0;
        this.heightStyled = "";
      }
      if (this.element && this.element.offsetParent !== null) {
        this.initialize(true);
      }
      this.dispatch("row-relayout", this);
    }
    //get heights when doing bulk row style calcs in virtual DOM
    calcHeight(force) {
      var maxHeight = 0, minHeight = 0;
      if (this.table.options.rowHeight) {
        this.height = this.table.options.rowHeight;
      } else {
        minHeight = this.calcMinHeight();
        maxHeight = this.calcMaxHeight();
        if (force) {
          this.height = Math.max(maxHeight, minHeight);
        } else {
          this.height = this.manualHeight ? this.height : Math.max(maxHeight, minHeight);
        }
      }
      this.heightStyled = this.height ? this.height + "px" : "";
      this.outerHeight = this.element.offsetHeight;
    }
    calcMinHeight() {
      return this.table.options.resizableRows ? this.element.clientHeight : 0;
    }
    calcMaxHeight() {
      var maxHeight = 0;
      this.cells.forEach(function(cell) {
        var height = cell.getHeight();
        if (height > maxHeight) {
          maxHeight = height;
        }
      });
      return maxHeight;
    }
    //set of cells
    setCellHeight() {
      this.cells.forEach(function(cell) {
        cell.setHeight();
      });
      this.heightInitialized = true;
    }
    clearCellHeight() {
      this.cells.forEach(function(cell) {
        cell.clearHeight();
      });
    }
    //normalize the height of elements in the row
    normalizeHeight(force) {
      if (force && !this.table.options.rowHeight) {
        this.clearCellHeight();
      }
      this.calcHeight(force);
      this.setCellHeight();
    }
    //set height of rows
    setHeight(height, force) {
      if (this.height != height || force) {
        this.manualHeight = true;
        this.height = height;
        this.heightStyled = height ? height + "px" : "";
        this.setCellHeight();
        this.outerHeight = this.element.offsetHeight;
        if (this.subscribedExternal("rowHeight")) {
          this.dispatchExternal("rowHeight", this.getComponent());
        }
      }
    }
    //return rows outer height
    getHeight() {
      return this.outerHeight;
    }
    //return rows outer Width
    getWidth() {
      return this.element.offsetWidth;
    }
    //////////////// Cell Management /////////////////
    deleteCell(cell) {
      var index2 = this.cells.indexOf(cell);
      if (index2 > -1) {
        this.cells.splice(index2, 1);
      }
    }
    //////////////// Data Management /////////////////
    setData(data) {
      this.data = this.chain("row-data-init-before", [this, data], void 0, data);
      this.dispatch("row-data-init-after", this);
    }
    //update the rows data
    updateData(updatedData) {
      var visible = this.element && Helpers.elVisible(this.element), tempData = {}, newRowData;
      return new Promise((resolve2, reject) => {
        if (typeof updatedData === "string") {
          updatedData = JSON.parse(updatedData);
        }
        this.dispatch("row-data-save-before", this);
        if (this.subscribed("row-data-changing")) {
          tempData = Object.assign(tempData, this.data);
          tempData = Object.assign(tempData, updatedData);
        }
        newRowData = this.chain("row-data-changing", [this, tempData, updatedData], null, updatedData);
        for (let attrname in newRowData) {
          this.data[attrname] = newRowData[attrname];
        }
        this.dispatch("row-data-save-after", this);
        for (let attrname in updatedData) {
          let columns = this.table.columnManager.getColumnsByFieldRoot(attrname);
          columns.forEach((column) => {
            let cell = this.getCell(column.getField());
            if (cell) {
              let value = column.getFieldValue(newRowData);
              if (cell.getValue() !== value) {
                cell.setValueProcessData(value);
                if (visible) {
                  cell.cellRendered();
                }
              }
            }
          });
        }
        if (visible) {
          this.normalizeHeight(true);
          if (this.table.options.rowFormatter) {
            this.table.options.rowFormatter(this.getComponent());
          }
        } else {
          this.initialized = false;
          this.height = 0;
          this.heightStyled = "";
        }
        this.dispatch("row-data-changed", this, visible, updatedData);
        this.dispatchExternal("rowUpdated", this.getComponent());
        if (this.subscribedExternal("dataChanged")) {
          this.dispatchExternal("dataChanged", this.table.rowManager.getData());
        }
        resolve2();
      });
    }
    getData(transform) {
      if (transform) {
        return this.chain("row-data-retrieve", [this, transform], null, this.data);
      }
      return this.data;
    }
    getCell(column) {
      var match = false;
      column = this.table.columnManager.findColumn(column);
      if (!this.initialized && this.cells.length === 0) {
        this.generateCells();
      }
      match = this.cells.find(function(cell) {
        return cell.column === column;
      });
      return match;
    }
    getCellIndex(findCell) {
      return this.cells.findIndex(function(cell) {
        return cell === findCell;
      });
    }
    findCell(subject) {
      return this.cells.find((cell) => {
        return cell.element === subject;
      });
    }
    getCells() {
      if (!this.initialized && this.cells.length === 0) {
        this.generateCells();
      }
      return this.cells;
    }
    nextRow() {
      var row = this.table.rowManager.nextDisplayRow(this, true);
      return row || false;
    }
    prevRow() {
      var row = this.table.rowManager.prevDisplayRow(this, true);
      return row || false;
    }
    moveToRow(to2, before) {
      var toRow = this.table.rowManager.findRow(to2);
      if (toRow) {
        this.table.rowManager.moveRowActual(this, toRow, !before);
        this.table.rowManager.refreshActiveData("display", false, true);
      } else {
        console.warn("Move Error - No matching row found:", to2);
      }
    }
    ///////////////////// Actions  /////////////////////
    delete() {
      this.dispatch("row-delete", this);
      this.deleteActual();
      return Promise.resolve();
    }
    deleteActual(blockRedraw) {
      this.detachModules();
      this.table.rowManager.deleteRow(this, blockRedraw);
      this.deleteCells();
      this.initialized = false;
      this.heightInitialized = false;
      this.element = false;
      this.dispatch("row-deleted", this);
    }
    detachModules() {
      this.dispatch("row-deleting", this);
    }
    deleteCells() {
      var cellCount = this.cells.length;
      for (let i2 = 0; i2 < cellCount; i2++) {
        this.cells[0].delete();
      }
    }
    wipe() {
      this.detachModules();
      this.deleteCells();
      if (this.element) {
        while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
        if (this.element.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
      }
      this.element = false;
      this.modules = {};
    }
    isDisplayed() {
      return this.table.rowManager.getDisplayRows().includes(this);
    }
    getPosition() {
      return this.isDisplayed() ? this.position : false;
    }
    setPosition(position) {
      if (position != this.position) {
        this.position = position;
        this.positionWatchers.forEach((callback) => {
          callback(this.position);
        });
      }
    }
    watchPosition(callback) {
      this.positionWatchers.push(callback);
      callback(this.position);
    }
    getGroup() {
      return this.modules.group || false;
    }
    //////////////// Object Generation /////////////////
    getComponent() {
      if (!this.component) {
        this.component = new RowComponent(this);
      }
      return this.component;
    }
  }
  function maskInput(el, options) {
    var mask = options.mask, maskLetter = typeof options.maskLetterChar !== "undefined" ? options.maskLetterChar : "A", maskNumber = typeof options.maskNumberChar !== "undefined" ? options.maskNumberChar : "9", maskWildcard = typeof options.maskWildcardChar !== "undefined" ? options.maskWildcardChar : "*";
    function fillSymbols(index2) {
      var symbol = mask[index2];
      if (typeof symbol !== "undefined" && symbol !== maskWildcard && symbol !== maskLetter && symbol !== maskNumber) {
        el.value = el.value + "" + symbol;
        fillSymbols(index2 + 1);
      }
    }
    el.addEventListener("keydown", (e) => {
      var index2 = el.value.length, char = e.key;
      if (e.keyCode > 46 && !e.ctrlKey && !e.metaKey) {
        if (index2 >= mask.length) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        } else {
          switch (mask[index2]) {
            case maskLetter:
              if (char.toUpperCase() == char.toLowerCase()) {
                e.preventDefault();
                e.stopPropagation();
                return false;
              }
              break;
            case maskNumber:
              if (isNaN(char)) {
                e.preventDefault();
                e.stopPropagation();
                return false;
              }
              break;
            case maskWildcard:
              break;
            default:
              if (char !== mask[index2]) {
                e.preventDefault();
                e.stopPropagation();
                return false;
              }
          }
        }
      }
      return;
    });
    el.addEventListener("keyup", (e) => {
      if (e.keyCode > 46) {
        if (options.maskAutoFill) {
          fillSymbols(el.value.length);
        }
      }
    });
    if (!el.placeholder) {
      el.placeholder = mask;
    }
    if (options.maskAutoFill) {
      fillSymbols(el.value.length);
    }
  }
  function input(cell, onRendered, success, cancel, editorParams) {
    var cellValue = cell.getValue(), input2 = document.createElement("input");
    input2.setAttribute("type", editorParams.search ? "search" : "text");
    input2.style.padding = "4px";
    input2.style.width = "100%";
    input2.style.boxSizing = "border-box";
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          input2.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    input2.value = typeof cellValue !== "undefined" ? cellValue : "";
    onRendered(function() {
      if (cell.getType() === "cell") {
        input2.focus({ preventScroll: true });
        input2.style.height = "100%";
        if (editorParams.selectContents) {
          input2.select();
        }
      }
    });
    function onChange(e) {
      if ((cellValue === null || typeof cellValue === "undefined") && input2.value !== "" || input2.value !== cellValue) {
        if (success(input2.value)) {
          cellValue = input2.value;
        }
      } else {
        cancel();
      }
    }
    input2.addEventListener("change", onChange);
    input2.addEventListener("blur", onChange);
    input2.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        // case 9:
        case 13:
          onChange();
          break;
        case 27:
          cancel();
          break;
        case 35:
        case 36:
          e.stopPropagation();
          break;
      }
    });
    if (editorParams.mask) {
      maskInput(input2, editorParams);
    }
    return input2;
  }
  function textarea$1(cell, onRendered, success, cancel, editorParams) {
    var cellValue = cell.getValue(), vertNav = editorParams.verticalNavigation || "hybrid", value = String(cellValue !== null && typeof cellValue !== "undefined" ? cellValue : ""), input2 = document.createElement("textarea"), scrollHeight = 0;
    input2.style.display = "block";
    input2.style.padding = "2px";
    input2.style.height = "100%";
    input2.style.width = "100%";
    input2.style.boxSizing = "border-box";
    input2.style.whiteSpace = "pre-wrap";
    input2.style.resize = "none";
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          input2.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    input2.value = value;
    onRendered(function() {
      if (cell.getType() === "cell") {
        input2.focus({ preventScroll: true });
        input2.style.height = "100%";
        input2.scrollHeight;
        input2.style.height = input2.scrollHeight + "px";
        cell.getRow().normalizeHeight();
        if (editorParams.selectContents) {
          input2.select();
        }
      }
    });
    function onChange(e) {
      if ((cellValue === null || typeof cellValue === "undefined") && input2.value !== "" || input2.value !== cellValue) {
        if (success(input2.value)) {
          cellValue = input2.value;
        }
        setTimeout(function() {
          cell.getRow().normalizeHeight();
        }, 300);
      } else {
        cancel();
      }
    }
    input2.addEventListener("change", onChange);
    input2.addEventListener("blur", onChange);
    input2.addEventListener("keyup", function() {
      input2.style.height = "";
      var heightNow = input2.scrollHeight;
      input2.style.height = heightNow + "px";
      if (heightNow != scrollHeight) {
        scrollHeight = heightNow;
        cell.getRow().normalizeHeight();
      }
    });
    input2.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        case 13:
          if (e.shiftKey && editorParams.shiftEnterSubmit) {
            onChange();
          }
          break;
        case 27:
          cancel();
          break;
        case 38:
          if (vertNav == "editor" || vertNav == "hybrid" && input2.selectionStart) {
            e.stopImmediatePropagation();
            e.stopPropagation();
          }
          break;
        case 40:
          if (vertNav == "editor" || vertNav == "hybrid" && input2.selectionStart !== input2.value.length) {
            e.stopImmediatePropagation();
            e.stopPropagation();
          }
          break;
        case 35:
        case 36:
          e.stopPropagation();
          break;
      }
    });
    if (editorParams.mask) {
      maskInput(input2, editorParams);
    }
    return input2;
  }
  function number$1(cell, onRendered, success, cancel, editorParams) {
    var cellValue = cell.getValue(), vertNav = editorParams.verticalNavigation || "editor", input2 = document.createElement("input");
    input2.setAttribute("type", "number");
    if (typeof editorParams.max != "undefined") {
      input2.setAttribute("max", editorParams.max);
    }
    if (typeof editorParams.min != "undefined") {
      input2.setAttribute("min", editorParams.min);
    }
    if (typeof editorParams.step != "undefined") {
      input2.setAttribute("step", editorParams.step);
    }
    input2.style.padding = "4px";
    input2.style.width = "100%";
    input2.style.boxSizing = "border-box";
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          input2.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    input2.value = cellValue;
    var blurFunc = function(e) {
      onChange();
    };
    onRendered(function() {
      if (cell.getType() === "cell") {
        input2.removeEventListener("blur", blurFunc);
        input2.focus({ preventScroll: true });
        input2.style.height = "100%";
        input2.addEventListener("blur", blurFunc);
        if (editorParams.selectContents) {
          input2.select();
        }
      }
    });
    function onChange() {
      var value = input2.value;
      if (!isNaN(value) && value !== "") {
        value = Number(value);
      }
      if (value !== cellValue) {
        if (success(value)) {
          cellValue = value;
        }
      } else {
        cancel();
      }
    }
    input2.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        case 13:
          onChange();
          break;
        case 27:
          cancel();
          break;
        case 38:
        //up arrow
        case 40:
          if (vertNav == "editor") {
            e.stopImmediatePropagation();
            e.stopPropagation();
          }
          break;
        case 35:
        case 36:
          e.stopPropagation();
          break;
      }
    });
    if (editorParams.mask) {
      maskInput(input2, editorParams);
    }
    return input2;
  }
  function range(cell, onRendered, success, cancel, editorParams) {
    var cellValue = cell.getValue(), input2 = document.createElement("input");
    input2.setAttribute("type", "range");
    if (typeof editorParams.max != "undefined") {
      input2.setAttribute("max", editorParams.max);
    }
    if (typeof editorParams.min != "undefined") {
      input2.setAttribute("min", editorParams.min);
    }
    if (typeof editorParams.step != "undefined") {
      input2.setAttribute("step", editorParams.step);
    }
    input2.style.padding = "4px";
    input2.style.width = "100%";
    input2.style.boxSizing = "border-box";
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          input2.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    input2.value = cellValue;
    onRendered(function() {
      if (cell.getType() === "cell") {
        input2.focus({ preventScroll: true });
        input2.style.height = "100%";
      }
    });
    function onChange() {
      var value = input2.value;
      if (!isNaN(value) && value !== "") {
        value = Number(value);
      }
      if (value != cellValue) {
        if (success(value)) {
          cellValue = value;
        }
      } else {
        cancel();
      }
    }
    input2.addEventListener("blur", function(e) {
      onChange();
    });
    input2.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        case 13:
          onChange();
          break;
        case 27:
          cancel();
          break;
      }
    });
    return input2;
  }
  function date$1(cell, onRendered, success, cancel, editorParams) {
    var inputFormat = editorParams.format, vertNav = editorParams.verticalNavigation || "editor", DT = inputFormat ? window.DateTime || luxon.DateTime : null;
    var cellValue = cell.getValue(), input2 = document.createElement("input");
    function convertDate(value) {
      var newDatetime;
      if (DT.isDateTime(value)) {
        newDatetime = value;
      } else if (inputFormat === "iso") {
        newDatetime = DT.fromISO(String(value));
      } else {
        newDatetime = DT.fromFormat(String(value), inputFormat);
      }
      return newDatetime.toFormat("yyyy-MM-dd");
    }
    input2.type = "date";
    input2.style.padding = "4px";
    input2.style.width = "100%";
    input2.style.boxSizing = "border-box";
    if (editorParams.max) {
      input2.setAttribute("max", inputFormat ? convertDate(editorParams.max) : editorParams.max);
    }
    if (editorParams.min) {
      input2.setAttribute("min", inputFormat ? convertDate(editorParams.min) : editorParams.min);
    }
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          input2.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    cellValue = typeof cellValue !== "undefined" ? cellValue : "";
    if (inputFormat) {
      if (DT) {
        cellValue = convertDate(cellValue);
      } else {
        console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js");
      }
    }
    input2.value = cellValue;
    onRendered(function() {
      if (cell.getType() === "cell") {
        input2.focus({ preventScroll: true });
        input2.style.height = "100%";
        if (editorParams.selectContents) {
          input2.select();
        }
      }
    });
    function onChange() {
      var value = input2.value, luxDate;
      if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
        if (value && inputFormat) {
          luxDate = DT.fromFormat(String(value), "yyyy-MM-dd");
          switch (inputFormat) {
            case true:
              value = luxDate;
              break;
            case "iso":
              value = luxDate.toISO();
              break;
            default:
              value = luxDate.toFormat(inputFormat);
          }
        }
        if (success(value)) {
          cellValue = input2.value;
        }
      } else {
        cancel();
      }
    }
    input2.addEventListener("blur", function(e) {
      if (e.relatedTarget || e.rangeParent || e.explicitOriginalTarget !== input2) {
        onChange();
      }
    });
    input2.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        // case 9:
        case 13:
          onChange();
          break;
        case 27:
          cancel();
          break;
        case 35:
        case 36:
          e.stopPropagation();
          break;
        case 38:
        //up arrow
        case 40:
          if (vertNav == "editor") {
            e.stopImmediatePropagation();
            e.stopPropagation();
          }
          break;
      }
    });
    return input2;
  }
  function time$1(cell, onRendered, success, cancel, editorParams) {
    var inputFormat = editorParams.format, vertNav = editorParams.verticalNavigation || "editor", DT = inputFormat ? window.DateTime || luxon.DateTime : null, newDatetime;
    var cellValue = cell.getValue(), input2 = document.createElement("input");
    input2.type = "time";
    input2.style.padding = "4px";
    input2.style.width = "100%";
    input2.style.boxSizing = "border-box";
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          input2.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    cellValue = typeof cellValue !== "undefined" ? cellValue : "";
    if (inputFormat) {
      if (DT) {
        if (DT.isDateTime(cellValue)) {
          newDatetime = cellValue;
        } else if (inputFormat === "iso") {
          newDatetime = DT.fromISO(String(cellValue));
        } else {
          newDatetime = DT.fromFormat(String(cellValue), inputFormat);
        }
        cellValue = newDatetime.toFormat("HH:mm");
      } else {
        console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js");
      }
    }
    input2.value = cellValue;
    onRendered(function() {
      if (cell.getType() == "cell") {
        input2.focus({ preventScroll: true });
        input2.style.height = "100%";
        if (editorParams.selectContents) {
          input2.select();
        }
      }
    });
    function onChange() {
      var value = input2.value, luxTime;
      if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
        if (value && inputFormat) {
          luxTime = DT.fromFormat(String(value), "hh:mm");
          switch (inputFormat) {
            case true:
              value = luxTime;
              break;
            case "iso":
              value = luxTime.toISO();
              break;
            default:
              value = luxTime.toFormat(inputFormat);
          }
        }
        if (success(value)) {
          cellValue = input2.value;
        }
      } else {
        cancel();
      }
    }
    input2.addEventListener("blur", function(e) {
      if (e.relatedTarget || e.rangeParent || e.explicitOriginalTarget !== input2) {
        onChange();
      }
    });
    input2.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        // case 9:
        case 13:
          onChange();
          break;
        case 27:
          cancel();
          break;
        case 35:
        case 36:
          e.stopPropagation();
          break;
        case 38:
        //up arrow
        case 40:
          if (vertNav == "editor") {
            e.stopImmediatePropagation();
            e.stopPropagation();
          }
          break;
      }
    });
    return input2;
  }
  function datetime$2(cell, onRendered, success, cancel, editorParams) {
    var inputFormat = editorParams.format, vertNav = editorParams.verticalNavigation || "editor", DT = inputFormat ? this.table.dependencyRegistry.lookup(["luxon", "DateTime"], "DateTime") : null, newDatetime;
    var cellValue = cell.getValue(), input2 = document.createElement("input");
    input2.type = "datetime-local";
    input2.style.padding = "4px";
    input2.style.width = "100%";
    input2.style.boxSizing = "border-box";
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          input2.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    cellValue = typeof cellValue !== "undefined" ? cellValue : "";
    if (inputFormat) {
      if (DT) {
        if (DT.isDateTime(cellValue)) {
          newDatetime = cellValue;
        } else if (inputFormat === "iso") {
          newDatetime = DT.fromISO(String(cellValue));
        } else {
          newDatetime = DT.fromFormat(String(cellValue), inputFormat);
        }
        cellValue = newDatetime.toFormat("yyyy-MM-dd") + "T" + newDatetime.toFormat("HH:mm");
      } else {
        console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js");
      }
    }
    input2.value = cellValue;
    onRendered(function() {
      if (cell.getType() === "cell") {
        input2.focus({ preventScroll: true });
        input2.style.height = "100%";
        if (editorParams.selectContents) {
          input2.select();
        }
      }
    });
    function onChange() {
      var value = input2.value, luxDateTime;
      if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
        if (value && inputFormat) {
          luxDateTime = DT.fromISO(String(value));
          switch (inputFormat) {
            case true:
              value = luxDateTime;
              break;
            case "iso":
              value = luxDateTime.toISO();
              break;
            default:
              value = luxDateTime.toFormat(inputFormat);
          }
        }
        if (success(value)) {
          cellValue = input2.value;
        }
      } else {
        cancel();
      }
    }
    input2.addEventListener("blur", function(e) {
      if (e.relatedTarget || e.rangeParent || e.explicitOriginalTarget !== input2) {
        onChange();
      }
    });
    input2.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        // case 9:
        case 13:
          onChange();
          break;
        case 27:
          cancel();
          break;
        case 35:
        case 36:
          e.stopPropagation();
          break;
        case 38:
        //up arrow
        case 40:
          if (vertNav == "editor") {
            e.stopImmediatePropagation();
            e.stopPropagation();
          }
          break;
      }
    });
    return input2;
  }
  let Edit$1 = class Edit {
    constructor(editor, cell, onRendered, success, cancel, editorParams) {
      this.edit = editor;
      this.table = editor.table;
      this.cell = cell;
      this.params = this._initializeParams(editorParams);
      this.data = [];
      this.displayItems = [];
      this.currentItems = [];
      this.focusedItem = null;
      this.input = this._createInputElement();
      this.listEl = this._createListElement();
      this.initialValues = null;
      this.isFilter = cell.getType() === "header";
      this.filterTimeout = null;
      this.filtered = false;
      this.typing = false;
      this.values = [];
      this.popup = null;
      this.listIteration = 0;
      this.lastAction = "";
      this.filterTerm = "";
      this.blurable = true;
      this.actions = {
        success,
        cancel
      };
      this._deprecatedOptionsCheck();
      this._initializeValue();
      onRendered(this._onRendered.bind(this));
    }
    _deprecatedOptionsCheck() {
    }
    _initializeValue() {
      var initialValue = this.cell.getValue();
      if (typeof initialValue === "undefined" && typeof this.params.defaultValue !== "undefined") {
        initialValue = this.params.defaultValue;
      }
      this.initialValues = this.params.multiselect ? initialValue : [initialValue];
      if (this.isFilter) {
        this.input.value = this.initialValues ? this.initialValues.join(",") : "";
        this.headerFilterInitialListGen();
      }
    }
    _onRendered() {
      var cellEl = this.cell.getElement();
      function clickStop(e) {
        e.stopPropagation();
      }
      if (!this.isFilter) {
        this.input.style.height = "100%";
        this.input.focus({ preventScroll: true });
      }
      cellEl.addEventListener("click", clickStop);
      setTimeout(() => {
        cellEl.removeEventListener("click", clickStop);
      }, 1e3);
      this.input.addEventListener("mousedown", this._preventPopupBlur.bind(this));
    }
    _createListElement() {
      var listEl = document.createElement("div");
      listEl.classList.add("tabulator-edit-list");
      listEl.addEventListener("mousedown", this._preventBlur.bind(this));
      listEl.addEventListener("keydown", this._inputKeyDown.bind(this));
      return listEl;
    }
    _setListWidth() {
      var element = this.isFilter ? this.input : this.cell.getElement();
      this.listEl.style.minWidth = element.offsetWidth + "px";
      if (this.params.maxWidth) {
        if (this.params.maxWidth === true) {
          this.listEl.style.maxWidth = element.offsetWidth + "px";
        } else if (typeof this.params.maxWidth === "number") {
          this.listEl.style.maxWidth = this.params.maxWidth + "px";
        } else {
          this.listEl.style.maxWidth = this.params.maxWidth;
        }
      }
    }
    _createInputElement() {
      var attribs = this.params.elementAttributes;
      var input2 = document.createElement("input");
      input2.setAttribute("type", this.params.clearable ? "search" : "text");
      input2.style.padding = "4px";
      input2.style.width = "100%";
      input2.style.boxSizing = "border-box";
      if (!this.params.autocomplete) {
        input2.style.cursor = "default";
        input2.style.caretColor = "transparent";
      }
      if (attribs && typeof attribs == "object") {
        for (let key in attribs) {
          if (key.charAt(0) == "+") {
            key = key.slice(1);
            input2.setAttribute(key, input2.getAttribute(key) + attribs["+" + key]);
          } else {
            input2.setAttribute(key, attribs[key]);
          }
        }
      }
      if (this.params.mask) {
        maskInput(input2, this.params);
      }
      this._bindInputEvents(input2);
      return input2;
    }
    _initializeParams(params) {
      var valueKeys = ["values", "valuesURL", "valuesLookup"], valueCheck;
      params = Object.assign({}, params);
      params.verticalNavigation = params.verticalNavigation || "editor";
      params.placeholderLoading = typeof params.placeholderLoading === "undefined" ? "Searching ..." : params.placeholderLoading;
      params.placeholderEmpty = typeof params.placeholderEmpty === "undefined" ? "No Results Found" : params.placeholderEmpty;
      params.filterDelay = typeof params.filterDelay === "undefined" ? 300 : params.filterDelay;
      params.emptyValue = Object.keys(params).includes("emptyValue") ? params.emptyValue : "";
      valueCheck = Object.keys(params).filter((key) => valueKeys.includes(key)).length;
      if (!valueCheck) {
        console.warn("list editor config error - either the values, valuesURL, or valuesLookup option must be set");
      } else if (valueCheck > 1) {
        console.warn("list editor config error - only one of the values, valuesURL, or valuesLookup options can be set on the same editor");
      }
      if (params.autocomplete) {
        if (params.multiselect) {
          params.multiselect = false;
          console.warn("list editor config error - multiselect option is not available when autocomplete is enabled");
        }
      } else {
        if (params.freetext) {
          params.freetext = false;
          console.warn("list editor config error - freetext option is only available when autocomplete is enabled");
        }
        if (params.filterFunc) {
          params.filterFunc = false;
          console.warn("list editor config error - filterFunc option is only available when autocomplete is enabled");
        }
        if (params.filterRemote) {
          params.filterRemote = false;
          console.warn("list editor config error - filterRemote option is only available when autocomplete is enabled");
        }
        if (params.mask) {
          params.mask = false;
          console.warn("list editor config error - mask option is only available when autocomplete is enabled");
        }
        if (params.allowEmpty) {
          params.allowEmpty = false;
          console.warn("list editor config error - allowEmpty option is only available when autocomplete is enabled");
        }
        if (params.listOnEmpty) {
          params.listOnEmpty = false;
          console.warn("list editor config error - listOnEmpty option is only available when autocomplete is enabled");
        }
      }
      if (params.filterRemote && !(typeof params.valuesLookup === "function" || params.valuesURL)) {
        params.filterRemote = false;
        console.warn("list editor config error - filterRemote option should only be used when values list is populated from a remote source");
      }
      return params;
    }
    //////////////////////////////////////
    ////////// Event Handling ////////////
    //////////////////////////////////////
    _bindInputEvents(input2) {
      input2.addEventListener("focus", this._inputFocus.bind(this));
      input2.addEventListener("click", this._inputClick.bind(this));
      input2.addEventListener("blur", this._inputBlur.bind(this));
      input2.addEventListener("keydown", this._inputKeyDown.bind(this));
      input2.addEventListener("search", this._inputSearch.bind(this));
      if (this.params.autocomplete) {
        input2.addEventListener("keyup", this._inputKeyUp.bind(this));
      }
    }
    _inputFocus(e) {
      this.rebuildOptionsList();
    }
    _filter() {
      if (this.params.filterRemote) {
        clearTimeout(this.filterTimeout);
        this.filterTimeout = setTimeout(() => {
          this.rebuildOptionsList();
        }, this.params.filterDelay);
      } else {
        this._filterList();
      }
    }
    _inputClick(e) {
      e.stopPropagation();
    }
    _inputBlur(e) {
      if (this.blurable) {
        if (this.popup) {
          this.popup.hide();
        } else {
          this._resolveValue(true);
        }
      }
    }
    _inputSearch() {
      this._clearChoices();
    }
    _inputKeyDown(e) {
      switch (e.keyCode) {
        case 38:
          this._keyUp(e);
          break;
        case 40:
          this._keyDown(e);
          break;
        case 37:
        //left arrow
        case 39:
          this._keySide(e);
          break;
        case 13:
          this._keyEnter();
          break;
        case 27:
          this._keyEsc();
          break;
        case 36:
        //home
        case 35:
          this._keyHomeEnd(e);
          break;
        case 9:
          this._keyTab(e);
          break;
        default:
          this._keySelectLetter(e);
      }
    }
    _inputKeyUp(e) {
      switch (e.keyCode) {
        case 38:
        //up arrow
        case 37:
        //left arrow
        case 39:
        //up arrow
        case 40:
        //right arrow
        case 13:
        //enter
        case 27:
          break;
        default:
          this._keyAutoCompLetter(e);
      }
    }
    _preventPopupBlur() {
      if (this.popup) {
        this.popup.blockHide();
      }
      setTimeout(() => {
        if (this.popup) {
          this.popup.restoreHide();
        }
      }, 10);
    }
    _preventBlur() {
      this.blurable = false;
      setTimeout(() => {
        this.blurable = true;
      }, 10);
    }
    //////////////////////////////////////
    //////// Keyboard Navigation /////////
    //////////////////////////////////////
    _keyTab(e) {
      if (this.params.autocomplete && this.lastAction === "typing") {
        this._resolveValue(true);
      } else {
        if (this.focusedItem) {
          this._chooseItem(this.focusedItem, true);
        }
      }
    }
    _keyUp(e) {
      var index2 = this.displayItems.indexOf(this.focusedItem);
      if (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && index2) {
        e.stopImmediatePropagation();
        e.stopPropagation();
        e.preventDefault();
        if (index2 > 0) {
          this._focusItem(this.displayItems[index2 - 1]);
        }
      }
    }
    _keyDown(e) {
      var index2 = this.displayItems.indexOf(this.focusedItem);
      if (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && index2 < this.displayItems.length - 1) {
        e.stopImmediatePropagation();
        e.stopPropagation();
        e.preventDefault();
        if (index2 < this.displayItems.length - 1) {
          if (index2 == -1) {
            this._focusItem(this.displayItems[0]);
          } else {
            this._focusItem(this.displayItems[index2 + 1]);
          }
        }
      }
    }
    _keySide(e) {
      if (!this.params.autocomplete) {
        e.stopImmediatePropagation();
        e.stopPropagation();
        e.preventDefault();
      }
    }
    _keyEnter(e) {
      if (this.params.autocomplete && this.lastAction === "typing") {
        this._resolveValue(true);
      } else {
        if (this.focusedItem) {
          this._chooseItem(this.focusedItem);
        }
      }
    }
    _keyEsc(e) {
      this._cancel();
    }
    _keyHomeEnd(e) {
      if (this.params.autocomplete) {
        e.stopImmediatePropagation();
      }
    }
    _keySelectLetter(e) {
      if (!this.params.autocomplete) {
        e.preventDefault();
        if (e.keyCode >= 38 && e.keyCode <= 90) {
          this._scrollToValue(e.keyCode);
        }
      }
    }
    _keyAutoCompLetter(e) {
      this._filter();
      this.lastAction = "typing";
      this.typing = true;
    }
    _scrollToValue(char) {
      clearTimeout(this.filterTimeout);
      var character = String.fromCharCode(char).toLowerCase();
      this.filterTerm += character.toLowerCase();
      var match = this.displayItems.find((item) => {
        return typeof item.label !== "undefined" && item.label.toLowerCase().startsWith(this.filterTerm);
      });
      if (match) {
        this._focusItem(match);
      }
      this.filterTimeout = setTimeout(() => {
        this.filterTerm = "";
      }, 800);
    }
    _focusItem(item) {
      this.lastAction = "focus";
      if (this.focusedItem && this.focusedItem.element) {
        this.focusedItem.element.classList.remove("focused");
      }
      this.focusedItem = item;
      if (item && item.element) {
        item.element.classList.add("focused");
        item.element.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" });
      }
    }
    //////////////////////////////////////
    /////// Data List Generation /////////
    //////////////////////////////////////
    headerFilterInitialListGen() {
      this._generateOptions(true);
    }
    rebuildOptionsList() {
      this._generateOptions().then(this._sortOptions.bind(this)).then(this._buildList.bind(this)).then(this._showList.bind(this)).catch((e) => {
        if (!Number.isInteger(e)) {
          console.error("List generation error", e);
        }
      });
    }
    _filterList() {
      this._buildList(this._filterOptions());
      this._showList();
    }
    _generateOptions(silent) {
      var values = [];
      var iteration = ++this.listIteration;
      this.filtered = false;
      if (this.params.values) {
        values = this.params.values;
      } else if (this.params.valuesURL) {
        values = this._ajaxRequest(this.params.valuesURL, this.input.value);
      } else {
        if (typeof this.params.valuesLookup === "function") {
          values = this.params.valuesLookup(this.cell, this.input.value);
        } else if (this.params.valuesLookup) {
          values = this._uniqueColumnValues(this.params.valuesLookupField);
        }
      }
      if (values instanceof Promise) {
        if (!silent) {
          this._addPlaceholder(this.params.placeholderLoading);
        }
        return values.then().then((responseValues) => {
          if (this.listIteration === iteration) {
            return this._parseList(responseValues);
          } else {
            return Promise.reject(iteration);
          }
        });
      } else {
        return Promise.resolve(this._parseList(values));
      }
    }
    _addPlaceholder(contents) {
      var placeholder = document.createElement("div");
      if (typeof contents === "function") {
        contents = contents(this.cell.getComponent(), this.listEl);
      }
      if (contents) {
        this._clearList();
        if (contents instanceof HTMLElement) {
          placeholder = contents;
        } else {
          placeholder.classList.add("tabulator-edit-list-placeholder");
          placeholder.innerHTML = contents;
        }
        this.listEl.appendChild(placeholder);
        this._showList();
      }
    }
    _ajaxRequest(url, term) {
      var params = this.params.filterRemote ? { term } : {};
      url = urlBuilder(url, {}, params);
      return fetch(url).then((response) => {
        if (response.ok) {
          return response.json().catch((error) => {
            console.warn("List Ajax Load Error - Invalid JSON returned", error);
            return Promise.reject(error);
          });
        } else {
          console.error("List Ajax Load Error - Connection Error: " + response.status, response.statusText);
          return Promise.reject(response);
        }
      }).catch((error) => {
        console.error("List Ajax Load Error - Connection Error: ", error);
        return Promise.reject(error);
      });
    }
    _uniqueColumnValues(field) {
      var output = {}, data = this.table.getData(this.params.valuesLookup), column;
      if (field) {
        column = this.table.columnManager.getColumnByField(field);
      } else {
        column = this.cell.getColumn()._getSelf();
      }
      if (column) {
        data.forEach((row) => {
          var val = column.getFieldValue(row);
          if (!this._emptyValueCheck(val)) {
            if (this.params.multiselect && Array.isArray(val)) {
              val.forEach((item) => {
                if (!this._emptyValueCheck(item)) {
                  output[item] = true;
                }
              });
            } else {
              output[val] = true;
            }
          }
        });
      } else {
        console.warn("unable to find matching column to create select lookup list:", field);
        output = [];
      }
      return Object.keys(output);
    }
    _emptyValueCheck(value) {
      return value === null || typeof value === "undefined" || value === "";
    }
    _parseList(inputValues) {
      var data = [];
      if (!Array.isArray(inputValues)) {
        inputValues = Object.entries(inputValues).map(([key, value]) => {
          return {
            label: value,
            value: key
          };
        });
      }
      inputValues.forEach((value) => {
        if (typeof value !== "object") {
          value = {
            label: value,
            value
          };
        }
        this._parseListItem(value, data, 0);
      });
      if (!this.currentItems.length && this.params.freetext) {
        this.input.value = this.initialValues;
        this.typing = true;
        this.lastAction = "typing";
      }
      this.data = data;
      return data;
    }
    _parseListItem(option, data, level) {
      var item = {};
      if (option.options) {
        item = this._parseListGroup(option, level + 1);
      } else {
        item = {
          label: option.label,
          value: option.value,
          itemParams: option.itemParams,
          elementAttributes: option.elementAttributes,
          element: false,
          selected: false,
          visible: true,
          level,
          original: option
        };
        if (this.initialValues && this.initialValues.indexOf(option.value) > -1) {
          this._chooseItem(item, true);
        }
      }
      data.push(item);
    }
    _parseListGroup(option, level) {
      var item = {
        label: option.label,
        group: true,
        itemParams: option.itemParams,
        elementAttributes: option.elementAttributes,
        element: false,
        visible: true,
        level,
        options: [],
        original: option
      };
      option.options.forEach((child) => {
        this._parseListItem(child, item.options, level);
      });
      return item;
    }
    _sortOptions(options) {
      var sorter;
      if (this.params.sort) {
        sorter = typeof this.params.sort === "function" ? this.params.sort : this._defaultSortFunction.bind(this);
        this._sortGroup(sorter, options);
      }
      return options;
    }
    _sortGroup(sorter, options) {
      options.sort((a2, b2) => {
        return sorter(a2.label, b2.label, a2.value, b2.value, a2.original, b2.original);
      });
      options.forEach((option) => {
        if (option.group) {
          this._sortGroup(sorter, option.options);
        }
      });
    }
    _defaultSortFunction(as, bs) {
      var a2, b2, a1, b1, i2 = 0, L2, rx = /(\d+)|(\D+)/g, rd = /\d/;
      var emptyAlign = 0;
      if (this.params.sort === "desc") {
        [as, bs] = [bs, as];
      }
      if (!as && as !== 0) {
        emptyAlign = !bs && bs !== 0 ? 0 : -1;
      } else if (!bs && bs !== 0) {
        emptyAlign = 1;
      } else {
        if (isFinite(as) && isFinite(bs)) return as - bs;
        a2 = String(as).toLowerCase();
        b2 = String(bs).toLowerCase();
        if (a2 === b2) return 0;
        if (!(rd.test(a2) && rd.test(b2))) return a2 > b2 ? 1 : -1;
        a2 = a2.match(rx);
        b2 = b2.match(rx);
        L2 = a2.length > b2.length ? b2.length : a2.length;
        while (i2 < L2) {
          a1 = a2[i2];
          b1 = b2[i2++];
          if (a1 !== b1) {
            if (isFinite(a1) && isFinite(b1)) {
              if (a1.charAt(0) === "0") a1 = "." + a1;
              if (b1.charAt(0) === "0") b1 = "." + b1;
              return a1 - b1;
            } else return a1 > b1 ? 1 : -1;
          }
        }
        return a2.length > b2.length;
      }
      return emptyAlign;
    }
    _filterOptions() {
      var filterFunc = this.params.filterFunc || this._defaultFilterFunc, term = this.input.value;
      if (term) {
        this.filtered = true;
        this.data.forEach((item) => {
          this._filterItem(filterFunc, term, item);
        });
      } else {
        this.filtered = false;
      }
      return this.data;
    }
    _filterItem(func, term, item) {
      var matches2 = false;
      if (!item.group) {
        item.visible = func(term, item.label, item.value, item.original);
      } else {
        item.options.forEach((option) => {
          if (this._filterItem(func, term, option)) {
            matches2 = true;
          }
        });
        item.visible = matches2;
      }
      return item.visible;
    }
    _defaultFilterFunc(term, label, value, item) {
      term = String(term).toLowerCase();
      if (label !== null && typeof label !== "undefined") {
        if (String(label).toLowerCase().indexOf(term) > -1 || String(value).toLowerCase().indexOf(term) > -1) {
          return true;
        }
      }
      return false;
    }
    //////////////////////////////////////
    /////////// Display List /////////////
    //////////////////////////////////////
    _clearList() {
      while (this.listEl.firstChild) this.listEl.removeChild(this.listEl.firstChild);
      this.displayItems = [];
    }
    _buildList(data) {
      this._clearList();
      data.forEach((option) => {
        this._buildItem(option);
      });
      if (!this.displayItems.length) {
        this._addPlaceholder(this.params.placeholderEmpty);
      }
    }
    _buildItem(item) {
      var el = item.element, contents;
      if (!this.filtered || item.visible) {
        if (!el) {
          el = document.createElement("div");
          el.tabIndex = 0;
          contents = this.params.itemFormatter ? this.params.itemFormatter(item.label, item.value, item.original, el) : item.label;
          if (contents instanceof HTMLElement) {
            el.appendChild(contents);
          } else {
            el.innerHTML = contents;
          }
          if (item.group) {
            el.classList.add("tabulator-edit-list-group");
          } else {
            el.classList.add("tabulator-edit-list-item");
          }
          el.classList.add("tabulator-edit-list-group-level-" + item.level);
          if (item.elementAttributes && typeof item.elementAttributes == "object") {
            for (let key in item.elementAttributes) {
              if (key.charAt(0) == "+") {
                key = key.slice(1);
                el.setAttribute(key, this.input.getAttribute(key) + item.elementAttributes["+" + key]);
              } else {
                el.setAttribute(key, item.elementAttributes[key]);
              }
            }
          }
          if (item.group) {
            el.addEventListener("click", this._groupClick.bind(this, item));
          } else {
            el.addEventListener("click", this._itemClick.bind(this, item));
          }
          el.addEventListener("mousedown", this._preventBlur.bind(this));
          item.element = el;
        }
        this._styleItem(item);
        this.listEl.appendChild(el);
        if (item.group) {
          item.options.forEach((option) => {
            this._buildItem(option);
          });
        } else {
          this.displayItems.push(item);
        }
      }
    }
    _showList() {
      var startVis = this.popup && this.popup.isVisible();
      if (this.input.parentNode) {
        if (this.params.autocomplete && this.input.value === "" && !this.params.listOnEmpty) {
          if (this.popup) {
            this.popup.hide(true);
          }
          return;
        }
        this._setListWidth();
        if (!this.popup) {
          this.popup = this.edit.popup(this.listEl);
        }
        this.popup.show(this.cell.getElement(), "bottom");
        if (!startVis) {
          setTimeout(() => {
            this.popup.hideOnBlur(this._resolveValue.bind(this, true));
          }, 10);
        }
      }
    }
    _styleItem(item) {
      if (item && item.element) {
        if (item.selected) {
          item.element.classList.add("active");
        } else {
          item.element.classList.remove("active");
        }
      }
    }
    //////////////////////////////////////
    ///////// User Interaction ///////////
    //////////////////////////////////////
    _itemClick(item, e) {
      e.stopPropagation();
      this._chooseItem(item);
    }
    _groupClick(item, e) {
      e.stopPropagation();
    }
    //////////////////////////////////////
    ////// Current Item Management ///////
    //////////////////////////////////////
    _cancel() {
      this.popup.hide(true);
      this.actions.cancel();
    }
    _clearChoices() {
      this.typing = true;
      this.currentItems.forEach((item) => {
        item.selected = false;
        this._styleItem(item);
      });
      this.currentItems = [];
      this.focusedItem = null;
    }
    _chooseItem(item, silent) {
      var index2;
      this.typing = false;
      if (this.params.multiselect) {
        index2 = this.currentItems.indexOf(item);
        if (index2 > -1) {
          this.currentItems.splice(index2, 1);
          item.selected = false;
        } else {
          this.currentItems.push(item);
          item.selected = true;
        }
        this.input.value = this.currentItems.map((item2) => item2.label).join(",");
        this._styleItem(item);
      } else {
        this.currentItems = [item];
        item.selected = true;
        this.input.value = item.label;
        this._styleItem(item);
        if (!silent) {
          this._resolveValue();
        }
      }
      this._focusItem(item);
    }
    _resolveValue(blur) {
      var output, initialValue;
      if (this.popup) {
        this.popup.hide(true);
      }
      if (this.params.multiselect) {
        output = this.currentItems.map((item) => item.value);
      } else {
        if (blur && this.params.autocomplete && this.typing) {
          if (this.params.freetext || this.params.allowEmpty && this.input.value === "") {
            output = this.input.value;
          } else {
            this.actions.cancel();
            return;
          }
        } else {
          if (this.currentItems[0]) {
            output = this.currentItems[0].value;
          } else {
            initialValue = Array.isArray(this.initialValues) ? this.initialValues[0] : this.initialValues;
            if (initialValue === null || typeof initialValue === "undefined" || initialValue === "") {
              output = initialValue;
            } else {
              output = this.params.emptyValue;
            }
          }
        }
      }
      if (output === "") {
        output = this.params.emptyValue;
      }
      this.actions.success(output);
      if (this.isFilter) {
        this.initialValues = output && !Array.isArray(output) ? [output] : output;
        this.currentItems = [];
      }
    }
  };
  function list(cell, onRendered, success, cancel, editorParams) {
    var list2 = new Edit$1(this, cell, onRendered, success, cancel, editorParams);
    return list2.input;
  }
  function star$1(cell, onRendered, success, cancel, editorParams) {
    var self2 = this, element = cell.getElement(), value = cell.getValue(), maxStars = element.getElementsByTagName("svg").length || 5, size2 = element.getElementsByTagName("svg")[0] ? element.getElementsByTagName("svg")[0].getAttribute("width") : 14, stars = [], starsHolder = document.createElement("div"), star2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    function starChange(val) {
      stars.forEach(function(star3, i3) {
        if (i3 < val) {
          if (self2.table.browser == "ie") {
            star3.setAttribute("class", "tabulator-star-active");
          } else {
            star3.classList.replace("tabulator-star-inactive", "tabulator-star-active");
          }
          star3.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
        } else {
          if (self2.table.browser == "ie") {
            star3.setAttribute("class", "tabulator-star-inactive");
          } else {
            star3.classList.replace("tabulator-star-active", "tabulator-star-inactive");
          }
          star3.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
        }
      });
    }
    function buildStar(i3) {
      var starHolder = document.createElement("span");
      var nextStar = star2.cloneNode(true);
      stars.push(nextStar);
      starHolder.addEventListener("mouseenter", function(e) {
        e.stopPropagation();
        e.stopImmediatePropagation();
        starChange(i3);
      });
      starHolder.addEventListener("mousemove", function(e) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      });
      starHolder.addEventListener("click", function(e) {
        e.stopPropagation();
        e.stopImmediatePropagation();
        success(i3);
        element.blur();
      });
      starHolder.appendChild(nextStar);
      starsHolder.appendChild(starHolder);
    }
    function changeValue(val) {
      value = val;
      starChange(val);
    }
    element.style.whiteSpace = "nowrap";
    element.style.overflow = "hidden";
    element.style.textOverflow = "ellipsis";
    starsHolder.style.verticalAlign = "middle";
    starsHolder.style.display = "inline-block";
    starsHolder.style.padding = "4px";
    star2.setAttribute("width", size2);
    star2.setAttribute("height", size2);
    star2.setAttribute("viewBox", "0 0 512 512");
    star2.setAttribute("xml:space", "preserve");
    star2.style.padding = "0 1px";
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          starsHolder.setAttribute(key, starsHolder.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          starsHolder.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    for (var i2 = 1; i2 <= maxStars; i2++) {
      buildStar(i2);
    }
    value = Math.min(parseInt(value), maxStars);
    starChange(value);
    starsHolder.addEventListener("mousemove", function(e) {
      starChange(0);
    });
    starsHolder.addEventListener("click", function(e) {
      success(0);
    });
    element.addEventListener("blur", function(e) {
      cancel();
    });
    element.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        case 39:
          changeValue(value + 1);
          break;
        case 37:
          changeValue(value - 1);
          break;
        case 13:
          success(value);
          break;
        case 27:
          cancel();
          break;
      }
    });
    return starsHolder;
  }
  function progress$1(cell, onRendered, success, cancel, editorParams) {
    var element = cell.getElement(), max2 = typeof editorParams.max === "undefined" ? element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("max") || 100 : editorParams.max, min2 = typeof editorParams.min === "undefined" ? element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("min") || 0 : editorParams.min, percent = (max2 - min2) / 100, value = cell.getValue() || 0, handle2 = document.createElement("div"), bar = document.createElement("div"), mouseDrag, mouseDragWidth;
    function updateValue() {
      var style = window.getComputedStyle(element, null);
      var calcVal = percent * Math.round(bar.offsetWidth / ((element.clientWidth - parseInt(style.getPropertyValue("padding-left")) - parseInt(style.getPropertyValue("padding-right"))) / 100)) + min2;
      success(calcVal);
      element.setAttribute("aria-valuenow", calcVal);
      element.setAttribute("aria-label", value);
    }
    handle2.style.position = "absolute";
    handle2.style.right = "0";
    handle2.style.top = "0";
    handle2.style.bottom = "0";
    handle2.style.width = "5px";
    handle2.classList.add("tabulator-progress-handle");
    bar.style.display = "inline-block";
    bar.style.position = "relative";
    bar.style.height = "100%";
    bar.style.backgroundColor = "#488CE9";
    bar.style.maxWidth = "100%";
    bar.style.minWidth = "0%";
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          bar.setAttribute(key, bar.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          bar.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    element.style.padding = "4px 4px";
    value = Math.min(parseFloat(value), max2);
    value = Math.max(parseFloat(value), min2);
    value = Math.round((value - min2) / percent);
    bar.style.width = value + "%";
    element.setAttribute("aria-valuemin", min2);
    element.setAttribute("aria-valuemax", max2);
    bar.appendChild(handle2);
    handle2.addEventListener("mousedown", function(e) {
      mouseDrag = e.screenX;
      mouseDragWidth = bar.offsetWidth;
    });
    handle2.addEventListener("mouseover", function() {
      handle2.style.cursor = "ew-resize";
    });
    element.addEventListener("mousemove", function(e) {
      if (mouseDrag) {
        bar.style.width = mouseDragWidth + e.screenX - mouseDrag + "px";
      }
    });
    element.addEventListener("mouseup", function(e) {
      if (mouseDrag) {
        e.stopPropagation();
        e.stopImmediatePropagation();
        mouseDrag = false;
        mouseDragWidth = false;
        updateValue();
      }
    });
    element.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        case 39:
          e.preventDefault();
          bar.style.width = bar.clientWidth + element.clientWidth / 100 + "px";
          break;
        case 37:
          e.preventDefault();
          bar.style.width = bar.clientWidth - element.clientWidth / 100 + "px";
          break;
        case 9:
        //tab
        case 13:
          updateValue();
          break;
        case 27:
          cancel();
          break;
      }
    });
    element.addEventListener("blur", function() {
      cancel();
    });
    return bar;
  }
  function tickCross$1(cell, onRendered, success, cancel, editorParams) {
    var value = cell.getValue(), input2 = document.createElement("input"), tristate = editorParams.tristate, indetermValue = typeof editorParams.indeterminateValue === "undefined" ? null : editorParams.indeterminateValue, indetermState = false, trueValueSet = Object.keys(editorParams).includes("trueValue"), falseValueSet = Object.keys(editorParams).includes("falseValue");
    input2.setAttribute("type", "checkbox");
    input2.style.marginTop = "5px";
    input2.style.boxSizing = "border-box";
    if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
      for (let key in editorParams.elementAttributes) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
        } else {
          input2.setAttribute(key, editorParams.elementAttributes[key]);
        }
      }
    }
    input2.value = value;
    if (tristate && (typeof value === "undefined" || value === indetermValue || value === "")) {
      indetermState = true;
      input2.indeterminate = true;
    }
    if (this.table.browser != "firefox" && this.table.browser != "safari") {
      onRendered(function() {
        if (cell.getType() === "cell") {
          input2.focus({ preventScroll: true });
        }
      });
    }
    input2.checked = trueValueSet ? value === editorParams.trueValue : value === true || value === "true" || value === "True" || value === 1;
    function setValue(blur) {
      var checkedValue = input2.checked;
      if (trueValueSet && checkedValue) {
        checkedValue = editorParams.trueValue;
      } else if (falseValueSet && !checkedValue) {
        checkedValue = editorParams.falseValue;
      }
      if (tristate) {
        if (!blur) {
          if (input2.checked && !indetermState) {
            input2.checked = false;
            input2.indeterminate = true;
            indetermState = true;
            return indetermValue;
          } else {
            indetermState = false;
            return checkedValue;
          }
        } else {
          if (indetermState) {
            return indetermValue;
          } else {
            return checkedValue;
          }
        }
      } else {
        return checkedValue;
      }
    }
    input2.addEventListener("change", function(e) {
      success(setValue());
    });
    input2.addEventListener("blur", function(e) {
      success(setValue(true));
    });
    input2.addEventListener("keydown", function(e) {
      if (e.keyCode == 13) {
        success(setValue());
      }
      if (e.keyCode == 27) {
        cancel();
      }
    });
    return input2;
  }
  function adaptable$1(cell, onRendered, success, cancel, params) {
    var column = cell._getSelf().column, lookup2, editorFunc, editorParams;
    function defaultLookup(cell2) {
      var value = cell2.getValue(), editor = "input";
      switch (typeof value) {
        case "number":
          editor = "number";
          break;
        case "boolean":
          editor = "tickCross";
          break;
        case "string":
          if (value.includes("\n")) {
            editor = "textarea";
          }
          break;
      }
      return editor;
    }
    lookup2 = params.editorLookup ? params.editorLookup(cell) : defaultLookup(cell);
    if (params.paramsLookup) {
      editorParams = typeof params.paramsLookup === "function" ? params.paramsLookup(lookup2, cell) : params.paramsLookup[lookup2];
    }
    editorFunc = this.table.modules.edit.lookupEditor(lookup2, column);
    return editorFunc.call(this, cell, onRendered, success, cancel, editorParams || {});
  }
  var defaultEditors = {
    input,
    textarea: textarea$1,
    number: number$1,
    range,
    date: date$1,
    time: time$1,
    datetime: datetime$2,
    list,
    star: star$1,
    progress: progress$1,
    tickCross: tickCross$1,
    adaptable: adaptable$1
  };
  const _Edit = class _Edit extends Module {
    constructor(table) {
      super(table);
      this.currentCell = false;
      this.mouseClick = false;
      this.recursionBlock = false;
      this.invalidEdit = false;
      this.editedCells = [];
      this.convertEmptyValues = false;
      this.editors = _Edit.editors;
      this.registerTableOption("editTriggerEvent", "focus");
      this.registerTableOption("editorEmptyValue");
      this.registerTableOption("editorEmptyValueFunc", this.emptyValueCheck.bind(this));
      this.registerColumnOption("editable");
      this.registerColumnOption("editor");
      this.registerColumnOption("editorParams");
      this.registerColumnOption("editorEmptyValue");
      this.registerColumnOption("editorEmptyValueFunc");
      this.registerColumnOption("cellEditing");
      this.registerColumnOption("cellEdited");
      this.registerColumnOption("cellEditCancelled");
      this.registerTableFunction("getEditedCells", this.getEditedCells.bind(this));
      this.registerTableFunction("clearCellEdited", this.clearCellEdited.bind(this));
      this.registerTableFunction("navigatePrev", this.navigatePrev.bind(this));
      this.registerTableFunction("navigateNext", this.navigateNext.bind(this));
      this.registerTableFunction("navigateLeft", this.navigateLeft.bind(this));
      this.registerTableFunction("navigateRight", this.navigateRight.bind(this));
      this.registerTableFunction("navigateUp", this.navigateUp.bind(this));
      this.registerTableFunction("navigateDown", this.navigateDown.bind(this));
      this.registerComponentFunction("cell", "isEdited", this.cellIsEdited.bind(this));
      this.registerComponentFunction("cell", "clearEdited", this.clearEdited.bind(this));
      this.registerComponentFunction("cell", "edit", this.editCell.bind(this));
      this.registerComponentFunction("cell", "cancelEdit", this.cellCancelEdit.bind(this));
      this.registerComponentFunction("cell", "navigatePrev", this.navigatePrev.bind(this));
      this.registerComponentFunction("cell", "navigateNext", this.navigateNext.bind(this));
      this.registerComponentFunction("cell", "navigateLeft", this.navigateLeft.bind(this));
      this.registerComponentFunction("cell", "navigateRight", this.navigateRight.bind(this));
      this.registerComponentFunction("cell", "navigateUp", this.navigateUp.bind(this));
      this.registerComponentFunction("cell", "navigateDown", this.navigateDown.bind(this));
    }
    initialize() {
      this.subscribe("cell-init", this.bindEditor.bind(this));
      this.subscribe("cell-delete", this.clearEdited.bind(this));
      this.subscribe("cell-value-changed", this.updateCellClass.bind(this));
      this.subscribe("column-layout", this.initializeColumnCheck.bind(this));
      this.subscribe("column-delete", this.columnDeleteCheck.bind(this));
      this.subscribe("row-deleting", this.rowDeleteCheck.bind(this));
      this.subscribe("row-layout", this.rowEditableCheck.bind(this));
      this.subscribe("data-refreshing", this.cancelEdit.bind(this));
      this.subscribe("clipboard-paste", this.pasteBlocker.bind(this));
      this.subscribe("keybinding-nav-prev", this.navigatePrev.bind(this, void 0));
      this.subscribe("keybinding-nav-next", this.keybindingNavigateNext.bind(this));
      this.subscribe("keybinding-nav-up", this.navigateUp.bind(this, void 0));
      this.subscribe("keybinding-nav-down", this.navigateDown.bind(this, void 0));
      if (Object.keys(this.table.options).includes("editorEmptyValue")) {
        this.convertEmptyValues = true;
      }
    }
    ///////////////////////////////////
    ///////// Paste Negation //////////
    ///////////////////////////////////
    pasteBlocker(e) {
      if (this.currentCell) {
        return true;
      }
    }
    ///////////////////////////////////
    ////// Keybinding Functions ///////
    ///////////////////////////////////
    keybindingNavigateNext(e) {
      var cell = this.currentCell, newRow = this.options("tabEndNewRow");
      if (cell) {
        if (!this.navigateNext(cell, e)) {
          if (newRow) {
            cell.getElement().firstChild.blur();
            if (!this.invalidEdit) {
              if (newRow === true) {
                newRow = this.table.addRow({});
              } else {
                if (typeof newRow == "function") {
                  newRow = this.table.addRow(newRow(cell.row.getComponent()));
                } else {
                  newRow = this.table.addRow(Object.assign({}, newRow));
                }
              }
              newRow.then(() => {
                setTimeout(() => {
                  cell.getComponent().navigateNext();
                });
              });
            }
          }
        }
      }
    }
    ///////////////////////////////////
    ///////// Cell Functions //////////
    ///////////////////////////////////
    cellIsEdited(cell) {
      return !!cell.modules.edit && cell.modules.edit.edited;
    }
    cellCancelEdit(cell) {
      if (cell === this.currentCell) {
        this.table.modules.edit.cancelEdit();
      } else {
        console.warn("Cancel Editor Error - This cell is not currently being edited ");
      }
    }
    ///////////////////////////////////
    ///////// Table Functions /////////
    ///////////////////////////////////
    updateCellClass(cell) {
      if (this.allowEdit(cell)) {
        cell.getElement().classList.add("tabulator-editable");
      } else {
        cell.getElement().classList.remove("tabulator-editable");
      }
    }
    clearCellEdited(cells) {
      if (!cells) {
        cells = this.table.modules.edit.getEditedCells();
      }
      if (!Array.isArray(cells)) {
        cells = [cells];
      }
      cells.forEach((cell) => {
        this.table.modules.edit.clearEdited(cell._getSelf());
      });
    }
    navigatePrev(cell = this.currentCell, e) {
      var nextCell, prevRow;
      if (cell) {
        if (e) {
          e.preventDefault();
        }
        nextCell = this.navigateLeft();
        if (nextCell) {
          return true;
        } else {
          prevRow = this.table.rowManager.prevDisplayRow(cell.row, true);
          if (prevRow) {
            nextCell = this.findPrevEditableCell(prevRow, prevRow.cells.length);
            if (nextCell) {
              nextCell.getComponent().edit();
              return true;
            }
          }
        }
      }
      return false;
    }
    navigateNext(cell = this.currentCell, e) {
      var nextCell, nextRow;
      if (cell) {
        if (e) {
          e.preventDefault();
        }
        nextCell = this.navigateRight();
        if (nextCell) {
          return true;
        } else {
          nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);
          if (nextRow) {
            nextCell = this.findNextEditableCell(nextRow, -1);
            if (nextCell) {
              nextCell.getComponent().edit();
              return true;
            }
          }
        }
      }
      return false;
    }
    navigateLeft(cell = this.currentCell, e) {
      var index2, nextCell;
      if (cell) {
        if (e) {
          e.preventDefault();
        }
        index2 = cell.getIndex();
        nextCell = this.findPrevEditableCell(cell.row, index2);
        if (nextCell) {
          nextCell.getComponent().edit();
          return true;
        }
      }
      return false;
    }
    navigateRight(cell = this.currentCell, e) {
      var index2, nextCell;
      if (cell) {
        if (e) {
          e.preventDefault();
        }
        index2 = cell.getIndex();
        nextCell = this.findNextEditableCell(cell.row, index2);
        if (nextCell) {
          nextCell.getComponent().edit();
          return true;
        }
      }
      return false;
    }
    navigateUp(cell = this.currentCell, e) {
      var index2, nextRow;
      if (cell) {
        if (e) {
          e.preventDefault();
        }
        index2 = cell.getIndex();
        nextRow = this.table.rowManager.prevDisplayRow(cell.row, true);
        if (nextRow) {
          nextRow.cells[index2].getComponent().edit();
          return true;
        }
      }
      return false;
    }
    navigateDown(cell = this.currentCell, e) {
      var index2, nextRow;
      if (cell) {
        if (e) {
          e.preventDefault();
        }
        index2 = cell.getIndex();
        nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);
        if (nextRow) {
          nextRow.cells[index2].getComponent().edit();
          return true;
        }
      }
      return false;
    }
    findNextEditableCell(row, index2) {
      var nextCell = false;
      if (index2 < row.cells.length - 1) {
        for (var i2 = index2 + 1; i2 < row.cells.length; i2++) {
          let cell = row.cells[i2];
          if (cell.column.modules.edit && Helpers.elVisible(cell.getElement())) {
            let allowEdit = this.allowEdit(cell);
            if (allowEdit) {
              nextCell = cell;
              break;
            }
          }
        }
      }
      return nextCell;
    }
    findPrevEditableCell(row, index2) {
      var prevCell = false;
      if (index2 > 0) {
        for (var i2 = index2 - 1; i2 >= 0; i2--) {
          let cell = row.cells[i2];
          if (cell.column.modules.edit && Helpers.elVisible(cell.getElement())) {
            let allowEdit = this.allowEdit(cell);
            if (allowEdit) {
              prevCell = cell;
              break;
            }
          }
        }
      }
      return prevCell;
    }
    ///////////////////////////////////
    ///////// Internal Logic //////////
    ///////////////////////////////////
    initializeColumnCheck(column) {
      if (typeof column.definition.editor !== "undefined") {
        this.initializeColumn(column);
      }
    }
    columnDeleteCheck(column) {
      if (this.currentCell && this.currentCell.column === column) {
        this.cancelEdit();
      }
    }
    rowDeleteCheck(row) {
      if (this.currentCell && this.currentCell.row === row) {
        this.cancelEdit();
      }
    }
    rowEditableCheck(row) {
      row.getCells().forEach((cell) => {
        if (cell.column.modules.edit && typeof cell.column.modules.edit.check === "function") {
          this.updateCellClass(cell);
        }
      });
    }
    //initialize column editor
    initializeColumn(column) {
      var convertEmpty = Object.keys(column.definition).includes("editorEmptyValue");
      var config = {
        editor: false,
        blocked: false,
        check: column.definition.editable,
        params: column.definition.editorParams || {},
        convertEmptyValues: convertEmpty,
        editorEmptyValue: column.definition.editorEmptyValue,
        editorEmptyValueFunc: column.definition.editorEmptyValueFunc
      };
      config.editor = this.lookupEditor(column.definition.editor, column);
      if (config.editor) {
        column.modules.edit = config;
      }
    }
    lookupEditor(editor, column) {
      var editorFunc;
      switch (typeof editor) {
        case "string":
          if (this.editors[editor]) {
            editorFunc = this.editors[editor];
          } else {
            console.warn("Editor Error - No such editor found: ", editor);
          }
          break;
        case "function":
          editorFunc = editor;
          break;
        case "boolean":
          if (editor === true) {
            if (typeof column.definition.formatter !== "function") {
              if (this.editors[column.definition.formatter]) {
                editorFunc = this.editors[column.definition.formatter];
              } else {
                editorFunc = this.editors["input"];
              }
            } else {
              console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", column.definition.formatter);
            }
          }
          break;
      }
      return editorFunc;
    }
    getCurrentCell() {
      return this.currentCell ? this.currentCell.getComponent() : false;
    }
    clearEditor(cancel) {
      var cell = this.currentCell, cellEl;
      this.invalidEdit = false;
      if (cell) {
        this.currentCell = false;
        cellEl = cell.getElement();
        this.dispatch("edit-editor-clear", cell, cancel);
        cellEl.classList.remove("tabulator-editing");
        while (cellEl.firstChild) cellEl.removeChild(cellEl.firstChild);
        cell.row.getElement().classList.remove("tabulator-editing");
        cell.table.element.classList.remove("tabulator-editing");
      }
    }
    cancelEdit() {
      if (this.currentCell) {
        var cell = this.currentCell;
        var component = this.currentCell.getComponent();
        this.clearEditor(true);
        cell.setValueActual(cell.getValue());
        cell.cellRendered();
        if (cell.column.definition.editor == "textarea" || cell.column.definition.variableHeight) {
          cell.row.normalizeHeight(true);
        }
        if (cell.column.definition.cellEditCancelled) {
          cell.column.definition.cellEditCancelled.call(this.table, component);
        }
        this.dispatch("edit-cancelled", cell);
        this.dispatchExternal("cellEditCancelled", component);
      }
    }
    //return a formatted value for a cell
    bindEditor(cell) {
      if (cell.column.modules.edit) {
        var self2 = this, element = cell.getElement(true);
        this.updateCellClass(cell);
        element.setAttribute("tabindex", 0);
        element.addEventListener("mousedown", function(e) {
          if (e.button === 2) {
            e.preventDefault();
          } else {
            self2.mouseClick = true;
          }
        });
        if (this.options("editTriggerEvent") === "dblclick") {
          element.addEventListener("dblclick", function(e) {
            if (!element.classList.contains("tabulator-editing")) {
              element.focus({ preventScroll: true });
              self2.edit(cell, e, false);
            }
          });
        }
        if (this.options("editTriggerEvent") === "focus" || this.options("editTriggerEvent") === "click") {
          element.addEventListener("click", function(e) {
            if (!element.classList.contains("tabulator-editing")) {
              element.focus({ preventScroll: true });
              self2.edit(cell, e, false);
            }
          });
        }
        if (this.options("editTriggerEvent") === "focus") {
          element.addEventListener("focus", function(e) {
            if (!self2.recursionBlock) {
              self2.edit(cell, e, false);
            }
          });
        }
      }
    }
    focusCellNoEvent(cell, block) {
      this.recursionBlock = true;
      if (!(block && this.table.browser === "ie")) {
        cell.getElement().focus({ preventScroll: true });
      }
      this.recursionBlock = false;
    }
    editCell(cell, forceEdit) {
      this.focusCellNoEvent(cell);
      this.edit(cell, false, forceEdit);
    }
    focusScrollAdjust(cell) {
      if (this.table.rowManager.getRenderMode() == "virtual") {
        var topEdge = this.table.rowManager.element.scrollTop, bottomEdge = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop, rowEl = cell.row.getElement();
        if (rowEl.offsetTop < topEdge) {
          this.table.rowManager.element.scrollTop -= topEdge - rowEl.offsetTop;
        } else {
          if (rowEl.offsetTop + rowEl.offsetHeight > bottomEdge) {
            this.table.rowManager.element.scrollTop += rowEl.offsetTop + rowEl.offsetHeight - bottomEdge;
          }
        }
        var leftEdge = this.table.rowManager.element.scrollLeft, rightEdge = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft, cellEl = cell.getElement();
        if (this.table.modExists("frozenColumns")) {
          leftEdge += parseInt(this.table.modules.frozenColumns.leftMargin || 0);
          rightEdge -= parseInt(this.table.modules.frozenColumns.rightMargin || 0);
        }
        if (this.table.options.renderHorizontal === "virtual") {
          leftEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
          rightEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
        }
        if (cellEl.offsetLeft < leftEdge) {
          this.table.rowManager.element.scrollLeft -= leftEdge - cellEl.offsetLeft;
        } else {
          if (cellEl.offsetLeft + cellEl.offsetWidth > rightEdge) {
            this.table.rowManager.element.scrollLeft += cellEl.offsetLeft + cellEl.offsetWidth - rightEdge;
          }
        }
      }
    }
    allowEdit(cell) {
      var check = cell.column.modules.edit ? true : false;
      if (cell.column.modules.edit) {
        switch (typeof cell.column.modules.edit.check) {
          case "function":
            if (cell.row.initialized) {
              check = cell.column.modules.edit.check(cell.getComponent());
            }
            break;
          case "string":
            check = !!cell.row.data[cell.column.modules.edit.check];
            break;
          case "boolean":
            check = cell.column.modules.edit.check;
            break;
        }
      }
      return check;
    }
    edit(cell, e, forceEdit) {
      var self2 = this, allowEdit = true, rendered = function() {
      }, element = cell.getElement(), editFinished = false, cellEditor, component, params;
      if (this.currentCell) {
        if (!this.invalidEdit && this.currentCell !== cell) {
          this.cancelEdit();
        }
        return;
      }
      function success(value) {
        if (self2.currentCell === cell && !editFinished) {
          var valid = self2.chain("edit-success", [cell, value], true, true);
          if (valid === true || self2.table.options.validationMode === "highlight") {
            editFinished = true;
            self2.clearEditor();
            if (!cell.modules.edit) {
              cell.modules.edit = {};
            }
            cell.modules.edit.edited = true;
            if (self2.editedCells.indexOf(cell) == -1) {
              self2.editedCells.push(cell);
            }
            value = self2.transformEmptyValues(value, cell);
            cell.setValue(value, true);
            return valid === true;
          } else {
            editFinished = true;
            self2.invalidEdit = true;
            self2.focusCellNoEvent(cell, true);
            rendered();
            setTimeout(() => {
              editFinished = false;
            }, 10);
            return false;
          }
        }
      }
      function cancel() {
        if (self2.currentCell === cell && !editFinished) {
          self2.cancelEdit();
        }
      }
      function onRendered(callback) {
        rendered = callback;
      }
      if (!cell.column.modules.edit.blocked) {
        if (e) {
          e.stopPropagation();
        }
        allowEdit = this.allowEdit(cell);
        if (allowEdit || forceEdit) {
          self2.cancelEdit();
          self2.currentCell = cell;
          this.focusScrollAdjust(cell);
          component = cell.getComponent();
          if (this.mouseClick) {
            this.mouseClick = false;
            if (cell.column.definition.cellClick) {
              cell.column.definition.cellClick.call(this.table, e, component);
            }
          }
          if (cell.column.definition.cellEditing) {
            cell.column.definition.cellEditing.call(this.table, component);
          }
          this.dispatch("cell-editing", cell);
          this.dispatchExternal("cellEditing", component);
          params = typeof cell.column.modules.edit.params === "function" ? cell.column.modules.edit.params(component) : cell.column.modules.edit.params;
          cellEditor = cell.column.modules.edit.editor.call(self2, component, onRendered, success, cancel, params);
          if (this.currentCell && cellEditor !== false) {
            if (cellEditor instanceof Node) {
              element.classList.add("tabulator-editing");
              cell.row.getElement().classList.add("tabulator-editing");
              cell.table.element.classList.add("tabulator-editing");
              while (element.firstChild) element.removeChild(element.firstChild);
              element.appendChild(cellEditor);
              rendered();
              var children = element.children;
              for (var i2 = 0; i2 < children.length; i2++) {
                children[i2].addEventListener("click", function(e2) {
                  e2.stopPropagation();
                });
              }
            } else {
              console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", cellEditor);
              this.blur(element);
              return false;
            }
          } else {
            this.blur(element);
            return false;
          }
          return true;
        } else {
          this.mouseClick = false;
          this.blur(element);
          return false;
        }
      } else {
        this.mouseClick = false;
        this.blur(element);
        return false;
      }
    }
    emptyValueCheck(value) {
      return value === "" || value === null || typeof value === "undefined";
    }
    transformEmptyValues(value, cell) {
      var mod = cell.column.modules.edit, convert = mod.convertEmptyValues || this.convertEmptyValues, checkFunc;
      if (convert) {
        checkFunc = mod.editorEmptyValueFunc || this.options("editorEmptyValueFunc");
        if (checkFunc && checkFunc(value)) {
          value = mod.convertEmptyValues ? mod.editorEmptyValue : this.options("editorEmptyValue");
        }
      }
      return value;
    }
    blur(element) {
      if (!this.confirm("edit-blur", [element])) {
        element.blur();
      }
    }
    getEditedCells() {
      var output = [];
      this.editedCells.forEach((cell) => {
        output.push(cell.getComponent());
      });
      return output;
    }
    clearEdited(cell) {
      var editIndex;
      if (cell.modules.edit && cell.modules.edit.edited) {
        cell.modules.edit.edited = false;
        this.dispatch("edit-edited-clear", cell);
      }
      editIndex = this.editedCells.indexOf(cell);
      if (editIndex > -1) {
        this.editedCells.splice(editIndex, 1);
      }
    }
  };
  __publicField(_Edit, "moduleName", "edit");
  //load defaults
  __publicField(_Edit, "editors", defaultEditors);
  let Edit = _Edit;
  class ExportRow {
    constructor(type, columns, component, indent) {
      this.type = type;
      this.columns = columns;
      this.component = component || false;
      this.indent = indent || 0;
    }
  }
  class ExportColumn {
    constructor(value, component, width, height, depth) {
      this.value = value;
      this.component = component || false;
      this.width = width;
      this.height = height;
      this.depth = depth;
    }
  }
  var columnLookups$1 = {};
  var rowLookups$1 = {
    visible: function() {
      return this.rowManager.getVisibleRows(false, true);
    },
    all: function() {
      return this.rowManager.rows;
    },
    selected: function() {
      return this.modules.selectRow.selectedRows;
    },
    active: function() {
      if (this.options.pagination) {
        return this.rowManager.getDisplayRows(this.rowManager.displayRows.length - 2);
      } else {
        return this.rowManager.getDisplayRows();
      }
    }
  };
  const _Export = class _Export extends Module {
    constructor(table) {
      super(table);
      this.config = {};
      this.cloneTableStyle = true;
      this.colVisProp = "";
      this.colVisPropAttach = "";
      this.registerTableOption("htmlOutputConfig", false);
      this.registerColumnOption("htmlOutput");
      this.registerColumnOption("titleHtmlOutput");
    }
    initialize() {
      this.registerTableFunction("getHtml", this.getHtml.bind(this));
    }
    ///////////////////////////////////
    ///////// Internal Logic //////////
    ///////////////////////////////////
    generateExportList(config, style, range2, colVisProp) {
      var headers, body, columns, colLookup;
      this.cloneTableStyle = style;
      this.config = config || {};
      this.colVisProp = colVisProp;
      this.colVisPropAttach = this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1);
      colLookup = _Export.columnLookups[range2];
      if (colLookup) {
        columns = colLookup.call(this.table);
        columns = columns.filter((col) => this.columnVisCheck(col));
      }
      headers = this.config.columnHeaders !== false ? this.headersToExportRows(this.generateColumnGroupHeaders(columns)) : [];
      if (columns) {
        columns = columns.map((col) => col.getComponent());
      }
      body = this.bodyToExportRows(this.rowLookup(range2), columns);
      return headers.concat(body);
    }
    generateTable(config, style, range2, colVisProp) {
      var list2 = this.generateExportList(config, style, range2, colVisProp);
      return this.generateTableElement(list2);
    }
    rowLookup(range2) {
      var rows = [], rowLookup;
      if (typeof range2 == "function") {
        range2.call(this.table).forEach((row) => {
          row = this.table.rowManager.findRow(row);
          if (row) {
            rows.push(row);
          }
        });
      } else {
        rowLookup = _Export.rowLookups[range2] || _Export.rowLookups["active"];
        rows = rowLookup.call(this.table);
      }
      return Object.assign([], rows);
    }
    generateColumnGroupHeaders(columns) {
      var output = [];
      if (!columns) {
        columns = this.config.columnGroups !== false ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;
      }
      columns.forEach((column) => {
        var colData = this.processColumnGroup(column);
        if (colData) {
          output.push(colData);
        }
      });
      return output;
    }
    processColumnGroup(column) {
      var subGroups = column.columns, maxDepth = 0, title = column.definition["title" + this.colVisPropAttach] || column.definition.title;
      var groupData = {
        title,
        column,
        depth: 1
      };
      if (subGroups.length) {
        groupData.subGroups = [];
        groupData.width = 0;
        subGroups.forEach((subGroup) => {
          var subGroupData = this.processColumnGroup(subGroup);
          if (subGroupData) {
            groupData.width += subGroupData.width;
            groupData.subGroups.push(subGroupData);
            if (subGroupData.depth > maxDepth) {
              maxDepth = subGroupData.depth;
            }
          }
        });
        groupData.depth += maxDepth;
        if (!groupData.width) {
          return false;
        }
      } else {
        if (this.columnVisCheck(column)) {
          groupData.width = 1;
        } else {
          return false;
        }
      }
      return groupData;
    }
    columnVisCheck(column) {
      var visProp = column.definition[this.colVisProp];
      if (this.config.rowHeaders === false && column.isRowHeader) {
        return false;
      }
      if (typeof visProp === "function") {
        visProp = visProp.call(this.table, column.getComponent());
      }
      if (visProp === false || visProp === true) {
        return visProp;
      }
      return column.visible && column.field;
    }
    headersToExportRows(columns) {
      var headers = [], headerDepth = 0, exportRows = [];
      function parseColumnGroup(column, level) {
        var depth = headerDepth - level;
        if (typeof headers[level] === "undefined") {
          headers[level] = [];
        }
        column.height = column.subGroups ? 1 : depth - column.depth + 1;
        headers[level].push(column);
        if (column.height > 1) {
          for (let i2 = 1; i2 < column.height; i2++) {
            if (typeof headers[level + i2] === "undefined") {
              headers[level + i2] = [];
            }
            headers[level + i2].push(false);
          }
        }
        if (column.width > 1) {
          for (let i2 = 1; i2 < column.width; i2++) {
            headers[level].push(false);
          }
        }
        if (column.subGroups) {
          column.subGroups.forEach(function(subGroup) {
            parseColumnGroup(subGroup, level + 1);
          });
        }
      }
      columns.forEach(function(column) {
        if (column.depth > headerDepth) {
          headerDepth = column.depth;
        }
      });
      columns.forEach(function(column) {
        parseColumnGroup(column, 0);
      });
      headers.forEach((header) => {
        var columns2 = [];
        header.forEach((col) => {
          if (col) {
            let title = typeof col.title === "undefined" ? "" : col.title;
            columns2.push(new ExportColumn(title, col.column.getComponent(), col.width, col.height, col.depth));
          } else {
            columns2.push(null);
          }
        });
        exportRows.push(new ExportRow("header", columns2));
      });
      return exportRows;
    }
    bodyToExportRows(rows, columns = []) {
      var exportRows = [];
      if (columns.length === 0) {
        this.table.columnManager.columnsByIndex.forEach((column) => {
          if (this.columnVisCheck(column)) {
            columns.push(column.getComponent());
          }
        });
      }
      if (this.config.columnCalcs !== false && this.table.modExists("columnCalcs")) {
        if (this.table.modules.columnCalcs.topInitialized) {
          rows.unshift(this.table.modules.columnCalcs.topRow);
        }
        if (this.table.modules.columnCalcs.botInitialized) {
          rows.push(this.table.modules.columnCalcs.botRow);
        }
      }
      rows = rows.filter((row) => {
        switch (row.type) {
          case "group":
            return this.config.rowGroups !== false;
          case "calc":
            return this.config.columnCalcs !== false;
          case "row":
            return !(this.table.options.dataTree && this.config.dataTree === false && row.modules.dataTree.parent);
        }
        return true;
      });
      rows.forEach((row, i2) => {
        var rowData = row.getData(this.colVisProp);
        var exportCols = [];
        var indent = 0;
        switch (row.type) {
          case "group":
            indent = row.level;
            exportCols.push(new ExportColumn(row.key, row.getComponent(), columns.length, 1));
            break;
          case "calc":
          case "row":
            columns.forEach((col) => {
              exportCols.push(new ExportColumn(col._column.getFieldValue(rowData), col, 1, 1));
            });
            if (this.table.options.dataTree && this.config.dataTree !== false) {
              indent = row.modules.dataTree.index;
            }
            break;
        }
        exportRows.push(new ExportRow(row.type, exportCols, row.getComponent(), indent));
      });
      return exportRows;
    }
    generateTableElement(list2) {
      var table = document.createElement("table"), headerEl = document.createElement("thead"), bodyEl = document.createElement("tbody"), styles = this.lookupTableStyles(), rowFormatter = this.table.options["rowFormatter" + this.colVisPropAttach], setup = {};
      setup.rowFormatter = rowFormatter !== null ? rowFormatter : this.table.options.rowFormatter;
      if (this.table.options.dataTree && this.config.dataTree !== false && this.table.modExists("columnCalcs")) {
        setup.treeElementField = this.table.modules.dataTree.elementField;
      }
      setup.groupHeader = this.table.options["groupHeader" + this.colVisPropAttach];
      if (setup.groupHeader && !Array.isArray(setup.groupHeader)) {
        setup.groupHeader = [setup.groupHeader];
      }
      table.classList.add("tabulator-print-table");
      this.mapElementStyles(this.table.columnManager.getHeadersElement(), headerEl, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);
      if (list2.length > 1e3) {
        console.warn("It may take a long time to render an HTML table with more than 1000 rows");
      }
      list2.forEach((row, i2) => {
        let rowEl;
        switch (row.type) {
          case "header":
            headerEl.appendChild(this.generateHeaderElement(row, setup, styles));
            break;
          case "group":
            bodyEl.appendChild(this.generateGroupElement(row, setup, styles));
            break;
          case "calc":
            bodyEl.appendChild(this.generateCalcElement(row, setup, styles));
            break;
          case "row":
            rowEl = this.generateRowElement(row, setup, styles);
            this.mapElementStyles(i2 % 2 && styles.evenRow ? styles.evenRow : styles.oddRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
            bodyEl.appendChild(rowEl);
            break;
        }
      });
      if (headerEl.innerHTML) {
        table.appendChild(headerEl);
      }
      table.appendChild(bodyEl);
      this.mapElementStyles(this.table.element, table, ["border-top", "border-left", "border-right", "border-bottom"]);
      return table;
    }
    lookupTableStyles() {
      var styles = {};
      if (this.cloneTableStyle && window.getComputedStyle) {
        styles.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)");
        styles.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)");
        styles.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs");
        styles.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)");
        styles.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0];
        if (styles.firstRow) {
          styles.styleCells = styles.firstRow.getElementsByClassName("tabulator-cell");
          styles.styleRowHeader = styles.firstRow.getElementsByClassName("tabulator-row-header")[0];
          styles.firstCell = styles.styleCells[0];
          styles.lastCell = styles.styleCells[styles.styleCells.length - 1];
        }
      }
      return styles;
    }
    generateHeaderElement(row, setup, styles) {
      var rowEl = document.createElement("tr");
      row.columns.forEach((column) => {
        if (column) {
          var cellEl = document.createElement("th");
          var classNames = column.component._column.definition.cssClass ? column.component._column.definition.cssClass.split(" ") : [];
          cellEl.colSpan = column.width;
          cellEl.rowSpan = column.height;
          cellEl.innerHTML = column.value;
          if (this.cloneTableStyle) {
            cellEl.style.boxSizing = "border-box";
          }
          classNames.forEach(function(className) {
            cellEl.classList.add(className);
          });
          this.mapElementStyles(column.component.getElement(), cellEl, ["text-align", "border-left", "border-right", "background-color", "color", "font-weight", "font-family", "font-size"]);
          this.mapElementStyles(column.component._column.contentElement, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);
          if (column.component._column.visible) {
            this.mapElementStyles(column.component.getElement(), cellEl, ["width"]);
          } else {
            if (column.component._column.definition.width) {
              cellEl.style.width = column.component._column.definition.width + "px";
            }
          }
          if (column.component._column.parent && column.component._column.parent.isGroup) {
            this.mapElementStyles(column.component._column.parent.groupElement, cellEl, ["border-top"]);
          } else {
            this.mapElementStyles(column.component.getElement(), cellEl, ["border-top"]);
          }
          if (column.component._column.isGroup) {
            this.mapElementStyles(column.component.getElement(), cellEl, ["border-bottom"]);
          } else {
            this.mapElementStyles(this.table.columnManager.getElement(), cellEl, ["border-bottom"]);
          }
          rowEl.appendChild(cellEl);
        }
      });
      return rowEl;
    }
    generateGroupElement(row, setup, styles) {
      var rowEl = document.createElement("tr"), cellEl = document.createElement("td"), group = row.columns[0];
      rowEl.classList.add("tabulator-print-table-row");
      if (setup.groupHeader && setup.groupHeader[row.indent]) {
        group.value = setup.groupHeader[row.indent](group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
      } else {
        if (setup.groupHeader !== false) {
          group.value = row.component._group.generator(group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
        }
      }
      cellEl.colSpan = group.width;
      cellEl.innerHTML = group.value;
      rowEl.classList.add("tabulator-print-table-group");
      rowEl.classList.add("tabulator-group-level-" + row.indent);
      if (group.component.isVisible()) {
        rowEl.classList.add("tabulator-group-visible");
      }
      this.mapElementStyles(styles.firstGroup, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
      this.mapElementStyles(styles.firstGroup, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);
      rowEl.appendChild(cellEl);
      return rowEl;
    }
    generateCalcElement(row, setup, styles) {
      var rowEl = this.generateRowElement(row, setup, styles);
      rowEl.classList.add("tabulator-print-table-calcs");
      this.mapElementStyles(styles.calcRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
      return rowEl;
    }
    generateRowElement(row, setup, styles) {
      var rowEl = document.createElement("tr");
      rowEl.classList.add("tabulator-print-table-row");
      row.columns.forEach((col, i2) => {
        if (col) {
          var cellEl = document.createElement("td"), column = col.component._column, table = this.table, index2 = table.columnManager.findColumnIndex(column), value = col.value, cellStyle, styleProps;
          var cellWrapper = {
            modules: {},
            getValue: function() {
              return value;
            },
            getField: function() {
              return column.definition.field;
            },
            getElement: function() {
              return cellEl;
            },
            getType: function() {
              return "cell";
            },
            getColumn: function() {
              return column.getComponent();
            },
            getData: function() {
              return row.component.getData();
            },
            getRow: function() {
              return row.component;
            },
            getTable: function() {
              return table;
            },
            getComponent: function() {
              return cellWrapper;
            },
            column
          };
          var classNames = column.definition.cssClass ? column.definition.cssClass.split(" ") : [];
          classNames.forEach(function(className) {
            cellEl.classList.add(className);
          });
          if (this.table.modExists("format") && this.config.formatCells !== false) {
            value = this.table.modules.format.formatExportValue(cellWrapper, this.colVisProp);
          } else {
            switch (typeof value) {
              case "object":
                value = value !== null ? JSON.stringify(value) : "";
                break;
              case "undefined":
                value = "";
                break;
            }
          }
          if (value instanceof Node) {
            cellEl.appendChild(value);
          } else {
            cellEl.innerHTML = value;
          }
          styleProps = ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "text-align"];
          if (column.isRowHeader) {
            cellStyle = styles.styleRowHeader;
            styleProps.push("background-color");
          } else {
            cellStyle = styles.styleCells && styles.styleCells[index2] ? styles.styleCells[index2] : styles.firstCell;
          }
          if (cellStyle) {
            this.mapElementStyles(cellStyle, cellEl, styleProps);
            if (column.definition.align) {
              cellEl.style.textAlign = column.definition.align;
            }
          }
          if (this.table.options.dataTree && this.config.dataTree !== false) {
            if (setup.treeElementField && setup.treeElementField == column.field || !setup.treeElementField && i2 == 0) {
              if (row.component._row.modules.dataTree.controlEl) {
                cellEl.insertBefore(row.component._row.modules.dataTree.controlEl.cloneNode(true), cellEl.firstChild);
              }
              if (row.component._row.modules.dataTree.branchEl) {
                cellEl.insertBefore(row.component._row.modules.dataTree.branchEl.cloneNode(true), cellEl.firstChild);
              }
            }
          }
          rowEl.appendChild(cellEl);
          if (cellWrapper.modules.format && cellWrapper.modules.format.renderedCallback) {
            cellWrapper.modules.format.renderedCallback();
          }
        }
      });
      if (setup.rowFormatter && row.type === "row" && this.config.formatCells !== false) {
        let formatComponent = Object.assign(row.component);
        formatComponent.getElement = function() {
          return rowEl;
        };
        setup.rowFormatter(row.component);
      }
      return rowEl;
    }
    generateHTMLTable(list2) {
      var holder = document.createElement("div");
      holder.appendChild(this.generateTableElement(list2));
      return holder.innerHTML;
    }
    getHtml(visible, style, config, colVisProp) {
      var list2 = this.generateExportList(config || this.table.options.htmlOutputConfig, style, visible, colVisProp || "htmlOutput");
      return this.generateHTMLTable(list2);
    }
    mapElementStyles(from, to2, props) {
      if (this.cloneTableStyle && from && to2) {
        var lookup2 = {
          "background-color": "backgroundColor",
          "color": "fontColor",
          "width": "width",
          "font-weight": "fontWeight",
          "font-family": "fontFamily",
          "font-size": "fontSize",
          "text-align": "textAlign",
          "border-top": "borderTop",
          "border-left": "borderLeft",
          "border-right": "borderRight",
          "border-bottom": "borderBottom",
          "padding-top": "paddingTop",
          "padding-left": "paddingLeft",
          "padding-right": "paddingRight",
          "padding-bottom": "paddingBottom"
        };
        if (window.getComputedStyle) {
          var fromStyle = window.getComputedStyle(from);
          props.forEach(function(prop) {
            if (!to2.style[lookup2[prop]]) {
              to2.style[lookup2[prop]] = fromStyle.getPropertyValue(prop);
            }
          });
        }
      }
    }
  };
  __publicField(_Export, "moduleName", "export");
  __publicField(_Export, "columnLookups", columnLookups$1);
  __publicField(_Export, "rowLookups", rowLookups$1);
  let Export = _Export;
  function plaintext(cell, formatterParams, onRendered) {
    return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
  }
  function html(cell, formatterParams, onRendered) {
    return cell.getValue();
  }
  function textarea(cell, formatterParams, onRendered) {
    cell.getElement().style.whiteSpace = "pre-wrap";
    return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
  }
  function money(cell, formatterParams, onRendered) {
    var floatVal = parseFloat(cell.getValue()), sign = "", number, integer, decimal, rgx, value;
    var decimalSym = formatterParams.decimal || ".";
    var thousandSym = formatterParams.thousand || ",";
    var negativeSign = formatterParams.negativeSign || "-";
    var symbol = formatterParams.symbol || "";
    var after = !!formatterParams.symbolAfter;
    var precision = typeof formatterParams.precision !== "undefined" ? formatterParams.precision : 2;
    if (isNaN(floatVal)) {
      return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
    }
    if (floatVal < 0) {
      floatVal = Math.abs(floatVal);
      sign = negativeSign;
    }
    number = precision !== false ? floatVal.toFixed(precision) : floatVal;
    number = String(number).split(".");
    integer = number[0];
    decimal = number.length > 1 ? decimalSym + number[1] : "";
    if (formatterParams.thousand !== false) {
      rgx = /(\d+)(\d{3})/;
      while (rgx.test(integer)) {
        integer = integer.replace(rgx, "$1" + thousandSym + "$2");
      }
    }
    value = integer + decimal;
    if (sign === true) {
      value = "(" + value + ")";
      return after ? value + symbol : symbol + value;
    } else {
      return after ? sign + value + symbol : sign + symbol + value;
    }
  }
  function link(cell, formatterParams, onRendered) {
    var value = cell.getValue(), urlPrefix = formatterParams.urlPrefix || "", download = formatterParams.download, label = value, el = document.createElement("a"), data;
    function labelTraverse(path, data2) {
      var item = path.shift(), value2 = data2[item];
      if (path.length && typeof value2 === "object") {
        return labelTraverse(path, value2);
      }
      return value2;
    }
    if (formatterParams.labelField) {
      data = cell.getData();
      label = labelTraverse(formatterParams.labelField.split(this.table.options.nestedFieldSeparator), data);
    }
    if (formatterParams.label) {
      switch (typeof formatterParams.label) {
        case "string":
          label = formatterParams.label;
          break;
        case "function":
          label = formatterParams.label(cell);
          break;
      }
    }
    if (label) {
      if (formatterParams.urlField) {
        data = cell.getData();
        value = Helpers.retrieveNestedData(this.table.options.nestedFieldSeparator, formatterParams.urlField, data);
      }
      if (formatterParams.url) {
        switch (typeof formatterParams.url) {
          case "string":
            value = formatterParams.url;
            break;
          case "function":
            value = formatterParams.url(cell);
            break;
        }
      }
      el.setAttribute("href", urlPrefix + value);
      if (formatterParams.target) {
        el.setAttribute("target", formatterParams.target);
      }
      if (formatterParams.download) {
        if (typeof download == "function") {
          download = download(cell);
        } else {
          download = download === true ? "" : download;
        }
        el.setAttribute("download", download);
      }
      el.innerHTML = this.emptyToSpace(this.sanitizeHTML(label));
      return el;
    } else {
      return "&nbsp;";
    }
  }
  function image(cell, formatterParams, onRendered) {
    var el = document.createElement("img"), src = cell.getValue();
    if (formatterParams.urlPrefix) {
      src = formatterParams.urlPrefix + cell.getValue();
    }
    if (formatterParams.urlSuffix) {
      src = src + formatterParams.urlSuffix;
    }
    el.setAttribute("src", src);
    switch (typeof formatterParams.height) {
      case "number":
        el.style.height = formatterParams.height + "px";
        break;
      case "string":
        el.style.height = formatterParams.height;
        break;
    }
    switch (typeof formatterParams.width) {
      case "number":
        el.style.width = formatterParams.width + "px";
        break;
      case "string":
        el.style.width = formatterParams.width;
        break;
    }
    el.addEventListener("load", function() {
      cell.getRow().normalizeHeight();
    });
    return el;
  }
  function tickCross(cell, formatterParams, onRendered) {
    var value = cell.getValue(), element = cell.getElement(), empty = formatterParams.allowEmpty, truthy = formatterParams.allowTruthy, trueValueSet = Object.keys(formatterParams).includes("trueValue"), tick = typeof formatterParams.tickElement !== "undefined" ? formatterParams.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>', cross = typeof formatterParams.crossElement !== "undefined" ? formatterParams.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
    if (trueValueSet && value === formatterParams.trueValue || !trueValueSet && (truthy && value || (value === true || value === "true" || value === "True" || value === 1 || value === "1"))) {
      element.setAttribute("aria-checked", true);
      return tick || "";
    } else {
      if (empty && (value === "null" || value === "" || value === null || typeof value === "undefined")) {
        element.setAttribute("aria-checked", "mixed");
        return "";
      } else {
        element.setAttribute("aria-checked", false);
        return cross || "";
      }
    }
  }
  function datetime$1(cell, formatterParams, onRendered) {
    var DT = this.table.dependencyRegistry.lookup(["luxon", "DateTime"], "DateTime");
    var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
    var outputFormat = formatterParams.outputFormat || "dd/MM/yyyy HH:mm:ss";
    var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
    var value = cell.getValue();
    if (typeof DT != "undefined") {
      var newDatetime;
      if (DT.isDateTime(value)) {
        newDatetime = value;
      } else if (inputFormat === "iso") {
        newDatetime = DT.fromISO(String(value));
      } else {
        newDatetime = DT.fromFormat(String(value), inputFormat);
      }
      if (newDatetime.isValid) {
        if (formatterParams.timezone) {
          newDatetime = newDatetime.setZone(formatterParams.timezone);
        }
        return newDatetime.toFormat(outputFormat);
      } else {
        if (invalid === true || !value) {
          return value;
        } else if (typeof invalid === "function") {
          return invalid(value);
        } else {
          return invalid;
        }
      }
    } else {
      console.error("Format Error - 'datetime' formatter is dependant on luxon.js");
    }
  }
  function datetimediff(cell, formatterParams, onRendered) {
    var DT = this.table.dependencyRegistry.lookup(["luxon", "DateTime"], "DateTime");
    var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
    var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
    var suffix = typeof formatterParams.suffix !== "undefined" ? formatterParams.suffix : false;
    var unit = typeof formatterParams.unit !== "undefined" ? formatterParams.unit : "days";
    var humanize = typeof formatterParams.humanize !== "undefined" ? formatterParams.humanize : false;
    var date = typeof formatterParams.date !== "undefined" ? formatterParams.date : DT.now();
    var value = cell.getValue();
    if (typeof DT != "undefined") {
      var newDatetime;
      if (DT.isDateTime(value)) {
        newDatetime = value;
      } else if (inputFormat === "iso") {
        newDatetime = DT.fromISO(String(value));
      } else {
        newDatetime = DT.fromFormat(String(value), inputFormat);
      }
      if (newDatetime.isValid) {
        if (humanize) {
          return newDatetime.diff(date, unit).toHuman() + (suffix ? " " + suffix : "");
        } else {
          return parseInt(newDatetime.diff(date, unit)[unit]) + (suffix ? " " + suffix : "");
        }
      } else {
        if (invalid === true) {
          return value;
        } else if (typeof invalid === "function") {
          return invalid(value);
        } else {
          return invalid;
        }
      }
    } else {
      console.error("Format Error - 'datetimediff' formatter is dependant on luxon.js");
    }
  }
  function lookup(cell, formatterParams, onRendered) {
    var value = cell.getValue();
    if (typeof formatterParams[value] === "undefined") {
      console.warn("Missing display value for " + value);
      return value;
    }
    return formatterParams[value];
  }
  function star(cell, formatterParams, onRendered) {
    var value = cell.getValue(), element = cell.getElement(), maxStars = formatterParams && formatterParams.stars ? formatterParams.stars : 5, stars = document.createElement("span"), star2 = document.createElementNS("http://www.w3.org/2000/svg", "svg"), starActive = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>', starInactive = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
    stars.style.verticalAlign = "middle";
    star2.setAttribute("width", "14");
    star2.setAttribute("height", "14");
    star2.setAttribute("viewBox", "0 0 512 512");
    star2.setAttribute("xml:space", "preserve");
    star2.style.padding = "0 1px";
    value = value && !isNaN(value) ? parseInt(value) : 0;
    value = Math.max(0, Math.min(value, maxStars));
    for (var i2 = 1; i2 <= maxStars; i2++) {
      var nextStar = star2.cloneNode(true);
      nextStar.innerHTML = i2 <= value ? starActive : starInactive;
      stars.appendChild(nextStar);
    }
    element.style.whiteSpace = "nowrap";
    element.style.overflow = "hidden";
    element.style.textOverflow = "ellipsis";
    element.setAttribute("aria-label", value);
    return stars;
  }
  function traffic(cell, formatterParams, onRendered) {
    var value = this.sanitizeHTML(cell.getValue()) || 0, el = document.createElement("span"), max2 = formatterParams && formatterParams.max ? formatterParams.max : 100, min2 = formatterParams && formatterParams.min ? formatterParams.min : 0, colors = formatterParams && typeof formatterParams.color !== "undefined" ? formatterParams.color : ["red", "orange", "green"], color2 = "#666666", percent, percentValue;
    if (isNaN(value) || typeof cell.getValue() === "undefined") {
      return;
    }
    el.classList.add("tabulator-traffic-light");
    percentValue = parseFloat(value) <= max2 ? parseFloat(value) : max2;
    percentValue = parseFloat(percentValue) >= min2 ? parseFloat(percentValue) : min2;
    percent = (max2 - min2) / 100;
    percentValue = Math.round((percentValue - min2) / percent);
    switch (typeof colors) {
      case "string":
        color2 = colors;
        break;
      case "function":
        color2 = colors(value);
        break;
      case "object":
        if (Array.isArray(colors)) {
          var unit = 100 / colors.length;
          var index2 = Math.floor(percentValue / unit);
          index2 = Math.min(index2, colors.length - 1);
          index2 = Math.max(index2, 0);
          color2 = colors[index2];
          break;
        }
    }
    el.style.backgroundColor = color2;
    return el;
  }
  function progress(cell, formatterParams = {}, onRendered) {
    var value = this.sanitizeHTML(cell.getValue()) || 0, element = cell.getElement(), max2 = formatterParams.max ? formatterParams.max : 100, min2 = formatterParams.min ? formatterParams.min : 0, legendAlign = formatterParams.legendAlign ? formatterParams.legendAlign : "center", percent, percentValue, color2, legend, legendColor;
    percentValue = parseFloat(value) <= max2 ? parseFloat(value) : max2;
    percentValue = parseFloat(percentValue) >= min2 ? parseFloat(percentValue) : min2;
    percent = (max2 - min2) / 100;
    percentValue = Math.round((percentValue - min2) / percent);
    switch (typeof formatterParams.color) {
      case "string":
        color2 = formatterParams.color;
        break;
      case "function":
        color2 = formatterParams.color(value);
        break;
      case "object":
        if (Array.isArray(formatterParams.color)) {
          let unit = 100 / formatterParams.color.length;
          let index2 = Math.floor(percentValue / unit);
          index2 = Math.min(index2, formatterParams.color.length - 1);
          index2 = Math.max(index2, 0);
          color2 = formatterParams.color[index2];
          break;
        }
      default:
        color2 = "#2DC214";
    }
    switch (typeof formatterParams.legend) {
      case "string":
        legend = formatterParams.legend;
        break;
      case "function":
        legend = formatterParams.legend(value);
        break;
      case "boolean":
        legend = value;
        break;
      default:
        legend = false;
    }
    switch (typeof formatterParams.legendColor) {
      case "string":
        legendColor = formatterParams.legendColor;
        break;
      case "function":
        legendColor = formatterParams.legendColor(value);
        break;
      case "object":
        if (Array.isArray(formatterParams.legendColor)) {
          let unit = 100 / formatterParams.legendColor.length;
          let index2 = Math.floor(percentValue / unit);
          index2 = Math.min(index2, formatterParams.legendColor.length - 1);
          index2 = Math.max(index2, 0);
          legendColor = formatterParams.legendColor[index2];
        }
        break;
      default:
        legendColor = "#000";
    }
    element.style.minWidth = "30px";
    element.style.position = "relative";
    element.setAttribute("aria-label", percentValue);
    var barEl = document.createElement("div");
    barEl.style.display = "inline-block";
    barEl.style.width = percentValue + "%";
    barEl.style.backgroundColor = color2;
    barEl.style.height = "100%";
    barEl.setAttribute("data-max", max2);
    barEl.setAttribute("data-min", min2);
    var barContainer = document.createElement("div");
    barContainer.style.position = "relative";
    barContainer.style.width = "100%";
    barContainer.style.height = "100%";
    if (legend) {
      var legendEl = document.createElement("div");
      legendEl.style.position = "absolute";
      legendEl.style.top = 0;
      legendEl.style.left = 0;
      legendEl.style.textAlign = legendAlign;
      legendEl.style.width = "100%";
      legendEl.style.color = legendColor;
      legendEl.innerHTML = legend;
    }
    onRendered(function() {
      if (!(cell instanceof CellComponent)) {
        var holderEl = document.createElement("div");
        holderEl.style.position = "absolute";
        holderEl.style.top = "4px";
        holderEl.style.bottom = "4px";
        holderEl.style.left = "4px";
        holderEl.style.right = "4px";
        element.appendChild(holderEl);
        element = holderEl;
      }
      element.appendChild(barContainer);
      barContainer.appendChild(barEl);
      if (legend) {
        barContainer.appendChild(legendEl);
      }
    });
    return "";
  }
  function color(cell, formatterParams, onRendered) {
    cell.getElement().style.backgroundColor = this.sanitizeHTML(cell.getValue());
    return "";
  }
  function buttonTick(cell, formatterParams, onRendered) {
    return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
  }
  function buttonCross(cell, formatterParams, onRendered) {
    return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
  }
  function toggle(cell, formatterParams, onRendered) {
    var value = cell.getValue(), size2 = formatterParams.size || 15, sizePx = size2 + "px", containEl, switchEl, onValue = formatterParams.hasOwnProperty("onValue") ? formatterParams.onValue : true, offValue = formatterParams.hasOwnProperty("offValue") ? formatterParams.offValue : false, state = formatterParams.onTruthy ? value : value === onValue;
    containEl = document.createElement("div");
    containEl.classList.add("tabulator-toggle");
    if (state) {
      containEl.classList.add("tabulator-toggle-on");
      containEl.style.flexDirection = "row-reverse";
      if (formatterParams.onColor) {
        containEl.style.background = formatterParams.onColor;
      }
    } else {
      if (formatterParams.offColor) {
        containEl.style.background = formatterParams.offColor;
      }
    }
    containEl.style.width = 2.5 * size2 + "px";
    containEl.style.borderRadius = sizePx;
    if (formatterParams.clickable) {
      containEl.addEventListener("click", (e) => {
        cell.setValue(state ? offValue : onValue);
      });
    }
    switchEl = document.createElement("div");
    switchEl.classList.add("tabulator-toggle-switch");
    switchEl.style.height = sizePx;
    switchEl.style.width = sizePx;
    switchEl.style.borderRadius = sizePx;
    containEl.appendChild(switchEl);
    return containEl;
  }
  function rownum(cell, formatterParams, onRendered) {
    var content = document.createElement("span");
    var row = cell.getRow();
    var table = cell.getTable();
    row.watchPosition((position) => {
      if (formatterParams.relativeToPage) {
        position += table.modules.page.getPageSize() * (table.modules.page.getPage() - 1);
      }
      content.innerText = position;
    });
    return content;
  }
  function handle(cell, formatterParams, onRendered) {
    cell.getElement().classList.add("tabulator-row-handle");
    return "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
  }
  function adaptable(cell, params, onRendered) {
    var lookup2, formatterFunc, formatterParams;
    function defaultLookup(cell2) {
      var value = cell2.getValue(), formatter = "plaintext";
      switch (typeof value) {
        case "boolean":
          formatter = "tickCross";
          break;
        case "string":
          if (value.includes("\n")) {
            formatter = "textarea";
          }
          break;
      }
      return formatter;
    }
    lookup2 = params.formatterLookup ? params.formatterLookup(cell) : defaultLookup(cell);
    if (params.paramsLookup) {
      formatterParams = typeof params.paramsLookup === "function" ? params.paramsLookup(lookup2, cell) : params.paramsLookup[lookup2];
    }
    formatterFunc = this.table.modules.format.lookupFormatter(lookup2);
    return formatterFunc.call(this, cell, formatterParams || {}, onRendered);
  }
  function array$2(cell, formatterParams, onRendered) {
    var delimiter = formatterParams.delimiter || ",", value = cell.getValue(), table = this.table, valueMap;
    if (formatterParams.valueMap) {
      if (typeof formatterParams.valueMap === "string") {
        valueMap = function(value2) {
          return value2.map((item) => {
            return Helpers.retrieveNestedData(table.options.nestedFieldSeparator, formatterParams.valueMap, item);
          });
        };
      } else {
        valueMap = formatterParams.valueMap;
      }
    }
    if (Array.isArray(value)) {
      if (valueMap) {
        value = valueMap(value);
      }
      return value.join(delimiter);
    } else {
      return value;
    }
  }
  function json$1(cell, formatterParams, onRendered) {
    var indent = formatterParams.indent || "	", multiline = typeof formatterParams.multiline === "undefined" ? true : formatterParams.multiline, replacer2 = formatterParams.replacer || null, value = cell.getValue();
    if (multiline) {
      cell.getElement().style.whiteSpace = "pre-wrap";
    }
    return JSON.stringify(value, replacer2, indent);
  }
  var defaultFormatters = {
    plaintext,
    html,
    textarea,
    money,
    link,
    image,
    tickCross,
    datetime: datetime$1,
    datetimediff,
    lookup,
    star,
    traffic,
    progress,
    color,
    buttonTick,
    buttonCross,
    toggle,
    rownum,
    handle,
    adaptable,
    array: array$2,
    json: json$1
  };
  const _Format = class _Format extends Module {
    constructor(table) {
      super(table);
      this.registerColumnOption("formatter");
      this.registerColumnOption("formatterParams");
      this.registerColumnOption("formatterPrint");
      this.registerColumnOption("formatterPrintParams");
      this.registerColumnOption("formatterClipboard");
      this.registerColumnOption("formatterClipboardParams");
      this.registerColumnOption("formatterHtmlOutput");
      this.registerColumnOption("formatterHtmlOutputParams");
      this.registerColumnOption("titleFormatter");
      this.registerColumnOption("titleFormatterParams");
    }
    initialize() {
      this.subscribe("cell-format", this.formatValue.bind(this));
      this.subscribe("cell-rendered", this.cellRendered.bind(this));
      this.subscribe("column-layout", this.initializeColumn.bind(this));
      this.subscribe("column-format", this.formatHeader.bind(this));
    }
    //initialize column formatter
    initializeColumn(column) {
      column.modules.format = this.lookupTypeFormatter(column, "");
      if (typeof column.definition.formatterPrint !== "undefined") {
        column.modules.format.print = this.lookupTypeFormatter(column, "Print");
      }
      if (typeof column.definition.formatterClipboard !== "undefined") {
        column.modules.format.clipboard = this.lookupTypeFormatter(column, "Clipboard");
      }
      if (typeof column.definition.formatterHtmlOutput !== "undefined") {
        column.modules.format.htmlOutput = this.lookupTypeFormatter(column, "HtmlOutput");
      }
    }
    lookupTypeFormatter(column, type) {
      var config = { params: column.definition["formatter" + type + "Params"] || {} }, formatter = column.definition["formatter" + type];
      config.formatter = this.lookupFormatter(formatter);
      return config;
    }
    lookupFormatter(formatter) {
      var formatterFunc;
      switch (typeof formatter) {
        case "string":
          if (_Format.formatters[formatter]) {
            formatterFunc = _Format.formatters[formatter];
          } else {
            console.warn("Formatter Error - No such formatter found: ", formatter);
            formatterFunc = _Format.formatters.plaintext;
          }
          break;
        case "function":
          formatterFunc = formatter;
          break;
        default:
          formatterFunc = _Format.formatters.plaintext;
          break;
      }
      return formatterFunc;
    }
    cellRendered(cell) {
      if (cell.modules.format && cell.modules.format.renderedCallback && !cell.modules.format.rendered) {
        cell.modules.format.renderedCallback();
        cell.modules.format.rendered = true;
      }
    }
    //return a formatted value for a column header
    formatHeader(column, title, el) {
      var formatter, params, onRendered, mockCell;
      if (column.definition.titleFormatter) {
        formatter = this.lookupFormatter(column.definition.titleFormatter);
        onRendered = (callback) => {
          column.titleFormatterRendered = callback;
        };
        mockCell = {
          getValue: function() {
            return title;
          },
          getElement: function() {
            return el;
          },
          getType: function() {
            return "header";
          },
          getColumn: function() {
            return column.getComponent();
          },
          getTable: () => {
            return this.table;
          }
        };
        params = column.definition.titleFormatterParams || {};
        params = typeof params === "function" ? params() : params;
        return formatter.call(this, mockCell, params, onRendered);
      } else {
        return title;
      }
    }
    //return a formatted value for a cell
    formatValue(cell) {
      var component = cell.getComponent(), params = typeof cell.column.modules.format.params === "function" ? cell.column.modules.format.params(component) : cell.column.modules.format.params;
      function onRendered(callback) {
        if (!cell.modules.format) {
          cell.modules.format = {};
        }
        cell.modules.format.renderedCallback = callback;
        cell.modules.format.rendered = false;
      }
      return cell.column.modules.format.formatter.call(this, component, params, onRendered);
    }
    formatExportValue(cell, type) {
      var formatter = cell.column.modules.format[type], params;
      if (formatter) {
        let onRendered = function(callback) {
          if (!cell.modules.format) {
            cell.modules.format = {};
          }
          cell.modules.format.renderedCallback = callback;
          cell.modules.format.rendered = false;
        };
        params = typeof formatter.params === "function" ? formatter.params(cell.getComponent()) : formatter.params;
        return formatter.formatter.call(this, cell.getComponent(), params, onRendered);
      } else {
        return this.formatValue(cell);
      }
    }
    sanitizeHTML(value) {
      if (value) {
        var entityMap = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;",
          "/": "&#x2F;",
          "`": "&#x60;",
          "=": "&#x3D;"
        };
        return String(value).replace(/[&<>"'`=/]/g, function(s2) {
          return entityMap[s2];
        });
      } else {
        return value;
      }
    }
    emptyToSpace(value) {
      return value === null || typeof value === "undefined" || value === "" ? "&nbsp;" : value;
    }
  };
  __publicField(_Format, "moduleName", "format");
  //load defaults
  __publicField(_Format, "formatters", defaultFormatters);
  let Format = _Format;
  class Interaction extends Module {
    constructor(table) {
      super(table);
      this.eventMap = {
        //row events
        rowClick: "row-click",
        rowDblClick: "row-dblclick",
        rowContext: "row-contextmenu",
        rowMouseEnter: "row-mouseenter",
        rowMouseLeave: "row-mouseleave",
        rowMouseOver: "row-mouseover",
        rowMouseOut: "row-mouseout",
        rowMouseMove: "row-mousemove",
        rowMouseDown: "row-mousedown",
        rowMouseUp: "row-mouseup",
        rowTap: "row",
        rowDblTap: "row",
        rowTapHold: "row",
        //cell events
        cellClick: "cell-click",
        cellDblClick: "cell-dblclick",
        cellContext: "cell-contextmenu",
        cellMouseEnter: "cell-mouseenter",
        cellMouseLeave: "cell-mouseleave",
        cellMouseOver: "cell-mouseover",
        cellMouseOut: "cell-mouseout",
        cellMouseMove: "cell-mousemove",
        cellMouseDown: "cell-mousedown",
        cellMouseUp: "cell-mouseup",
        cellTap: "cell",
        cellDblTap: "cell",
        cellTapHold: "cell",
        //column header events
        headerClick: "column-click",
        headerDblClick: "column-dblclick",
        headerContext: "column-contextmenu",
        headerMouseEnter: "column-mouseenter",
        headerMouseLeave: "column-mouseleave",
        headerMouseOver: "column-mouseover",
        headerMouseOut: "column-mouseout",
        headerMouseMove: "column-mousemove",
        headerMouseDown: "column-mousedown",
        headerMouseUp: "column-mouseup",
        headerTap: "column",
        headerDblTap: "column",
        headerTapHold: "column",
        //group header
        groupClick: "group-click",
        groupDblClick: "group-dblclick",
        groupContext: "group-contextmenu",
        groupMouseEnter: "group-mouseenter",
        groupMouseLeave: "group-mouseleave",
        groupMouseOver: "group-mouseover",
        groupMouseOut: "group-mouseout",
        groupMouseMove: "group-mousemove",
        groupMouseDown: "group-mousedown",
        groupMouseUp: "group-mouseup",
        groupTap: "group",
        groupDblTap: "group",
        groupTapHold: "group"
      };
      this.subscribers = {};
      this.touchSubscribers = {};
      this.columnSubscribers = {};
      this.touchWatchers = {
        row: {
          tap: null,
          tapDbl: null,
          tapHold: null
        },
        cell: {
          tap: null,
          tapDbl: null,
          tapHold: null
        },
        column: {
          tap: null,
          tapDbl: null,
          tapHold: null
        },
        group: {
          tap: null,
          tapDbl: null,
          tapHold: null
        }
      };
      this.registerColumnOption("headerClick");
      this.registerColumnOption("headerDblClick");
      this.registerColumnOption("headerContext");
      this.registerColumnOption("headerMouseEnter");
      this.registerColumnOption("headerMouseLeave");
      this.registerColumnOption("headerMouseOver");
      this.registerColumnOption("headerMouseOut");
      this.registerColumnOption("headerMouseMove");
      this.registerColumnOption("headerMouseDown");
      this.registerColumnOption("headerMouseUp");
      this.registerColumnOption("headerTap");
      this.registerColumnOption("headerDblTap");
      this.registerColumnOption("headerTapHold");
      this.registerColumnOption("cellClick");
      this.registerColumnOption("cellDblClick");
      this.registerColumnOption("cellContext");
      this.registerColumnOption("cellMouseEnter");
      this.registerColumnOption("cellMouseLeave");
      this.registerColumnOption("cellMouseOver");
      this.registerColumnOption("cellMouseOut");
      this.registerColumnOption("cellMouseMove");
      this.registerColumnOption("cellMouseDown");
      this.registerColumnOption("cellMouseUp");
      this.registerColumnOption("cellTap");
      this.registerColumnOption("cellDblTap");
      this.registerColumnOption("cellTapHold");
    }
    initialize() {
      this.initializeExternalEvents();
      this.subscribe("column-init", this.initializeColumn.bind(this));
      this.subscribe("cell-dblclick", this.cellContentsSelectionFixer.bind(this));
      this.subscribe("scroll-horizontal", this.clearTouchWatchers.bind(this));
      this.subscribe("scroll-vertical", this.clearTouchWatchers.bind(this));
    }
    clearTouchWatchers() {
      var types = Object.values(this.touchWatchers);
      types.forEach((type) => {
        for (let key in type) {
          type[key] = null;
        }
      });
    }
    cellContentsSelectionFixer(e, cell) {
      var range2;
      if (this.table.modExists("edit")) {
        if (this.table.modules.edit.currentCell === cell) {
          return;
        }
      }
      e.preventDefault();
      try {
        if (document.selection) {
          range2 = document.body.createTextRange();
          range2.moveToElementText(cell.getElement());
          range2.select();
        } else if (window.getSelection) {
          range2 = document.createRange();
          range2.selectNode(cell.getElement());
          window.getSelection().removeAllRanges();
          window.getSelection().addRange(range2);
        }
      } catch (e2) {
      }
    }
    initializeExternalEvents() {
      for (let key in this.eventMap) {
        this.subscriptionChangeExternal(key, this.subscriptionChanged.bind(this, key));
      }
    }
    subscriptionChanged(key, added) {
      if (added) {
        if (!this.subscribers[key]) {
          if (this.eventMap[key].includes("-")) {
            this.subscribers[key] = this.handle.bind(this, key);
            this.subscribe(this.eventMap[key], this.subscribers[key]);
          } else {
            this.subscribeTouchEvents(key);
          }
        }
      } else {
        if (this.eventMap[key].includes("-")) {
          if (this.subscribers[key] && !this.columnSubscribers[key] && !this.subscribedExternal(key)) {
            this.unsubscribe(this.eventMap[key], this.subscribers[key]);
            delete this.subscribers[key];
          }
        } else {
          this.unsubscribeTouchEvents(key);
        }
      }
    }
    subscribeTouchEvents(key) {
      var type = this.eventMap[key];
      if (!this.touchSubscribers[type + "-touchstart"]) {
        this.touchSubscribers[type + "-touchstart"] = this.handleTouch.bind(this, type, "start");
        this.touchSubscribers[type + "-touchend"] = this.handleTouch.bind(this, type, "end");
        this.subscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
        this.subscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);
      }
      this.subscribers[key] = true;
    }
    unsubscribeTouchEvents(key) {
      var noTouch = true, type = this.eventMap[key];
      if (this.subscribers[key] && !this.subscribedExternal(key)) {
        delete this.subscribers[key];
        for (let i2 in this.eventMap) {
          if (this.eventMap[i2] === type) {
            if (this.subscribers[i2]) {
              noTouch = false;
            }
          }
        }
        if (noTouch) {
          this.unsubscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
          this.unsubscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);
          delete this.touchSubscribers[type + "-touchstart"];
          delete this.touchSubscribers[type + "-touchend"];
        }
      }
    }
    initializeColumn(column) {
      var def2 = column.definition;
      for (let key in this.eventMap) {
        if (def2[key]) {
          this.subscriptionChanged(key, true);
          if (!this.columnSubscribers[key]) {
            this.columnSubscribers[key] = [];
          }
          this.columnSubscribers[key].push(column);
        }
      }
    }
    handle(action, e, component) {
      this.dispatchEvent(action, e, component);
    }
    handleTouch(type, action, e, component) {
      var watchers = this.touchWatchers[type];
      if (type === "column") {
        type = "header";
      }
      switch (action) {
        case "start":
          watchers.tap = true;
          clearTimeout(watchers.tapHold);
          watchers.tapHold = setTimeout(() => {
            clearTimeout(watchers.tapHold);
            watchers.tapHold = null;
            watchers.tap = null;
            clearTimeout(watchers.tapDbl);
            watchers.tapDbl = null;
            this.dispatchEvent(type + "TapHold", e, component);
          }, 1e3);
          break;
        case "end":
          if (watchers.tap) {
            watchers.tap = null;
            this.dispatchEvent(type + "Tap", e, component);
          }
          if (watchers.tapDbl) {
            clearTimeout(watchers.tapDbl);
            watchers.tapDbl = null;
            this.dispatchEvent(type + "DblTap", e, component);
          } else {
            watchers.tapDbl = setTimeout(() => {
              clearTimeout(watchers.tapDbl);
              watchers.tapDbl = null;
            }, 300);
          }
          clearTimeout(watchers.tapHold);
          watchers.tapHold = null;
          break;
      }
    }
    dispatchEvent(action, e, component) {
      var componentObj = component.getComponent(), callback;
      if (this.columnSubscribers[action]) {
        if (component instanceof Cell) {
          callback = component.column.definition[action];
        } else if (component instanceof Column) {
          callback = component.definition[action];
        }
        if (callback) {
          callback(e, componentObj);
        }
      }
      this.dispatchExternal(action, e, componentObj);
    }
  }
  __publicField(Interaction, "moduleName", "interaction");
  var defaultBindings = {
    navPrev: "shift + 9",
    navNext: 9,
    navUp: 38,
    navDown: 40,
    navLeft: 37,
    navRight: 39,
    scrollPageUp: 33,
    scrollPageDown: 34,
    scrollToStart: 36,
    scrollToEnd: 35
  };
  var defaultActions = {
    keyBlock: function(e) {
      e.stopPropagation();
      e.preventDefault();
    },
    scrollPageUp: function(e) {
      var rowManager = this.table.rowManager, newPos = rowManager.scrollTop - rowManager.element.clientHeight;
      e.preventDefault();
      if (rowManager.displayRowsCount) {
        if (newPos >= 0) {
          rowManager.element.scrollTop = newPos;
        } else {
          rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
        }
      }
      this.table.element.focus();
    },
    scrollPageDown: function(e) {
      var rowManager = this.table.rowManager, newPos = rowManager.scrollTop + rowManager.element.clientHeight, scrollMax = rowManager.element.scrollHeight;
      e.preventDefault();
      if (rowManager.displayRowsCount) {
        if (newPos <= scrollMax) {
          rowManager.element.scrollTop = newPos;
        } else {
          rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
        }
      }
      this.table.element.focus();
    },
    scrollToStart: function(e) {
      var rowManager = this.table.rowManager;
      e.preventDefault();
      if (rowManager.displayRowsCount) {
        rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
      }
      this.table.element.focus();
    },
    scrollToEnd: function(e) {
      var rowManager = this.table.rowManager;
      e.preventDefault();
      if (rowManager.displayRowsCount) {
        rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
      }
      this.table.element.focus();
    },
    navPrev: function(e) {
      this.dispatch("keybinding-nav-prev", e);
    },
    navNext: function(e) {
      this.dispatch("keybinding-nav-next", e);
    },
    navLeft: function(e) {
      this.dispatch("keybinding-nav-left", e);
    },
    navRight: function(e) {
      this.dispatch("keybinding-nav-right", e);
    },
    navUp: function(e) {
      this.dispatch("keybinding-nav-up", e);
    },
    navDown: function(e) {
      this.dispatch("keybinding-nav-down", e);
    }
  };
  const _Keybindings = class _Keybindings extends Module {
    constructor(table) {
      super(table);
      this.watchKeys = null;
      this.pressedKeys = null;
      this.keyupBinding = false;
      this.keydownBinding = false;
      this.registerTableOption("keybindings", {});
      this.registerTableOption("tabEndNewRow", false);
    }
    initialize() {
      var bindings2 = this.table.options.keybindings, mergedBindings = {};
      this.watchKeys = {};
      this.pressedKeys = [];
      if (bindings2 !== false) {
        Object.assign(mergedBindings, _Keybindings.bindings);
        Object.assign(mergedBindings, bindings2);
        this.mapBindings(mergedBindings);
        this.bindEvents();
      }
      this.subscribe("table-destroy", this.clearBindings.bind(this));
    }
    mapBindings(bindings2) {
      for (let key in bindings2) {
        if (_Keybindings.actions[key]) {
          if (bindings2[key]) {
            if (typeof bindings2[key] !== "object") {
              bindings2[key] = [bindings2[key]];
            }
            bindings2[key].forEach((binding) => {
              var bindingList = Array.isArray(binding) ? binding : [binding];
              bindingList.forEach((item) => {
                this.mapBinding(key, item);
              });
            });
          }
        } else {
          console.warn("Key Binding Error - no such action:", key);
        }
      }
    }
    mapBinding(action, symbolsList) {
      var binding = {
        action: _Keybindings.actions[action],
        keys: [],
        ctrl: false,
        shift: false,
        meta: false
      };
      var symbols = symbolsList.toString().toLowerCase().split(" ").join("").split("+");
      symbols.forEach((symbol) => {
        switch (symbol) {
          case "ctrl":
            binding.ctrl = true;
            break;
          case "shift":
            binding.shift = true;
            break;
          case "meta":
            binding.meta = true;
            break;
          default:
            symbol = isNaN(symbol) ? symbol.toUpperCase().charCodeAt(0) : parseInt(symbol);
            binding.keys.push(symbol);
            if (!this.watchKeys[symbol]) {
              this.watchKeys[symbol] = [];
            }
            this.watchKeys[symbol].push(binding);
        }
      });
    }
    bindEvents() {
      var self2 = this;
      this.keyupBinding = function(e) {
        var code = e.keyCode;
        var bindings2 = self2.watchKeys[code];
        if (bindings2) {
          self2.pressedKeys.push(code);
          bindings2.forEach(function(binding) {
            self2.checkBinding(e, binding);
          });
        }
      };
      this.keydownBinding = function(e) {
        var code = e.keyCode;
        var bindings2 = self2.watchKeys[code];
        if (bindings2) {
          var index2 = self2.pressedKeys.indexOf(code);
          if (index2 > -1) {
            self2.pressedKeys.splice(index2, 1);
          }
        }
      };
      this.table.element.addEventListener("keydown", this.keyupBinding);
      this.table.element.addEventListener("keyup", this.keydownBinding);
    }
    clearBindings() {
      if (this.keyupBinding) {
        this.table.element.removeEventListener("keydown", this.keyupBinding);
      }
      if (this.keydownBinding) {
        this.table.element.removeEventListener("keyup", this.keydownBinding);
      }
    }
    checkBinding(e, binding) {
      var match = true;
      if (e.ctrlKey == binding.ctrl && e.shiftKey == binding.shift && e.metaKey == binding.meta) {
        binding.keys.forEach((key) => {
          var index2 = this.pressedKeys.indexOf(key);
          if (index2 == -1) {
            match = false;
          }
        });
        if (match) {
          binding.action.call(this, e);
        }
        return true;
      }
      return false;
    }
  };
  __publicField(_Keybindings, "moduleName", "keybindings");
  //load defaults
  __publicField(_Keybindings, "bindings", defaultBindings);
  __publicField(_Keybindings, "actions", defaultActions);
  let Keybindings = _Keybindings;
  var defaultMutators = {};
  const _Mutator = class _Mutator extends Module {
    constructor(table) {
      super(table);
      this.allowedTypes = ["", "data", "edit", "clipboard", "import"];
      this.enabled = true;
      this.registerColumnOption("mutator");
      this.registerColumnOption("mutatorParams");
      this.registerColumnOption("mutatorData");
      this.registerColumnOption("mutatorDataParams");
      this.registerColumnOption("mutatorEdit");
      this.registerColumnOption("mutatorEditParams");
      this.registerColumnOption("mutatorClipboard");
      this.registerColumnOption("mutatorClipboardParams");
      this.registerColumnOption("mutatorImport");
      this.registerColumnOption("mutatorImportParams");
      this.registerColumnOption("mutateLink");
    }
    initialize() {
      this.subscribe("cell-value-changing", this.transformCell.bind(this));
      this.subscribe("cell-value-changed", this.mutateLink.bind(this));
      this.subscribe("column-layout", this.initializeColumn.bind(this));
      this.subscribe("row-data-init-before", this.rowDataChanged.bind(this));
      this.subscribe("row-data-changing", this.rowDataChanged.bind(this));
    }
    rowDataChanged(row, tempData, updatedData) {
      return this.transformRow(tempData, "data", updatedData);
    }
    //initialize column mutator
    initializeColumn(column) {
      var match = false, config = {};
      this.allowedTypes.forEach((type) => {
        var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)), mutator;
        if (column.definition[key]) {
          mutator = this.lookupMutator(column.definition[key]);
          if (mutator) {
            match = true;
            config[key] = {
              mutator,
              params: column.definition[key + "Params"] || {}
            };
          }
        }
      });
      if (match) {
        column.modules.mutate = config;
      }
    }
    lookupMutator(value) {
      var mutator = false;
      switch (typeof value) {
        case "string":
          if (_Mutator.mutators[value]) {
            mutator = _Mutator.mutators[value];
          } else {
            console.warn("Mutator Error - No such mutator found, ignoring: ", value);
          }
          break;
        case "function":
          mutator = value;
          break;
      }
      return mutator;
    }
    //apply mutator to row
    transformRow(data, type, updatedData) {
      var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)), value;
      if (this.enabled) {
        this.table.columnManager.traverse((column) => {
          var mutator, params, component;
          if (column.modules.mutate) {
            mutator = column.modules.mutate[key] || column.modules.mutate.mutator || false;
            if (mutator) {
              value = column.getFieldValue(typeof updatedData !== "undefined" ? updatedData : data);
              if (type == "data" && !updatedData || typeof value !== "undefined") {
                component = column.getComponent();
                params = typeof mutator.params === "function" ? mutator.params(value, data, type, component) : mutator.params;
                column.setFieldValue(data, mutator.mutator(value, data, type, params, component));
              }
            }
          }
        });
      }
      return data;
    }
    //apply mutator to new cell value
    transformCell(cell, value) {
      if (cell.column.modules.mutate) {
        var mutator = cell.column.modules.mutate.mutatorEdit || cell.column.modules.mutate.mutator || false, tempData = {};
        if (mutator) {
          tempData = Object.assign(tempData, cell.row.getData());
          cell.column.setFieldValue(tempData, value);
          return mutator.mutator(value, tempData, "edit", mutator.params, cell.getComponent());
        }
      }
      return value;
    }
    mutateLink(cell) {
      var links = cell.column.definition.mutateLink;
      if (links) {
        if (!Array.isArray(links)) {
          links = [links];
        }
        links.forEach((link2) => {
          var linkCell = cell.row.getCell(link2);
          if (linkCell) {
            linkCell.setValue(linkCell.getValue(), true, true);
          }
        });
      }
    }
    enable() {
      this.enabled = true;
    }
    disable() {
      this.enabled = false;
    }
  };
  __publicField(_Mutator, "moduleName", "mutator");
  //load defaults
  __publicField(_Mutator, "mutators", defaultMutators);
  let Mutator = _Mutator;
  class ResizeColumns extends Module {
    constructor(table) {
      super(table);
      this.startColumn = false;
      this.startX = false;
      this.startWidth = false;
      this.latestX = false;
      this.handle = null;
      this.initialNextColumn = null;
      this.nextColumn = null;
      this.initialized = false;
      this.registerColumnOption("resizable", true);
      this.registerTableOption("resizableColumnFit", false);
      this.registerTableOption("resizableColumnGuide", false);
    }
    initialize() {
      this.subscribe("column-rendered", this.layoutColumnHeader.bind(this));
    }
    initializeEventWatchers() {
      if (!this.initialized) {
        this.subscribe("cell-rendered", this.layoutCellHandles.bind(this));
        this.subscribe("cell-delete", this.deInitializeComponent.bind(this));
        this.subscribe("cell-height", this.resizeHandle.bind(this));
        this.subscribe("column-moved", this.columnLayoutUpdated.bind(this));
        this.subscribe("column-hide", this.deInitializeColumn.bind(this));
        this.subscribe("column-show", this.columnLayoutUpdated.bind(this));
        this.subscribe("column-width", this.columnWidthUpdated.bind(this));
        this.subscribe("column-delete", this.deInitializeComponent.bind(this));
        this.subscribe("column-height", this.resizeHandle.bind(this));
        this.initialized = true;
      }
    }
    layoutCellHandles(cell) {
      if (cell.row.type === "row") {
        this.deInitializeComponent(cell);
        this.initializeColumn("cell", cell, cell.column, cell.element);
      }
    }
    layoutColumnHeader(column) {
      if (column.definition.resizable) {
        this.initializeEventWatchers();
        this.deInitializeComponent(column);
        this.initializeColumn("header", column, column, column.element);
      }
    }
    columnLayoutUpdated(column) {
      var prev = column.prevColumn();
      this.reinitializeColumn(column);
      if (prev) {
        this.reinitializeColumn(prev);
      }
    }
    columnWidthUpdated(column) {
      if (column.modules.frozen) {
        if (this.table.modules.frozenColumns.leftColumns.includes(column)) {
          this.table.modules.frozenColumns.leftColumns.forEach((col) => {
            this.reinitializeColumn(col);
          });
        } else if (this.table.modules.frozenColumns.rightColumns.includes(column)) {
          this.table.modules.frozenColumns.rightColumns.forEach((col) => {
            this.reinitializeColumn(col);
          });
        }
      }
    }
    frozenColumnOffset(column) {
      var offset2 = false;
      if (column.modules.frozen) {
        offset2 = column.modules.frozen.marginValue;
        if (column.modules.frozen.position === "left") {
          offset2 += column.getWidth() - 3;
        } else {
          if (offset2) {
            offset2 -= 3;
          }
        }
      }
      return offset2 !== false ? offset2 + "px" : false;
    }
    reinitializeColumn(column) {
      var frozenOffset = this.frozenColumnOffset(column);
      column.cells.forEach((cell) => {
        if (cell.modules.resize && cell.modules.resize.handleEl) {
          if (frozenOffset) {
            cell.modules.resize.handleEl.style[column.modules.frozen.position] = frozenOffset;
            cell.modules.resize.handleEl.style["z-index"] = 11;
          }
          cell.element.after(cell.modules.resize.handleEl);
        }
      });
      if (column.modules.resize && column.modules.resize.handleEl) {
        if (frozenOffset) {
          column.modules.resize.handleEl.style[column.modules.frozen.position] = frozenOffset;
        }
        column.element.after(column.modules.resize.handleEl);
      }
    }
    initializeColumn(type, component, column, element) {
      var self2 = this, variableHeight = false, mode = column.definition.resizable, config = {}, nearestColumn = column.getLastColumn();
      if (type === "header") {
        variableHeight = column.definition.formatter == "textarea" || column.definition.variableHeight;
        config = { variableHeight };
      }
      if ((mode === true || mode == type) && this._checkResizability(nearestColumn)) {
        var handle2 = document.createElement("span");
        handle2.className = "tabulator-col-resize-handle";
        handle2.addEventListener("click", function(e) {
          e.stopPropagation();
        });
        var handleDown = function(e) {
          self2.startColumn = column;
          self2.initialNextColumn = self2.nextColumn = nearestColumn.nextColumn();
          self2._mouseDown(e, nearestColumn, handle2);
        };
        handle2.addEventListener("mousedown", handleDown);
        handle2.addEventListener("touchstart", handleDown, { passive: true });
        handle2.addEventListener("dblclick", (e) => {
          var oldWidth = nearestColumn.getWidth();
          e.stopPropagation();
          nearestColumn.reinitializeWidth(true);
          if (oldWidth !== nearestColumn.getWidth()) {
            self2.dispatch("column-resized", nearestColumn);
            self2.dispatchExternal("columnResized", nearestColumn.getComponent());
          }
        });
        if (column.modules.frozen) {
          handle2.style.position = "sticky";
          handle2.style[column.modules.frozen.position] = this.frozenColumnOffset(column);
        }
        config.handleEl = handle2;
        if (element.parentNode && column.visible) {
          element.after(handle2);
        }
      }
      component.modules.resize = config;
    }
    deInitializeColumn(column) {
      this.deInitializeComponent(column);
      column.cells.forEach((cell) => {
        this.deInitializeComponent(cell);
      });
    }
    deInitializeComponent(component) {
      var handleEl;
      if (component.modules.resize) {
        handleEl = component.modules.resize.handleEl;
        if (handleEl && handleEl.parentElement) {
          handleEl.parentElement.removeChild(handleEl);
        }
      }
    }
    resizeHandle(component, height) {
      if (component.modules.resize && component.modules.resize.handleEl) {
        component.modules.resize.handleEl.style.height = height;
      }
    }
    resize(e, column) {
      var x2 = typeof e.clientX === "undefined" ? e.touches[0].clientX : e.clientX, startDiff = x2 - this.startX, moveDiff = x2 - this.latestX, blockedBefore, blockedAfter;
      this.latestX = x2;
      if (this.table.rtl) {
        startDiff = -startDiff;
        moveDiff = -moveDiff;
      }
      blockedBefore = column.width == column.minWidth || column.width == column.maxWidth;
      column.setWidth(this.startWidth + startDiff);
      blockedAfter = column.width == column.minWidth || column.width == column.maxWidth;
      if (moveDiff < 0) {
        this.nextColumn = this.initialNextColumn;
      }
      if (this.table.options.resizableColumnFit && this.nextColumn && !(blockedBefore && blockedAfter)) {
        let colWidth = this.nextColumn.getWidth();
        if (moveDiff > 0) {
          if (colWidth <= this.nextColumn.minWidth) {
            this.nextColumn = this.nextColumn.nextColumn();
          }
        }
        if (this.nextColumn) {
          this.nextColumn.setWidth(this.nextColumn.getWidth() - moveDiff);
        }
      }
      this.table.columnManager.rerenderColumns(true);
      if (!this.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
        column.checkCellHeights();
      }
    }
    calcGuidePosition(e, column, handle2) {
      var mouseX = typeof e.clientX === "undefined" ? e.touches[0].clientX : e.clientX, handleX = handle2.getBoundingClientRect().x - this.table.element.getBoundingClientRect().x, tableX = this.table.element.getBoundingClientRect().x, columnX = column.element.getBoundingClientRect().left - tableX, mouseDiff = mouseX - this.startX, pos = Math.max(handleX + mouseDiff, columnX + column.minWidth);
      if (column.maxWidth) {
        pos = Math.min(pos, columnX + column.maxWidth);
      }
      return pos;
    }
    _checkResizability(column) {
      return column.definition.resizable;
    }
    _mouseDown(e, column, handle2) {
      var self2 = this, guideEl;
      this.dispatchExternal("columnResizing", column.getComponent());
      if (self2.table.options.resizableColumnGuide) {
        guideEl = document.createElement("span");
        guideEl.classList.add("tabulator-col-resize-guide");
        self2.table.element.appendChild(guideEl);
        setTimeout(() => {
          guideEl.style.left = self2.calcGuidePosition(e, column, handle2) + "px";
        });
      }
      self2.table.element.classList.add("tabulator-block-select");
      function mouseMove(e2) {
        if (self2.table.options.resizableColumnGuide) {
          guideEl.style.left = self2.calcGuidePosition(e2, column, handle2) + "px";
        } else {
          self2.resize(e2, column);
        }
      }
      function mouseUp(e2) {
        if (self2.table.options.resizableColumnGuide) {
          self2.resize(e2, column);
          guideEl.remove();
        }
        if (self2.startColumn.modules.edit) {
          self2.startColumn.modules.edit.blocked = false;
        }
        if (self2.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
          column.checkCellHeights();
        }
        document.body.removeEventListener("mouseup", mouseUp);
        document.body.removeEventListener("mousemove", mouseMove);
        handle2.removeEventListener("touchmove", mouseMove);
        handle2.removeEventListener("touchend", mouseUp);
        self2.table.element.classList.remove("tabulator-block-select");
        if (self2.startWidth !== column.getWidth()) {
          self2.table.columnManager.verticalAlignHeaders();
          self2.dispatch("column-resized", column);
          self2.dispatchExternal("columnResized", column.getComponent());
        }
      }
      e.stopPropagation();
      if (self2.startColumn.modules.edit) {
        self2.startColumn.modules.edit.blocked = true;
      }
      self2.startX = typeof e.clientX === "undefined" ? e.touches[0].clientX : e.clientX;
      self2.latestX = self2.startX;
      self2.startWidth = column.getWidth();
      document.body.addEventListener("mousemove", mouseMove);
      document.body.addEventListener("mouseup", mouseUp);
      handle2.addEventListener("touchmove", mouseMove, { passive: true });
      handle2.addEventListener("touchend", mouseUp);
    }
  }
  __publicField(ResizeColumns, "moduleName", "resizeColumns");
  class RangeComponent {
    constructor(range2) {
      this._range = range2;
      return new Proxy(this, {
        get: function(target, name, receiver) {
          if (typeof target[name] !== "undefined") {
            return target[name];
          } else {
            return target._range.table.componentFunctionBinder.handle("range", target._range, name);
          }
        }
      });
    }
    getElement() {
      return this._range.element;
    }
    getData() {
      return this._range.getData();
    }
    getCells() {
      return this._range.getCells(true, true);
    }
    getStructuredCells() {
      return this._range.getStructuredCells();
    }
    getRows() {
      return this._range.getRows().map((row) => row.getComponent());
    }
    getColumns() {
      return this._range.getColumns().map((column) => column.getComponent());
    }
    getBounds() {
      return this._range.getBounds();
    }
    getTopEdge() {
      return this._range.top;
    }
    getBottomEdge() {
      return this._range.bottom;
    }
    getLeftEdge() {
      return this._range.left;
    }
    getRightEdge() {
      return this._range.right;
    }
    setBounds(start, end) {
      if (this._range.destroyedGuard("setBounds")) {
        this._range.setBounds(start ? start._cell : start, end ? end._cell : end);
      }
    }
    setStartBound(start) {
      if (this._range.destroyedGuard("setStartBound")) {
        this._range.setEndBound(start ? start._cell : start);
        this._range.rangeManager.layoutElement();
      }
    }
    setEndBound(end) {
      if (this._range.destroyedGuard("setEndBound")) {
        this._range.setEndBound(end ? end._cell : end);
        this._range.rangeManager.layoutElement();
      }
    }
    clearValues() {
      if (this._range.destroyedGuard("clearValues")) {
        this._range.clearValues();
      }
    }
    remove() {
      if (this._range.destroyedGuard("remove")) {
        this._range.destroy(true);
      }
    }
  }
  class Range extends CoreFeature {
    constructor(table, rangeManager, start, end) {
      super(table);
      this.rangeManager = rangeManager;
      this.element = null;
      this.initialized = false;
      this.initializing = {
        start: false,
        end: false
      };
      this.destroyed = false;
      this.top = 0;
      this.bottom = 0;
      this.left = 0;
      this.right = 0;
      this.table = table;
      this.start = { row: 0, col: 0 };
      this.end = { row: 0, col: 0 };
      if (this.rangeManager.rowHeader) {
        this.left = 1;
        this.right = 1;
        this.start.col = 1;
        this.end.col = 1;
      }
      this.initElement();
      setTimeout(() => {
        this.initBounds(start, end);
      });
    }
    initElement() {
      this.element = document.createElement("div");
      this.element.classList.add("tabulator-range");
    }
    initBounds(start, end) {
      this._updateMinMax();
      if (start) {
        this.setBounds(start, end || start);
      }
    }
    ///////////////////////////////////
    ///////   Boundary Setup    ///////
    ///////////////////////////////////
    setStart(row, col) {
      if (this.start.row !== row || this.start.col !== col) {
        this.start.row = row;
        this.start.col = col;
        this.initializing.start = true;
        this._updateMinMax();
      }
    }
    setEnd(row, col) {
      if (this.end.row !== row || this.end.col !== col) {
        this.end.row = row;
        this.end.col = col;
        this.initializing.end = true;
        this._updateMinMax();
      }
    }
    setBounds(start, end, visibleRows) {
      if (start) {
        this.setStartBound(start);
      }
      this.setEndBound(end || start);
      this.rangeManager.layoutElement(visibleRows);
    }
    setStartBound(element) {
      var row, col;
      if (element.type === "column") {
        if (this.rangeManager.columnSelection) {
          this.setStart(0, element.getPosition() - 1);
        }
      } else {
        row = element.row.position - 1;
        col = element.column.getPosition() - 1;
        if (element.column === this.rangeManager.rowHeader) {
          this.setStart(row, 1);
        } else {
          this.setStart(row, col);
        }
      }
    }
    setEndBound(element) {
      var rowsCount = this._getTableRows().length, row, col, isRowHeader;
      if (element.type === "column") {
        if (this.rangeManager.columnSelection) {
          if (this.rangeManager.selecting === "column") {
            this.setEnd(rowsCount - 1, element.getPosition() - 1);
          } else if (this.rangeManager.selecting === "cell") {
            this.setEnd(0, element.getPosition() - 1);
          }
        }
      } else {
        row = element.row.position - 1;
        col = element.column.getPosition() - 1;
        isRowHeader = element.column === this.rangeManager.rowHeader;
        if (this.rangeManager.selecting === "row") {
          this.setEnd(row, this._getTableColumns().length - 1);
        } else if (this.rangeManager.selecting !== "row" && isRowHeader) {
          this.setEnd(row, 0);
        } else if (this.rangeManager.selecting === "column") {
          this.setEnd(rowsCount - 1, col);
        } else {
          this.setEnd(row, col);
        }
      }
    }
    _updateMinMax() {
      this.top = Math.min(this.start.row, this.end.row);
      this.bottom = Math.max(this.start.row, this.end.row);
      this.left = Math.min(this.start.col, this.end.col);
      this.right = Math.max(this.start.col, this.end.col);
      if (this.initialized) {
        this.dispatchExternal("rangeChanged", this.getComponent());
      } else {
        if (this.initializing.start && this.initializing.end) {
          this.initialized = true;
          this.dispatchExternal("rangeAdded", this.getComponent());
        }
      }
    }
    _getTableColumns() {
      return this.table.columnManager.getVisibleColumnsByIndex();
    }
    _getTableRows() {
      return this.table.rowManager.getDisplayRows().filter((row) => row.type === "row");
    }
    ///////////////////////////////////
    ///////      Rendering      ///////
    ///////////////////////////////////
    layout() {
      var _vDomTop = this.table.rowManager.renderer.vDomTop, _vDomBottom = this.table.rowManager.renderer.vDomBottom, _vDomLeft = this.table.columnManager.renderer.leftCol, _vDomRight = this.table.columnManager.renderer.rightCol, top, bottom, left, right, topLeftCell, bottomRightCell, topLeftCellEl, bottomRightCellEl, topLeftRowEl, bottomRightRowEl;
      if (this.table.options.renderHorizontal === "virtual" && this.rangeManager.rowHeader) {
        _vDomRight += 1;
      }
      if (_vDomTop == null) {
        _vDomTop = 0;
      }
      if (_vDomBottom == null) {
        _vDomBottom = Infinity;
      }
      if (_vDomLeft == null) {
        _vDomLeft = 0;
      }
      if (_vDomRight == null) {
        _vDomRight = Infinity;
      }
      if (this.overlaps(_vDomLeft, _vDomTop, _vDomRight, _vDomBottom)) {
        top = Math.max(this.top, _vDomTop);
        bottom = Math.min(this.bottom, _vDomBottom);
        left = Math.max(this.left, _vDomLeft);
        right = Math.min(this.right, _vDomRight);
        topLeftCell = this.rangeManager.getCell(top, left);
        bottomRightCell = this.rangeManager.getCell(bottom, right);
        topLeftCellEl = topLeftCell.getElement();
        bottomRightCellEl = bottomRightCell.getElement();
        topLeftRowEl = topLeftCell.row.getElement();
        bottomRightRowEl = bottomRightCell.row.getElement();
        this.element.classList.add("tabulator-range-active");
        if (this.table.rtl) {
          this.element.style.right = topLeftRowEl.offsetWidth - topLeftCellEl.offsetLeft - topLeftCellEl.offsetWidth + "px";
          this.element.style.width = topLeftCellEl.offsetLeft + topLeftCellEl.offsetWidth - bottomRightCellEl.offsetLeft + "px";
        } else {
          this.element.style.left = topLeftRowEl.offsetLeft + topLeftCellEl.offsetLeft + "px";
          this.element.style.width = bottomRightCellEl.offsetLeft + bottomRightCellEl.offsetWidth - topLeftCellEl.offsetLeft + "px";
        }
        this.element.style.top = topLeftRowEl.offsetTop + "px";
        this.element.style.height = bottomRightRowEl.offsetTop + bottomRightRowEl.offsetHeight - topLeftRowEl.offsetTop + "px";
      }
    }
    atTopLeft(cell) {
      return cell.row.position - 1 === this.top && cell.column.getPosition() - 1 === this.left;
    }
    atBottomRight(cell) {
      return cell.row.position - 1 === this.bottom && cell.column.getPosition() - 1 === this.right;
    }
    occupies(cell) {
      return this.occupiesRow(cell.row) && this.occupiesColumn(cell.column);
    }
    occupiesRow(row) {
      return this.top <= row.position - 1 && row.position - 1 <= this.bottom;
    }
    occupiesColumn(col) {
      return this.left <= col.getPosition() - 1 && col.getPosition() - 1 <= this.right;
    }
    overlaps(left, top, right, bottom) {
      if (this.left > right || left > this.right || (this.top > bottom || top > this.bottom)) {
        return false;
      }
      return true;
    }
    getData() {
      var data = [], rows = this.getRows(), columns = this.getColumns();
      rows.forEach((row) => {
        var rowData = row.getData(), result = {};
        columns.forEach((column) => {
          result[column.field] = rowData[column.field];
        });
        data.push(result);
      });
      return data;
    }
    getCells(structured, component) {
      var cells = [], rows = this.getRows(), columns = this.getColumns();
      if (structured) {
        cells = rows.map((row) => {
          var arr = [];
          row.getCells().forEach((cell) => {
            if (columns.includes(cell.column)) {
              arr.push(component ? cell.getComponent() : cell);
            }
          });
          return arr;
        });
      } else {
        rows.forEach((row) => {
          row.getCells().forEach((cell) => {
            if (columns.includes(cell.column)) {
              cells.push(component ? cell.getComponent() : cell);
            }
          });
        });
      }
      return cells;
    }
    getStructuredCells() {
      return this.getCells(true, true);
    }
    getRows() {
      return this._getTableRows().slice(this.top, this.bottom + 1);
    }
    getColumns() {
      return this._getTableColumns().slice(this.left, this.right + 1);
    }
    clearValues() {
      var cells = this.getCells();
      var clearValue = this.table.options.selectableRangeClearCellsValue;
      this.table.blockRedraw();
      cells.forEach((cell) => {
        cell.setValue(clearValue);
      });
      this.table.restoreRedraw();
    }
    getBounds(component) {
      var cells = this.getCells(false, component), output = {
        start: null,
        end: null
      };
      if (cells.length) {
        output.start = cells[0];
        output.end = cells[cells.length - 1];
      } else {
        console.warn("No bounds defined on range");
      }
      return output;
    }
    getComponent() {
      if (!this.component) {
        this.component = new RangeComponent(this);
      }
      return this.component;
    }
    destroy(notify) {
      this.destroyed = true;
      this.element.remove();
      if (notify) {
        this.rangeManager.rangeRemoved(this);
      }
      if (this.initialized) {
        this.dispatchExternal("rangeRemoved", this.getComponent());
      }
    }
    destroyedGuard(func) {
      if (this.destroyed) {
        console.warn("You cannot call the " + func + " function on a destroyed range");
      }
      return !this.destroyed;
    }
  }
  var bindings = {
    rangeJumpUp: ["ctrl + 38", "meta + 38"],
    rangeJumpDown: ["ctrl + 40", "meta + 40"],
    rangeJumpLeft: ["ctrl + 37", "meta + 37"],
    rangeJumpRight: ["ctrl + 39", "meta + 39"],
    rangeExpandUp: "shift + 38",
    rangeExpandDown: "shift + 40",
    rangeExpandLeft: "shift + 37",
    rangeExpandRight: "shift + 39",
    rangeExpandJumpUp: ["ctrl + shift + 38", "meta + shift + 38"],
    rangeExpandJumpDown: ["ctrl + shift + 40", "meta + shift + 40"],
    rangeExpandJumpLeft: ["ctrl + shift + 37", "meta + shift + 37"],
    rangeExpandJumpRight: ["ctrl + shift + 39", "meta + shift + 39"]
  };
  var actions = {
    rangeJumpLeft: function(e) {
      this.dispatch("keybinding-nav-range", e, "left", true, false);
    },
    rangeJumpRight: function(e) {
      this.dispatch("keybinding-nav-range", e, "right", true, false);
    },
    rangeJumpUp: function(e) {
      this.dispatch("keybinding-nav-range", e, "up", true, false);
    },
    rangeJumpDown: function(e) {
      this.dispatch("keybinding-nav-range", e, "down", true, false);
    },
    rangeExpandLeft: function(e) {
      this.dispatch("keybinding-nav-range", e, "left", false, true);
    },
    rangeExpandRight: function(e) {
      this.dispatch("keybinding-nav-range", e, "right", false, true);
    },
    rangeExpandUp: function(e) {
      this.dispatch("keybinding-nav-range", e, "up", false, true);
    },
    rangeExpandDown: function(e) {
      this.dispatch("keybinding-nav-range", e, "down", false, true);
    },
    rangeExpandJumpLeft: function(e) {
      this.dispatch("keybinding-nav-range", e, "left", true, true);
    },
    rangeExpandJumpRight: function(e) {
      this.dispatch("keybinding-nav-range", e, "right", true, true);
    },
    rangeExpandJumpUp: function(e) {
      this.dispatch("keybinding-nav-range", e, "up", true, true);
    },
    rangeExpandJumpDown: function(e) {
      this.dispatch("keybinding-nav-range", e, "down", true, true);
    }
  };
  var pasteActions = {
    range: function(data) {
      var rows = [], range2 = this.table.modules.selectRange.activeRange, singleCell = false, bounds, startCell, startRow, rowWidth, dataLength;
      dataLength = data.length;
      if (range2) {
        bounds = range2.getBounds();
        startCell = bounds.start;
        if (bounds.start === bounds.end) {
          singleCell = true;
        }
        if (startCell) {
          rows = this.table.rowManager.activeRows.slice();
          startRow = rows.indexOf(startCell.row);
          if (singleCell) {
            rowWidth = data.length;
          } else {
            rowWidth = rows.indexOf(bounds.end.row) - startRow + 1;
          }
          if (startRow > -1) {
            this.table.blockRedraw();
            rows = rows.slice(startRow, startRow + rowWidth);
            rows.forEach((row, i2) => {
              row.updateData(data[i2 % dataLength]);
            });
            this.table.restoreRedraw();
          }
        }
      }
      return rows;
    }
  };
  var pasteParsers = {
    range: function(clipboard) {
      var data = [], rows = [], range2 = this.table.modules.selectRange.activeRange, singleCell = false, bounds, startCell, colWidth, columnMap, startCol;
      if (range2) {
        bounds = range2.getBounds();
        startCell = bounds.start;
        if (bounds.start === bounds.end) {
          singleCell = true;
        }
        if (startCell) {
          clipboard = clipboard.split("\n");
          clipboard.forEach(function(row) {
            data.push(row.split("	"));
          });
          if (data.length) {
            columnMap = this.table.columnManager.getVisibleColumnsByIndex();
            startCol = columnMap.indexOf(startCell.column);
            if (startCol > -1) {
              if (singleCell) {
                colWidth = data[0].length;
              } else {
                colWidth = columnMap.indexOf(bounds.end.column) - startCol + 1;
              }
              columnMap = columnMap.slice(startCol, startCol + colWidth);
              data.forEach((item) => {
                var row = {};
                var itemLength = item.length;
                columnMap.forEach(function(col, i2) {
                  row[col.field] = item[i2 % itemLength];
                });
                rows.push(row);
              });
              return rows;
            }
          }
        }
      }
      return false;
    }
  };
  var columnLookups = {
    range: function() {
      var columns = this.modules.selectRange.selectedColumns();
      if (this.columnManager.rowHeader) {
        columns.unshift(this.columnManager.rowHeader);
      }
      return columns;
    }
  };
  var rowLookups = {
    range: function() {
      return this.modules.selectRange.selectedRows();
    }
  };
  var extensions = {
    keybindings: {
      bindings,
      actions
    },
    clipboard: {
      pasteActions,
      pasteParsers
    },
    export: {
      columnLookups,
      rowLookups
    }
  };
  class SelectRange extends Module {
    constructor(table) {
      super(table);
      this.selecting = "cell";
      this.mousedown = false;
      this.ranges = [];
      this.overlay = null;
      this.rowHeader = null;
      this.layoutChangeTimeout = null;
      this.columnSelection = false;
      this.rowSelection = false;
      this.maxRanges = 0;
      this.activeRange = false;
      this.blockKeydown = false;
      this.keyDownEvent = this._handleKeyDown.bind(this);
      this.mouseUpEvent = this._handleMouseUp.bind(this);
      this.registerTableOption("selectableRange", false);
      this.registerTableOption("selectableRangeColumns", false);
      this.registerTableOption("selectableRangeRows", false);
      this.registerTableOption("selectableRangeClearCells", false);
      this.registerTableOption("selectableRangeClearCellsValue", void 0);
      this.registerTableOption("selectableRangeAutoFocus", true);
      this.registerTableFunction("getRangesData", this.getRangesData.bind(this));
      this.registerTableFunction("getRanges", this.getRanges.bind(this));
      this.registerTableFunction("addRange", this.addRangeFromComponent.bind(this));
      this.registerComponentFunction("cell", "getRanges", this.cellGetRanges.bind(this));
      this.registerComponentFunction("row", "getRanges", this.rowGetRanges.bind(this));
      this.registerComponentFunction("column", "getRanges", this.colGetRanges.bind(this));
    }
    ///////////////////////////////////
    ///////    Initialization   ///////
    ///////////////////////////////////
    initialize() {
      if (this.options("selectableRange")) {
        if (!this.options("selectableRows")) {
          this.maxRanges = this.options("selectableRange");
          this.initializeTable();
          this.initializeWatchers();
        } else {
          console.warn("SelectRange functionality cannot be used in conjunction with row selection");
        }
        if (this.options("columns").findIndex((column) => column.frozen) > 0) {
          console.warn("Having frozen column in arbitrary position with selectRange option may result in unpredictable behavior.");
        }
        if (this.options("columns").filter((column) => column.frozen) > 1) {
          console.warn("Having multiple frozen columns with selectRange option may result in unpredictable behavior.");
        }
      }
    }
    initializeTable() {
      this.overlay = document.createElement("div");
      this.overlay.classList.add("tabulator-range-overlay");
      this.rangeContainer = document.createElement("div");
      this.rangeContainer.classList.add("tabulator-range-container");
      this.activeRangeCellElement = document.createElement("div");
      this.activeRangeCellElement.classList.add("tabulator-range-cell-active");
      this.overlay.appendChild(this.rangeContainer);
      this.overlay.appendChild(this.activeRangeCellElement);
      this.table.rowManager.element.addEventListener("keydown", this.keyDownEvent);
      this.resetRanges();
      this.table.rowManager.element.appendChild(this.overlay);
      this.table.columnManager.element.setAttribute("tabindex", 0);
      this.table.element.classList.add("tabulator-ranges");
    }
    initializeWatchers() {
      this.columnSelection = this.options("selectableRangeColumns");
      this.rowSelection = this.options("selectableRangeRows");
      this.subscribe("column-init", this.initializeColumn.bind(this));
      this.subscribe("column-mousedown", this.handleColumnMouseDown.bind(this));
      this.subscribe("column-mousemove", this.handleColumnMouseMove.bind(this));
      this.subscribe("column-resized", this.handleColumnResized.bind(this));
      this.subscribe("column-moving", this.handleColumnMoving.bind(this));
      this.subscribe("column-moved", this.handleColumnMoved.bind(this));
      this.subscribe("column-width", this.layoutChange.bind(this));
      this.subscribe("column-height", this.layoutChange.bind(this));
      this.subscribe("column-resized", this.layoutChange.bind(this));
      this.subscribe("columns-loaded", this.updateHeaderColumn.bind(this));
      this.subscribe("cell-height", this.layoutChange.bind(this));
      this.subscribe("cell-rendered", this.renderCell.bind(this));
      this.subscribe("cell-mousedown", this.handleCellMouseDown.bind(this));
      this.subscribe("cell-mousemove", this.handleCellMouseMove.bind(this));
      this.subscribe("cell-click", this.handleCellClick.bind(this));
      this.subscribe("cell-editing", this.handleEditingCell.bind(this));
      this.subscribe("page-changed", this.redraw.bind(this));
      this.subscribe("scroll-vertical", this.layoutChange.bind(this));
      this.subscribe("scroll-horizontal", this.layoutChange.bind(this));
      this.subscribe("data-destroy", this.tableDestroyed.bind(this));
      this.subscribe("data-processed", this.resetRanges.bind(this));
      this.subscribe("table-layout", this.layoutElement.bind(this));
      this.subscribe("table-redraw", this.redraw.bind(this));
      this.subscribe("table-destroy", this.tableDestroyed.bind(this));
      this.subscribe("edit-editor-clear", this.finishEditingCell.bind(this));
      this.subscribe("edit-blur", this.restoreFocus.bind(this));
      this.subscribe("keybinding-nav-prev", this.keyNavigate.bind(this, "left"));
      this.subscribe("keybinding-nav-next", this.keyNavigate.bind(this, "right"));
      this.subscribe("keybinding-nav-left", this.keyNavigate.bind(this, "left"));
      this.subscribe("keybinding-nav-right", this.keyNavigate.bind(this, "right"));
      this.subscribe("keybinding-nav-up", this.keyNavigate.bind(this, "up"));
      this.subscribe("keybinding-nav-down", this.keyNavigate.bind(this, "down"));
      this.subscribe("keybinding-nav-range", this.keyNavigateRange.bind(this));
    }
    initializeColumn(column) {
      if (this.columnSelection && column.definition.headerSort && this.options("headerSortClickElement") !== "icon") {
        console.warn("Using column headerSort with selectableRangeColumns option may result in unpredictable behavior. Consider using headerSortClickElement: 'icon'.");
      }
      if (column.modules.edit) ;
    }
    updateHeaderColumn() {
      var frozenCols;
      if (this.rowSelection) {
        this.rowHeader = this.table.columnManager.getVisibleColumnsByIndex()[0];
        if (this.rowHeader) {
          this.rowHeader.definition.cssClass = this.rowHeader.definition.cssClass + " tabulator-range-row-header";
          if (this.rowHeader.definition.headerSort) {
            console.warn("Using column headerSort with selectableRangeRows option may result in unpredictable behavior");
          }
          if (this.rowHeader.definition.editor) {
            console.warn("Using column editor with selectableRangeRows option may result in unpredictable behavior");
          }
        }
      }
      if (this.table.modules.frozenColumns && this.table.modules.frozenColumns.active) {
        frozenCols = this.table.modules.frozenColumns.getFrozenColumns();
        if (frozenCols.length > 1 || frozenCols.length === 1 && frozenCols[0] !== this.rowHeader) {
          console.warn("Using frozen columns that are not the range header in combination with the selectRange option may result in unpredictable behavior");
        }
      }
    }
    ///////////////////////////////////
    ///////   Table Functions   ///////
    ///////////////////////////////////
    getRanges() {
      return this.ranges.map((range2) => range2.getComponent());
    }
    getRangesData() {
      return this.ranges.map((range2) => range2.getData());
    }
    addRangeFromComponent(start, end) {
      start = start ? start._cell : null;
      end = end ? end._cell : null;
      return this.addRange(start, end);
    }
    ///////////////////////////////////
    /////// Component Functions ///////
    ///////////////////////////////////
    cellGetRanges(cell) {
      var ranges = [];
      if (cell.column === this.rowHeader) {
        ranges = this.ranges.filter((range2) => range2.occupiesRow(cell.row));
      } else {
        ranges = this.ranges.filter((range2) => range2.occupies(cell));
      }
      return ranges.map((range2) => range2.getComponent());
    }
    rowGetRanges(row) {
      var ranges = this.ranges.filter((range2) => range2.occupiesRow(row));
      return ranges.map((range2) => range2.getComponent());
    }
    colGetRanges(col) {
      var ranges = this.ranges.filter((range2) => range2.occupiesColumn(col));
      return ranges.map((range2) => range2.getComponent());
    }
    ///////////////////////////////////
    ////////// Event Handlers /////////
    ///////////////////////////////////
    _handleMouseUp(e) {
      this.mousedown = false;
      document.removeEventListener("mouseup", this.mouseUpEvent);
    }
    _handleKeyDown(e) {
      if (!this.blockKeydown && (!this.table.modules.edit || this.table.modules.edit && !this.table.modules.edit.currentCell)) {
        if (e.key === "Enter") {
          if (this.table.modules.edit && this.table.modules.edit.currentCell) {
            return;
          }
          this.table.modules.edit.editCell(this.getActiveCell());
          e.preventDefault();
        }
        if ((e.key === "Backspace" || e.key === "Delete") && this.options("selectableRangeClearCells")) {
          if (this.activeRange) {
            this.activeRange.clearValues();
          }
        }
      }
    }
    initializeFocus(cell) {
      var range2;
      this.restoreFocus();
      try {
        if (document.selection) {
          range2 = document.body.createTextRange();
          range2.moveToElementText(cell.getElement());
          range2.select();
        } else if (window.getSelection) {
          range2 = document.createRange();
          range2.selectNode(cell.getElement());
          window.getSelection().removeAllRanges();
          window.getSelection().addRange(range2);
        }
      } catch (e) {
      }
    }
    restoreFocus(element) {
      this.table.rowManager.element.focus();
      return true;
    }
    ///////////////////////////////////
    ////// Column Functionality ///////
    ///////////////////////////////////
    handleColumnResized(column) {
      var selected;
      if (this.selecting !== "column" && this.selecting !== "all") {
        return;
      }
      selected = this.ranges.some((range2) => range2.occupiesColumn(column));
      if (!selected) {
        return;
      }
      this.ranges.forEach((range2) => {
        var selectedColumns = range2.getColumns(true);
        selectedColumns.forEach((selectedColumn) => {
          if (selectedColumn !== column) {
            selectedColumn.setWidth(column.width);
          }
        });
      });
    }
    handleColumnMoving(_event, column) {
      this.resetRanges().setBounds(column);
      this.overlay.style.visibility = "hidden";
    }
    handleColumnMoved(from, _to, _after) {
      this.activeRange.setBounds(from);
      this.layoutElement();
    }
    handleColumnMouseDown(event, column) {
      if (event.button === 2 && (this.selecting === "column" || this.selecting === "all") && this.activeRange.occupiesColumn(column)) {
        return;
      }
      if (this.table.options.movableColumns && this.selecting === "column" && this.activeRange.occupiesColumn(column)) {
        return;
      }
      this.mousedown = true;
      document.addEventListener("mouseup", this.mouseUpEvent);
      this.newSelection(event, column);
    }
    handleColumnMouseMove(e, column) {
      if (column === this.rowHeader || !this.mousedown || this.selecting === "all") {
        return;
      }
      this.activeRange.setBounds(false, column, true);
    }
    ///////////////////////////////////
    //////// Cell Functionality ///////
    ///////////////////////////////////
    renderCell(cell) {
      var el = cell.getElement(), rangeIdx = this.ranges.findIndex((range2) => range2.occupies(cell));
      el.classList.toggle("tabulator-range-selected", rangeIdx !== -1);
      el.classList.toggle("tabulator-range-only-cell-selected", this.ranges.length === 1 && this.ranges[0].atTopLeft(cell) && this.ranges[0].atBottomRight(cell));
      el.dataset.range = rangeIdx;
    }
    handleCellMouseDown(event, cell) {
      if (event.button === 2 && (this.activeRange.occupies(cell) || (this.selecting === "row" || this.selecting === "all") && this.activeRange.occupiesRow(cell.row))) {
        return;
      }
      this.mousedown = true;
      document.addEventListener("mouseup", this.mouseUpEvent);
      this.newSelection(event, cell);
    }
    handleCellMouseMove(e, cell) {
      if (!this.mousedown || this.selecting === "all") {
        return;
      }
      this.activeRange.setBounds(false, cell, true);
    }
    handleCellClick(e, cell) {
      this.initializeFocus(cell);
    }
    handleEditingCell(cell) {
      if (this.activeRange) {
        this.activeRange.setBounds(cell);
      }
    }
    finishEditingCell() {
      this.blockKeydown = true;
      this.table.rowManager.element.focus();
      setTimeout(() => {
        this.blockKeydown = false;
      }, 10);
    }
    ///////////////////////////////////
    ///////     Navigation      ///////
    ///////////////////////////////////
    keyNavigate(dir, e) {
      if (this.navigate(false, false, dir)) ;
      e.preventDefault();
    }
    keyNavigateRange(e, dir, jump, expand) {
      if (this.navigate(jump, expand, dir)) ;
      e.preventDefault();
    }
    navigate(jump, expand, dir) {
      var moved = false, range2, rangeEdge, prevRect, nextRow, nextCol, row, column, rowRect, rowManagerRect, columnRect, columnManagerRect;
      if (this.table.modules.edit && this.table.modules.edit.currentCell) {
        return false;
      }
      if (this.ranges.length > 1) {
        this.ranges = this.ranges.filter((range3) => {
          if (range3 === this.activeRange) {
            range3.setEnd(range3.start.row, range3.start.col);
            return true;
          }
          range3.destroy();
          return false;
        });
      }
      range2 = this.activeRange;
      prevRect = {
        top: range2.top,
        bottom: range2.bottom,
        left: range2.left,
        right: range2.right
      };
      rangeEdge = expand ? range2.end : range2.start;
      nextRow = rangeEdge.row;
      nextCol = rangeEdge.col;
      if (jump) {
        switch (dir) {
          case "left":
            nextCol = this.findJumpCellLeft(range2.start.row, rangeEdge.col);
            break;
          case "right":
            nextCol = this.findJumpCellRight(range2.start.row, rangeEdge.col);
            break;
          case "up":
            nextRow = this.findJumpCellUp(rangeEdge.row, range2.start.col);
            break;
          case "down":
            nextRow = this.findJumpCellDown(rangeEdge.row, range2.start.col);
            break;
        }
      } else {
        if (expand) {
          if (this.selecting === "row" && (dir === "left" || dir === "right") || this.selecting === "column" && (dir === "up" || dir === "down")) {
            return;
          }
        }
        switch (dir) {
          case "left":
            nextCol = Math.max(nextCol - 1, 0);
            break;
          case "right":
            nextCol = Math.min(nextCol + 1, this.getTableColumns().length - 1);
            break;
          case "up":
            nextRow = Math.max(nextRow - 1, 0);
            break;
          case "down":
            nextRow = Math.min(nextRow + 1, this.getTableRows().length - 1);
            break;
        }
      }
      if (this.rowHeader && nextCol === 0) {
        nextCol = 1;
      }
      if (!expand) {
        range2.setStart(nextRow, nextCol);
      }
      range2.setEnd(nextRow, nextCol);
      if (!expand) {
        this.selecting = "cell";
      }
      moved = prevRect.top !== range2.top || prevRect.bottom !== range2.bottom || prevRect.left !== range2.left || prevRect.right !== range2.right;
      if (moved) {
        row = this.getRowByRangePos(range2.end.row);
        column = this.getColumnByRangePos(range2.end.col);
        rowRect = row.getElement().getBoundingClientRect();
        columnRect = column.getElement().getBoundingClientRect();
        rowManagerRect = this.table.rowManager.getElement().getBoundingClientRect();
        columnManagerRect = this.table.columnManager.getElement().getBoundingClientRect();
        if (!(rowRect.top >= rowManagerRect.top && rowRect.bottom <= rowManagerRect.bottom)) {
          if (row.getElement().parentNode && column.getElement().parentNode) {
            this.autoScroll(range2, row.getElement(), column.getElement());
          } else {
            row.getComponent().scrollTo(void 0, false);
          }
        }
        if (!(columnRect.left >= columnManagerRect.left + this.getRowHeaderWidth() && columnRect.right <= columnManagerRect.right)) {
          if (row.getElement().parentNode && column.getElement().parentNode) {
            this.autoScroll(range2, row.getElement(), column.getElement());
          } else {
            column.getComponent().scrollTo(void 0, false);
          }
        }
        this.layoutElement();
        return true;
      }
    }
    rangeRemoved(removed) {
      this.ranges = this.ranges.filter((range2) => range2 !== removed);
      if (this.activeRange === removed) {
        if (this.ranges.length) {
          this.activeRange = this.ranges[this.ranges.length - 1];
        } else {
          this.addRange();
        }
      }
      this.layoutElement();
    }
    findJumpRow(column, rows, reverse, emptyStart, emptySide) {
      if (reverse) {
        rows = rows.reverse();
      }
      return this.findJumpItem(emptyStart, emptySide, rows, function(row) {
        return row.getData()[column.getField()];
      });
    }
    findJumpCol(row, columns, reverse, emptyStart, emptySide) {
      if (reverse) {
        columns = columns.reverse();
      }
      return this.findJumpItem(emptyStart, emptySide, columns, function(column) {
        return row.getData()[column.getField()];
      });
    }
    findJumpItem(emptyStart, emptySide, items, valueResolver) {
      var nextItem;
      for (let currentItem of items) {
        let currentValue = valueResolver(currentItem);
        if (emptyStart) {
          nextItem = currentItem;
          if (currentValue) {
            break;
          }
        } else {
          if (emptySide) {
            nextItem = currentItem;
            if (currentValue) {
              break;
            }
          } else {
            if (currentValue) {
              nextItem = currentItem;
            } else {
              break;
            }
          }
        }
      }
      return nextItem;
    }
    findJumpCellLeft(rowPos, colPos) {
      var row = this.getRowByRangePos(rowPos), columns = this.getTableColumns(), isStartingCellEmpty = this.isEmpty(row.getData()[columns[colPos].getField()]), isLeftOfStartingCellEmpty = columns[colPos - 1] ? this.isEmpty(row.getData()[columns[colPos - 1].getField()]) : false, targetCols = this.rowHeader ? columns.slice(1, colPos) : columns.slice(0, colPos), jumpCol = this.findJumpCol(row, targetCols, true, isStartingCellEmpty, isLeftOfStartingCellEmpty);
      if (jumpCol) {
        return jumpCol.getPosition() - 1;
      }
      return colPos;
    }
    findJumpCellRight(rowPos, colPos) {
      var row = this.getRowByRangePos(rowPos), columns = this.getTableColumns(), isStartingCellEmpty = this.isEmpty(row.getData()[columns[colPos].getField()]), isRightOfStartingCellEmpty = columns[colPos + 1] ? this.isEmpty(row.getData()[columns[colPos + 1].getField()]) : false, jumpCol = this.findJumpCol(row, columns.slice(colPos + 1, columns.length), false, isStartingCellEmpty, isRightOfStartingCellEmpty);
      if (jumpCol) {
        return jumpCol.getPosition() - 1;
      }
      return colPos;
    }
    findJumpCellUp(rowPos, colPos) {
      var column = this.getColumnByRangePos(colPos), rows = this.getTableRows(), isStartingCellEmpty = this.isEmpty(rows[rowPos].getData()[column.getField()]), isTopOfStartingCellEmpty = rows[rowPos - 1] ? this.isEmpty(rows[rowPos - 1].getData()[column.getField()]) : false, jumpRow = this.findJumpRow(column, rows.slice(0, rowPos), true, isStartingCellEmpty, isTopOfStartingCellEmpty);
      if (jumpRow) {
        return jumpRow.position - 1;
      }
      return rowPos;
    }
    findJumpCellDown(rowPos, colPos) {
      var column = this.getColumnByRangePos(colPos), rows = this.getTableRows(), isStartingCellEmpty = this.isEmpty(rows[rowPos].getData()[column.getField()]), isBottomOfStartingCellEmpty = rows[rowPos + 1] ? this.isEmpty(rows[rowPos + 1].getData()[column.getField()]) : false, jumpRow = this.findJumpRow(column, rows.slice(rowPos + 1, rows.length), false, isStartingCellEmpty, isBottomOfStartingCellEmpty);
      if (jumpRow) {
        return jumpRow.position - 1;
      }
      return rowPos;
    }
    ///////////////////////////////////
    ///////      Selection      ///////
    ///////////////////////////////////
    newSelection(event, element) {
      var range2;
      if (element.type === "column") {
        if (!this.columnSelection) {
          return;
        }
        if (element === this.rowHeader) {
          range2 = this.resetRanges();
          this.selecting = "all";
          var topLeftCell, bottomRightCell = this.getCell(-1, -1);
          if (this.rowHeader) {
            topLeftCell = this.getCell(0, 1);
          } else {
            topLeftCell = this.getCell(0, 0);
          }
          range2.setBounds(topLeftCell, bottomRightCell);
          return;
        } else {
          this.selecting = "column";
        }
      } else if (element.column === this.rowHeader) {
        this.selecting = "row";
      } else {
        this.selecting = "cell";
      }
      if (event.shiftKey) {
        this.activeRange.setBounds(false, element);
      } else if (event.ctrlKey) {
        this.addRange().setBounds(element);
      } else {
        this.resetRanges().setBounds(element);
      }
    }
    autoScroll(range2, row, column) {
      var tableHolder = this.table.rowManager.element, rect, view, withinHorizontalView, withinVerticalView;
      if (typeof row === "undefined") {
        row = this.getRowByRangePos(range2.end.row).getElement();
      }
      if (typeof column === "undefined") {
        column = this.getColumnByRangePos(range2.end.col).getElement();
      }
      rect = {
        left: column.offsetLeft,
        right: column.offsetLeft + column.offsetWidth,
        top: row.offsetTop,
        bottom: row.offsetTop + row.offsetHeight
      };
      view = {
        left: tableHolder.scrollLeft + this.getRowHeaderWidth(),
        right: Math.ceil(tableHolder.scrollLeft + tableHolder.clientWidth),
        top: tableHolder.scrollTop,
        bottom: tableHolder.scrollTop + tableHolder.offsetHeight - this.table.rowManager.scrollbarWidth
      };
      withinHorizontalView = view.left < rect.left && rect.left < view.right && view.left < rect.right && rect.right < view.right;
      withinVerticalView = view.top < rect.top && rect.top < view.bottom && view.top < rect.bottom && rect.bottom < view.bottom;
      if (!withinHorizontalView) {
        if (rect.left < view.left) {
          tableHolder.scrollLeft = rect.left - this.getRowHeaderWidth();
        } else if (rect.right > view.right) {
          tableHolder.scrollLeft = Math.min(rect.right - tableHolder.clientWidth, rect.left - this.getRowHeaderWidth());
        }
      }
      if (!withinVerticalView) {
        if (rect.top < view.top) {
          tableHolder.scrollTop = rect.top;
        } else if (rect.bottom > view.bottom) {
          tableHolder.scrollTop = rect.bottom - tableHolder.clientHeight;
        }
      }
    }
    ///////////////////////////////////
    ///////       Layout        ///////
    ///////////////////////////////////
    layoutChange() {
      this.overlay.style.visibility = "hidden";
      clearTimeout(this.layoutChangeTimeout);
      this.layoutChangeTimeout = setTimeout(this.layoutRanges.bind(this), 200);
    }
    redraw(force) {
      if (force) {
        this.selecting = "cell";
        this.resetRanges();
        this.layoutElement();
      }
    }
    layoutElement(visibleRows) {
      var rows;
      if (visibleRows) {
        rows = this.table.rowManager.getVisibleRows(true);
      } else {
        rows = this.table.rowManager.getRows();
      }
      rows.forEach((row) => {
        if (row.type === "row") {
          this.layoutRow(row);
          row.cells.forEach((cell) => this.renderCell(cell));
        }
      });
      this.getTableColumns().forEach((column) => {
        this.layoutColumn(column);
      });
      this.layoutRanges();
    }
    layoutRow(row) {
      var el = row.getElement(), selected = false, occupied = this.ranges.some((range2) => range2.occupiesRow(row));
      if (this.selecting === "row") {
        selected = occupied;
      } else if (this.selecting === "all") {
        selected = true;
      }
      el.classList.toggle("tabulator-range-selected", selected);
      el.classList.toggle("tabulator-range-highlight", occupied);
    }
    layoutColumn(column) {
      var el = column.getElement(), selected = false, occupied = this.ranges.some((range2) => range2.occupiesColumn(column));
      if (this.selecting === "column") {
        selected = occupied;
      } else if (this.selecting === "all") {
        selected = true;
      }
      el.classList.toggle("tabulator-range-selected", selected);
      el.classList.toggle("tabulator-range-highlight", occupied);
    }
    layoutRanges() {
      var activeCell, activeCellEl, activeRowEl;
      if (!this.table.initialized) {
        return;
      }
      activeCell = this.getActiveCell();
      if (!activeCell) {
        return;
      }
      activeCellEl = activeCell.getElement();
      activeRowEl = activeCell.row.getElement();
      if (this.table.rtl) {
        this.activeRangeCellElement.style.right = activeRowEl.offsetWidth - activeCellEl.offsetLeft - activeCellEl.offsetWidth + "px";
      } else {
        this.activeRangeCellElement.style.left = activeRowEl.offsetLeft + activeCellEl.offsetLeft + "px";
      }
      this.activeRangeCellElement.style.top = activeRowEl.offsetTop + "px";
      this.activeRangeCellElement.style.width = activeCellEl.offsetWidth + "px";
      this.activeRangeCellElement.style.height = activeRowEl.offsetHeight + "px";
      this.ranges.forEach((range2) => range2.layout());
      this.overlay.style.visibility = "visible";
    }
    ///////////////////////////////////
    ///////  Helper Functions   ///////
    ///////////////////////////////////	
    getCell(rowIdx, colIdx) {
      var row;
      if (colIdx < 0) {
        colIdx = this.getTableColumns().length + colIdx;
        if (colIdx < 0) {
          return null;
        }
      }
      if (rowIdx < 0) {
        rowIdx = this.getTableRows().length + rowIdx;
      }
      row = this.table.rowManager.getRowFromPosition(rowIdx + 1);
      return row ? row.getCells(false, true).filter((cell) => cell.column.visible)[colIdx] : null;
    }
    getActiveCell() {
      return this.getCell(this.activeRange.start.row, this.activeRange.start.col);
    }
    getRowByRangePos(pos) {
      return this.getTableRows()[pos];
    }
    getColumnByRangePos(pos) {
      return this.getTableColumns()[pos];
    }
    getTableRows() {
      return this.table.rowManager.getDisplayRows().filter((row) => row.type === "row");
    }
    getTableColumns() {
      return this.table.columnManager.getVisibleColumnsByIndex();
    }
    addRange(start, end) {
      var range2;
      if (this.maxRanges !== true && this.ranges.length >= this.maxRanges) {
        this.ranges.shift().destroy();
      }
      range2 = new Range(this.table, this, start, end);
      this.activeRange = range2;
      this.ranges.push(range2);
      this.rangeContainer.appendChild(range2.element);
      return range2;
    }
    resetRanges() {
      var range2, cell, visibleCells;
      this.ranges.forEach((range3) => range3.destroy());
      this.ranges = [];
      range2 = this.addRange();
      if (this.table.rowManager.activeRows.length) {
        visibleCells = this.table.rowManager.activeRows[0].cells.filter((cell2) => cell2.column.visible);
        cell = visibleCells[this.rowHeader ? 1 : 0];
        if (cell) {
          range2.setBounds(cell);
          if (this.options("selectableRangeAutoFocus")) {
            this.initializeFocus(cell);
          }
        }
      }
      return range2;
    }
    tableDestroyed() {
      document.removeEventListener("mouseup", this.mouseUpEvent);
      this.table.rowManager.element.removeEventListener("keydown", this.keyDownEvent);
    }
    selectedRows(component) {
      return component ? this.activeRange.getRows().map((row) => row.getComponent()) : this.activeRange.getRows();
    }
    selectedColumns(component) {
      return component ? this.activeRange.getColumns().map((col) => col.getComponent()) : this.activeRange.getColumns();
    }
    getRowHeaderWidth() {
      if (!this.rowHeader) {
        return 0;
      }
      return this.rowHeader.getElement().offsetWidth;
    }
    isEmpty(value) {
      return value === null || value === void 0 || value === "";
    }
  }
  __publicField(SelectRange, "moduleName", "selectRange");
  __publicField(SelectRange, "moduleInitOrder", 1);
  __publicField(SelectRange, "moduleExtensions", extensions);
  var defaultOptions = {
    debugEventsExternal: false,
    //flag to console log events
    debugEventsInternal: false,
    //flag to console log events
    debugInvalidOptions: true,
    //allow toggling of invalid option warnings
    debugInvalidComponentFuncs: true,
    //allow toggling of invalid component warnings
    debugInitialization: true,
    //allow toggling of pre initialization function call warnings
    debugDeprecation: true,
    //allow toggling of deprecation warnings
    height: false,
    //height of tabulator
    minHeight: false,
    //minimum height of tabulator
    maxHeight: false,
    //maximum height of tabulator
    columnHeaderVertAlign: "top",
    //vertical alignment of column headers
    popupContainer: false,
    columns: [],
    //store for colum header info
    columnDefaults: {},
    //store column default props
    rowHeader: false,
    data: false,
    //default starting data
    autoColumns: false,
    //build columns from data row structure
    autoColumnsDefinitions: false,
    nestedFieldSeparator: ".",
    //separator for nested data
    footerElement: false,
    //hold footer element
    index: "id",
    //filed for row index
    textDirection: "auto",
    addRowPos: "bottom",
    //position to insert blank rows, top|bottom
    headerVisible: true,
    //hide header
    renderVertical: "virtual",
    renderHorizontal: "basic",
    renderVerticalBuffer: 0,
    // set virtual DOM buffer size
    scrollToRowPosition: "top",
    scrollToRowIfVisible: true,
    scrollToColumnPosition: "left",
    scrollToColumnIfVisible: true,
    rowFormatter: false,
    rowFormatterPrint: null,
    rowFormatterClipboard: null,
    rowFormatterHtmlOutput: null,
    rowHeight: null,
    placeholder: false,
    dataLoader: true,
    dataLoaderLoading: false,
    dataLoaderError: false,
    dataLoaderErrorTimeout: 3e3,
    dataSendParams: {},
    dataReceiveParams: {},
    dependencies: {}
  };
  class OptionsList {
    constructor(table, msgType, defaults2 = {}) {
      this.table = table;
      this.msgType = msgType;
      this.registeredDefaults = Object.assign({}, defaults2);
    }
    register(option, value) {
      this.registeredDefaults[option] = value;
    }
    generate(defaultOptions2, userOptions = {}) {
      var output = Object.assign({}, this.registeredDefaults), warn = this.table.options.debugInvalidOptions || userOptions.debugInvalidOptions === true;
      Object.assign(output, defaultOptions2);
      for (let key in userOptions) {
        if (!output.hasOwnProperty(key)) {
          if (warn) {
            console.warn("Invalid " + this.msgType + " option:", key);
          }
          output[key] = userOptions.key;
        }
      }
      for (let key in output) {
        if (key in userOptions) {
          output[key] = userOptions[key];
        } else {
          if (Array.isArray(output[key])) {
            output[key] = Object.assign([], output[key]);
          } else if (typeof output[key] === "object" && output[key] !== null) {
            output[key] = Object.assign({}, output[key]);
          } else if (typeof output[key] === "undefined") {
            delete output[key];
          }
        }
      }
      return output;
    }
  }
  class Renderer extends CoreFeature {
    constructor(table) {
      super(table);
      this.elementVertical = table.rowManager.element;
      this.elementHorizontal = table.columnManager.element;
      this.tableElement = table.rowManager.tableElement;
      this.verticalFillMode = "fit";
    }
    ///////////////////////////////////
    /////// Internal Bindings /////////
    ///////////////////////////////////
    initialize() {
    }
    clearRows() {
    }
    clearColumns() {
    }
    reinitializeColumnWidths(columns) {
    }
    renderRows() {
    }
    renderColumns() {
    }
    rerenderRows(callback) {
      if (callback) {
        callback();
      }
    }
    rerenderColumns(update, blockRedraw) {
    }
    renderRowCells(row) {
    }
    rerenderRowCells(row, force) {
    }
    scrollColumns(left, dir) {
    }
    scrollRows(top, dir) {
    }
    resize() {
    }
    scrollToRow(row) {
    }
    scrollToRowNearestTop(row) {
    }
    visibleRows(includingBuffer) {
      return [];
    }
    ///////////////////////////////////
    //////// Helper Functions /////////
    ///////////////////////////////////
    rows() {
      return this.table.rowManager.getDisplayRows();
    }
    styleRow(row, index2) {
      var rowEl = row.getElement();
      if (index2 % 2) {
        rowEl.classList.add("tabulator-row-even");
        rowEl.classList.remove("tabulator-row-odd");
      } else {
        rowEl.classList.add("tabulator-row-odd");
        rowEl.classList.remove("tabulator-row-even");
      }
    }
    ///////////////////////////////////
    /////// External Triggers /////////
    /////// (DO NOT OVERRIDE) /////////
    ///////////////////////////////////
    clear() {
      this.clearRows();
      this.clearColumns();
    }
    render() {
      this.renderRows();
      this.renderColumns();
    }
    rerender(callback) {
      this.rerenderRows();
      this.rerenderColumns();
    }
    scrollToRowPosition(row, position, ifVisible) {
      var rowIndex = this.rows().indexOf(row), rowEl = row.getElement(), offset2 = 0;
      return new Promise((resolve2, reject) => {
        if (rowIndex > -1) {
          if (typeof ifVisible === "undefined") {
            ifVisible = this.table.options.scrollToRowIfVisible;
          }
          if (!ifVisible) {
            if (Helpers.elVisible(rowEl)) {
              offset2 = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top;
              if (offset2 > 0 && offset2 < this.elementVertical.clientHeight - rowEl.offsetHeight) {
                resolve2();
                return false;
              }
            }
          }
          if (typeof position === "undefined") {
            position = this.table.options.scrollToRowPosition;
          }
          if (position === "nearest") {
            position = this.scrollToRowNearestTop(row) ? "top" : "bottom";
          }
          this.scrollToRow(row);
          switch (position) {
            case "middle":
            case "center":
              if (this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight) {
                this.elementVertical.scrollTop = this.elementVertical.scrollTop + (rowEl.offsetTop - this.elementVertical.scrollTop) - (this.elementVertical.scrollHeight - rowEl.offsetTop) / 2;
              } else {
                this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight / 2;
              }
              break;
            case "bottom":
              if (this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight) {
                this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.scrollHeight - rowEl.offsetTop) + rowEl.offsetHeight;
              } else {
                this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight + rowEl.offsetHeight;
              }
              break;
            case "top":
              this.elementVertical.scrollTop = rowEl.offsetTop;
              break;
          }
          resolve2();
        } else {
          console.warn("Scroll Error - Row not visible");
          reject("Scroll Error - Row not visible");
        }
      });
    }
  }
  class BasicHorizontal extends Renderer {
    constructor(table) {
      super(table);
    }
    renderRowCells(row, inFragment) {
      const rowFrag = document.createDocumentFragment();
      row.cells.forEach((cell) => {
        rowFrag.appendChild(cell.getElement());
      });
      row.element.appendChild(rowFrag);
      if (!inFragment) {
        row.cells.forEach((cell) => {
          cell.cellRendered();
        });
      }
    }
    reinitializeColumnWidths(columns) {
      columns.forEach(function(column) {
        column.reinitializeWidth();
      });
    }
  }
  class VirtualDomHorizontal extends Renderer {
    constructor(table) {
      super(table);
      this.leftCol = 0;
      this.rightCol = 0;
      this.scrollLeft = 0;
      this.vDomScrollPosLeft = 0;
      this.vDomScrollPosRight = 0;
      this.vDomPadLeft = 0;
      this.vDomPadRight = 0;
      this.fitDataColAvg = 0;
      this.windowBuffer = 200;
      this.visibleRows = null;
      this.initialized = false;
      this.isFitData = false;
      this.columns = [];
    }
    initialize() {
      this.compatibilityCheck();
      this.layoutCheck();
      this.vertScrollListen();
    }
    compatibilityCheck() {
      if (this.options("layout") == "fitDataTable") {
        console.warn("Horizontal Virtual DOM is not compatible with fitDataTable layout mode");
      }
      if (this.options("responsiveLayout")) {
        console.warn("Horizontal Virtual DOM is not compatible with responsive columns");
      }
      if (this.options("rtl")) {
        console.warn("Horizontal Virtual DOM is not currently compatible with RTL text direction");
      }
    }
    layoutCheck() {
      this.isFitData = this.options("layout").startsWith("fitData");
    }
    vertScrollListen() {
      this.subscribe("scroll-vertical", this.clearVisRowCache.bind(this));
      this.subscribe("data-refreshed", this.clearVisRowCache.bind(this));
    }
    clearVisRowCache() {
      this.visibleRows = null;
    }
    //////////////////////////////////////
    ///////// Public Functions ///////////
    //////////////////////////////////////
    renderColumns(row, force) {
      this.dataChange();
    }
    scrollColumns(left, dir) {
      if (this.scrollLeft != left) {
        this.scrollLeft = left;
        this.scroll(left - (this.vDomScrollPosLeft + this.windowBuffer));
      }
    }
    calcWindowBuffer() {
      var buffer = this.elementVertical.clientWidth;
      this.table.columnManager.columnsByIndex.forEach((column) => {
        if (column.visible) {
          var width = column.getWidth();
          if (width > buffer) {
            buffer = width;
          }
        }
      });
      this.windowBuffer = buffer * 2;
    }
    rerenderColumns(update, blockRedraw) {
      var old = {
        cols: this.columns,
        leftCol: this.leftCol,
        rightCol: this.rightCol
      }, colPos = 0;
      if (update && !this.initialized) {
        return;
      }
      this.clear();
      this.calcWindowBuffer();
      this.scrollLeft = this.elementVertical.scrollLeft;
      this.vDomScrollPosLeft = this.scrollLeft - this.windowBuffer;
      this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
      this.table.columnManager.columnsByIndex.forEach((column) => {
        var config = {}, width;
        if (column.visible) {
          if (!column.modules.frozen) {
            width = column.getWidth();
            config.leftPos = colPos;
            config.rightPos = colPos + width;
            config.width = width;
            if (this.isFitData) {
              config.fitDataCheck = column.modules.vdomHoz ? column.modules.vdomHoz.fitDataCheck : true;
            }
            if (colPos + width > this.vDomScrollPosLeft && colPos < this.vDomScrollPosRight) {
              if (this.leftCol == -1) {
                this.leftCol = this.columns.length;
                this.vDomPadLeft = colPos;
              }
              this.rightCol = this.columns.length;
            } else {
              if (this.leftCol !== -1) {
                this.vDomPadRight += width;
              }
            }
            this.columns.push(column);
            column.modules.vdomHoz = config;
            colPos += width;
          }
        }
      });
      this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
      this.tableElement.style.paddingRight = this.vDomPadRight + "px";
      this.initialized = true;
      if (!blockRedraw) {
        if (!update || this.reinitChanged(old)) {
          this.reinitializeRows();
        }
      }
      this.elementVertical.scrollLeft = this.scrollLeft;
    }
    renderRowCells(row) {
      if (this.initialized) {
        this.initializeRow(row);
      } else {
        const rowFrag = document.createDocumentFragment();
        row.cells.forEach((cell) => {
          rowFrag.appendChild(cell.getElement());
        });
        row.element.appendChild(rowFrag);
        row.cells.forEach((cell) => {
          cell.cellRendered();
        });
      }
    }
    rerenderRowCells(row, force) {
      this.reinitializeRow(row, force);
    }
    reinitializeColumnWidths(columns) {
      for (let i2 = this.leftCol; i2 <= this.rightCol; i2++) {
        let col = this.columns[i2];
        if (col) {
          col.reinitializeWidth();
        }
      }
    }
    //////////////////////////////////////
    //////// Internal Rendering //////////
    //////////////////////////////////////
    deinitialize() {
      this.initialized = false;
    }
    clear() {
      this.columns = [];
      this.leftCol = -1;
      this.rightCol = 0;
      this.vDomScrollPosLeft = 0;
      this.vDomScrollPosRight = 0;
      this.vDomPadLeft = 0;
      this.vDomPadRight = 0;
    }
    dataChange() {
      var change = false, row, rowEl;
      if (this.isFitData) {
        this.table.columnManager.columnsByIndex.forEach((column) => {
          if (!column.definition.width && column.visible) {
            change = true;
          }
        });
        if (change && this.table.rowManager.getDisplayRows().length) {
          this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
          row = this.chain("rows-sample", [1], [], () => {
            return this.table.rowManager.getDisplayRows();
          })[0];
          if (row) {
            rowEl = row.getElement();
            row.generateCells();
            this.tableElement.appendChild(rowEl);
            for (let colEnd = 0; colEnd < row.cells.length; colEnd++) {
              let cell = row.cells[colEnd];
              rowEl.appendChild(cell.getElement());
              cell.column.reinitializeWidth();
            }
            rowEl.parentNode.removeChild(rowEl);
            this.rerenderColumns(false, true);
          }
        }
      } else {
        if (this.options("layout") === "fitColumns") {
          this.layoutRefresh();
          this.rerenderColumns(false, true);
        }
      }
    }
    reinitChanged(old) {
      var match = true;
      if (old.cols.length !== this.columns.length || old.leftCol !== this.leftCol || old.rightCol !== this.rightCol) {
        return true;
      }
      old.cols.forEach((col, i2) => {
        if (col !== this.columns[i2]) {
          match = false;
        }
      });
      return !match;
    }
    reinitializeRows() {
      var visibleRows = this.getVisibleRows(), otherRows = this.table.rowManager.getRows().filter((row) => !visibleRows.includes(row));
      visibleRows.forEach((row) => {
        this.reinitializeRow(row, true);
      });
      otherRows.forEach((row) => {
        row.deinitialize();
      });
    }
    getVisibleRows() {
      if (!this.visibleRows) {
        this.visibleRows = this.table.rowManager.getVisibleRows();
      }
      return this.visibleRows;
    }
    scroll(diff) {
      this.vDomScrollPosLeft += diff;
      this.vDomScrollPosRight += diff;
      if (Math.abs(diff) > this.windowBuffer / 2) {
        this.rerenderColumns();
      } else {
        if (diff > 0) {
          this.addColRight();
          this.removeColLeft();
        } else {
          this.addColLeft();
          this.removeColRight();
        }
      }
    }
    colPositionAdjust(start, end, diff) {
      for (let i2 = start; i2 < end; i2++) {
        let column = this.columns[i2];
        column.modules.vdomHoz.leftPos += diff;
        column.modules.vdomHoz.rightPos += diff;
      }
    }
    addColRight() {
      var changes = false, working = true;
      while (working) {
        let column = this.columns[this.rightCol + 1];
        if (column) {
          if (column.modules.vdomHoz.leftPos <= this.vDomScrollPosRight) {
            changes = true;
            this.getVisibleRows().forEach((row) => {
              if (row.type !== "group") {
                var cell = row.getCell(column);
                row.getElement().insertBefore(cell.getElement(), row.getCell(this.columns[this.rightCol]).getElement().nextSibling);
                cell.cellRendered();
              }
            });
            this.fitDataColActualWidthCheck(column);
            this.rightCol++;
            this.getVisibleRows().forEach((row) => {
              if (row.type !== "group") {
                row.modules.vdomHoz.rightCol = this.rightCol;
              }
            });
            if (this.rightCol >= this.columns.length - 1) {
              this.vDomPadRight = 0;
            } else {
              this.vDomPadRight -= column.getWidth();
            }
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      if (changes) {
        this.tableElement.style.paddingRight = this.vDomPadRight + "px";
      }
    }
    addColLeft() {
      var changes = false, working = true;
      while (working) {
        let column = this.columns[this.leftCol - 1];
        if (column) {
          if (column.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft) {
            changes = true;
            this.getVisibleRows().forEach((row) => {
              if (row.type !== "group") {
                var cell = row.getCell(column);
                row.getElement().insertBefore(cell.getElement(), row.getCell(this.columns[this.leftCol]).getElement());
                cell.cellRendered();
              }
            });
            this.leftCol--;
            this.getVisibleRows().forEach((row) => {
              if (row.type !== "group") {
                row.modules.vdomHoz.leftCol = this.leftCol;
              }
            });
            if (this.leftCol <= 0) {
              this.vDomPadLeft = 0;
            } else {
              this.vDomPadLeft -= column.getWidth();
            }
            let diff = this.fitDataColActualWidthCheck(column);
            if (diff) {
              this.scrollLeft = this.elementVertical.scrollLeft = this.elementVertical.scrollLeft + diff;
              this.vDomPadRight -= diff;
            }
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      if (changes) {
        this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
      }
    }
    removeColRight() {
      var changes = false, working = true;
      while (working) {
        let column = this.columns[this.rightCol];
        if (column) {
          if (column.modules.vdomHoz.leftPos > this.vDomScrollPosRight) {
            changes = true;
            this.getVisibleRows().forEach((row) => {
              if (row.type !== "group") {
                var cell = row.getCell(column);
                try {
                  row.getElement().removeChild(cell.getElement());
                } catch (ex) {
                  console.warn("Could not removeColRight", ex.message);
                }
              }
            });
            this.vDomPadRight += column.getWidth();
            this.rightCol--;
            this.getVisibleRows().forEach((row) => {
              if (row.type !== "group") {
                row.modules.vdomHoz.rightCol = this.rightCol;
              }
            });
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      if (changes) {
        this.tableElement.style.paddingRight = this.vDomPadRight + "px";
      }
    }
    removeColLeft() {
      var changes = false, working = true;
      while (working) {
        let column = this.columns[this.leftCol];
        if (column) {
          if (column.modules.vdomHoz.rightPos < this.vDomScrollPosLeft) {
            changes = true;
            this.getVisibleRows().forEach((row) => {
              if (row.type !== "group") {
                var cell = row.getCell(column);
                try {
                  row.getElement().removeChild(cell.getElement());
                } catch (ex) {
                  console.warn("Could not removeColLeft", ex.message);
                }
              }
            });
            this.vDomPadLeft += column.getWidth();
            this.leftCol++;
            this.getVisibleRows().forEach((row) => {
              if (row.type !== "group") {
                row.modules.vdomHoz.leftCol = this.leftCol;
              }
            });
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      if (changes) {
        this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
      }
    }
    fitDataColActualWidthCheck(column) {
      var newWidth, widthDiff;
      if (column.modules.vdomHoz.fitDataCheck) {
        column.reinitializeWidth();
        newWidth = column.getWidth();
        widthDiff = newWidth - column.modules.vdomHoz.width;
        if (widthDiff) {
          column.modules.vdomHoz.rightPos += widthDiff;
          column.modules.vdomHoz.width = newWidth;
          this.colPositionAdjust(this.columns.indexOf(column) + 1, this.columns.length, widthDiff);
        }
        column.modules.vdomHoz.fitDataCheck = false;
      }
      return widthDiff;
    }
    initializeRow(row) {
      if (row.type !== "group") {
        row.modules.vdomHoz = {
          leftCol: this.leftCol,
          rightCol: this.rightCol
        };
        if (this.table.modules.frozenColumns) {
          this.table.modules.frozenColumns.leftColumns.forEach((column) => {
            this.appendCell(row, column);
          });
        }
        for (let i2 = this.leftCol; i2 <= this.rightCol; i2++) {
          this.appendCell(row, this.columns[i2]);
        }
        if (this.table.modules.frozenColumns) {
          this.table.modules.frozenColumns.rightColumns.forEach((column) => {
            this.appendCell(row, column);
          });
        }
      }
    }
    appendCell(row, column) {
      if (column && column.visible) {
        let cell = row.getCell(column);
        row.getElement().appendChild(cell.getElement());
        cell.cellRendered();
      }
    }
    reinitializeRow(row, force) {
      if (row.type !== "group") {
        if (force || !row.modules.vdomHoz || row.modules.vdomHoz.leftCol !== this.leftCol || row.modules.vdomHoz.rightCol !== this.rightCol) {
          var rowEl = row.getElement();
          while (rowEl.firstChild) rowEl.removeChild(rowEl.firstChild);
          this.initializeRow(row);
        }
      }
    }
  }
  class ColumnManager extends CoreFeature {
    constructor(table) {
      super(table);
      this.blockHozScrollEvent = false;
      this.headersElement = null;
      this.contentsElement = null;
      this.rowHeader = null;
      this.element = null;
      this.columns = [];
      this.columnsByIndex = [];
      this.columnsByField = {};
      this.scrollLeft = 0;
      this.optionsList = new OptionsList(this.table, "column definition", defaultColumnOptions);
      this.redrawBlock = false;
      this.redrawBlockUpdate = null;
      this.renderer = null;
    }
    ////////////// Setup Functions /////////////////
    initialize() {
      this.initializeRenderer();
      this.headersElement = this.createHeadersElement();
      this.contentsElement = this.createHeaderContentsElement();
      this.element = this.createHeaderElement();
      this.contentsElement.insertBefore(this.headersElement, this.contentsElement.firstChild);
      this.element.insertBefore(this.contentsElement, this.element.firstChild);
      this.initializeScrollWheelWatcher();
      this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
      this.subscribe("scrollbar-vertical", this.padVerticalScrollbar.bind(this));
    }
    padVerticalScrollbar(width) {
      if (this.table.rtl) {
        this.headersElement.style.marginLeft = width + "px";
      } else {
        this.headersElement.style.marginRight = width + "px";
      }
    }
    initializeRenderer() {
      var renderClass;
      var renderers = {
        "virtual": VirtualDomHorizontal,
        "basic": BasicHorizontal
      };
      if (typeof this.table.options.renderHorizontal === "string") {
        renderClass = renderers[this.table.options.renderHorizontal];
      } else {
        renderClass = this.table.options.renderHorizontal;
      }
      if (renderClass) {
        this.renderer = new renderClass(this.table, this.element, this.tableElement);
        this.renderer.initialize();
      } else {
        console.error("Unable to find matching renderer:", this.table.options.renderHorizontal);
      }
    }
    createHeadersElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-headers");
      el.setAttribute("role", "row");
      return el;
    }
    createHeaderContentsElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-header-contents");
      el.setAttribute("role", "rowgroup");
      return el;
    }
    createHeaderElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-header");
      el.setAttribute("role", "rowgroup");
      if (!this.table.options.headerVisible) {
        el.classList.add("tabulator-header-hidden");
      }
      return el;
    }
    //return containing element
    getElement() {
      return this.element;
    }
    //return containing contents element
    getContentsElement() {
      return this.contentsElement;
    }
    //return header containing element
    getHeadersElement() {
      return this.headersElement;
    }
    //scroll horizontally to match table body
    scrollHorizontal(left) {
      this.contentsElement.scrollLeft = left;
      this.scrollLeft = left;
      this.renderer.scrollColumns(left);
    }
    initializeScrollWheelWatcher() {
      this.contentsElement.addEventListener("wheel", (e) => {
        var left;
        if (e.deltaX) {
          left = this.contentsElement.scrollLeft + e.deltaX;
          this.table.rowManager.scrollHorizontal(left);
          this.table.columnManager.scrollHorizontal(left);
        }
      });
    }
    ///////////// Column Setup Functions /////////////
    generateColumnsFromRowData(data) {
      var cols = [], collProgress = {}, rowSample = this.table.options.autoColumns === "full" ? data : [data[0]], definitions = this.table.options.autoColumnsDefinitions;
      if (data && data.length) {
        rowSample.forEach((row) => {
          Object.keys(row).forEach((key, index2) => {
            let value = row[key], col;
            if (!collProgress[key]) {
              col = {
                field: key,
                title: key,
                sorter: this.calculateSorterFromValue(value)
              };
              cols.splice(index2, 0, col);
              collProgress[key] = typeof value === "undefined" ? col : true;
            } else if (collProgress[key] !== true) {
              if (typeof value !== "undefined") {
                collProgress[key].sorter = this.calculateSorterFromValue(value);
                collProgress[key] = true;
              }
            }
          });
        });
        if (definitions) {
          switch (typeof definitions) {
            case "function":
              this.table.options.columns = definitions.call(this.table, cols);
              break;
            case "object":
              if (Array.isArray(definitions)) {
                cols.forEach((col) => {
                  var match = definitions.find((def2) => {
                    return def2.field === col.field;
                  });
                  if (match) {
                    Object.assign(col, match);
                  }
                });
              } else {
                cols.forEach((col) => {
                  if (definitions[col.field]) {
                    Object.assign(col, definitions[col.field]);
                  }
                });
              }
              this.table.options.columns = cols;
              break;
          }
        } else {
          this.table.options.columns = cols;
        }
        this.setColumns(this.table.options.columns);
      }
    }
    calculateSorterFromValue(value) {
      var sorter;
      switch (typeof value) {
        case "undefined":
          sorter = "string";
          break;
        case "boolean":
          sorter = "boolean";
          break;
        case "number":
          sorter = "number";
          break;
        case "object":
          if (Array.isArray(value)) {
            sorter = "array";
          } else {
            sorter = "string";
          }
          break;
        default:
          if (!isNaN(value) && value !== "") {
            sorter = "number";
          } else {
            if (value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)) {
              sorter = "alphanum";
            } else {
              sorter = "string";
            }
          }
          break;
      }
      return sorter;
    }
    setColumns(cols, row) {
      while (this.headersElement.firstChild) this.headersElement.removeChild(this.headersElement.firstChild);
      this.columns = [];
      this.columnsByIndex = [];
      this.columnsByField = {};
      this.dispatch("columns-loading");
      this.dispatchExternal("columnsLoading");
      if (this.table.options.rowHeader) {
        this.rowHeader = new Column(this.table.options.rowHeader === true ? {} : this.table.options.rowHeader, this, true);
        this.columns.push(this.rowHeader);
        this.headersElement.appendChild(this.rowHeader.getElement());
        this.rowHeader.columnRendered();
      }
      cols.forEach((def2, i2) => {
        this._addColumn(def2);
      });
      this._reIndexColumns();
      this.dispatch("columns-loaded");
      if (this.subscribedExternal("columnsLoaded")) {
        this.dispatchExternal("columnsLoaded", this.getComponents());
      }
      this.rerenderColumns(false, true);
      this.redraw(true);
    }
    _addColumn(definition, before, nextToColumn) {
      var column = new Column(definition, this), colEl = column.getElement(), index2 = nextToColumn ? this.findColumnIndex(nextToColumn) : nextToColumn;
      if (before && this.rowHeader && (!nextToColumn || nextToColumn === this.rowHeader)) {
        before = false;
        nextToColumn = this.rowHeader;
        index2 = 0;
      }
      if (nextToColumn && index2 > -1) {
        var topColumn = nextToColumn.getTopColumn();
        var parentIndex = this.columns.indexOf(topColumn);
        var nextEl = topColumn.getElement();
        if (before) {
          this.columns.splice(parentIndex, 0, column);
          nextEl.parentNode.insertBefore(colEl, nextEl);
        } else {
          this.columns.splice(parentIndex + 1, 0, column);
          nextEl.parentNode.insertBefore(colEl, nextEl.nextSibling);
        }
      } else {
        if (before) {
          this.columns.unshift(column);
          this.headersElement.insertBefore(column.getElement(), this.headersElement.firstChild);
        } else {
          this.columns.push(column);
          this.headersElement.appendChild(column.getElement());
        }
      }
      column.columnRendered();
      return column;
    }
    registerColumnField(col) {
      if (col.definition.field) {
        this.columnsByField[col.definition.field] = col;
      }
    }
    registerColumnPosition(col) {
      this.columnsByIndex.push(col);
    }
    _reIndexColumns() {
      this.columnsByIndex = [];
      this.columns.forEach(function(column) {
        column.reRegisterPosition();
      });
    }
    //ensure column headers take up the correct amount of space in column groups
    verticalAlignHeaders() {
      var minHeight = 0;
      if (!this.redrawBlock) {
        this.headersElement.style.height = "";
        this.columns.forEach((column) => {
          column.clearVerticalAlign();
        });
        this.columns.forEach((column) => {
          var height = column.getHeight();
          if (height > minHeight) {
            minHeight = height;
          }
        });
        this.headersElement.style.height = minHeight + "px";
        this.columns.forEach((column) => {
          column.verticalAlign(this.table.options.columnHeaderVertAlign, minHeight);
        });
        this.table.rowManager.adjustTableSize();
      }
    }
    //////////////// Column Details /////////////////
    findColumn(subject) {
      var columns;
      if (typeof subject == "object") {
        if (subject instanceof Column) {
          return subject;
        } else if (subject instanceof ColumnComponent) {
          return subject._getSelf() || false;
        } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
          columns = [];
          this.columns.forEach((column) => {
            columns.push(column);
            columns = columns.concat(column.getColumns(true));
          });
          let match = columns.find((column) => {
            return column.element === subject;
          });
          return match || false;
        }
      } else {
        return this.columnsByField[subject] || false;
      }
      return false;
    }
    getColumnByField(field) {
      return this.columnsByField[field];
    }
    getColumnsByFieldRoot(root2) {
      var matches2 = [];
      Object.keys(this.columnsByField).forEach((field) => {
        var fieldRoot = this.table.options.nestedFieldSeparator ? field.split(this.table.options.nestedFieldSeparator)[0] : field;
        if (fieldRoot === root2) {
          matches2.push(this.columnsByField[field]);
        }
      });
      return matches2;
    }
    getColumnByIndex(index2) {
      return this.columnsByIndex[index2];
    }
    getFirstVisibleColumn() {
      var index2 = this.columnsByIndex.findIndex((col) => {
        return col.visible;
      });
      return index2 > -1 ? this.columnsByIndex[index2] : false;
    }
    getVisibleColumnsByIndex() {
      return this.columnsByIndex.filter((col) => col.visible);
    }
    getColumns() {
      return this.columns;
    }
    findColumnIndex(column) {
      return this.columnsByIndex.findIndex((col) => {
        return column === col;
      });
    }
    //return all columns that are not groups
    getRealColumns() {
      return this.columnsByIndex;
    }
    //traverse across columns and call action
    traverse(callback) {
      this.columnsByIndex.forEach((column, i2) => {
        callback(column, i2);
      });
    }
    //get definitions of actual columns
    getDefinitions(active) {
      var output = [];
      this.columnsByIndex.forEach((column) => {
        if (!active || active && column.visible) {
          output.push(column.getDefinition());
        }
      });
      return output;
    }
    //get full nested definition tree
    getDefinitionTree() {
      var output = [];
      this.columns.forEach((column) => {
        output.push(column.getDefinition(true));
      });
      return output;
    }
    getComponents(structured) {
      var output = [], columns = structured ? this.columns : this.columnsByIndex;
      columns.forEach((column) => {
        output.push(column.getComponent());
      });
      return output;
    }
    getWidth() {
      var width = 0;
      this.columnsByIndex.forEach((column) => {
        if (column.visible) {
          width += column.getWidth();
        }
      });
      return width;
    }
    moveColumn(from, to2, after) {
      to2.element.parentNode.insertBefore(from.element, to2.element);
      if (after) {
        to2.element.parentNode.insertBefore(to2.element, from.element);
      }
      this.moveColumnActual(from, to2, after);
      this.verticalAlignHeaders();
      this.table.rowManager.reinitialize();
    }
    moveColumnActual(from, to2, after) {
      if (from.parent.isGroup) {
        this._moveColumnInArray(from.parent.columns, from, to2, after);
      } else {
        this._moveColumnInArray(this.columns, from, to2, after);
      }
      this._moveColumnInArray(this.columnsByIndex, from, to2, after, true);
      this.rerenderColumns(true);
      this.dispatch("column-moved", from, to2, after);
      if (this.subscribedExternal("columnMoved")) {
        this.dispatchExternal("columnMoved", from.getComponent(), this.table.columnManager.getComponents());
      }
    }
    _moveColumnInArray(columns, from, to2, after, updateRows) {
      var fromIndex = columns.indexOf(from), toIndex, rows = [];
      if (fromIndex > -1) {
        columns.splice(fromIndex, 1);
        toIndex = columns.indexOf(to2);
        if (toIndex > -1) {
          if (after) {
            toIndex = toIndex + 1;
          }
        } else {
          toIndex = fromIndex;
        }
        columns.splice(toIndex, 0, from);
        if (updateRows) {
          rows = this.chain("column-moving-rows", [from, to2, after], null, []) || [];
          rows = rows.concat(this.table.rowManager.rows);
          rows.forEach(function(row) {
            if (row.cells.length) {
              var cell = row.cells.splice(fromIndex, 1)[0];
              row.cells.splice(toIndex, 0, cell);
            }
          });
        }
      }
    }
    scrollToColumn(column, position, ifVisible) {
      var left = 0, offset2 = column.getLeftOffset(), adjust = 0, colEl = column.getElement();
      return new Promise((resolve2, reject) => {
        if (typeof position === "undefined") {
          position = this.table.options.scrollToColumnPosition;
        }
        if (typeof ifVisible === "undefined") {
          ifVisible = this.table.options.scrollToColumnIfVisible;
        }
        if (column.visible) {
          switch (position) {
            case "middle":
            case "center":
              adjust = -this.element.clientWidth / 2;
              break;
            case "right":
              adjust = colEl.clientWidth - this.headersElement.clientWidth;
              break;
          }
          if (!ifVisible) {
            if (offset2 > 0 && offset2 + colEl.offsetWidth < this.element.clientWidth) {
              return false;
            }
          }
          left = offset2 + adjust;
          left = Math.max(Math.min(left, this.table.rowManager.element.scrollWidth - this.table.rowManager.element.clientWidth), 0);
          this.table.rowManager.scrollHorizontal(left);
          this.scrollHorizontal(left);
          resolve2();
        } else {
          console.warn("Scroll Error - Column not visible");
          reject("Scroll Error - Column not visible");
        }
      });
    }
    //////////////// Cell Management /////////////////
    generateCells(row) {
      var cells = [];
      this.columnsByIndex.forEach((column) => {
        cells.push(column.generateCell(row));
      });
      return cells;
    }
    //////////////// Column Management /////////////////
    getFlexBaseWidth() {
      var totalWidth = this.table.element.clientWidth, fixedWidth = 0;
      if (this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight) {
        totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
      }
      this.columnsByIndex.forEach(function(column) {
        var width, minWidth, colWidth;
        if (column.visible) {
          width = column.definition.width || 0;
          minWidth = parseInt(column.minWidth);
          if (typeof width == "string") {
            if (width.indexOf("%") > -1) {
              colWidth = totalWidth / 100 * parseInt(width);
            } else {
              colWidth = parseInt(width);
            }
          } else {
            colWidth = width;
          }
          fixedWidth += colWidth > minWidth ? colWidth : minWidth;
        }
      });
      return fixedWidth;
    }
    addColumn(definition, before, nextToColumn) {
      return new Promise((resolve2, reject) => {
        var column = this._addColumn(definition, before, nextToColumn);
        this._reIndexColumns();
        this.dispatch("column-add", definition, before, nextToColumn);
        if (this.layoutMode() != "fitColumns") {
          column.reinitializeWidth();
        }
        this.redraw(true);
        this.table.rowManager.reinitialize();
        this.rerenderColumns();
        resolve2(column);
      });
    }
    //remove column from system
    deregisterColumn(column) {
      var field = column.getField(), index2;
      if (field) {
        delete this.columnsByField[field];
      }
      index2 = this.columnsByIndex.indexOf(column);
      if (index2 > -1) {
        this.columnsByIndex.splice(index2, 1);
      }
      index2 = this.columns.indexOf(column);
      if (index2 > -1) {
        this.columns.splice(index2, 1);
      }
      this.verticalAlignHeaders();
      this.redraw();
    }
    rerenderColumns(update, silent) {
      if (!this.redrawBlock) {
        this.renderer.rerenderColumns(update, silent);
      } else {
        if (update === false || update === true && this.redrawBlockUpdate === null) {
          this.redrawBlockUpdate = update;
        }
      }
    }
    blockRedraw() {
      this.redrawBlock = true;
      this.redrawBlockUpdate = null;
    }
    restoreRedraw() {
      this.redrawBlock = false;
      this.verticalAlignHeaders();
      this.renderer.rerenderColumns(this.redrawBlockUpdate);
    }
    //redraw columns
    redraw(force) {
      if (Helpers.elVisible(this.element)) {
        this.verticalAlignHeaders();
      }
      if (force) {
        this.table.rowManager.resetScroll();
        this.table.rowManager.reinitialize();
      }
      if (!this.confirm("table-redrawing", force)) {
        this.layoutRefresh(force);
      }
      this.dispatch("table-redraw", force);
      this.table.footerManager.redraw();
    }
  }
  class BasicVertical extends Renderer {
    constructor(table) {
      super(table);
      this.verticalFillMode = "fill";
      this.scrollTop = 0;
      this.scrollLeft = 0;
      this.scrollTop = 0;
      this.scrollLeft = 0;
    }
    clearRows() {
      var element = this.tableElement;
      while (element.firstChild) element.removeChild(element.firstChild);
      element.scrollTop = 0;
      element.scrollLeft = 0;
      element.style.minWidth = "";
      element.style.minHeight = "";
      element.style.display = "";
      element.style.visibility = "";
    }
    renderRows() {
      var element = this.tableElement, onlyGroupHeaders = true, tableFrag = document.createDocumentFragment(), rows = this.rows();
      rows.forEach((row, index2) => {
        this.styleRow(row, index2);
        row.initialize(false, true);
        if (row.type !== "group") {
          onlyGroupHeaders = false;
        }
        tableFrag.appendChild(row.getElement());
      });
      element.appendChild(tableFrag);
      rows.forEach((row) => {
        row.rendered();
        if (!row.heightInitialized) {
          row.calcHeight(true);
        }
      });
      rows.forEach((row) => {
        if (!row.heightInitialized) {
          row.setCellHeight();
        }
      });
      if (onlyGroupHeaders) {
        element.style.minWidth = this.table.columnManager.getWidth() + "px";
      } else {
        element.style.minWidth = "";
      }
    }
    rerenderRows(callback) {
      this.clearRows();
      if (callback) {
        callback();
      }
      this.renderRows();
      if (!this.rows().length) {
        this.table.rowManager.tableEmpty();
      }
    }
    scrollToRowNearestTop(row) {
      var rowTop = Helpers.elOffset(row.getElement()).top;
      return !(Math.abs(this.elementVertical.scrollTop - rowTop) > Math.abs(this.elementVertical.scrollTop + this.elementVertical.clientHeight - rowTop));
    }
    scrollToRow(row) {
      var rowEl = row.getElement();
      this.elementVertical.scrollTop = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top + this.elementVertical.scrollTop;
    }
    visibleRows(includingBuffer) {
      return this.rows();
    }
  }
  class VirtualDomVertical extends Renderer {
    constructor(table) {
      super(table);
      this.verticalFillMode = "fill";
      this.scrollTop = 0;
      this.scrollLeft = 0;
      this.vDomRowHeight = 20;
      this.vDomTop = 0;
      this.vDomBottom = 0;
      this.vDomScrollPosTop = 0;
      this.vDomScrollPosBottom = 0;
      this.vDomTopPad = 0;
      this.vDomBottomPad = 0;
      this.vDomMaxRenderChain = 90;
      this.vDomWindowBuffer = 0;
      this.vDomWindowMinTotalRows = 20;
      this.vDomWindowMinMarginRows = 5;
      this.vDomTopNewRows = [];
      this.vDomBottomNewRows = [];
    }
    //////////////////////////////////////
    ///////// Public Functions ///////////
    //////////////////////////////////////
    clearRows() {
      var element = this.tableElement;
      while (element.firstChild) element.removeChild(element.firstChild);
      element.style.paddingTop = "";
      element.style.paddingBottom = "";
      element.style.minHeight = "";
      element.style.display = "";
      element.style.visibility = "";
      this.elementVertical.scrollTop = 0;
      this.elementVertical.scrollLeft = 0;
      this.scrollTop = 0;
      this.scrollLeft = 0;
      this.vDomTop = 0;
      this.vDomBottom = 0;
      this.vDomTopPad = 0;
      this.vDomBottomPad = 0;
      this.vDomScrollPosTop = 0;
      this.vDomScrollPosBottom = 0;
    }
    renderRows() {
      this._virtualRenderFill();
    }
    rerenderRows(callback) {
      var scrollTop = this.elementVertical.scrollTop;
      var topRow = false;
      var topOffset = false;
      var left = this.table.rowManager.scrollLeft;
      var rows = this.rows();
      for (var i2 = this.vDomTop; i2 <= this.vDomBottom; i2++) {
        if (rows[i2]) {
          var diff = scrollTop - rows[i2].getElement().offsetTop;
          if (topOffset === false || Math.abs(diff) < topOffset) {
            topOffset = diff;
            topRow = i2;
          } else {
            break;
          }
        }
      }
      rows.forEach((row) => {
        row.deinitializeHeight();
      });
      if (callback) {
        callback();
      }
      if (this.rows().length) {
        this._virtualRenderFill(topRow === false ? this.rows.length - 1 : topRow, true, topOffset || 0);
      } else {
        this.clear();
        this.table.rowManager.tableEmpty();
      }
      this.scrollColumns(left);
    }
    scrollColumns(left) {
      this.table.rowManager.scrollHorizontal(left);
    }
    scrollRows(top, dir) {
      var topDiff = top - this.vDomScrollPosTop;
      var bottomDiff = top - this.vDomScrollPosBottom;
      var margin = this.vDomWindowBuffer * 2;
      var rows = this.rows();
      this.scrollTop = top;
      if (-topDiff > margin || bottomDiff > margin) {
        var left = this.table.rowManager.scrollLeft;
        this._virtualRenderFill(Math.floor(this.elementVertical.scrollTop / this.elementVertical.scrollHeight * rows.length));
        this.scrollColumns(left);
      } else {
        if (dir) {
          if (topDiff < 0) {
            this._addTopRow(rows, -topDiff);
          }
          if (bottomDiff < 0) {
            if (this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer) {
              this._removeBottomRow(rows, -bottomDiff);
            } else {
              this.vDomScrollPosBottom = this.scrollTop;
            }
          }
        } else {
          if (bottomDiff >= 0) {
            this._addBottomRow(rows, bottomDiff);
          }
          if (topDiff >= 0) {
            if (this.scrollTop > this.vDomWindowBuffer) {
              this._removeTopRow(rows, topDiff);
            } else {
              this.vDomScrollPosTop = this.scrollTop;
            }
          }
        }
      }
    }
    resize() {
      this.vDomWindowBuffer = this.table.options.renderVerticalBuffer || this.elementVertical.clientHeight;
    }
    scrollToRowNearestTop(row) {
      var rowIndex = this.rows().indexOf(row);
      return !(Math.abs(this.vDomTop - rowIndex) > Math.abs(this.vDomBottom - rowIndex));
    }
    scrollToRow(row) {
      var index2 = this.rows().indexOf(row);
      if (index2 > -1) {
        this._virtualRenderFill(index2, true);
      }
    }
    visibleRows(includingBuffer) {
      var topEdge = this.elementVertical.scrollTop, bottomEdge = this.elementVertical.clientHeight + topEdge, topFound = false, topRow = 0, bottomRow = 0, rows = this.rows();
      if (includingBuffer) {
        topRow = this.vDomTop;
        bottomRow = this.vDomBottom;
      } else {
        for (var i2 = this.vDomTop; i2 <= this.vDomBottom; i2++) {
          if (rows[i2]) {
            if (!topFound) {
              if (topEdge - rows[i2].getElement().offsetTop >= 0) {
                topRow = i2;
              } else {
                topFound = true;
                if (bottomEdge - rows[i2].getElement().offsetTop >= 0) {
                  bottomRow = i2;
                } else {
                  break;
                }
              }
            } else {
              if (bottomEdge - rows[i2].getElement().offsetTop >= 0) {
                bottomRow = i2;
              } else {
                break;
              }
            }
          }
        }
      }
      return rows.slice(topRow, bottomRow + 1);
    }
    //////////////////////////////////////
    //////// Internal Rendering //////////
    //////////////////////////////////////
    //full virtual render
    _virtualRenderFill(position, forceMove, offset2) {
      var element = this.tableElement, holder = this.elementVertical, topPad = 0, rowsHeight = 0, rowHeight = 0, heightOccupied = 0, topPadHeight = 0, i2 = 0, rows = this.rows(), rowsCount = rows.length, index2 = 0, row, rowFragment, renderedRows = [], totalRowsRendered = 0, rowsToRender = 0, fixedHeight = this.table.rowManager.fixedHeight, containerHeight = this.elementVertical.clientHeight, avgRowHeight = this.table.options.rowHeight, resized = true;
      position = position || 0;
      offset2 = offset2 || 0;
      if (!position) {
        this.clear();
      } else {
        while (element.firstChild) element.removeChild(element.firstChild);
        heightOccupied = (rowsCount - position + 1) * this.vDomRowHeight;
        if (heightOccupied < containerHeight) {
          position -= Math.ceil((containerHeight - heightOccupied) / this.vDomRowHeight);
          if (position < 0) {
            position = 0;
          }
        }
        topPad = Math.min(Math.max(Math.floor(this.vDomWindowBuffer / this.vDomRowHeight), this.vDomWindowMinMarginRows), position);
        position -= topPad;
      }
      if (rowsCount && Helpers.elVisible(this.elementVertical)) {
        this.vDomTop = position;
        this.vDomBottom = position - 1;
        if (fixedHeight || this.table.options.maxHeight) {
          if (avgRowHeight) {
            rowsToRender = containerHeight / avgRowHeight + this.vDomWindowBuffer / avgRowHeight;
          }
          rowsToRender = Math.max(this.vDomWindowMinTotalRows, Math.ceil(rowsToRender));
        } else {
          rowsToRender = rowsCount;
        }
        while ((rowsToRender == rowsCount || rowsHeight <= containerHeight + this.vDomWindowBuffer || totalRowsRendered < this.vDomWindowMinTotalRows) && this.vDomBottom < rowsCount - 1) {
          renderedRows = [];
          rowFragment = document.createDocumentFragment();
          i2 = 0;
          while (i2 < rowsToRender && this.vDomBottom < rowsCount - 1) {
            index2 = this.vDomBottom + 1, row = rows[index2];
            this.styleRow(row, index2);
            row.initialize(false, true);
            if (!row.heightInitialized && !this.table.options.rowHeight) {
              row.clearCellHeight();
            }
            rowFragment.appendChild(row.getElement());
            renderedRows.push(row);
            this.vDomBottom++;
            i2++;
          }
          if (!renderedRows.length) {
            break;
          }
          element.appendChild(rowFragment);
          renderedRows.forEach((row2) => {
            row2.rendered();
            if (!row2.heightInitialized) {
              row2.calcHeight(true);
            }
          });
          renderedRows.forEach((row2) => {
            if (!row2.heightInitialized) {
              row2.setCellHeight();
            }
          });
          renderedRows.forEach((row2) => {
            rowHeight = row2.getHeight();
            if (totalRowsRendered < topPad) {
              topPadHeight += rowHeight;
            } else {
              rowsHeight += rowHeight;
            }
            if (rowHeight > this.vDomWindowBuffer) {
              this.vDomWindowBuffer = rowHeight * 2;
            }
            totalRowsRendered++;
          });
          resized = this.table.rowManager.adjustTableSize();
          containerHeight = this.elementVertical.clientHeight;
          if (resized && (fixedHeight || this.table.options.maxHeight)) {
            avgRowHeight = rowsHeight / totalRowsRendered;
            rowsToRender = Math.max(this.vDomWindowMinTotalRows, Math.ceil(containerHeight / avgRowHeight + this.vDomWindowBuffer / avgRowHeight));
          }
        }
        if (!position) {
          this.vDomTopPad = 0;
          this.vDomRowHeight = Math.floor((rowsHeight + topPadHeight) / totalRowsRendered);
          this.vDomBottomPad = this.vDomRowHeight * (rowsCount - this.vDomBottom - 1);
          this.vDomScrollHeight = topPadHeight + rowsHeight + this.vDomBottomPad - containerHeight;
        } else {
          this.vDomTopPad = !forceMove ? this.scrollTop - topPadHeight : this.vDomRowHeight * this.vDomTop + offset2;
          this.vDomBottomPad = this.vDomBottom == rowsCount - 1 ? 0 : Math.max(this.vDomScrollHeight - this.vDomTopPad - rowsHeight - topPadHeight, 0);
        }
        element.style.paddingTop = this.vDomTopPad + "px";
        element.style.paddingBottom = this.vDomBottomPad + "px";
        if (forceMove) {
          this.scrollTop = this.vDomTopPad + topPadHeight + offset2 - (this.elementVertical.scrollWidth > this.elementVertical.clientWidth ? this.elementVertical.offsetHeight - containerHeight : 0);
        }
        this.scrollTop = Math.min(this.scrollTop, this.elementVertical.scrollHeight - containerHeight);
        if (this.elementVertical.scrollWidth > this.elementVertical.clientWidth && forceMove) {
          this.scrollTop += this.elementVertical.offsetHeight - containerHeight;
        }
        this.vDomScrollPosTop = this.scrollTop;
        this.vDomScrollPosBottom = this.scrollTop;
        holder.scrollTop = this.scrollTop;
        this.dispatch("render-virtual-fill");
      }
    }
    _addTopRow(rows, fillableSpace) {
      var table = this.tableElement, addedRows = [], paddingAdjust = 0, index2 = this.vDomTop - 1, i2 = 0, working = true;
      while (working) {
        if (this.vDomTop) {
          let row = rows[index2], rowHeight, initialized;
          if (row && i2 < this.vDomMaxRenderChain) {
            rowHeight = row.getHeight() || this.vDomRowHeight;
            initialized = row.initialized;
            if (fillableSpace >= rowHeight) {
              this.styleRow(row, index2);
              table.insertBefore(row.getElement(), table.firstChild);
              if (!row.initialized || !row.heightInitialized) {
                addedRows.push(row);
              }
              row.initialize();
              if (!initialized) {
                rowHeight = row.getElement().offsetHeight;
                if (rowHeight > this.vDomWindowBuffer) {
                  this.vDomWindowBuffer = rowHeight * 2;
                }
              }
              fillableSpace -= rowHeight;
              paddingAdjust += rowHeight;
              this.vDomTop--;
              index2--;
              i2++;
            } else {
              working = false;
            }
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      for (let row of addedRows) {
        row.clearCellHeight();
      }
      this._quickNormalizeRowHeight(addedRows);
      if (paddingAdjust) {
        this.vDomTopPad -= paddingAdjust;
        if (this.vDomTopPad < 0) {
          this.vDomTopPad = index2 * this.vDomRowHeight;
        }
        if (index2 < 1) {
          this.vDomTopPad = 0;
        }
        table.style.paddingTop = this.vDomTopPad + "px";
        this.vDomScrollPosTop -= paddingAdjust;
      }
    }
    _removeTopRow(rows, fillableSpace) {
      var removableRows = [], paddingAdjust = 0, i2 = 0, working = true;
      while (working) {
        let row = rows[this.vDomTop], rowHeight;
        if (row && i2 < this.vDomMaxRenderChain) {
          rowHeight = row.getHeight() || this.vDomRowHeight;
          if (fillableSpace >= rowHeight) {
            this.vDomTop++;
            fillableSpace -= rowHeight;
            paddingAdjust += rowHeight;
            removableRows.push(row);
            i2++;
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      for (let row of removableRows) {
        let rowEl = row.getElement();
        if (rowEl.parentNode) {
          rowEl.parentNode.removeChild(rowEl);
        }
      }
      if (paddingAdjust) {
        this.vDomTopPad += paddingAdjust;
        this.tableElement.style.paddingTop = this.vDomTopPad + "px";
        this.vDomScrollPosTop += this.vDomTop ? paddingAdjust : paddingAdjust + this.vDomWindowBuffer;
      }
    }
    _addBottomRow(rows, fillableSpace) {
      var table = this.tableElement, addedRows = [], paddingAdjust = 0, index2 = this.vDomBottom + 1, i2 = 0, working = true;
      while (working) {
        let row = rows[index2], rowHeight, initialized;
        if (row && i2 < this.vDomMaxRenderChain) {
          rowHeight = row.getHeight() || this.vDomRowHeight;
          initialized = row.initialized;
          if (fillableSpace >= rowHeight) {
            this.styleRow(row, index2);
            table.appendChild(row.getElement());
            if (!row.initialized || !row.heightInitialized) {
              addedRows.push(row);
            }
            row.initialize();
            if (!initialized) {
              rowHeight = row.getElement().offsetHeight;
              if (rowHeight > this.vDomWindowBuffer) {
                this.vDomWindowBuffer = rowHeight * 2;
              }
            }
            fillableSpace -= rowHeight;
            paddingAdjust += rowHeight;
            this.vDomBottom++;
            index2++;
            i2++;
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      for (let row of addedRows) {
        row.clearCellHeight();
      }
      this._quickNormalizeRowHeight(addedRows);
      if (paddingAdjust) {
        this.vDomBottomPad -= paddingAdjust;
        if (this.vDomBottomPad < 0 || index2 == rows.length - 1) {
          this.vDomBottomPad = 0;
        }
        table.style.paddingBottom = this.vDomBottomPad + "px";
        this.vDomScrollPosBottom += paddingAdjust;
      }
    }
    _removeBottomRow(rows, fillableSpace) {
      var removableRows = [], paddingAdjust = 0, i2 = 0, working = true;
      while (working) {
        let row = rows[this.vDomBottom], rowHeight;
        if (row && i2 < this.vDomMaxRenderChain) {
          rowHeight = row.getHeight() || this.vDomRowHeight;
          if (fillableSpace >= rowHeight) {
            this.vDomBottom--;
            fillableSpace -= rowHeight;
            paddingAdjust += rowHeight;
            removableRows.push(row);
            i2++;
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      for (let row of removableRows) {
        let rowEl = row.getElement();
        if (rowEl.parentNode) {
          rowEl.parentNode.removeChild(rowEl);
        }
      }
      if (paddingAdjust) {
        this.vDomBottomPad += paddingAdjust;
        if (this.vDomBottomPad < 0) {
          this.vDomBottomPad = 0;
        }
        this.tableElement.style.paddingBottom = this.vDomBottomPad + "px";
        this.vDomScrollPosBottom -= paddingAdjust;
      }
    }
    _quickNormalizeRowHeight(rows) {
      for (let row of rows) {
        row.calcHeight();
      }
      for (let row of rows) {
        row.setCellHeight();
      }
    }
  }
  class RowManager extends CoreFeature {
    constructor(table) {
      super(table);
      this.element = this.createHolderElement();
      this.tableElement = this.createTableElement();
      this.heightFixer = this.createTableElement();
      this.placeholder = null;
      this.placeholderContents = null;
      this.firstRender = false;
      this.renderMode = "virtual";
      this.fixedHeight = false;
      this.rows = [];
      this.activeRowsPipeline = [];
      this.activeRows = [];
      this.activeRowsCount = 0;
      this.displayRows = [];
      this.displayRowsCount = 0;
      this.scrollTop = 0;
      this.scrollLeft = 0;
      this.redrawBlock = false;
      this.redrawBlockRestoreConfig = false;
      this.redrawBlockRenderInPosition = false;
      this.dataPipeline = [];
      this.displayPipeline = [];
      this.scrollbarWidth = 0;
      this.renderer = null;
    }
    //////////////// Setup Functions /////////////////
    createHolderElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-tableholder");
      el.setAttribute("tabindex", 0);
      return el;
    }
    createTableElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-table");
      el.setAttribute("role", "rowgroup");
      return el;
    }
    initializePlaceholder() {
      var placeholder = this.table.options.placeholder;
      if (typeof placeholder === "function") {
        placeholder = placeholder.call(this.table);
      }
      placeholder = this.chain("placeholder", [placeholder], placeholder, placeholder) || placeholder;
      if (placeholder) {
        let el = document.createElement("div");
        el.classList.add("tabulator-placeholder");
        if (typeof placeholder == "string") {
          let contents = document.createElement("div");
          contents.classList.add("tabulator-placeholder-contents");
          contents.innerHTML = placeholder;
          el.appendChild(contents);
          this.placeholderContents = contents;
        } else if (typeof HTMLElement !== "undefined" && placeholder instanceof HTMLElement) {
          el.appendChild(placeholder);
          this.placeholderContents = placeholder;
        } else {
          console.warn("Invalid placeholder provided, must be string or HTML Element", placeholder);
          this.el = null;
        }
        this.placeholder = el;
      }
    }
    //return containing element
    getElement() {
      return this.element;
    }
    //return table element
    getTableElement() {
      return this.tableElement;
    }
    initialize() {
      this.initializePlaceholder();
      this.initializeRenderer();
      this.element.appendChild(this.tableElement);
      this.firstRender = true;
      this.element.addEventListener("scroll", () => {
        var left = this.element.scrollLeft, leftDir = this.scrollLeft > left, top = this.element.scrollTop, topDir = this.scrollTop > top;
        if (this.scrollLeft != left) {
          this.scrollLeft = left;
          this.dispatch("scroll-horizontal", left, leftDir);
          this.dispatchExternal("scrollHorizontal", left, leftDir);
          this._positionPlaceholder();
        }
        if (this.scrollTop != top) {
          this.scrollTop = top;
          this.renderer.scrollRows(top, topDir);
          this.dispatch("scroll-vertical", top, topDir);
          this.dispatchExternal("scrollVertical", top, topDir);
        }
      });
    }
    ////////////////// Row Manipulation //////////////////
    findRow(subject) {
      if (typeof subject == "object") {
        if (subject instanceof Row) {
          return subject;
        } else if (subject instanceof RowComponent) {
          return subject._getSelf() || false;
        } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
          let match = this.rows.find((row) => {
            return row.getElement() === subject;
          });
          return match || false;
        } else if (subject === null) {
          return false;
        }
      } else if (typeof subject == "undefined") {
        return false;
      } else {
        let match = this.rows.find((row) => {
          return row.data[this.table.options.index] == subject;
        });
        return match || false;
      }
      return false;
    }
    getRowFromDataObject(data) {
      var match = this.rows.find((row) => {
        return row.data === data;
      });
      return match || false;
    }
    getRowFromPosition(position) {
      return this.getDisplayRows().find((row) => {
        return row.type === "row" && row.getPosition() === position && row.isDisplayed();
      });
    }
    scrollToRow(row, position, ifVisible) {
      return this.renderer.scrollToRowPosition(row, position, ifVisible);
    }
    ////////////////// Data Handling //////////////////
    setData(data, renderInPosition, columnsChanged) {
      return new Promise((resolve2, reject) => {
        if (renderInPosition && this.getDisplayRows().length) {
          if (this.table.options.pagination) {
            this._setDataActual(data, true);
          } else {
            this.reRenderInPosition(() => {
              this._setDataActual(data);
            });
          }
        } else {
          if (this.table.options.autoColumns && columnsChanged && this.table.initialized) {
            this.table.columnManager.generateColumnsFromRowData(data);
          }
          this.resetScroll();
          this._setDataActual(data);
        }
        resolve2();
      });
    }
    _setDataActual(data, renderInPosition) {
      this.dispatchExternal("dataProcessing", data);
      this._wipeElements();
      if (Array.isArray(data)) {
        this.dispatch("data-processing", data);
        data.forEach((def2, i2) => {
          if (def2 && typeof def2 === "object") {
            var row = new Row(def2, this);
            this.rows.push(row);
          } else {
            console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", def2);
          }
        });
        this.refreshActiveData(false, false, renderInPosition);
        this.dispatch("data-processed", data);
        this.dispatchExternal("dataProcessed", data);
      } else {
        console.error("Data Loading Error - Unable to process data due to invalid data type \nExpecting: array \nReceived: ", typeof data, "\nData:     ", data);
      }
    }
    _wipeElements() {
      this.dispatch("rows-wipe");
      this.destroy();
      this.adjustTableSize();
      this.dispatch("rows-wiped");
    }
    destroy() {
      this.rows.forEach((row) => {
        row.wipe();
      });
      this.rows = [];
      this.activeRows = [];
      this.activeRowsPipeline = [];
      this.activeRowsCount = 0;
      this.displayRows = [];
      this.displayRowsCount = 0;
    }
    deleteRow(row, blockRedraw) {
      var allIndex = this.rows.indexOf(row), activeIndex = this.activeRows.indexOf(row);
      if (activeIndex > -1) {
        this.activeRows.splice(activeIndex, 1);
      }
      if (allIndex > -1) {
        this.rows.splice(allIndex, 1);
      }
      this.setActiveRows(this.activeRows);
      this.displayRowIterator((rows) => {
        var displayIndex = rows.indexOf(row);
        if (displayIndex > -1) {
          rows.splice(displayIndex, 1);
        }
      });
      if (!blockRedraw) {
        this.reRenderInPosition();
      }
      this.regenerateRowPositions();
      this.dispatchExternal("rowDeleted", row.getComponent());
      if (!this.displayRowsCount) {
        this.tableEmpty();
      }
      if (this.subscribedExternal("dataChanged")) {
        this.dispatchExternal("dataChanged", this.getData());
      }
    }
    addRow(data, pos, index2, blockRedraw) {
      var row = this.addRowActual(data, pos, index2, blockRedraw);
      return row;
    }
    //add multiple rows
    addRows(data, pos, index2, refreshDisplayOnly) {
      var rows = [];
      return new Promise((resolve2, reject) => {
        pos = this.findAddRowPos(pos);
        if (!Array.isArray(data)) {
          data = [data];
        }
        if (typeof index2 == "undefined" && pos || typeof index2 !== "undefined" && !pos) {
          data.reverse();
        }
        data.forEach((item, i2) => {
          var row = this.addRow(item, pos, index2, true);
          rows.push(row);
          this.dispatch("row-added", row, item, pos, index2);
        });
        this.refreshActiveData(refreshDisplayOnly ? "displayPipeline" : false, false, true);
        this.regenerateRowPositions();
        if (this.displayRowsCount) {
          this._clearPlaceholder();
        }
        resolve2(rows);
      });
    }
    findAddRowPos(pos) {
      if (typeof pos === "undefined") {
        pos = this.table.options.addRowPos;
      }
      if (pos === "pos") {
        pos = true;
      }
      if (pos === "bottom") {
        pos = false;
      }
      return pos;
    }
    addRowActual(data, pos, index2, blockRedraw) {
      var row = data instanceof Row ? data : new Row(data || {}, this), top = this.findAddRowPos(pos), allIndex = -1, activeIndex, chainResult;
      if (!index2) {
        chainResult = this.chain("row-adding-position", [row, top], null, { index: index2, top });
        index2 = chainResult.index;
        top = chainResult.top;
      }
      if (typeof index2 !== "undefined") {
        index2 = this.findRow(index2);
      }
      index2 = this.chain("row-adding-index", [row, index2, top], null, index2);
      if (index2) {
        allIndex = this.rows.indexOf(index2);
      }
      if (index2 && allIndex > -1) {
        activeIndex = this.activeRows.indexOf(index2);
        this.displayRowIterator(function(rows) {
          var displayIndex = rows.indexOf(index2);
          if (displayIndex > -1) {
            rows.splice(top ? displayIndex : displayIndex + 1, 0, row);
          }
        });
        if (activeIndex > -1) {
          this.activeRows.splice(top ? activeIndex : activeIndex + 1, 0, row);
        }
        this.rows.splice(top ? allIndex : allIndex + 1, 0, row);
      } else {
        if (top) {
          this.displayRowIterator(function(rows) {
            rows.unshift(row);
          });
          this.activeRows.unshift(row);
          this.rows.unshift(row);
        } else {
          this.displayRowIterator(function(rows) {
            rows.push(row);
          });
          this.activeRows.push(row);
          this.rows.push(row);
        }
      }
      this.setActiveRows(this.activeRows);
      this.dispatchExternal("rowAdded", row.getComponent());
      if (this.subscribedExternal("dataChanged")) {
        this.dispatchExternal("dataChanged", this.table.rowManager.getData());
      }
      if (!blockRedraw) {
        this.reRenderInPosition();
      }
      return row;
    }
    moveRow(from, to2, after) {
      this.dispatch("row-move", from, to2, after);
      this.moveRowActual(from, to2, after);
      this.regenerateRowPositions();
      this.dispatch("row-moved", from, to2, after);
      this.dispatchExternal("rowMoved", from.getComponent());
    }
    moveRowActual(from, to2, after) {
      this.moveRowInArray(this.rows, from, to2, after);
      this.moveRowInArray(this.activeRows, from, to2, after);
      this.displayRowIterator((rows) => {
        this.moveRowInArray(rows, from, to2, after);
      });
      this.dispatch("row-moving", from, to2, after);
    }
    moveRowInArray(rows, from, to2, after) {
      var fromIndex, toIndex, start, end;
      if (from !== to2) {
        fromIndex = rows.indexOf(from);
        if (fromIndex > -1) {
          rows.splice(fromIndex, 1);
          toIndex = rows.indexOf(to2);
          if (toIndex > -1) {
            if (after) {
              rows.splice(toIndex + 1, 0, from);
            } else {
              rows.splice(toIndex, 0, from);
            }
          } else {
            rows.splice(fromIndex, 0, from);
          }
        }
        if (rows === this.getDisplayRows()) {
          start = fromIndex < toIndex ? fromIndex : toIndex;
          end = toIndex > fromIndex ? toIndex : fromIndex + 1;
          for (let i2 = start; i2 <= end; i2++) {
            if (rows[i2]) {
              this.styleRow(rows[i2], i2);
            }
          }
        }
      }
    }
    clearData() {
      this.setData([]);
    }
    getRowIndex(row) {
      return this.findRowIndex(row, this.rows);
    }
    getDisplayRowIndex(row) {
      var index2 = this.getDisplayRows().indexOf(row);
      return index2 > -1 ? index2 : false;
    }
    nextDisplayRow(row, rowOnly) {
      var index2 = this.getDisplayRowIndex(row), nextRow = false;
      if (index2 !== false && index2 < this.displayRowsCount - 1) {
        nextRow = this.getDisplayRows()[index2 + 1];
      }
      if (nextRow && (!(nextRow instanceof Row) || nextRow.type != "row")) {
        return this.nextDisplayRow(nextRow, rowOnly);
      }
      return nextRow;
    }
    prevDisplayRow(row, rowOnly) {
      var index2 = this.getDisplayRowIndex(row), prevRow = false;
      if (index2) {
        prevRow = this.getDisplayRows()[index2 - 1];
      }
      if (rowOnly && prevRow && (!(prevRow instanceof Row) || prevRow.type != "row")) {
        return this.prevDisplayRow(prevRow, rowOnly);
      }
      return prevRow;
    }
    findRowIndex(row, list2) {
      var rowIndex;
      row = this.findRow(row);
      if (row) {
        rowIndex = list2.indexOf(row);
        if (rowIndex > -1) {
          return rowIndex;
        }
      }
      return false;
    }
    getData(active, transform) {
      var output = [], rows = this.getRows(active);
      rows.forEach(function(row) {
        if (row.type == "row") {
          output.push(row.getData(transform || "data"));
        }
      });
      return output;
    }
    getComponents(active) {
      var output = [], rows = this.getRows(active);
      rows.forEach(function(row) {
        output.push(row.getComponent());
      });
      return output;
    }
    getDataCount(active) {
      var rows = this.getRows(active);
      return rows.length;
    }
    scrollHorizontal(left) {
      this.scrollLeft = left;
      this.element.scrollLeft = left;
      this.dispatch("scroll-horizontal", left);
    }
    registerDataPipelineHandler(handler, priority) {
      if (typeof priority !== "undefined") {
        this.dataPipeline.push({ handler, priority });
        this.dataPipeline.sort((a2, b2) => {
          return a2.priority - b2.priority;
        });
      } else {
        console.error("Data pipeline handlers must have a priority in order to be registered");
      }
    }
    registerDisplayPipelineHandler(handler, priority) {
      if (typeof priority !== "undefined") {
        this.displayPipeline.push({ handler, priority });
        this.displayPipeline.sort((a2, b2) => {
          return a2.priority - b2.priority;
        });
      } else {
        console.error("Display pipeline handlers must have a priority in order to be registered");
      }
    }
    //set active data set
    refreshActiveData(handler, skipStage, renderInPosition) {
      var table = this.table, stage = "", index2 = 0, cascadeOrder = ["all", "dataPipeline", "display", "displayPipeline", "end"];
      if (!this.table.destroyed) {
        if (typeof handler === "function") {
          index2 = this.dataPipeline.findIndex((item) => {
            return item.handler === handler;
          });
          if (index2 > -1) {
            stage = "dataPipeline";
            if (skipStage) {
              if (index2 == this.dataPipeline.length - 1) {
                stage = "display";
              } else {
                index2++;
              }
            }
          } else {
            index2 = this.displayPipeline.findIndex((item) => {
              return item.handler === handler;
            });
            if (index2 > -1) {
              stage = "displayPipeline";
              if (skipStage) {
                if (index2 == this.displayPipeline.length - 1) {
                  stage = "end";
                } else {
                  index2++;
                }
              }
            } else {
              console.error("Unable to refresh data, invalid handler provided", handler);
              return;
            }
          }
        } else {
          stage = handler || "all";
          index2 = 0;
        }
        if (this.redrawBlock) {
          if (!this.redrawBlockRestoreConfig || this.redrawBlockRestoreConfig && (this.redrawBlockRestoreConfig.stage === stage && index2 < this.redrawBlockRestoreConfig.index || cascadeOrder.indexOf(stage) < cascadeOrder.indexOf(this.redrawBlockRestoreConfig.stage))) {
            this.redrawBlockRestoreConfig = {
              handler,
              skipStage,
              renderInPosition,
              stage,
              index: index2
            };
          }
          return;
        } else {
          if (Helpers.elVisible(this.element)) {
            if (renderInPosition) {
              this.reRenderInPosition(this.refreshPipelines.bind(this, handler, stage, index2, renderInPosition));
            } else {
              this.refreshPipelines(handler, stage, index2, renderInPosition);
              if (!handler) {
                this.table.columnManager.renderer.renderColumns();
              }
              this.renderTable();
              if (table.options.layoutColumnsOnNewData) {
                this.table.columnManager.redraw(true);
              }
            }
          } else {
            this.refreshPipelines(handler, stage, index2, renderInPosition);
          }
          this.dispatch("data-refreshed");
        }
      }
    }
    refreshPipelines(handler, stage, index2, renderInPosition) {
      this.dispatch("data-refreshing");
      if (!handler || !this.activeRowsPipeline[0]) {
        this.activeRowsPipeline[0] = this.rows.slice(0);
      }
      switch (stage) {
        case "all":
        //handle case where all data needs refreshing
        case "dataPipeline":
          for (let i2 = index2; i2 < this.dataPipeline.length; i2++) {
            let result = this.dataPipeline[i2].handler(this.activeRowsPipeline[i2].slice(0));
            this.activeRowsPipeline[i2 + 1] = result || this.activeRowsPipeline[i2].slice(0);
          }
          this.setActiveRows(this.activeRowsPipeline[this.dataPipeline.length]);
        case "display":
          index2 = 0;
          this.resetDisplayRows();
        case "displayPipeline":
          for (let i2 = index2; i2 < this.displayPipeline.length; i2++) {
            let result = this.displayPipeline[i2].handler((i2 ? this.getDisplayRows(i2 - 1) : this.activeRows).slice(0), renderInPosition);
            this.setDisplayRows(result || this.getDisplayRows(i2 - 1).slice(0), i2);
          }
        case "end":
          this.regenerateRowPositions();
      }
      if (this.getDisplayRows().length) {
        this._clearPlaceholder();
      }
    }
    //regenerate row positions
    regenerateRowPositions() {
      var rows = this.getDisplayRows();
      var index2 = 1;
      rows.forEach((row) => {
        if (row.type === "row") {
          row.setPosition(index2);
          index2++;
        }
      });
    }
    setActiveRows(activeRows) {
      this.activeRows = this.activeRows = Object.assign([], activeRows);
      this.activeRowsCount = this.activeRows.length;
    }
    //reset display rows array
    resetDisplayRows() {
      this.displayRows = [];
      this.displayRows.push(this.activeRows.slice(0));
      this.displayRowsCount = this.displayRows[0].length;
    }
    //set display row pipeline data
    setDisplayRows(displayRows, index2) {
      this.displayRows[index2] = displayRows;
      if (index2 == this.displayRows.length - 1) {
        this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
      }
    }
    getDisplayRows(index2) {
      if (typeof index2 == "undefined") {
        return this.displayRows.length ? this.displayRows[this.displayRows.length - 1] : [];
      } else {
        return this.displayRows[index2] || [];
      }
    }
    getVisibleRows(chain, viewable) {
      var rows = Object.assign([], this.renderer.visibleRows(!viewable));
      if (chain) {
        rows = this.chain("rows-visible", [viewable], rows, rows);
      }
      return rows;
    }
    //repeat action across display rows
    displayRowIterator(callback) {
      this.activeRowsPipeline.forEach(callback);
      this.displayRows.forEach(callback);
      this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
    }
    //return only actual rows (not group headers etc)
    getRows(type) {
      var rows = [];
      switch (type) {
        case "active":
          rows = this.activeRows;
          break;
        case "display":
          rows = this.table.rowManager.getDisplayRows();
          break;
        case "visible":
          rows = this.getVisibleRows(false, true);
          break;
        default:
          rows = this.chain("rows-retrieve", type, null, this.rows) || this.rows;
      }
      return rows;
    }
    ///////////////// Table Rendering /////////////////
    //trigger rerender of table in current position
    reRenderInPosition(callback) {
      if (this.redrawBlock) {
        if (callback) {
          callback();
        } else {
          this.redrawBlockRenderInPosition = true;
        }
      } else {
        this.dispatchExternal("renderStarted");
        this.renderer.rerenderRows(callback);
        if (!this.fixedHeight) {
          this.adjustTableSize();
        }
        this.scrollBarCheck();
        this.dispatchExternal("renderComplete");
      }
    }
    scrollBarCheck() {
      var scrollbarWidth = 0;
      if (this.element.scrollHeight > this.element.clientHeight) {
        scrollbarWidth = this.element.offsetWidth - this.element.clientWidth;
      }
      if (scrollbarWidth !== this.scrollbarWidth) {
        this.scrollbarWidth = scrollbarWidth;
        this.dispatch("scrollbar-vertical", scrollbarWidth);
      }
    }
    initializeRenderer() {
      var renderClass;
      var renderers = {
        "virtual": VirtualDomVertical,
        "basic": BasicVertical
      };
      if (typeof this.table.options.renderVertical === "string") {
        renderClass = renderers[this.table.options.renderVertical];
      } else {
        renderClass = this.table.options.renderVertical;
      }
      if (renderClass) {
        this.renderMode = this.table.options.renderVertical;
        this.renderer = new renderClass(this.table, this.element, this.tableElement);
        this.renderer.initialize();
        if ((this.table.element.clientHeight || this.table.options.height) && !(this.table.options.minHeight && this.table.options.maxHeight)) {
          this.fixedHeight = true;
        } else {
          this.fixedHeight = false;
        }
      } else {
        console.error("Unable to find matching renderer:", this.table.options.renderVertical);
      }
    }
    getRenderMode() {
      return this.renderMode;
    }
    renderTable() {
      this.dispatchExternal("renderStarted");
      this.element.scrollTop = 0;
      this._clearTable();
      if (this.displayRowsCount) {
        this.renderer.renderRows();
        if (this.firstRender) {
          this.firstRender = false;
          if (!this.fixedHeight) {
            this.adjustTableSize();
          }
          this.layoutRefresh(true);
        }
      } else {
        this.renderEmptyScroll();
      }
      if (!this.fixedHeight) {
        this.adjustTableSize();
      }
      this.dispatch("table-layout");
      if (!this.displayRowsCount) {
        this._showPlaceholder();
      }
      this.scrollBarCheck();
      this.dispatchExternal("renderComplete");
    }
    //show scrollbars on empty table div
    renderEmptyScroll() {
      if (this.placeholder) {
        this.tableElement.style.display = "none";
      } else {
        this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px";
      }
    }
    _clearTable() {
      this._clearPlaceholder();
      this.scrollTop = 0;
      this.scrollLeft = 0;
      this.renderer.clearRows();
    }
    tableEmpty() {
      this.renderEmptyScroll();
      this._showPlaceholder();
    }
    checkPlaceholder() {
      if (this.displayRowsCount) {
        this._clearPlaceholder();
      } else {
        this.tableEmpty();
      }
    }
    _showPlaceholder() {
      if (this.placeholder) {
        if (this.placeholder && this.placeholder.parentNode) {
          this.placeholder.parentNode.removeChild(this.placeholder);
        }
        this.initializePlaceholder();
        this.placeholder.setAttribute("tabulator-render-mode", this.renderMode);
        this.getElement().appendChild(this.placeholder);
        this._positionPlaceholder();
        this.adjustTableSize();
      }
    }
    _clearPlaceholder() {
      if (this.placeholder && this.placeholder.parentNode) {
        this.placeholder.parentNode.removeChild(this.placeholder);
      }
      this.tableElement.style.minWidth = "";
      this.tableElement.style.display = "";
    }
    _positionPlaceholder() {
      if (this.placeholder && this.placeholder.parentNode) {
        this.placeholder.style.width = this.table.columnManager.getWidth() + "px";
        this.placeholderContents.style.width = this.table.rowManager.element.clientWidth + "px";
        this.placeholderContents.style.marginLeft = this.scrollLeft + "px";
      }
    }
    styleRow(row, index2) {
      var rowEl = row.getElement();
      if (index2 % 2) {
        rowEl.classList.add("tabulator-row-even");
        rowEl.classList.remove("tabulator-row-odd");
      } else {
        rowEl.classList.add("tabulator-row-odd");
        rowEl.classList.remove("tabulator-row-even");
      }
    }
    //normalize height of active rows
    normalizeHeight(force) {
      this.activeRows.forEach(function(row) {
        row.normalizeHeight(force);
      });
    }
    //adjust the height of the table holder to fit in the Tabulator element
    adjustTableSize() {
      let initialHeight = this.element.clientHeight, minHeight;
      let resized = false;
      if (this.renderer.verticalFillMode === "fill") {
        let otherHeight = Math.floor(this.table.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));
        if (this.fixedHeight) {
          minHeight = isNaN(this.table.options.minHeight) ? this.table.options.minHeight : this.table.options.minHeight + "px";
          const height = "calc(100% - " + otherHeight + "px)";
          this.element.style.minHeight = minHeight || "calc(100% - " + otherHeight + "px)";
          this.element.style.height = height;
          this.element.style.maxHeight = height;
        } else {
          this.element.style.height = "";
          this.element.style.height = this.table.element.clientHeight - otherHeight + "px";
          this.element.scrollTop = this.scrollTop;
        }
        this.renderer.resize();
        if (!this.fixedHeight && initialHeight != this.element.clientHeight) {
          resized = true;
          if (this.subscribed("table-resize")) {
            this.dispatch("table-resize");
          } else {
            this.redraw();
          }
        }
        this.scrollBarCheck();
      }
      this._positionPlaceholder();
      return resized;
    }
    //reinitialize all rows
    reinitialize() {
      this.rows.forEach(function(row) {
        row.reinitialize(true);
      });
    }
    //prevent table from being redrawn
    blockRedraw() {
      this.redrawBlock = true;
      this.redrawBlockRestoreConfig = false;
    }
    //restore table redrawing
    restoreRedraw() {
      this.redrawBlock = false;
      if (this.redrawBlockRestoreConfig) {
        this.refreshActiveData(this.redrawBlockRestoreConfig.handler, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition);
        this.redrawBlockRestoreConfig = false;
      } else {
        if (this.redrawBlockRenderInPosition) {
          this.reRenderInPosition();
        }
      }
      this.redrawBlockRenderInPosition = false;
    }
    //redraw table
    redraw(force) {
      this.adjustTableSize();
      this.table.tableWidth = this.table.element.clientWidth;
      if (!force) {
        this.reRenderInPosition();
        this.scrollHorizontal(this.scrollLeft);
      } else {
        this.renderTable();
      }
    }
    resetScroll() {
      this.element.scrollLeft = 0;
      this.element.scrollTop = 0;
      if (this.table.browser === "ie") {
        var event = document.createEvent("Event");
        event.initEvent("scroll", false, true);
        this.element.dispatchEvent(event);
      } else {
        this.element.dispatchEvent(new Event("scroll"));
      }
    }
  }
  class FooterManager extends CoreFeature {
    constructor(table) {
      super(table);
      this.active = false;
      this.element = this.createElement();
      this.containerElement = this.createContainerElement();
      this.external = false;
    }
    initialize() {
      this.initializeElement();
    }
    createElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-footer");
      return el;
    }
    createContainerElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-footer-contents");
      this.element.appendChild(el);
      return el;
    }
    initializeElement() {
      if (this.table.options.footerElement) {
        switch (typeof this.table.options.footerElement) {
          case "string":
            if (this.table.options.footerElement[0] === "<") {
              this.containerElement.innerHTML = this.table.options.footerElement;
            } else {
              this.external = true;
              this.containerElement = document.querySelector(this.table.options.footerElement);
            }
            break;
          default:
            this.element = this.table.options.footerElement;
            break;
        }
      }
    }
    getElement() {
      return this.element;
    }
    append(element) {
      this.activate();
      this.containerElement.appendChild(element);
      this.table.rowManager.adjustTableSize();
    }
    prepend(element) {
      this.activate();
      this.element.insertBefore(element, this.element.firstChild);
      this.table.rowManager.adjustTableSize();
    }
    remove(element) {
      element.parentNode.removeChild(element);
      this.deactivate();
    }
    deactivate(force) {
      if (!this.element.firstChild || force) {
        if (!this.external) {
          this.element.parentNode.removeChild(this.element);
        }
        this.active = false;
      }
    }
    activate() {
      if (!this.active) {
        this.active = true;
        if (!this.external) {
          this.table.element.appendChild(this.getElement());
          this.table.element.style.display = "";
        }
      }
    }
    redraw() {
      this.dispatch("footer-redraw");
    }
  }
  class InteractionManager extends CoreFeature {
    constructor(table) {
      super(table);
      this.el = null;
      this.abortClasses = ["tabulator-headers", "tabulator-table"];
      this.previousTargets = {};
      this.listeners = [
        "click",
        "dblclick",
        "contextmenu",
        "mouseenter",
        "mouseleave",
        "mouseover",
        "mouseout",
        "mousemove",
        "mouseup",
        "mousedown",
        "touchstart",
        "touchend"
      ];
      this.componentMap = {
        "tabulator-cell": "cell",
        "tabulator-row": "row",
        "tabulator-group": "group",
        "tabulator-col": "column"
      };
      this.pseudoTrackers = {
        "row": {
          subscriber: null,
          target: null
        },
        "cell": {
          subscriber: null,
          target: null
        },
        "group": {
          subscriber: null,
          target: null
        },
        "column": {
          subscriber: null,
          target: null
        }
      };
      this.pseudoTracking = false;
    }
    initialize() {
      this.el = this.table.element;
      this.buildListenerMap();
      this.bindSubscriptionWatchers();
    }
    buildListenerMap() {
      var listenerMap = {};
      this.listeners.forEach((listener) => {
        listenerMap[listener] = {
          handler: null,
          components: []
        };
      });
      this.listeners = listenerMap;
    }
    bindPseudoEvents() {
      Object.keys(this.pseudoTrackers).forEach((key) => {
        this.pseudoTrackers[key].subscriber = this.pseudoMouseEnter.bind(this, key);
        this.subscribe(key + "-mouseover", this.pseudoTrackers[key].subscriber);
      });
      this.pseudoTracking = true;
    }
    pseudoMouseEnter(key, e, target) {
      if (this.pseudoTrackers[key].target !== target) {
        if (this.pseudoTrackers[key].target) {
          this.dispatch(key + "-mouseleave", e, this.pseudoTrackers[key].target);
        }
        this.pseudoMouseLeave(key, e);
        this.pseudoTrackers[key].target = target;
        this.dispatch(key + "-mouseenter", e, target);
      }
    }
    pseudoMouseLeave(key, e) {
      var leaveList = Object.keys(this.pseudoTrackers), linkedKeys = {
        "row": ["cell"],
        "cell": ["row"]
      };
      leaveList = leaveList.filter((item) => {
        var links = linkedKeys[key];
        return item !== key && (!links || links && !links.includes(item));
      });
      leaveList.forEach((key2) => {
        var target = this.pseudoTrackers[key2].target;
        if (this.pseudoTrackers[key2].target) {
          this.dispatch(key2 + "-mouseleave", e, target);
          this.pseudoTrackers[key2].target = null;
        }
      });
    }
    bindSubscriptionWatchers() {
      var listeners = Object.keys(this.listeners), components = Object.values(this.componentMap);
      for (let comp of components) {
        for (let listener of listeners) {
          let key = comp + "-" + listener;
          this.subscriptionChange(key, this.subscriptionChanged.bind(this, comp, listener));
        }
      }
      this.subscribe("table-destroy", this.clearWatchers.bind(this));
    }
    subscriptionChanged(component, key, added) {
      var listener = this.listeners[key].components, index2 = listener.indexOf(component), changed = false;
      if (added) {
        if (index2 === -1) {
          listener.push(component);
          changed = true;
        }
      } else {
        if (!this.subscribed(component + "-" + key)) {
          if (index2 > -1) {
            listener.splice(index2, 1);
            changed = true;
          }
        }
      }
      if ((key === "mouseenter" || key === "mouseleave") && !this.pseudoTracking) {
        this.bindPseudoEvents();
      }
      if (changed) {
        this.updateEventListeners();
      }
    }
    updateEventListeners() {
      for (let key in this.listeners) {
        let listener = this.listeners[key];
        if (listener.components.length) {
          if (!listener.handler) {
            listener.handler = this.track.bind(this, key);
            this.el.addEventListener(key, listener.handler);
          }
        } else {
          if (listener.handler) {
            this.el.removeEventListener(key, listener.handler);
            listener.handler = null;
          }
        }
      }
    }
    track(type, e) {
      var path = e.composedPath && e.composedPath() || e.path;
      var targets = this.findTargets(path);
      targets = this.bindComponents(type, targets);
      this.triggerEvents(type, e, targets);
      if (this.pseudoTracking && (type == "mouseover" || type == "mouseleave") && !Object.keys(targets).length) {
        this.pseudoMouseLeave("none", e);
      }
    }
    findTargets(path) {
      var targets = {};
      let componentMap = Object.keys(this.componentMap);
      for (let el of path) {
        let classList = el.classList ? [...el.classList] : [];
        let abort = classList.filter((item) => {
          return this.abortClasses.includes(item);
        });
        if (abort.length) {
          break;
        }
        let elTargets = classList.filter((item) => {
          return componentMap.includes(item);
        });
        for (let target of elTargets) {
          if (!targets[this.componentMap[target]]) {
            targets[this.componentMap[target]] = el;
          }
        }
      }
      if (targets.group && targets.group === targets.row) {
        delete targets.row;
      }
      return targets;
    }
    bindComponents(type, targets) {
      var keys2 = Object.keys(targets).reverse(), listener = this.listeners[type], matches2 = {}, output = {}, targetMatches = {};
      for (let key of keys2) {
        let component, target = targets[key], previousTarget = this.previousTargets[key];
        if (previousTarget && previousTarget.target === target) {
          component = previousTarget.component;
        } else {
          switch (key) {
            case "row":
            case "group":
              if (listener.components.includes("row") || listener.components.includes("cell") || listener.components.includes("group")) {
                let rows = this.table.rowManager.getVisibleRows(true);
                component = rows.find((row) => {
                  return row.getElement() === target;
                });
                if (targets["row"] && targets["row"].parentNode && targets["row"].parentNode.closest(".tabulator-row")) {
                  targets[key] = false;
                }
              }
              break;
            case "column":
              if (listener.components.includes("column")) {
                component = this.table.columnManager.findColumn(target);
              }
              break;
            case "cell":
              if (listener.components.includes("cell")) {
                if (matches2["row"] instanceof Row) {
                  component = matches2["row"].findCell(target);
                } else {
                  if (targets["row"]) {
                    console.warn("Event Target Lookup Error - The row this cell is attached to cannot be found, has the table been reinitialized without being destroyed first?");
                  }
                }
              }
              break;
          }
        }
        if (component) {
          matches2[key] = component;
          targetMatches[key] = {
            target,
            component
          };
        }
      }
      this.previousTargets = targetMatches;
      Object.keys(targets).forEach((key) => {
        let value = matches2[key];
        output[key] = value;
      });
      return output;
    }
    triggerEvents(type, e, targets) {
      var listener = this.listeners[type];
      for (let key in targets) {
        if (targets[key] && listener.components.includes(key)) {
          this.dispatch(key + "-" + type, e, targets[key]);
        }
      }
    }
    clearWatchers() {
      for (let key in this.listeners) {
        let listener = this.listeners[key];
        if (listener.handler) {
          this.el.removeEventListener(key, listener.handler);
          listener.handler = null;
        }
      }
    }
  }
  class ComponentFunctionBinder {
    constructor(table) {
      this.table = table;
      this.bindings = {};
    }
    bind(type, funcName, handler) {
      if (!this.bindings[type]) {
        this.bindings[type] = {};
      }
      if (this.bindings[type][funcName]) {
        console.warn("Unable to bind component handler, a matching function name is already bound", type, funcName, handler);
      } else {
        this.bindings[type][funcName] = handler;
      }
    }
    handle(type, component, name) {
      if (this.bindings[type] && this.bindings[type][name] && typeof this.bindings[type][name].bind === "function") {
        return this.bindings[type][name].bind(null, component);
      } else {
        if (name !== "then" && typeof name === "string" && !name.startsWith("_")) {
          if (this.table.options.debugInvalidComponentFuncs) {
            console.error("The " + type + " component does not have a " + name + " function, have you checked that you have the correct Tabulator module installed?");
          }
        }
      }
    }
  }
  class DataLoader extends CoreFeature {
    constructor(table) {
      super(table);
      this.requestOrder = 0;
      this.loading = false;
    }
    initialize() {
    }
    load(data, params, config, replace, silent, columnsChanged) {
      var requestNo = ++this.requestOrder;
      if (this.table.destroyed) {
        return Promise.resolve();
      }
      this.dispatchExternal("dataLoading", data);
      if (data && (data.indexOf("{") == 0 || data.indexOf("[") == 0)) {
        data = JSON.parse(data);
      }
      if (this.confirm("data-loading", [data, params, config, silent])) {
        this.loading = true;
        if (!silent) {
          this.alertLoader();
        }
        params = this.chain("data-params", [data, config, silent], params || {}, params || {});
        params = this.mapParams(params, this.table.options.dataSendParams);
        var result = this.chain("data-load", [data, params, config, silent], false, Promise.resolve([]));
        return result.then((response) => {
          if (!this.table.destroyed) {
            if (!Array.isArray(response) && typeof response == "object") {
              response = this.mapParams(response, this.objectInvert(this.table.options.dataReceiveParams));
            }
            var rowData = this.chain("data-loaded", [response], null, response);
            if (requestNo == this.requestOrder) {
              this.clearAlert();
              if (rowData !== false) {
                this.dispatchExternal("dataLoaded", rowData);
                this.table.rowManager.setData(rowData, replace, typeof columnsChanged === "undefined" ? !replace : columnsChanged);
              }
            } else {
              console.warn("Data Load Response Blocked - An active data load request was blocked by an attempt to change table data while the request was being made");
            }
          } else {
            console.warn("Data Load Response Blocked - Table has been destroyed");
          }
        }).catch((error) => {
          console.error("Data Load Error: ", error);
          this.dispatchExternal("dataLoadError", error);
          if (!silent) {
            this.alertError();
          }
          setTimeout(() => {
            this.clearAlert();
          }, this.table.options.dataLoaderErrorTimeout);
        }).finally(() => {
          this.loading = false;
        });
      } else {
        this.dispatchExternal("dataLoaded", data);
        if (!data) {
          data = [];
        }
        this.table.rowManager.setData(data, replace, typeof columnsChanged === "undefined" ? !replace : columnsChanged);
        return Promise.resolve();
      }
    }
    mapParams(params, map) {
      var output = {};
      for (let key in params) {
        output[map.hasOwnProperty(key) ? map[key] : key] = params[key];
      }
      return output;
    }
    objectInvert(obj) {
      var output = {};
      for (let key in obj) {
        output[obj[key]] = key;
      }
      return output;
    }
    blockActiveLoad() {
      this.requestOrder++;
    }
    alertLoader() {
      var shouldLoad = typeof this.table.options.dataLoader === "function" ? this.table.options.dataLoader() : this.table.options.dataLoader;
      if (shouldLoad) {
        this.table.alertManager.alert(this.table.options.dataLoaderLoading || this.langText("data|loading"));
      }
    }
    alertError() {
      this.table.alertManager.alert(this.table.options.dataLoaderError || this.langText("data|error"), "error");
    }
    clearAlert() {
      this.table.alertManager.clear();
    }
  }
  class ExternalEventBus {
    constructor(table, optionsList, debug) {
      this.table = table;
      this.events = {};
      this.optionsList = optionsList || {};
      this.subscriptionNotifiers = {};
      this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
      this.debug = debug;
    }
    subscriptionChange(key, callback) {
      if (!this.subscriptionNotifiers[key]) {
        this.subscriptionNotifiers[key] = [];
      }
      this.subscriptionNotifiers[key].push(callback);
      if (this.subscribed(key)) {
        this._notifySubscriptionChange(key, true);
      }
    }
    subscribe(key, callback) {
      if (!this.events[key]) {
        this.events[key] = [];
      }
      this.events[key].push(callback);
      this._notifySubscriptionChange(key, true);
    }
    unsubscribe(key, callback) {
      var index2;
      if (this.events[key]) {
        if (callback) {
          index2 = this.events[key].findIndex((item) => {
            return item === callback;
          });
          if (index2 > -1) {
            this.events[key].splice(index2, 1);
          } else {
            console.warn("Cannot remove event, no matching event found:", key, callback);
            return;
          }
        } else {
          delete this.events[key];
        }
      } else {
        console.warn("Cannot remove event, no events set on:", key);
        return;
      }
      this._notifySubscriptionChange(key, false);
    }
    subscribed(key) {
      return this.events[key] && this.events[key].length;
    }
    _notifySubscriptionChange(key, subscribed) {
      var notifiers = this.subscriptionNotifiers[key];
      if (notifiers) {
        notifiers.forEach((callback) => {
          callback(subscribed);
        });
      }
    }
    _dispatch() {
      var args = Array.from(arguments), key = args.shift(), result;
      if (this.events[key]) {
        this.events[key].forEach((callback, i2) => {
          let callResult = callback.apply(this.table, args);
          if (!i2) {
            result = callResult;
          }
        });
      }
      return result;
    }
    _debugDispatch() {
      var args = Array.from(arguments), key = args[0];
      args[0] = "ExternalEvent:" + args[0];
      if (this.debug === true || this.debug.includes(key)) {
        console.log(...args);
      }
      return this._dispatch(...arguments);
    }
  }
  class InternalEventBus {
    constructor(debug) {
      this.events = {};
      this.subscriptionNotifiers = {};
      this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
      this.chain = debug ? this._debugChain.bind(this) : this._chain.bind(this);
      this.confirm = debug ? this._debugConfirm.bind(this) : this._confirm.bind(this);
      this.debug = debug;
    }
    subscriptionChange(key, callback) {
      if (!this.subscriptionNotifiers[key]) {
        this.subscriptionNotifiers[key] = [];
      }
      this.subscriptionNotifiers[key].push(callback);
      if (this.subscribed(key)) {
        this._notifySubscriptionChange(key, true);
      }
    }
    subscribe(key, callback, priority = 1e4) {
      if (!this.events[key]) {
        this.events[key] = [];
      }
      this.events[key].push({ callback, priority });
      this.events[key].sort((a2, b2) => {
        return a2.priority - b2.priority;
      });
      this._notifySubscriptionChange(key, true);
    }
    unsubscribe(key, callback) {
      var index2;
      if (this.events[key]) {
        if (callback) {
          index2 = this.events[key].findIndex((item) => {
            return item.callback === callback;
          });
          if (index2 > -1) {
            this.events[key].splice(index2, 1);
          } else {
            console.warn("Cannot remove event, no matching event found:", key, callback);
            return;
          }
        }
      } else {
        console.warn("Cannot remove event, no events set on:", key);
        return;
      }
      this._notifySubscriptionChange(key, false);
    }
    subscribed(key) {
      return this.events[key] && this.events[key].length;
    }
    _chain(key, args, initialValue, fallback) {
      var value = initialValue;
      if (!Array.isArray(args)) {
        args = [args];
      }
      if (this.subscribed(key)) {
        this.events[key].forEach((subscriber, i2) => {
          value = subscriber.callback.apply(this, args.concat([value]));
        });
        return value;
      } else {
        return typeof fallback === "function" ? fallback() : fallback;
      }
    }
    _confirm(key, args) {
      var confirmed = false;
      if (!Array.isArray(args)) {
        args = [args];
      }
      if (this.subscribed(key)) {
        this.events[key].forEach((subscriber, i2) => {
          if (subscriber.callback.apply(this, args)) {
            confirmed = true;
          }
        });
      }
      return confirmed;
    }
    _notifySubscriptionChange(key, subscribed) {
      var notifiers = this.subscriptionNotifiers[key];
      if (notifiers) {
        notifiers.forEach((callback) => {
          callback(subscribed);
        });
      }
    }
    _dispatch() {
      var args = Array.from(arguments), key = args.shift();
      if (this.events[key]) {
        this.events[key].forEach((subscriber) => {
          subscriber.callback.apply(this, args);
        });
      }
    }
    _debugDispatch() {
      var args = Array.from(arguments), key = args[0];
      args[0] = "InternalEvent:" + key;
      if (this.debug === true || this.debug.includes(key)) {
        console.log(...args);
      }
      return this._dispatch(...arguments);
    }
    _debugChain() {
      var args = Array.from(arguments), key = args[0];
      args[0] = "InternalEvent:" + key;
      if (this.debug === true || this.debug.includes(key)) {
        console.log(...args);
      }
      return this._chain(...arguments);
    }
    _debugConfirm() {
      var args = Array.from(arguments), key = args[0];
      args[0] = "InternalEvent:" + key;
      if (this.debug === true || this.debug.includes(key)) {
        console.log(...args);
      }
      return this._confirm(...arguments);
    }
  }
  class DeprecationAdvisor extends CoreFeature {
    constructor(table) {
      super(table);
    }
    _warnUser() {
      if (this.options("debugDeprecation")) {
        console.warn(...arguments);
      }
    }
    check(oldOption, newOption, convert) {
      var msg = "";
      if (typeof this.options(oldOption) !== "undefined") {
        msg = "Deprecated Setup Option - Use of the %c" + oldOption + "%c option is now deprecated";
        if (newOption) {
          msg = msg + ", Please use the %c" + newOption + "%c option instead";
          this._warnUser(msg, "font-weight: bold;", "font-weight: normal;", "font-weight: bold;", "font-weight: normal;");
          if (convert) {
            this.table.options[newOption] = this.table.options[oldOption];
          }
        } else {
          this._warnUser(msg, "font-weight: bold;", "font-weight: normal;");
        }
        return false;
      } else {
        return true;
      }
    }
    checkMsg(oldOption, msg) {
      if (typeof this.options(oldOption) !== "undefined") {
        this._warnUser("%cDeprecated Setup Option - Use of the %c" + oldOption + " %c option is now deprecated, " + msg, "font-weight: normal;", "font-weight: bold;", "font-weight: normal;");
        return false;
      } else {
        return true;
      }
    }
    msg(msg) {
      this._warnUser(msg);
    }
  }
  class DependencyRegistry extends CoreFeature {
    constructor(table) {
      super(table);
      this.deps = {};
      this.props = {};
    }
    initialize() {
      this.deps = Object.assign({}, this.options("dependencies"));
    }
    lookup(key, prop, silent) {
      if (Array.isArray(key)) {
        for (const item of key) {
          var match = this.lookup(item, prop, true);
          if (match) {
            break;
          }
        }
        if (match) {
          return match;
        } else {
          this.error(key);
        }
      } else {
        if (prop) {
          return this.lookupProp(key, prop, silent);
        } else {
          return this.lookupKey(key, silent);
        }
      }
    }
    lookupProp(key, prop, silent) {
      var dependency;
      if (this.props[key] && this.props[key][prop]) {
        return this.props[key][prop];
      } else {
        dependency = this.lookupKey(key, silent);
        if (dependency) {
          if (!this.props[key]) {
            this.props[key] = {};
          }
          this.props[key][prop] = dependency[prop] || dependency;
          return this.props[key][prop];
        }
      }
    }
    lookupKey(key, silent) {
      var dependency;
      if (this.deps[key]) {
        dependency = this.deps[key];
      } else if (window[key]) {
        this.deps[key] = window[key];
        dependency = this.deps[key];
      } else {
        if (!silent) {
          this.error(key);
        }
      }
      return dependency;
    }
    error(key) {
      console.error("Unable to find dependency", key, "Please check documentation and ensure you have imported the required library into your project");
    }
  }
  function fitData(columns, forced) {
    if (forced) {
      this.table.columnManager.renderer.reinitializeColumnWidths(columns);
    }
    if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
      this.table.modules.responsiveLayout.update();
    }
  }
  function fitDataGeneral(columns, forced) {
    columns.forEach(function(column) {
      column.reinitializeWidth();
    });
    if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
      this.table.modules.responsiveLayout.update();
    }
  }
  function fitDataStretch(columns, forced) {
    var colsWidth = 0, tableWidth = this.table.rowManager.element.clientWidth, gap = 0, lastCol = false;
    columns.forEach((column, i2) => {
      if (!column.widthFixed) {
        column.reinitializeWidth();
      }
      if (this.table.options.responsiveLayout ? column.modules.responsive.visible : column.visible) {
        lastCol = column;
      }
      if (column.visible) {
        colsWidth += column.getWidth();
      }
    });
    if (lastCol) {
      gap = tableWidth - colsWidth + lastCol.getWidth();
      if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
        lastCol.setWidth(0);
        this.table.modules.responsiveLayout.update();
      }
      if (gap > 0) {
        lastCol.setWidth(gap);
      } else {
        lastCol.reinitializeWidth();
      }
    } else {
      if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
        this.table.modules.responsiveLayout.update();
      }
    }
  }
  function fitColumns(columns, forced) {
    var totalWidth = this.table.rowManager.element.getBoundingClientRect().width;
    var fixedWidth = 0;
    var flexWidth = 0;
    var flexGrowUnits = 0;
    var flexColWidth = 0;
    var flexColumns = [];
    var fixedShrinkColumns = [];
    var flexShrinkUnits = 0;
    var overflowWidth = 0;
    var gapFill = 0;
    function calcWidth(width) {
      var colWidth;
      if (typeof width == "string") {
        if (width.indexOf("%") > -1) {
          colWidth = totalWidth / 100 * parseInt(width);
        } else {
          colWidth = parseInt(width);
        }
      } else {
        colWidth = width;
      }
      return colWidth;
    }
    function scaleColumns(columns2, freeSpace, colWidth, shrinkCols) {
      var oversizeCols = [], oversizeSpace = 0, remainingSpace = 0, nextColWidth = 0, remainingFlexGrowUnits = flexGrowUnits, gap = 0, changeUnits = 0, undersizeCols = [];
      function calcGrow(col) {
        return colWidth * (col.column.definition.widthGrow || 1);
      }
      function calcShrink(col) {
        return calcWidth(col.width) - colWidth * (col.column.definition.widthShrink || 0);
      }
      columns2.forEach(function(col, i2) {
        var width = shrinkCols ? calcShrink(col) : calcGrow(col);
        if (col.column.minWidth >= width) {
          oversizeCols.push(col);
        } else {
          if (col.column.maxWidth && col.column.maxWidth < width) {
            col.width = col.column.maxWidth;
            freeSpace -= col.column.maxWidth;
            remainingFlexGrowUnits -= shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;
            if (remainingFlexGrowUnits) {
              colWidth = Math.floor(freeSpace / remainingFlexGrowUnits);
            }
          } else {
            undersizeCols.push(col);
            changeUnits += shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;
          }
        }
      });
      if (oversizeCols.length) {
        oversizeCols.forEach(function(col) {
          oversizeSpace += shrinkCols ? col.width - col.column.minWidth : col.column.minWidth;
          col.width = col.column.minWidth;
        });
        remainingSpace = freeSpace - oversizeSpace;
        nextColWidth = changeUnits ? Math.floor(remainingSpace / changeUnits) : remainingSpace;
        gap = scaleColumns(undersizeCols, remainingSpace, nextColWidth, shrinkCols);
      } else {
        gap = changeUnits ? freeSpace - Math.floor(freeSpace / changeUnits) * changeUnits : freeSpace;
        undersizeCols.forEach(function(column) {
          column.width = shrinkCols ? calcShrink(column) : calcGrow(column);
        });
      }
      return gap;
    }
    if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
      this.table.modules.responsiveLayout.update();
    }
    if (this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight) {
      totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
    }
    columns.forEach(function(column) {
      var width, minWidth, colWidth;
      if (column.visible) {
        width = column.definition.width;
        minWidth = parseInt(column.minWidth);
        if (width) {
          colWidth = calcWidth(width);
          fixedWidth += colWidth > minWidth ? colWidth : minWidth;
          if (column.definition.widthShrink) {
            fixedShrinkColumns.push({
              column,
              width: colWidth > minWidth ? colWidth : minWidth
            });
            flexShrinkUnits += column.definition.widthShrink;
          }
        } else {
          flexColumns.push({
            column,
            width: 0
          });
          flexGrowUnits += column.definition.widthGrow || 1;
        }
      }
    });
    flexWidth = totalWidth - fixedWidth;
    flexColWidth = Math.floor(flexWidth / flexGrowUnits);
    gapFill = scaleColumns(flexColumns, flexWidth, flexColWidth, false);
    if (flexColumns.length && gapFill > 0) {
      flexColumns[flexColumns.length - 1].width += gapFill;
    }
    flexColumns.forEach(function(col) {
      flexWidth -= col.width;
    });
    overflowWidth = Math.abs(gapFill) + flexWidth;
    if (overflowWidth > 0 && flexShrinkUnits) {
      gapFill = scaleColumns(fixedShrinkColumns, overflowWidth, Math.floor(overflowWidth / flexShrinkUnits), true);
    }
    if (gapFill && fixedShrinkColumns.length) {
      fixedShrinkColumns[fixedShrinkColumns.length - 1].width -= gapFill;
    }
    flexColumns.forEach(function(col) {
      col.column.setWidth(col.width);
    });
    fixedShrinkColumns.forEach(function(col) {
      col.column.setWidth(col.width);
    });
  }
  var defaultModes = {
    fitData,
    fitDataFill: fitDataGeneral,
    fitDataTable: fitDataGeneral,
    fitDataStretch,
    fitColumns
  };
  const _Layout = class _Layout extends Module {
    constructor(table) {
      super(table, "layout");
      this.mode = null;
      this.registerTableOption("layout", "fitData");
      this.registerTableOption("layoutColumnsOnNewData", false);
      this.registerColumnOption("widthGrow");
      this.registerColumnOption("widthShrink");
    }
    //initialize layout system
    initialize() {
      var layout = this.table.options.layout;
      if (_Layout.modes[layout]) {
        this.mode = layout;
      } else {
        console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + layout);
        this.mode = "fitData";
      }
      this.table.element.setAttribute("tabulator-layout", this.mode);
      this.subscribe("column-init", this.initializeColumn.bind(this));
    }
    initializeColumn(column) {
      if (column.definition.widthGrow) {
        column.definition.widthGrow = Number(column.definition.widthGrow);
      }
      if (column.definition.widthShrink) {
        column.definition.widthShrink = Number(column.definition.widthShrink);
      }
    }
    getMode() {
      return this.mode;
    }
    //trigger table layout
    layout(dataChanged) {
      var variableHeight = this.table.columnManager.columnsByIndex.find((column) => column.definition.variableHeight || column.definition.formatter === "textarea");
      this.dispatch("layout-refreshing");
      _Layout.modes[this.mode].call(this, this.table.columnManager.columnsByIndex, dataChanged);
      if (variableHeight) {
        this.table.rowManager.normalizeHeight(true);
      }
      this.dispatch("layout-refreshed");
    }
  };
  __publicField(_Layout, "moduleName", "layout");
  //load defaults
  __publicField(_Layout, "modes", defaultModes);
  let Layout = _Layout;
  var defaultLangs = {
    "default": {
      //hold default locale text
      "groups": {
        "item": "item",
        "items": "items"
      },
      "columns": {},
      "data": {
        "loading": "Loading",
        "error": "Error"
      },
      "pagination": {
        "page_size": "Page Size",
        "page_title": "Show Page",
        "first": "First",
        "first_title": "First Page",
        "last": "Last",
        "last_title": "Last Page",
        "prev": "Prev",
        "prev_title": "Prev Page",
        "next": "Next",
        "next_title": "Next Page",
        "all": "All",
        "counter": {
          "showing": "Showing",
          "of": "of",
          "rows": "rows",
          "pages": "pages"
        }
      },
      "headerFilters": {
        "default": "filter column...",
        "columns": {}
      }
    }
  };
  const _Localize = class _Localize extends Module {
    constructor(table) {
      super(table);
      this.locale = "default";
      this.lang = false;
      this.bindings = {};
      this.langList = {};
      this.registerTableOption("locale", false);
      this.registerTableOption("langs", {});
    }
    initialize() {
      this.langList = Helpers.deepClone(_Localize.langs);
      if (this.table.options.columnDefaults.headerFilterPlaceholder !== false) {
        this.setHeaderFilterPlaceholder(this.table.options.columnDefaults.headerFilterPlaceholder);
      }
      for (let locale2 in this.table.options.langs) {
        this.installLang(locale2, this.table.options.langs[locale2]);
      }
      this.setLocale(this.table.options.locale);
      this.registerTableFunction("setLocale", this.setLocale.bind(this));
      this.registerTableFunction("getLocale", this.getLocale.bind(this));
      this.registerTableFunction("getLang", this.getLang.bind(this));
    }
    //set header placeholder
    setHeaderFilterPlaceholder(placeholder) {
      this.langList.default.headerFilters.default = placeholder;
    }
    //setup a lang description object
    installLang(locale2, lang2) {
      if (this.langList[locale2]) {
        this._setLangProp(this.langList[locale2], lang2);
      } else {
        this.langList[locale2] = lang2;
      }
    }
    _setLangProp(lang2, values) {
      for (let key in values) {
        if (lang2[key] && typeof lang2[key] == "object") {
          this._setLangProp(lang2[key], values[key]);
        } else {
          lang2[key] = values[key];
        }
      }
    }
    //set current locale
    setLocale(desiredLocale) {
      desiredLocale = desiredLocale || "default";
      function traverseLang(trans, path) {
        for (var prop in trans) {
          if (typeof trans[prop] == "object") {
            if (!path[prop]) {
              path[prop] = {};
            }
            traverseLang(trans[prop], path[prop]);
          } else {
            path[prop] = trans[prop];
          }
        }
      }
      if (desiredLocale === true && navigator.language) {
        desiredLocale = navigator.language.toLowerCase();
      }
      if (desiredLocale) {
        if (!this.langList[desiredLocale]) {
          let prefix = desiredLocale.split("-")[0];
          if (this.langList[prefix]) {
            console.warn("Localization Error - Exact matching locale not found, using closest match: ", desiredLocale, prefix);
            desiredLocale = prefix;
          } else {
            console.warn("Localization Error - Matching locale not found, using default: ", desiredLocale);
            desiredLocale = "default";
          }
        }
      }
      this.locale = desiredLocale;
      this.lang = Helpers.deepClone(this.langList.default || {});
      if (desiredLocale != "default") {
        traverseLang(this.langList[desiredLocale], this.lang);
      }
      this.dispatchExternal("localized", this.locale, this.lang);
      this._executeBindings();
    }
    //get current locale
    getLocale(locale2) {
      return this.locale;
    }
    //get lang object for given local or current if none provided
    getLang(locale2) {
      return locale2 ? this.langList[locale2] : this.lang;
    }
    //get text for current locale
    getText(path, value) {
      var fillPath = value ? path + "|" + value : path, pathArray = fillPath.split("|"), text = this._getLangElement(pathArray, this.locale);
      return text || "";
    }
    //traverse langs object and find localized copy
    _getLangElement(path, locale2) {
      var root2 = this.lang;
      path.forEach(function(level) {
        var rootPath;
        if (root2) {
          rootPath = root2[level];
          if (typeof rootPath != "undefined") {
            root2 = rootPath;
          } else {
            root2 = false;
          }
        }
      });
      return root2;
    }
    //set update binding
    bind(path, callback) {
      if (!this.bindings[path]) {
        this.bindings[path] = [];
      }
      this.bindings[path].push(callback);
      callback(this.getText(path), this.lang);
    }
    //iterate through bindings and trigger updates
    _executeBindings() {
      for (let path in this.bindings) {
        this.bindings[path].forEach((binding) => {
          binding(this.getText(path), this.lang);
        });
      }
    }
  };
  __publicField(_Localize, "moduleName", "localize");
  //load defaults
  __publicField(_Localize, "langs", defaultLangs);
  let Localize = _Localize;
  class Comms extends Module {
    constructor(table) {
      super(table);
    }
    initialize() {
      this.registerTableFunction("tableComms", this.receive.bind(this));
    }
    getConnections(selectors) {
      var connections = [], connection;
      connection = this.table.constructor.registry.lookupTable(selectors);
      connection.forEach((con) => {
        if (this.table !== con) {
          connections.push(con);
        }
      });
      return connections;
    }
    send(selectors, module2, action, data) {
      var connections = this.getConnections(selectors);
      connections.forEach((connection) => {
        connection.tableComms(this.table.element, module2, action, data);
      });
      if (!connections.length && selectors) {
        console.warn("Table Connection Error - No tables matching selector found", selectors);
      }
    }
    receive(table, module2, action, data) {
      if (this.table.modExists(module2)) {
        return this.table.modules[module2].commsReceived(table, action, data);
      } else {
        console.warn("Inter-table Comms Error - no such module:", module2);
      }
    }
  }
  __publicField(Comms, "moduleName", "comms");
  var coreModules = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CommsModule: Comms,
    LayoutModule: Layout,
    LocalizeModule: Localize
  });
  const _TableRegistry = class _TableRegistry {
    static findTable(query) {
      var results = _TableRegistry.registry.lookupTable(query, true);
      return Array.isArray(results) && !results.length ? false : results;
    }
  };
  __publicField(_TableRegistry, "registry", {
    tables: [],
    register(table) {
      _TableRegistry.registry.tables.push(table);
    },
    deregister(table) {
      var index2 = _TableRegistry.registry.tables.indexOf(table);
      if (index2 > -1) {
        _TableRegistry.registry.tables.splice(index2, 1);
      }
    },
    lookupTable(query, silent) {
      var results = [], matches2, match;
      if (typeof query === "string") {
        matches2 = document.querySelectorAll(query);
        if (matches2.length) {
          for (var i2 = 0; i2 < matches2.length; i2++) {
            match = _TableRegistry.registry.matchElement(matches2[i2]);
            if (match) {
              results.push(match);
            }
          }
        }
      } else if (typeof HTMLElement !== "undefined" && query instanceof HTMLElement || query instanceof _TableRegistry) {
        match = _TableRegistry.registry.matchElement(query);
        if (match) {
          results.push(match);
        }
      } else if (Array.isArray(query)) {
        query.forEach(function(item) {
          results = results.concat(_TableRegistry.registry.lookupTable(item));
        });
      } else {
        if (!silent) {
          console.warn("Table Connection Error - Invalid Selector", query);
        }
      }
      return results;
    },
    matchElement(element) {
      return _TableRegistry.registry.tables.find(function(table) {
        return element instanceof _TableRegistry ? table === element : table.element === element;
      });
    }
  });
  let TableRegistry = _TableRegistry;
  const _ModuleBinder = class _ModuleBinder extends TableRegistry {
    constructor() {
      super();
    }
    static initializeModuleBinder(defaultModules) {
      if (!_ModuleBinder.modulesRegistered) {
        _ModuleBinder.modulesRegistered = true;
        _ModuleBinder._registerModules(coreModules, true);
        if (defaultModules) {
          _ModuleBinder._registerModules(defaultModules);
        }
      }
    }
    static _extendModule(name, property, values) {
      if (_ModuleBinder.moduleBindings[name]) {
        var source = _ModuleBinder.moduleBindings[name][property];
        if (source) {
          if (typeof values == "object") {
            for (let key in values) {
              source[key] = values[key];
            }
          } else {
            console.warn("Module Error - Invalid value type, it must be an object");
          }
        } else {
          console.warn("Module Error - property does not exist:", property);
        }
      } else {
        console.warn("Module Error - module does not exist:", name);
      }
    }
    static _registerModules(modules, core) {
      var mods = Object.values(modules);
      if (core) {
        mods.forEach((mod) => {
          mod.prototype.moduleCore = true;
        });
      }
      _ModuleBinder._registerModule(mods);
    }
    static _registerModule(modules) {
      if (!Array.isArray(modules)) {
        modules = [modules];
      }
      modules.forEach((mod) => {
        _ModuleBinder._registerModuleBinding(mod);
        _ModuleBinder._registerModuleExtensions(mod);
      });
    }
    static _registerModuleBinding(mod) {
      if (mod.moduleName) {
        _ModuleBinder.moduleBindings[mod.moduleName] = mod;
      } else {
        console.error("Unable to bind module, no moduleName defined", mod.moduleName);
      }
    }
    static _registerModuleExtensions(mod) {
      var extensions2 = mod.moduleExtensions;
      if (mod.moduleExtensions) {
        for (let modKey in extensions2) {
          let ext = extensions2[modKey];
          if (_ModuleBinder.moduleBindings[modKey]) {
            for (let propKey in ext) {
              _ModuleBinder._extendModule(modKey, propKey, ext[propKey]);
            }
          } else {
            if (!_ModuleBinder.moduleExtensions[modKey]) {
              _ModuleBinder.moduleExtensions[modKey] = {};
            }
            for (let propKey in ext) {
              if (!_ModuleBinder.moduleExtensions[modKey][propKey]) {
                _ModuleBinder.moduleExtensions[modKey][propKey] = {};
              }
              Object.assign(_ModuleBinder.moduleExtensions[modKey][propKey], ext[propKey]);
            }
          }
        }
      }
      _ModuleBinder._extendModuleFromQueue(mod);
    }
    static _extendModuleFromQueue(mod) {
      var extensions2 = _ModuleBinder.moduleExtensions[mod.moduleName];
      if (extensions2) {
        for (let propKey in extensions2) {
          _ModuleBinder._extendModule(mod.moduleName, propKey, extensions2[propKey]);
        }
      }
    }
    //ensure that module are bound to instantiated function
    _bindModules() {
      var orderedStartMods = [], orderedEndMods = [], unOrderedMods = [];
      this.modules = {};
      for (var name in _ModuleBinder.moduleBindings) {
        let mod = _ModuleBinder.moduleBindings[name];
        let module2 = new mod(this);
        this.modules[name] = module2;
        if (mod.prototype.moduleCore) {
          this.modulesCore.push(module2);
        } else {
          if (mod.moduleInitOrder) {
            if (mod.moduleInitOrder < 0) {
              orderedStartMods.push(module2);
            } else {
              orderedEndMods.push(module2);
            }
          } else {
            unOrderedMods.push(module2);
          }
        }
      }
      orderedStartMods.sort((a2, b2) => a2.moduleInitOrder > b2.moduleInitOrder ? 1 : -1);
      orderedEndMods.sort((a2, b2) => a2.moduleInitOrder > b2.moduleInitOrder ? 1 : -1);
      this.modulesRegular = orderedStartMods.concat(unOrderedMods.concat(orderedEndMods));
    }
  };
  __publicField(_ModuleBinder, "moduleBindings", {});
  __publicField(_ModuleBinder, "moduleExtensions", {});
  __publicField(_ModuleBinder, "modulesRegistered", false);
  __publicField(_ModuleBinder, "defaultModules", false);
  let ModuleBinder = _ModuleBinder;
  class Alert extends CoreFeature {
    constructor(table) {
      super(table);
      this.element = this._createAlertElement();
      this.msgElement = this._createMsgElement();
      this.type = null;
      this.element.appendChild(this.msgElement);
    }
    _createAlertElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-alert");
      return el;
    }
    _createMsgElement() {
      var el = document.createElement("div");
      el.classList.add("tabulator-alert-msg");
      el.setAttribute("role", "alert");
      return el;
    }
    _typeClass() {
      return "tabulator-alert-state-" + this.type;
    }
    alert(content, type = "msg") {
      if (content) {
        this.clear();
        this.dispatch("alert-show", type);
        this.type = type;
        while (this.msgElement.firstChild) this.msgElement.removeChild(this.msgElement.firstChild);
        this.msgElement.classList.add(this._typeClass());
        if (typeof content === "function") {
          content = content();
        }
        if (content instanceof HTMLElement) {
          this.msgElement.appendChild(content);
        } else {
          this.msgElement.innerHTML = content;
        }
        this.table.element.appendChild(this.element);
      }
    }
    clear() {
      this.dispatch("alert-hide", this.type);
      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
      this.msgElement.classList.remove(this._typeClass());
    }
  }
  const _Tabulator = class _Tabulator extends ModuleBinder {
    static extendModule() {
      _Tabulator.initializeModuleBinder();
      _Tabulator._extendModule(...arguments);
    }
    static registerModule() {
      _Tabulator.initializeModuleBinder();
      _Tabulator._registerModule(...arguments);
    }
    constructor(element, options, modules) {
      super();
      _Tabulator.initializeModuleBinder(modules);
      this.options = {};
      this.columnManager = null;
      this.rowManager = null;
      this.footerManager = null;
      this.alertManager = null;
      this.vdomHoz = null;
      this.externalEvents = null;
      this.eventBus = null;
      this.interactionMonitor = false;
      this.browser = "";
      this.browserSlow = false;
      this.browserMobile = false;
      this.rtl = false;
      this.originalElement = null;
      this.componentFunctionBinder = new ComponentFunctionBinder(this);
      this.dataLoader = false;
      this.modules = {};
      this.modulesCore = [];
      this.modulesRegular = [];
      this.deprecationAdvisor = new DeprecationAdvisor(this);
      this.optionsList = new OptionsList(this, "table constructor");
      this.dependencyRegistry = new DependencyRegistry(this);
      this.initialized = false;
      this.destroyed = false;
      if (this.initializeElement(element)) {
        this.initializeCoreSystems(options);
        setTimeout(() => {
          this._create();
        });
      }
      this.constructor.registry.register(this);
    }
    initializeElement(element) {
      if (typeof HTMLElement !== "undefined" && element instanceof HTMLElement) {
        this.element = element;
        return true;
      } else if (typeof element === "string") {
        this.element = document.querySelector(element);
        if (this.element) {
          return true;
        } else {
          console.error("Tabulator Creation Error - no element found matching selector: ", element);
          return false;
        }
      } else {
        console.error("Tabulator Creation Error - Invalid element provided:", element);
        return false;
      }
    }
    initializeCoreSystems(options) {
      this.columnManager = new ColumnManager(this);
      this.rowManager = new RowManager(this);
      this.footerManager = new FooterManager(this);
      this.dataLoader = new DataLoader(this);
      this.alertManager = new Alert(this);
      this._bindModules();
      this.options = this.optionsList.generate(_Tabulator.defaultOptions, options);
      this._clearObjectPointers();
      this._mapDeprecatedFunctionality();
      this.externalEvents = new ExternalEventBus(this, this.options, this.options.debugEventsExternal);
      this.eventBus = new InternalEventBus(this.options.debugEventsInternal);
      this.interactionMonitor = new InteractionManager(this);
      this.dataLoader.initialize();
      this.footerManager.initialize();
      this.dependencyRegistry.initialize();
    }
    //convert deprecated functionality to new functions
    _mapDeprecatedFunctionality() {
    }
    _clearSelection() {
      this.element.classList.add("tabulator-block-select");
      if (window.getSelection) {
        if (window.getSelection().empty) {
          window.getSelection().empty();
        } else if (window.getSelection().removeAllRanges) {
          window.getSelection().removeAllRanges();
        }
      } else if (document.selection) {
        document.selection.empty();
      }
      this.element.classList.remove("tabulator-block-select");
    }
    //create table
    _create() {
      this.externalEvents.dispatch("tableBuilding");
      this.eventBus.dispatch("table-building");
      this._rtlCheck();
      this._buildElement();
      this._initializeTable();
      this.initialized = true;
      this._loadInitialData().finally(() => {
        this.eventBus.dispatch("table-initialized");
        this.externalEvents.dispatch("tableBuilt");
      });
    }
    _rtlCheck() {
      var style = window.getComputedStyle(this.element);
      switch (this.options.textDirection) {
        case "auto":
          if (style.direction !== "rtl") {
            break;
          }
        case "rtl":
          this.element.classList.add("tabulator-rtl");
          this.rtl = true;
          break;
        case "ltr":
          this.element.classList.add("tabulator-ltr");
        default:
          this.rtl = false;
      }
    }
    //clear pointers to objects in default config object
    _clearObjectPointers() {
      this.options.columns = this.options.columns.slice(0);
      if (Array.isArray(this.options.data) && !this.options.reactiveData) {
        this.options.data = this.options.data.slice(0);
      }
    }
    //build tabulator element
    _buildElement() {
      var element = this.element, options = this.options, newElement;
      if (element.tagName === "TABLE") {
        this.originalElement = this.element;
        newElement = document.createElement("div");
        var attributes = element.attributes;
        for (var i2 in attributes) {
          if (typeof attributes[i2] == "object") {
            newElement.setAttribute(attributes[i2].name, attributes[i2].value);
          }
        }
        element.parentNode.replaceChild(newElement, element);
        this.element = element = newElement;
      }
      element.classList.add("tabulator");
      element.setAttribute("role", "grid");
      while (element.firstChild) element.removeChild(element.firstChild);
      if (options.height) {
        options.height = isNaN(options.height) ? options.height : options.height + "px";
        element.style.height = options.height;
      }
      if (options.minHeight !== false) {
        options.minHeight = isNaN(options.minHeight) ? options.minHeight : options.minHeight + "px";
        element.style.minHeight = options.minHeight;
      }
      if (options.maxHeight !== false) {
        options.maxHeight = isNaN(options.maxHeight) ? options.maxHeight : options.maxHeight + "px";
        element.style.maxHeight = options.maxHeight;
      }
    }
    //initialize core systems and modules
    _initializeTable() {
      var element = this.element, options = this.options;
      this.interactionMonitor.initialize();
      this.columnManager.initialize();
      this.rowManager.initialize();
      this._detectBrowser();
      this.modulesCore.forEach((mod) => {
        mod.initialize();
      });
      element.appendChild(this.columnManager.getElement());
      element.appendChild(this.rowManager.getElement());
      if (options.footerElement) {
        this.footerManager.activate();
      }
      if (options.autoColumns && options.data) {
        this.columnManager.generateColumnsFromRowData(this.options.data);
      }
      this.modulesRegular.forEach((mod) => {
        mod.initialize();
      });
      this.columnManager.setColumns(options.columns);
      this.eventBus.dispatch("table-built");
    }
    _loadInitialData() {
      return this.dataLoader.load(this.options.data).finally(() => {
        this.columnManager.verticalAlignHeaders();
      });
    }
    //deconstructor
    destroy() {
      var element = this.element;
      this.destroyed = true;
      this.constructor.registry.deregister(this);
      this.eventBus.dispatch("table-destroy");
      this.rowManager.destroy();
      while (element.firstChild) element.removeChild(element.firstChild);
      element.classList.remove("tabulator");
      this.externalEvents.dispatch("tableDestroyed");
    }
    _detectBrowser() {
      var ua = navigator.userAgent || navigator.vendor || window.opera;
      if (ua.indexOf("Trident") > -1) {
        this.browser = "ie";
        this.browserSlow = true;
      } else if (ua.indexOf("Edge") > -1) {
        this.browser = "edge";
        this.browserSlow = true;
      } else if (ua.indexOf("Firefox") > -1) {
        this.browser = "firefox";
        this.browserSlow = false;
      } else if (ua.indexOf("Mac OS") > -1) {
        this.browser = "safari";
        this.browserSlow = false;
      } else {
        this.browser = "other";
        this.browserSlow = false;
      }
      this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(ua) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(ua.slice(0, 4));
    }
    initGuard(func, msg) {
      var stack2, line;
      if (this.options.debugInitialization && !this.initialized) {
        if (!func) {
          stack2 = new Error().stack.split("\n");
          line = stack2[0] == "Error" ? stack2[2] : stack2[1];
          if (line[0] == " ") {
            func = line.trim().split(" ")[1].split(".")[1];
          } else {
            func = line.trim().split("@")[0];
          }
        }
        console.warn("Table Not Initialized - Calling the " + func + " function before the table is initialized may result in inconsistent behavior, Please wait for the `tableBuilt` event before calling this function." + (msg ? " " + msg : ""));
      }
      return this.initialized;
    }
    ////////////////// Data Handling //////////////////
    //block table redrawing
    blockRedraw() {
      this.initGuard();
      this.eventBus.dispatch("redraw-blocking");
      this.rowManager.blockRedraw();
      this.columnManager.blockRedraw();
      this.eventBus.dispatch("redraw-blocked");
    }
    //restore table redrawing
    restoreRedraw() {
      this.initGuard();
      this.eventBus.dispatch("redraw-restoring");
      this.rowManager.restoreRedraw();
      this.columnManager.restoreRedraw();
      this.eventBus.dispatch("redraw-restored");
    }
    //load data
    setData(data, params, config) {
      this.initGuard(false, "To set initial data please use the 'data' property in the table constructor.");
      return this.dataLoader.load(data, params, config, false);
    }
    //clear data
    clearData() {
      this.initGuard();
      this.dataLoader.blockActiveLoad();
      this.rowManager.clearData();
    }
    //get table data array
    getData(active) {
      return this.rowManager.getData(active);
    }
    //get table data array count
    getDataCount(active) {
      return this.rowManager.getDataCount(active);
    }
    //replace data, keeping table in position with same sort
    replaceData(data, params, config) {
      this.initGuard();
      return this.dataLoader.load(data, params, config, true, true);
    }
    //update table data
    updateData(data) {
      var responses = 0;
      this.initGuard();
      return new Promise((resolve2, reject) => {
        this.dataLoader.blockActiveLoad();
        if (typeof data === "string") {
          data = JSON.parse(data);
        }
        if (data && data.length > 0) {
          data.forEach((item) => {
            var row = this.rowManager.findRow(item[this.options.index]);
            if (row) {
              responses++;
              row.updateData(item).then(() => {
                responses--;
                if (!responses) {
                  resolve2();
                }
              }).catch((e) => {
                reject("Update Error - Unable to update row", item, e);
              });
            } else {
              reject("Update Error - Unable to find row", item);
            }
          });
        } else {
          console.warn("Update Error - No data provided");
          reject("Update Error - No data provided");
        }
      });
    }
    addData(data, pos, index2) {
      this.initGuard();
      return new Promise((resolve2, reject) => {
        this.dataLoader.blockActiveLoad();
        if (typeof data === "string") {
          data = JSON.parse(data);
        }
        if (data) {
          this.rowManager.addRows(data, pos, index2).then((rows) => {
            var output = [];
            rows.forEach(function(row) {
              output.push(row.getComponent());
            });
            resolve2(output);
          });
        } else {
          console.warn("Update Error - No data provided");
          reject("Update Error - No data provided");
        }
      });
    }
    //update table data
    updateOrAddData(data) {
      var rows = [], responses = 0;
      this.initGuard();
      return new Promise((resolve2, reject) => {
        this.dataLoader.blockActiveLoad();
        if (typeof data === "string") {
          data = JSON.parse(data);
        }
        if (data && data.length > 0) {
          data.forEach((item) => {
            var row = this.rowManager.findRow(item[this.options.index]);
            responses++;
            if (row) {
              row.updateData(item).then(() => {
                responses--;
                rows.push(row.getComponent());
                if (!responses) {
                  resolve2(rows);
                }
              });
            } else {
              this.rowManager.addRows(item).then((newRows) => {
                responses--;
                rows.push(newRows[0].getComponent());
                if (!responses) {
                  resolve2(rows);
                }
              });
            }
          });
        } else {
          console.warn("Update Error - No data provided");
          reject("Update Error - No data provided");
        }
      });
    }
    //get row object
    getRow(index2) {
      var row = this.rowManager.findRow(index2);
      if (row) {
        return row.getComponent();
      } else {
        console.warn("Find Error - No matching row found:", index2);
        return false;
      }
    }
    //get row object
    getRowFromPosition(position) {
      var row = this.rowManager.getRowFromPosition(position);
      if (row) {
        return row.getComponent();
      } else {
        console.warn("Find Error - No matching row found:", position);
        return false;
      }
    }
    //delete row from table
    deleteRow(index2) {
      var foundRows = [];
      this.initGuard();
      if (!Array.isArray(index2)) {
        index2 = [index2];
      }
      for (let item of index2) {
        let row = this.rowManager.findRow(item, true);
        if (row) {
          foundRows.push(row);
        } else {
          console.error("Delete Error - No matching row found:", item);
          return Promise.reject("Delete Error - No matching row found");
        }
      }
      foundRows.sort((a2, b2) => {
        return this.rowManager.rows.indexOf(a2) > this.rowManager.rows.indexOf(b2) ? 1 : -1;
      });
      foundRows.forEach((row) => {
        row.delete();
      });
      this.rowManager.reRenderInPosition();
      return Promise.resolve();
    }
    //add row to table
    addRow(data, pos, index2) {
      this.initGuard();
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      return this.rowManager.addRows(data, pos, index2, true).then((rows) => {
        return rows[0].getComponent();
      });
    }
    //update a row if it exists otherwise create it
    updateOrAddRow(index2, data) {
      var row = this.rowManager.findRow(index2);
      this.initGuard();
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      if (row) {
        return row.updateData(data).then(() => {
          return row.getComponent();
        });
      } else {
        return this.rowManager.addRows(data).then((rows) => {
          return rows[0].getComponent();
        });
      }
    }
    //update row data
    updateRow(index2, data) {
      var row = this.rowManager.findRow(index2);
      this.initGuard();
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      if (row) {
        return row.updateData(data).then(() => {
          return Promise.resolve(row.getComponent());
        });
      } else {
        console.warn("Update Error - No matching row found:", index2);
        return Promise.reject("Update Error - No matching row found");
      }
    }
    //scroll to row in DOM
    scrollToRow(index2, position, ifVisible) {
      var row = this.rowManager.findRow(index2);
      if (row) {
        return this.rowManager.scrollToRow(row, position, ifVisible);
      } else {
        console.warn("Scroll Error - No matching row found:", index2);
        return Promise.reject("Scroll Error - No matching row found");
      }
    }
    moveRow(from, to2, after) {
      var fromRow = this.rowManager.findRow(from);
      this.initGuard();
      if (fromRow) {
        fromRow.moveToRow(to2, after);
      } else {
        console.warn("Move Error - No matching row found:", from);
      }
    }
    getRows(active) {
      return this.rowManager.getComponents(active);
    }
    //get position of row in table
    getRowPosition(index2) {
      var row = this.rowManager.findRow(index2);
      if (row) {
        return row.getPosition();
      } else {
        console.warn("Position Error - No matching row found:", index2);
        return false;
      }
    }
    /////////////// Column Functions  ///////////////
    setColumns(definition) {
      this.initGuard(false, "To set initial columns please use the 'columns' property in the table constructor");
      this.columnManager.setColumns(definition);
    }
    getColumns(structured) {
      return this.columnManager.getComponents(structured);
    }
    getColumn(field) {
      var column = this.columnManager.findColumn(field);
      if (column) {
        return column.getComponent();
      } else {
        console.warn("Find Error - No matching column found:", field);
        return false;
      }
    }
    getColumnDefinitions() {
      return this.columnManager.getDefinitionTree();
    }
    showColumn(field) {
      var column = this.columnManager.findColumn(field);
      this.initGuard();
      if (column) {
        column.show();
      } else {
        console.warn("Column Show Error - No matching column found:", field);
        return false;
      }
    }
    hideColumn(field) {
      var column = this.columnManager.findColumn(field);
      this.initGuard();
      if (column) {
        column.hide();
      } else {
        console.warn("Column Hide Error - No matching column found:", field);
        return false;
      }
    }
    toggleColumn(field) {
      var column = this.columnManager.findColumn(field);
      this.initGuard();
      if (column) {
        if (column.visible) {
          column.hide();
        } else {
          column.show();
        }
      } else {
        console.warn("Column Visibility Toggle Error - No matching column found:", field);
        return false;
      }
    }
    addColumn(definition, before, field) {
      var column = this.columnManager.findColumn(field);
      this.initGuard();
      return this.columnManager.addColumn(definition, before, column).then((column2) => {
        return column2.getComponent();
      });
    }
    deleteColumn(field) {
      var column = this.columnManager.findColumn(field);
      this.initGuard();
      if (column) {
        return column.delete();
      } else {
        console.warn("Column Delete Error - No matching column found:", field);
        return Promise.reject();
      }
    }
    updateColumnDefinition(field, definition) {
      var column = this.columnManager.findColumn(field);
      this.initGuard();
      if (column) {
        return column.updateDefinition(definition);
      } else {
        console.warn("Column Update Error - No matching column found:", field);
        return Promise.reject();
      }
    }
    moveColumn(from, to2, after) {
      var fromColumn = this.columnManager.findColumn(from), toColumn = this.columnManager.findColumn(to2);
      this.initGuard();
      if (fromColumn) {
        if (toColumn) {
          this.columnManager.moveColumn(fromColumn, toColumn, after);
        } else {
          console.warn("Move Error - No matching column found:", toColumn);
        }
      } else {
        console.warn("Move Error - No matching column found:", from);
      }
    }
    //scroll to column in DOM
    scrollToColumn(field, position, ifVisible) {
      return new Promise((resolve2, reject) => {
        var column = this.columnManager.findColumn(field);
        if (column) {
          return this.columnManager.scrollToColumn(column, position, ifVisible);
        } else {
          console.warn("Scroll Error - No matching column found:", field);
          return Promise.reject("Scroll Error - No matching column found");
        }
      });
    }
    //////////// General Public Functions ////////////
    //redraw list without updating data
    redraw(force) {
      this.initGuard();
      this.columnManager.redraw(force);
      this.rowManager.redraw(force);
    }
    setHeight(height) {
      this.options.height = isNaN(height) ? height : height + "px";
      this.element.style.height = this.options.height;
      this.rowManager.initializeRenderer();
      this.rowManager.redraw(true);
    }
    //////////////////// Event Bus ///////////////////
    on(key, callback) {
      this.externalEvents.subscribe(key, callback);
    }
    off(key, callback) {
      this.externalEvents.unsubscribe(key, callback);
    }
    dispatchEvent() {
      var args = Array.from(arguments);
      args.shift();
      this.externalEvents.dispatch(...arguments);
    }
    //////////////////// Alerts ///////////////////
    alert(contents, type) {
      this.initGuard();
      this.alertManager.alert(contents, type);
    }
    clearAlert() {
      this.initGuard();
      this.alertManager.clear();
    }
    ////////////// Extension Management //////////////
    modExists(plugin, required) {
      if (this.modules[plugin]) {
        return true;
      } else {
        if (required) {
          console.error("Tabulator Module Not Installed: " + plugin);
        }
        return false;
      }
    }
    module(key) {
      var mod = this.modules[key];
      if (!mod) {
        console.error("Tabulator module not installed: " + key);
      }
      return mod;
    }
  };
  //default setup options
  __publicField(_Tabulator, "defaultOptions", defaultOptions);
  let Tabulator = _Tabulator;
  var Tabulator$1 = Tabulator;
  const PAGES = {
    GAMES_INSERT: "games_insert",
    GAMES_UPDATE: "games_update",
    LINEUPS: "lineups",
    GOALS: "goals",
    SUBS: "subs",
    CARDS: "cards"
  };
  const PAGES_WITHOUT_NAME = [
    PAGES.GAMES_UPDATE,
    PAGES.LINEUPS,
    PAGES.GOALS,
    PAGES.SUBS,
    PAGES.CARDS
  ];
  const PAGES_INSERT_ONLY = [
    PAGES.GAMES_INSERT,
    PAGES.LINEUPS,
    PAGES.GOALS,
    PAGES.SUBS,
    PAGES.CARDS
  ];
  const PAGES_UPDATE_ONLY = [
    PAGES.GAMES_UPDATE
  ];
  const RELATIONSHIP_PAGES = [
    PAGES.LINEUPS,
    PAGES.GOALS,
    PAGES.SUBS,
    PAGES.CARDS
  ];
  const TOOL_COLUMNS = {
    NAME: "name",
    ID: "id",
    EXTERNAL_ID: "external_id",
    COMPETITION_ID: "competition_id"
  };
  const SERVICE_COLUMNS = {
    IMPORT_STATUS: "import_status",
    IMPORT_INFO: "import_info"
  };
  const SERVICE_COLUMN_FIELDS = [
    SERVICE_COLUMNS.IMPORT_STATUS,
    SERVICE_COLUMNS.IMPORT_INFO
  ];
  const COLUMN_TYPES = {
    DROPDOWN: "dropdown",
    NUMERIC: "numeric",
    TEXTAREA: "textarea",
    HTML: "html"
  };
  const IMPORT_STATUS = {
    NOT_STARTED: "not started",
    PROCESSING: "processing",
    SUCCESS: "success",
    ERROR: "error"
  };
  const STATUS_CLASSES = {
    ERROR: "anwp-bg-red-100 anwp-text-red-700 anwp-border anwp-border-red-700",
    INFO: "anwp-bg-blue-100 anwp-text-blue-700 anwp-border anwp-border-blue-700"
  };
  const BATCH_SIZE = 5;
  const IMPORT_MODES = {
    REPLACE: "replace",
    APPEND: "append"
  };
  const ENTITY_LABELS = {
    [PAGES.GOALS]: "goals",
    [PAGES.CARDS]: "cards",
    [PAGES.SUBS]: "substitutes",
    [PAGES.LINEUPS]: "lineups"
  };
  const _hoisted_1$4 = { class: "anwp-vue-api-import-wrapper" };
  const _hoisted_2$2 = { class: "mb-3" };
  const _hoisted_3$2 = {
    key: 0,
    class: "text-muted mx-2 d-inline-block"
  };
  const _hoisted_4$2 = ["href", "onClick"];
  const _hoisted_5$1 = { class: "anwp-d-flex anwp-items-center anwp-gap-4 anwp-flex-wrap" };
  const _hoisted_6$1 = {
    key: 0,
    class: "anwp-d-flex anwp-items-center anwp-gap-2"
  };
  const _hoisted_7$1 = {
    key: 0,
    class: "anwp-text-xs anwp-px-2 anwp-py-1 anwp-bg-orange-100 anwp-text-orange-700 anwp-rounded",
    style: { "font-size": "11px" }
  };
  const _hoisted_8 = { class: "my-3 px-3 py-3 border anwp-sl-batch-import-filter-wrapper" };
  const _hoisted_9 = { class: "d-flex flex-wrap" };
  const _hoisted_10 = ["disabled"];
  const _hoisted_11 = { class: "anwp-overflow-x-auto" };
  const _hoisted_12 = ["onClick"];
  const _hoisted_13 = {
    key: 0,
    class: "anwp-icon anwp-icon--s24 anwp-icon--octi anwp-fill-current anwp-text-green-700"
  };
  const _hoisted_14 = {
    key: 1,
    class: "anwp-icon anwp-icon--s24 anwp-icon--feather anwp-opacity-70"
  };
  const _hoisted_15 = {
    key: 0,
    class: "my-3"
  };
  const _hoisted_16 = { class: "d-flex align-items-center mb-2" };
  const _hoisted_17 = {
    key: 0,
    class: "mt-3 mb-3 p-3 border border-primary anwp-bg-blue-100 anwp-w-max-700"
  };
  const _hoisted_18 = { class: "mb-2" };
  const _hoisted_19 = {
    key: 0,
    class: "anwp-text-gray-600"
  };
  const _hoisted_20 = {
    class: "anwp-progress",
    style: { "height": "20px", "background-color": "#e9ecef", "border-radius": "4px", "overflow": "hidden" }
  };
  const _hoisted_21 = ["aria-valuenow"];
  const _hoisted_22 = {
    key: 1,
    class: "anwp-mt-4 anwp-mb-3 anwp-p-4 anwp-border anwp-border-orange-400 anwp-bg-orange-100 anwp-rounded",
    style: { "max-width": "600px" }
  };
  const _hoisted_23 = { class: "anwp-mb-3" };
  const _hoisted_24 = { class: "anwp-mb-4 anwp-text-sm" };
  const _hoisted_25 = { class: "anwp-d-flex anwp-gap-3" };
  const _hoisted_26 = {
    key: 2,
    class: "d-flex flex-wrap mt-4"
  };
  const _hoisted_27 = ["disabled"];
  const _hoisted_28 = ["disabled"];
  const _hoisted_29 = ["disabled"];
  const _hoisted_30 = {
    key: 3,
    class: "anwp-mt-2 anwp-text-sm anwp-text-gray-600"
  };
  const _hoisted_31 = {
    key: 4,
    class: "anwp-mt-4 anwp-p-4 anwp-border anwp-border-blue-400 anwp-bg-blue-100 anwp-rounded",
    style: { "max-width": "800px" }
  };
  const _hoisted_32 = { class: "anwp-mb-3 anwp-text-sm" };
  const _hoisted_33 = {
    key: 0,
    class: "anwp-text-orange-700"
  };
  const _hoisted_34 = {
    class: "anwp-w-full anwp-text-sm",
    style: { "border-collapse": "collapse" }
  };
  const _hoisted_35 = { class: "anwp-bg-blue-200" };
  const _hoisted_36 = {
    key: 0,
    class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300"
  };
  const _hoisted_37 = { class: "anwp-p-2 anwp-border anwp-border-blue-300" };
  const _hoisted_38 = { class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300" };
  const _hoisted_39 = { class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300 anwp-text-green-700" };
  const _hoisted_40 = { class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300 anwp-text-red-700" };
  const _hoisted_41 = {
    key: 0,
    class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300 anwp-text-orange-700"
  };
  const _hoisted_42 = { class: "anwp-bg-blue-200 anwp-font-semibold" };
  const _hoisted_43 = { class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300" };
  const _hoisted_44 = { class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300 anwp-text-green-700" };
  const _hoisted_45 = { class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300 anwp-text-red-700" };
  const _hoisted_46 = {
    key: 0,
    class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300 anwp-text-orange-700"
  };
  const _hoisted_47 = {
    key: 0,
    class: "anwp-mt-2 anwp-text-sm anwp-text-red-700"
  };
  const _hoisted_48 = {
    key: 1,
    class: "anwp-mt-2 anwp-text-sm anwp-text-orange-700"
  };
  const _sfc_main$4 = {
    __name: "AppImportTool",
    setup(__props) {
      Tabulator$1.registerModule([
        Edit,
        Clipboard,
        Mutator,
        // Enables mutatorClipboard for paste value resolution in list columns
        Export,
        // Required by ClipboardModule for copy operations (generateExportList)
        SelectRange,
        ResizeColumns,
        Format,
        Interaction,
        Keybindings
      ]);
      if (!window._flImportTool) {
        throw new Error("[Import Tool] Configuration missing: window._flImportTool is not defined. Please ensure the WordPress backend is properly initializing the import tool data.");
      }
      if (!window._flImportTool.rest_root) {
        throw new Error("[Import Tool] Configuration missing: window._flImportTool.rest_root is not defined. REST API base URL is required.");
      }
      if (!window._flImportTool.rest_nonce) {
        throw new Error("[Import Tool] Configuration missing: window._flImportTool.rest_nonce is not defined. REST API authentication nonce is required.");
      }
      if (!window._flImportTool.pages) {
        console.warn("[Import Tool] No pages configured. Import tool may not function correctly.");
      }
      if (typeof Notyf === "undefined") {
        throw new Error("[Import Tool] Notyf library is not loaded. Please ensure the notification library is included in the page.");
      }
      const wp2 = useWordPressApi({
        restRoot: window._flImportTool.rest_root,
        restNonce: window._flImportTool.rest_nonce
      });
      const { showSuccess, handleApiError } = useErrorHandler();
      const activePage = ref("");
      const activeRequest = ref(false);
      const importQty = ref(0);
      const isActiveChangeStructure = ref(false);
      const isInsertMode = ref(true);
      const isPostImportMode = ref(false);
      const isSwitcherDisabled = ref(false);
      const columns = ref([]);
      const appPages = ref(window._flImportTool.pages || []);
      const anwpImportJExcelTool = ref(null);
      const importProgress = ref({ current: 0, total: 0, percentage: 0, matchInfo: "" });
      const isReplaceMode = ref(true);
      const showBatchPreview = ref(false);
      const batchPreviewData = ref([]);
      const showConfirmDialog = ref(false);
      const confirmDialogData = ref({ matchesWithData: 0, totalItems: 0 });
      let tableInstance = null;
      let pasteHandler = null;
      let keydownHandler = null;
      const isRelationshipPage = computed(() => RELATIONSHIP_PAGES.includes(activePage.value));
      const entityLabel = computed(() => ENTITY_LABELS[activePage.value] || activePage.value);
      const hasDuplicates = computed(() => batchPreviewData.value.some((g2) => g2.duplicates > 0));
      const previewTotals = computed(() => {
        return batchPreviewData.value.reduce(
          (acc, group) => ({
            total: acc.total + group.total,
            valid: acc.valid + group.valid,
            invalid: acc.invalid + group.invalid,
            duplicates: acc.duplicates + (group.duplicates || 0)
          }),
          { total: 0, valid: 0, invalid: 0, duplicates: 0 }
        );
      });
      const listColumnMaps = computed(() => {
        var _a2;
        const maps = {};
        for (const col of columns.value) {
          if (col.type === COLUMN_TYPES.DROPDOWN && ((_a2 = col.source) == null ? void 0 : _a2.length)) {
            const isSimple = typeof col.source[0] === "string";
            const values = {};
            const reverse = {};
            if (isSimple) {
              for (const v2 of col.source) {
                values[v2] = v2;
                reverse[v2.toLowerCase()] = v2;
              }
            } else {
              for (const item of col.source) {
                const key = String(item.id);
                values[key] = item.name;
                reverse[item.name.toLowerCase()] = key;
              }
            }
            maps[col.name] = { values, reverse };
          }
        }
        return maps;
      });
      const resolveListValue = (value, colMap) => {
        var _a2;
        if (!value || !colMap) return value;
        if (colMap.values[value] !== void 0) return value;
        return (_a2 = colMap.reverse[value.trim().toLowerCase()]) != null ? _a2 : value;
      };
      const resolveRowListValues = (rowData) => {
        const maps = listColumnMaps.value;
        const resolved = {};
        for (const [field, value] of Object.entries(rowData)) {
          resolved[field] = maps[field] ? resolveListValue(value, maps[field]) : value;
        }
        return resolved;
      };
      const convertColumnToTabulator = (phpCol) => {
        const baseCol = {
          field: phpCol.name,
          title: phpCol.title,
          headerSort: false,
          resizable: "header",
          minWidth: 100,
          visible: phpCol.visible !== false,
          editable: !phpCol.readOnly,
          fl_tool: phpCol.fl_tool,
          source: phpCol.source
        };
        if (phpCol.width) {
          baseCol.width = phpCol.width;
        }
        if (phpCol.type === COLUMN_TYPES.DROPDOWN && phpCol.source) {
          baseCol.editor = "list";
          const isSimpleArray = phpCol.source.length > 0 && typeof phpCol.source[0] === "string";
          baseCol.editorParams = {
            values: Object.fromEntries(
              isSimpleArray ? phpCol.source.map((value) => [value, value]) : phpCol.source.map((item) => [String(item.id), item.name])
            ),
            autocomplete: phpCol.autocomplete || false,
            freetext: true,
            listOnEmpty: true,
            allowEmpty: true
          };
          const fieldName = phpCol.name;
          baseCol.mutatorClipboard = (value) => resolveListValue(value, listColumnMaps.value[fieldName]);
          baseCol.formatter = function(cell) {
            var _a2;
            const value = cell.getValue();
            const values = (_a2 = cell.getColumn().getDefinition().editorParams) == null ? void 0 : _a2.values;
            const element = cell.getElement();
            const isValidId = (values == null ? void 0 : values[value]) !== void 0;
            const isValidName = value && Object.values(values || {}).includes(value);
            const isValid = isValidId || isValidName;
            if (value && !isValid) {
              element.classList.add("anwp-bg-orange-200", "anwp-text-orange-900");
            } else {
              element.classList.remove("anwp-bg-orange-200", "anwp-text-orange-900");
            }
            return (values == null ? void 0 : values[value]) || value;
          };
        } else if (phpCol.type === COLUMN_TYPES.NUMERIC) {
          baseCol.editor = "number";
        } else if (phpCol.type === COLUMN_TYPES.TEXTAREA) {
          baseCol.editor = "textarea";
          baseCol.editorParams = {
            elementAttributes: {
              maxlength: "10000"
              // Default max length for textarea
            },
            verticalNavigation: "editor"
            // Allow up/down arrows within textarea
          };
        } else if (phpCol.type === COLUMN_TYPES.HTML) {
          baseCol.formatter = "html";
          baseCol.editable = false;
          delete baseCol.editor;
        } else {
          baseCol.editor = "input";
          if (phpCol.mask || phpCol.placeholder) {
            baseCol.editorParams = {};
            if (phpCol.mask) {
              baseCol.editorParams.mask = phpCol.mask;
            }
            if (phpCol.placeholder) {
              baseCol.editorParams.elementAttributes = {
                placeholder: phpCol.placeholder
              };
            }
          }
        }
        return baseCol;
      };
      const addRows = (count) => {
        if (!tableInstance) return;
        const newRows = Array.from({ length: count }, () => ({}));
        tableInstance.addData(newRows);
      };
      const clearSuccess = () => {
        const filtered = tableInstance.getData().filter((r2) => r2[SERVICE_COLUMNS.IMPORT_STATUS] !== IMPORT_STATUS.SUCCESS);
        tableInstance.setData(filtered);
        isPostImportMode.value = false;
        const currentRowCount = tableInstance.getRows().length;
        if (currentRowCount < 10) {
          const rowsToAdd = 10 - currentRowCount;
          const newRows = Array.from({ length: rowsToAdd }, () => ({}));
          tableInstance.addData(newRows);
        }
      };
      const clearAll = () => {
        tableInstance.clearData();
        isPostImportMode.value = false;
        const newRows = Array.from({ length: 10 }, () => ({}));
        tableInstance.addData(newRows);
      };
      const applyNewSettings = () => {
        isActiveChangeStructure.value = false;
        initTable();
        const objectToSave = columns.value.map(({ name, visible }) => {
          return {
            name,
            visible
          };
        });
        localStorage.setItem(`fl-import-tool--${activePage.value}`, JSON.stringify(objectToSave));
      };
      const initTable = (tableData = []) => {
        if (anwpImportJExcelTool.value) {
          if (pasteHandler) {
            anwpImportJExcelTool.value.removeEventListener("paste", pasteHandler);
          }
          if (keydownHandler) {
            anwpImportJExcelTool.value.removeEventListener("keydown", keydownHandler);
          }
        }
        if (tableInstance) {
          tableInstance.destroy();
        }
        if (!tableData || tableData.length === 0) {
          tableData = Array.from({ length: 10 }, () => ({}));
        }
        let tableOptions = {
          data: tableData,
          layout: "fitDataTable",
          // Editing - click to edit (not focus, as that breaks navigation)
          editTriggerEvent: "click",
          // Keyboard Navigation - CRITICAL for Tab/Arrow keys to work
          keybindings: true,
          // Enable all default keybindings
          tabEndNewRow: true,
          // Auto-add rows on Tab at end
          // Clipboard (v6.3 compliant)
          clipboard: true,
          clipboardPasteAction: "range",
          clipboardCopyRowRange: "range",
          clipboardPasteParser: "range",
          clipboardCopyConfig: {
            rowHeaders: false,
            columnHeaders: false
          },
          clipboardPasteConfig: {
            rowHeaders: false
            // Don't try to paste into row header
          },
          // Range Selection (v6.3 compliant)
          selectableRange: true,
          selectableRangeClearCells: true,
          selectableRangeClearCellsValue: "",
          // Interaction
          movableRows: false,
          headerSort: false,
          rowContextMenu: [],
          columns: [],
          // Row header with row numbers
          rowHeader: {
            frozen: true,
            hozAlign: "center",
            formatter: "rownum",
            headerSort: false,
            cssClass: "row-number-column"
          }
        };
        tableOptions.columns = columns.value.filter((c2) => c2.visible).map(convertColumnToTabulator);
        tableOptions.columns.push({
          field: SERVICE_COLUMNS.IMPORT_STATUS,
          title: "- import status -",
          editable: false,
          headerSort: false,
          hozAlign: "center",
          formatter: function(cell) {
            const value = cell.getValue();
            const element = cell.getElement();
            element.classList.remove("anwp-bg-green-200", "anwp-bg-red-200");
            if (value === IMPORT_STATUS.SUCCESS) {
              element.classList.add("anwp-bg-green-200");
            } else if (value === IMPORT_STATUS.ERROR) {
              element.classList.add("anwp-bg-red-200");
            }
            return value || IMPORT_STATUS.NOT_STARTED;
          }
        });
        tableOptions.columns.push({
          field: SERVICE_COLUMNS.IMPORT_INFO,
          title: "- import info -",
          formatter: "html",
          editable: false,
          headerSort: false,
          minWidth: 250,
          // Larger width to accommodate content like "Game Title | view | edit"
          widthGrow: 2
          // Allow this column to grow more than others
        });
        tableInstance = new Tabulator$1(anwpImportJExcelTool.value, tableOptions);
        tableInstance.on("cellClick", function(e, cell) {
          tableInstance._lastCell = cell;
        });
        tableInstance.on("cellEdited", function(cell) {
          tableInstance._lastCell = cell;
        });
        tableInstance.on("rangeAdded", function(range2) {
          if (!range2 || typeof range2.getCells !== "function") {
            console.warn("Range object does not have getCells method:", range2);
            return;
          }
          const cells = range2.getCells();
          if (!cells || !Array.isArray(cells) || cells.length === 0) {
            return;
          }
          const allServiceColumns = cells.every((cell) => {
            if (!cell || typeof cell.getColumn !== "function") {
              return false;
            }
            const column = cell.getColumn();
            if (!column || typeof column.getField !== "function") {
              return false;
            }
            const field = column.getField();
            return SERVICE_COLUMN_FIELDS.includes(field);
          });
          if (allServiceColumns && typeof range2.remove === "function") {
            range2.remove();
            console.warn(`Cannot select service columns (${SERVICE_COLUMN_FIELDS.join(", ")})`);
          }
        });
        pasteHandler = function(e) {
          const target = e.target;
          if (target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
            const cellElement = target.closest(".tabulator-cell");
            if (cellElement) {
              e.preventDefault();
              e.stopPropagation();
              const clipboardData2 = e.clipboardData || window.clipboardData;
              if (!clipboardData2) return;
              const pastedText2 = clipboardData2.getData("text");
              if (!pastedText2) return;
              const rows = tableInstance.getRows();
              let targetCell = null;
              for (let row of rows) {
                const cells = row.getCells();
                for (let cell of cells) {
                  if (cell.getElement() === cellElement) {
                    targetCell = cell;
                    break;
                  }
                }
                if (targetCell) break;
              }
              if (!targetCell) return;
              if (typeof targetCell.cancelEdit !== "function" || typeof targetCell.getRow !== "function" || typeof targetCell.getColumn !== "function") {
                console.error("Invalid cell object:", targetCell);
                return;
              }
              targetCell.cancelEdit();
              setTimeout(() => {
                const startRow = targetCell.getRow();
                if (!startRow) {
                  console.error("Could not get row from cell");
                  return;
                }
                const startRowIndex2 = tableInstance.getRows().indexOf(startRow);
                const startCol = targetCell.getColumn();
                if (!startCol || typeof startCol.getField !== "function") {
                  console.error("Could not get column from cell");
                  return;
                }
                const startColField = startCol.getField();
                if (SERVICE_COLUMN_FIELDS.includes(startColField)) {
                  console.warn(`Cannot paste into service columns (${SERVICE_COLUMN_FIELDS.join(", ")})`);
                  return;
                }
                const visibleCols = columns.value.filter(
                  (c2) => c2.visible && !SERVICE_COLUMN_FIELDS.includes(c2.name)
                );
                const startColIndex = visibleCols.findIndex((c2) => c2.name === startColField);
                const rows2 = pastedText2.split(/\r\n|\n|\r/);
                const rowDataArray = rows2.map((row) => {
                  const cells = row.split("	");
                  const rowData = {};
                  cells.forEach((cellValue, cellIndex) => {
                    const targetColIndex = startColIndex + cellIndex;
                    if (targetColIndex < visibleCols.length) {
                      rowData[visibleCols[targetColIndex].name] = cellValue;
                    }
                  });
                  return rowData;
                });
                const totalRowsNeeded2 = startRowIndex2 + rowDataArray.length;
                const currentRowCount2 = tableInstance.getRows().length;
                const rowsToAdd2 = totalRowsNeeded2 - currentRowCount2;
                const applyPaste = () => {
                  const tableRows = tableInstance.getRows();
                  rowDataArray.forEach((rowData, rowOffset) => {
                    const targetRowIndex = startRowIndex2 + rowOffset;
                    if (targetRowIndex < tableRows.length) {
                      const targetRow = tableRows[targetRowIndex];
                      const resolvedData = resolveRowListValues(rowData);
                      Object.keys(resolvedData).forEach((field) => {
                        targetRow.update({ [field]: resolvedData[field] });
                      });
                    }
                  });
                };
                if (rowsToAdd2 > 0) {
                  const newRows = Array.from({ length: rowsToAdd2 }, () => ({}));
                  tableInstance.addData(newRows).then(() => {
                    applyPaste();
                  });
                } else {
                  applyPaste();
                }
              }, 50);
              return;
            }
          }
          const clipboardData = e.clipboardData || window.clipboardData;
          if (!clipboardData) return;
          const pastedText = clipboardData.getData("text");
          if (!pastedText) return;
          const pastedRows = pastedText.split(/\r\n|\n|\r/).filter((row) => row.trim() !== "");
          const pastedRowCount = pastedRows.length;
          if (pastedRowCount === 0) return;
          let startRowIndex = 0;
          try {
            if (tableInstance.modules.selectRange && tableInstance.modules.selectRange.activeRange) {
              startRowIndex = tableInstance.modules.selectRange.activeRange.start.row;
            } else {
              const focusedCell = anwpImportJExcelTool.value.querySelector(".tabulator-cell.tabulator-range-active, .tabulator-cell.tabulator-selected");
              if (focusedCell) {
                const rows = tableInstance.getRows();
                for (let i2 = 0; i2 < rows.length; i2++) {
                  const cells = rows[i2].getCells();
                  if (cells.some((cell) => cell.getElement() === focusedCell)) {
                    startRowIndex = i2;
                    break;
                  }
                }
              }
            }
          } catch (err) {
            console.warn("Could not determine paste start position:", err);
            startRowIndex = 0;
          }
          const totalRowsNeeded = startRowIndex + pastedRowCount;
          const currentRowCount = tableInstance.getRows().length;
          const rowsToAdd = totalRowsNeeded - currentRowCount;
          if (rowsToAdd > 0) {
            console.log(`Paste will exceed table size. Adding ${rowsToAdd} rows...`);
            e.preventDefault();
            e.stopPropagation();
            const savedText = pastedText;
            const savedStartRow = startRowIndex;
            const newRows = Array.from({ length: rowsToAdd }, () => ({}));
            tableInstance.addData(newRows).then(() => {
              console.log(`Auto-added ${rowsToAdd} rows`);
              const rows = savedText.split(/\r\n|\n|\r/);
              const rowDataArray = rows.map((rowText) => {
                const cells = rowText.split("	");
                const rowData = {};
                const visibleColumns = tableInstance.getColumns().filter((col) => {
                  const def2 = col.getDefinition();
                  return def2.visible !== false && !SERVICE_COLUMN_FIELDS.includes(def2.field);
                });
                cells.forEach((cellValue, index2) => {
                  if (index2 < visibleColumns.length) {
                    const field = visibleColumns[index2].getDefinition().field;
                    rowData[field] = cellValue;
                  }
                });
                return rowData;
              });
              const tableRows = tableInstance.getRows();
              rowDataArray.forEach((rowData, index2) => {
                const targetRowIndex = savedStartRow + index2;
                if (targetRowIndex < tableRows.length) {
                  tableRows[targetRowIndex].update(resolveRowListValues(rowData));
                }
              });
              console.log(`Pasted ${rowDataArray.length} rows starting at row ${savedStartRow}`);
            }).catch((err) => {
              console.error("Error adding rows:", err);
            });
          }
        };
        anwpImportJExcelTool.value.addEventListener("paste", pasteHandler);
        keydownHandler = function(e) {
          var _a2;
          if (e.ctrlKey || e.metaKey || e.altKey) {
            return;
          }
          if (e.key === "Tab" || e.key === "Escape") {
            return;
          }
          if (["INPUT", "TEXTAREA", "SELECT"].includes((_a2 = document.activeElement) == null ? void 0 : _a2.tagName)) {
            return;
          }
          let currentCell = null;
          if (tableInstance._lastCell) {
            currentCell = tableInstance._lastCell;
          }
          if (!currentCell) {
            const activeElement = anwpImportJExcelTool.value.querySelector(".tabulator-range-active");
            if (activeElement) {
              const rows = tableInstance.getRows();
              for (let row of rows) {
                const cells = row.getCells();
                for (let cell of cells) {
                  if (cell.getElement() === activeElement) {
                    currentCell = cell;
                    break;
                  }
                }
                if (currentCell) break;
              }
            }
          }
          if (!currentCell) return;
          if (typeof currentCell.getElement !== "function" || typeof currentCell.getColumn !== "function" || typeof currentCell.edit !== "function") {
            return;
          }
          const cellElement = currentCell.getElement();
          if (!cellElement) return;
          const isEditing = cellElement.classList.contains("tabulator-editing");
          const column = currentCell.getColumn();
          if (!column || typeof column.getDefinition !== "function") {
            return;
          }
          const columnDef = column.getDefinition();
          const isEditable = columnDef && columnDef.editable !== false;
          if (!isEditable || isEditing) return;
          if (e.key === "Enter") {
            e.preventDefault();
            currentCell.edit();
            return;
          }
          if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
            return;
          }
          if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
            e.preventDefault();
            e.stopPropagation();
            currentCell.edit();
            setTimeout(() => {
              const editor = cellElement.querySelector("input, textarea");
              if (editor) {
                editor.value = e.key;
                if (editor.setSelectionRange) {
                  editor.setSelectionRange(1, 1);
                }
              }
            }, 20);
          }
        };
        anwpImportJExcelTool.value.addEventListener("keydown", keydownHandler);
      };
      const changeUrl = (page) => {
        if (page.slug === activePage.value) {
          return;
        }
        const searchURL = new URL(window.location);
        searchURL.searchParams.set("tool", page.slug);
        window.history.pushState({}, "", searchURL);
        activePage.value = page.slug;
        isActiveChangeStructure.value = false;
        isPostImportMode.value = false;
        if (PAGES_UPDATE_ONLY.includes(page.slug)) {
          isInsertMode.value = false;
        } else {
          isInsertMode.value = true;
        }
        isSwitcherDisabled.value = PAGES_INSERT_ONLY.includes(page.slug) || PAGES_UPDATE_ONLY.includes(page.slug);
        initializeColumns();
      };
      const hasRowData = (rowData) => {
        return Object.keys(rowData).some((key) => {
          return rowData[key] !== void 0 && rowData[key] !== "" && rowData[key] !== null && key !== SERVICE_COLUMNS.IMPORT_STATUS && key !== SERVICE_COLUMNS.IMPORT_INFO;
        });
      };
      const validateRowData = (rowData) => {
        let errorMessage = "";
        if (isInsertMode.value && activePage.value === PAGES.GAMES_INSERT) {
          const titleCol = columns.value.find((c2) => c2.fl_tool === TOOL_COLUMNS.COMPETITION_ID);
          if (!titleCol || !rowData[titleCol.name]) {
            errorMessage = `${(titleCol == null ? void 0 : titleCol.title) || "Competition ID"} is required`;
          }
        } else if (isInsertMode.value && !PAGES_WITHOUT_NAME.includes(activePage.value)) {
          const titleCol = columns.value.find((c2) => c2.fl_tool === TOOL_COLUMNS.NAME);
          if (!titleCol || !rowData[titleCol.name] || String(rowData[titleCol.name]).trim() === "") {
            errorMessage = `${(titleCol == null ? void 0 : titleCol.title) || "Name"} is required`;
          }
        } else if (!isInsertMode.value) {
          const idCol = columns.value.find((c2) => c2.fl_tool === TOOL_COLUMNS.ID);
          const extCol = columns.value.find((c2) => c2.fl_tool === TOOL_COLUMNS.EXTERNAL_ID);
          if (!(rowData == null ? void 0 : rowData[idCol == null ? void 0 : idCol.name]) && !(rowData == null ? void 0 : rowData[extCol == null ? void 0 : extCol.name])) {
            const idTitle = (idCol == null ? void 0 : idCol.title) || "ID";
            const extTitle = (extCol == null ? void 0 : extCol.title) || "External ID";
            errorMessage = `${idTitle} or ${extTitle} is required for update`;
          }
        }
        return errorMessage;
      };
      const updateRowStatus = (row, status, info = "") => {
        const updateData = { [SERVICE_COLUMNS.IMPORT_STATUS]: status };
        if (info) {
          updateData[SERVICE_COLUMNS.IMPORT_INFO] = info;
        }
        row.update(updateData);
        const statusCell = row.getCell(SERVICE_COLUMNS.IMPORT_STATUS);
        const element = statusCell.getElement();
        element.classList.remove("anwp-bg-green-200", "anwp-bg-red-200");
        if (status === IMPORT_STATUS.ERROR) {
          element.classList.add("anwp-bg-red-200");
        } else if (status === IMPORT_STATUS.SUCCESS) {
          element.classList.add("anwp-bg-green-200");
        }
      };
      const sanitizeUrl = (url) => {
        if (!url) return "";
        try {
          const parsed = new URL(url, window.location.origin);
          if (parsed.protocol === "http:" || parsed.protocol === "https:") {
            return parsed.href;
          }
        } catch (e) {
          return "";
        }
        return "";
      };
      const buildImportInfo = (responseData) => {
        let importInfo = responseData.post_title || "";
        if (responseData.post_url) {
          const safeUrl = sanitizeUrl(responseData.post_url);
          if (safeUrl) {
            importInfo += ` | <a href="${safeUrl}" target="_blank">view</a>`;
          }
        }
        if (responseData.post_edit) {
          const safeUrl = sanitizeUrl(responseData.post_edit);
          if (safeUrl) {
            importInfo += ` | <a href="${safeUrl}" target="_blank">edit</a>`;
          }
        }
        return importInfo;
      };
      const groupRowsByMatch = (rows) => {
        const groups = /* @__PURE__ */ new Map();
        for (const row of rows) {
          const data = row.getData();
          const matchId = data.match_id;
          const matchExtId = data.match_external_id;
          let matchKey;
          if (matchId) {
            matchKey = `id:${matchId}`;
          } else if (matchExtId) {
            matchKey = `ext:${matchExtId}`;
          } else {
            matchKey = `invalid:${Date.now()}-${Math.random()}`;
          }
          if (!groups.has(matchKey)) {
            groups.set(matchKey, {
              matchKey,
              matchId: matchId || null,
              matchExtId: matchExtId || null,
              rows: []
            });
          }
          groups.get(matchKey).rows.push(row);
        }
        return groups;
      };
      const validateBatchRow = (rowData) => {
        if (!rowData.match_id && !rowData.match_external_id) {
          return { isValid: false, error: "Match ID or External ID required" };
        }
        switch (activePage.value) {
          case PAGES.GOALS:
            if (!rowData.player_id && !rowData.player_external_id && !rowData.player_temp) {
              return { isValid: false, error: "Player ID required" };
            }
            if (!rowData.club_id && !rowData.club_external_id) {
              return { isValid: false, error: "Club ID required" };
            }
            break;
          case PAGES.CARDS:
            if (!rowData.player_id && !rowData.player_external_id && !rowData.player_temp) {
              return { isValid: false, error: "Player ID required" };
            }
            if (!rowData.club_id && !rowData.club_external_id) {
              return { isValid: false, error: "Club ID required" };
            }
            if (!["y", "r", "yr"].includes(rowData.cart_type)) {
              return { isValid: false, error: "Invalid card type (use: y, r, yr)" };
            }
            break;
          case PAGES.SUBS:
            if (!rowData.player_in && !rowData.player_in_external_id) {
              return { isValid: false, error: "Player In ID required" };
            }
            if (!rowData.player_out && !rowData.player_out_external_id) {
              return { isValid: false, error: "Player Out ID required" };
            }
            if (!rowData.club_id && !rowData.club_external_id) {
              return { isValid: false, error: "Club ID required" };
            }
            break;
          case PAGES.LINEUPS:
            if (!rowData.player_id && !rowData.player_external_id && !rowData.player_temp) {
              return { isValid: false, error: "Player ID required" };
            }
            if (!rowData.club_id && !rowData.club_external_id) {
              return { isValid: false, error: "Club ID required" };
            }
            break;
        }
        return { isValid: true, error: null };
      };
      const detectDuplicates = (items) => {
        if (![PAGES.GOALS, PAGES.CARDS].includes(activePage.value)) {
          return 0;
        }
        const seen = /* @__PURE__ */ new Set();
        let duplicates = 0;
        for (const item of items) {
          const playerId = item.player_id || item.player_external_id || item.player_temp || "";
          const minute = item.minute || "";
          const key = `${playerId}-${minute}`;
          if (seen.has(key)) {
            duplicates++;
          } else {
            seen.add(key);
          }
        }
        return duplicates;
      };
      const prepareItemData = (rowData) => {
        const cleaned = {};
        for (const [key, value] of Object.entries(rowData)) {
          if (!SERVICE_COLUMN_FIELDS.includes(key) && value !== void 0 && value !== "") {
            cleaned[key] = value;
          }
        }
        return cleaned;
      };
      const previewBatchImport = () => __async(null, null, function* () {
        if (activeRequest.value || isPostImportMode.value) return;
        const allRows = tableInstance.getRows();
        const rowsWithData = allRows.filter((row) => hasRowData(row.getData()));
        if (rowsWithData.length === 0) {
          handleApiError({ message: "No data to import" });
          return;
        }
        const matchGroups = groupRowsByMatch(rowsWithData);
        const previewData = [];
        for (const [matchKey, group] of matchGroups) {
          const validItems = [];
          const invalidItems = [];
          for (const row of group.rows) {
            const rowData = row.getData();
            const validation = validateBatchRow(rowData);
            if (validation.isValid) {
              validItems.push(rowData);
            } else {
              invalidItems.push({ row, error: validation.error });
            }
          }
          const duplicateCount = detectDuplicates(validItems);
          previewData.push({
            matchKey: group.matchKey,
            matchId: group.matchId,
            matchExtId: group.matchExtId,
            matchTitle: group.matchId ? `Match #${group.matchId}` : `External: ${group.matchExtId}`,
            rows: group.rows,
            validItems,
            invalidItems,
            total: group.rows.length,
            valid: validItems.length,
            invalid: invalidItems.length,
            duplicates: duplicateCount
          });
        }
        batchPreviewData.value = previewData;
        showBatchPreview.value = true;
        showConfirmDialog.value = false;
      });
      const startBatchImport = () => {
        if (activeRequest.value || isPostImportMode.value) return;
        if (!showBatchPreview.value || batchPreviewData.value.length === 0) {
          handleApiError({ message: "Please preview import first" });
          return;
        }
        const validItemsCount = previewTotals.value.valid;
        if (validItemsCount === 0) {
          handleApiError({ message: "No valid items to import" });
          return;
        }
        if (isReplaceMode.value) {
          confirmDialogData.value = {
            matchCount: batchPreviewData.value.length,
            totalItems: validItemsCount
          };
          showConfirmDialog.value = true;
        } else {
          executeBatchImport();
        }
      };
      const confirmAndSave = () => {
        showConfirmDialog.value = false;
        executeBatchImport();
      };
      const cancelConfirm = () => {
        showConfirmDialog.value = false;
      };
      const executeBatchImport = () => __async(null, null, function* () {
        if (activeRequest.value) return;
        activeRequest.value = true;
        importQty.value = 0;
        const totalMatches = batchPreviewData.value.length;
        let totalSuccess = 0;
        let totalErrors = 0;
        importProgress.value = {
          current: 0,
          total: totalMatches,
          percentage: 0,
          matchInfo: ""
        };
        for (let i2 = 0; i2 < batchPreviewData.value.length; i2++) {
          const group = batchPreviewData.value[i2];
          importProgress.value.current = i2 + 1;
          importProgress.value.matchInfo = group.matchTitle;
          importProgress.value.percentage = Math.round((i2 + 1) / totalMatches * 100);
          const validItems = [];
          const rowsMap = /* @__PURE__ */ new Map();
          for (const row of group.rows) {
            const rowData = row.getData();
            const validation = validateBatchRow(rowData);
            if (validation.isValid) {
              validItems.push(prepareItemData(rowData));
              rowsMap.set(validItems.length - 1, row);
            } else {
              updateRowStatus(row, IMPORT_STATUS.ERROR, validation.error);
              totalErrors++;
            }
          }
          if (validItems.length === 0) continue;
          for (const row of rowsMap.values()) {
            row.update({ [SERVICE_COLUMNS.IMPORT_STATUS]: IMPORT_STATUS.PROCESSING });
          }
          const { success, data, error } = yield wp2.post(
            `anwpfl/import-tool/${activePage.value}-batch`,
            {
              match_id: group.matchId,
              match_external_id: group.matchExtId,
              mode: isReplaceMode.value ? IMPORT_MODES.REPLACE : IMPORT_MODES.APPEND,
              items: validItems
            },
            `Import ${entityLabel.value} batch`
          );
          if (success && (data == null ? void 0 : data.results)) {
            for (let j2 = 0; j2 < data.results.length; j2++) {
              const result = data.results[j2];
              const row = rowsMap.get(j2);
              if (!row) continue;
              if (result.success) {
                const importInfo = buildImportInfo(data);
                updateRowStatus(row, IMPORT_STATUS.SUCCESS, importInfo);
                totalSuccess++;
              } else {
                updateRowStatus(row, IMPORT_STATUS.ERROR, result.error || "Import failed");
                totalErrors++;
              }
            }
          } else {
            for (const row of rowsMap.values()) {
              updateRowStatus(row, IMPORT_STATUS.ERROR, error || "Batch import failed");
              totalErrors++;
            }
          }
        }
        importProgress.value = { current: 0, total: 0, percentage: 0, matchInfo: "" };
        importQty.value = totalSuccess;
        activeRequest.value = false;
        isPostImportMode.value = true;
        showBatchPreview.value = false;
        batchPreviewData.value = [];
        showSuccess(`Imported: ${totalSuccess} items, Errors: ${totalErrors}`);
        const infoColumn = tableInstance.getColumn(SERVICE_COLUMNS.IMPORT_INFO);
        if (infoColumn) {
          tableInstance.redraw(true);
        }
      });
      const processRow = (row) => __async(null, null, function* () {
        const rowData = resolveRowListValues(row.getData());
        const validationError = validateRowData(rowData);
        if (validationError) {
          updateRowStatus(row, "error", validationError);
          return { success: false };
        }
        row.update({ [SERVICE_COLUMNS.IMPORT_STATUS]: IMPORT_STATUS.PROCESSING });
        const { success, data, error } = yield wp2.post(
          "anwpfl/import-tool/" + activePage.value,
          {
            row_data: rowData,
            mode: isInsertMode.value ? "insert" : "update"
          },
          "Import Row"
        );
        if (success && (data == null ? void 0 : data.result)) {
          const importInfo = buildImportInfo(data);
          updateRowStatus(row, data.result, importInfo);
          return { success: data.result === "success" };
        }
        const errorMessage = error || "Import failed";
        updateRowStatus(row, "error", errorMessage);
        return { success: false };
      });
      const saveData = () => __async(null, null, function* () {
        if (activeRequest.value || isPostImportMode.value) {
          return;
        }
        activeRequest.value = true;
        importQty.value = 0;
        const allRows = tableInstance.getRows();
        const rowsToProcess = allRows.filter((row) => hasRowData(row.getData()));
        importProgress.value = {
          current: 0,
          total: rowsToProcess.length,
          percentage: 0
        };
        for (let i2 = 0; i2 < rowsToProcess.length; i2 += BATCH_SIZE) {
          const batch2 = rowsToProcess.slice(i2, i2 + BATCH_SIZE);
          const results = yield Promise.all(batch2.map((row) => processRow(row)));
          importQty.value += results.filter((r2) => r2.success).length;
          importProgress.value.current = Math.min(i2 + BATCH_SIZE, rowsToProcess.length);
          importProgress.value.percentage = Math.round(
            importProgress.value.current / importProgress.value.total * 100
          );
        }
        importProgress.value = { current: 0, total: 0, percentage: 0 };
        activeRequest.value = false;
        isPostImportMode.value = true;
        showSuccess(`Imported ${importQty.value} rows`);
        const infoColumn = tableInstance.getColumn(SERVICE_COLUMNS.IMPORT_INFO);
        if (infoColumn) {
          tableInstance.redraw(true);
        }
      });
      const initializeColumns = () => {
        var _a2;
        columns.value = ((_a2 = appPages.value.find((page) => page.slug === activePage.value)) == null ? void 0 : _a2.columns) || [];
        const savedColumns = safeJsonParse(localStorage.getItem(`fl-import-tool--${activePage.value}`), []);
        if (savedColumns && savedColumns.length) {
          columns.value = columns.value.map((column, cIndex) => {
            var _a3;
            const savedColumn = savedColumns.find((c2) => c2.name === column.name);
            const savedIndex = savedColumns.findIndex((c2) => c2.name === column.name);
            column.visible = (_a3 = savedColumn == null ? void 0 : savedColumn.visible) != null ? _a3 : column.visible;
            column.sort = savedIndex > -1 ? savedIndex : 100 + cIndex;
            return column;
          }).sort((a2, b2) => a2.sort - b2.sort).map((_b2) => {
            var _c = _b2, {
              sort
            } = _c, oProps = __objRest(_c, [
              "sort"
            ]);
            return oProps;
          });
        }
        initTable();
      };
      const getInsertModeMessage = () => {
        if (activePage.value === PAGES.GAMES_INSERT) {
          const requiredCol = columns.value.find((c2) => c2.fl_tool === TOOL_COLUMNS.COMPETITION_ID);
          if (!(requiredCol == null ? void 0 : requiredCol.visible)) {
            return {
              isError: true,
              msg: 'Required Column "Competition ID" is missing!',
              blockClass: STATUS_CLASSES.ERROR
            };
          }
        } else if (!PAGES_WITHOUT_NAME.includes(activePage.value)) {
          const requiredCol = columns.value.find((c2) => c2.fl_tool === TOOL_COLUMNS.NAME);
          if (!(requiredCol == null ? void 0 : requiredCol.visible)) {
            return {
              isError: true,
              msg: "Required Column with instance name is missing!",
              blockClass: STATUS_CLASSES.ERROR
            };
          }
        }
        if (!RELATIONSHIP_PAGES.includes(activePage.value)) {
          const idCol = columns.value.find((c2) => c2.fl_tool === TOOL_COLUMNS.ID);
          if (idCol == null ? void 0 : idCol.visible) {
            return {
              msg: `"${idCol.title}" column will be ignored. Maybe you want to import "External ID" field.`,
              blockClass: STATUS_CLASSES.INFO
            };
          }
        }
        return null;
      };
      const getUpdateModeMessage = () => {
        const idCol = columns.value.find((c2) => c2.fl_tool === TOOL_COLUMNS.ID);
        const extCol = columns.value.find((c2) => c2.fl_tool === TOOL_COLUMNS.EXTERNAL_ID);
        const hasIdVisible = idCol == null ? void 0 : idCol.visible;
        const hasExtIdVisible = extCol == null ? void 0 : extCol.visible;
        if (!hasIdVisible && !hasExtIdVisible) {
          return {
            isError: true,
            msg: "Required instance ID or External ID column is missing! Update Import is impossible.",
            blockClass: STATUS_CLASSES.ERROR
          };
        }
        if (hasIdVisible) {
          return {
            msg: `The plugin will match and update the data by "${idCol.title}"`,
            blockClass: STATUS_CLASSES.INFO
          };
        }
        if (hasExtIdVisible) {
          return {
            msg: `The plugin will match and update the data by "${extCol.title}"`,
            blockClass: STATUS_CLASSES.INFO
          };
        }
        return null;
      };
      const statusMessage = computed(() => {
        if (columns.value.length === 0) {
          return null;
        }
        return isInsertMode.value ? getInsertModeMessage() : getUpdateModeMessage();
      });
      onMounted(() => {
        var _a2;
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has("tool")) {
          activePage.value = urlParams.get("tool");
        } else {
          activePage.value = ((_a2 = appPages.value[0]) == null ? void 0 : _a2.slug) || "";
        }
        if (PAGES_UPDATE_ONLY.includes(activePage.value)) {
          isInsertMode.value = false;
        } else {
          isInsertMode.value = true;
        }
        isSwitcherDisabled.value = PAGES_INSERT_ONLY.includes(activePage.value) || PAGES_UPDATE_ONLY.includes(activePage.value);
        initializeColumns();
      });
      onBeforeUnmount(() => {
        if (anwpImportJExcelTool.value) {
          if (pasteHandler) {
            anwpImportJExcelTool.value.removeEventListener("paste", pasteHandler);
          }
          if (keydownHandler) {
            anwpImportJExcelTool.value.removeEventListener("keydown", keydownHandler);
          }
        }
        if (tableInstance) {
          tableInstance.destroy();
        }
      });
      return (_ctx, _cache) => {
        const _component_toggle = resolveComponent("toggle");
        const _component_draggable = resolveComponent("draggable");
        const _directive_tooltip = resolveDirective("tooltip");
        return openBlock(), createElementBlock("div", _hoisted_1$4, [
          createBaseVNode("div", _hoisted_2$2, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(appPages.value, (page) => {
              return openBlock(), createElementBlock(Fragment, {
                key: page.slug
              }, [
                "players" !== page.slug ? (openBlock(), createElementBlock("small", _hoisted_3$2, "|")) : createCommentVNode("", true),
                createBaseVNode("a", {
                  class: normalizeClass(["text-decoration-none anwp-text-capitalize anwp-text-sm", page.slug === activePage.value ? "text-muted" : ""]),
                  href: `admin.php?page=anwp-settings-tools&tool=${page.slug}`,
                  onClick: withModifiers(($event) => changeUrl(page), ["prevent"])
                }, toDisplayString(page.title), 11, _hoisted_4$2)
              ], 64);
            }), 128))
          ]),
          createBaseVNode("div", _hoisted_5$1, [
            withDirectives(createVNode(_component_toggle, {
              modelValue: isInsertMode.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isInsertMode.value = $event),
              "on-label": "Insert",
              "off-label": "Update",
              disabled: isSwitcherDisabled.value,
              class: "anwp-toggle-w-80 sl-toggle-green-blue"
            }, null, 8, ["modelValue", "disabled"]), [
              [_directive_tooltip, `insert or update`]
            ]),
            isRelationshipPage.value ? (openBlock(), createElementBlock("div", _hoisted_6$1, [
              withDirectives(createVNode(_component_toggle, {
                modelValue: isReplaceMode.value,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isReplaceMode.value = $event),
                "on-label": "Replace",
                "off-label": "Append",
                class: "anwp-toggle-w-100 sl-toggle-blue-green"
              }, null, 8, ["modelValue"]), [
                [_directive_tooltip, isReplaceMode.value ? "Clear existing data before import" : "Add to existing data"]
              ]),
              isReplaceMode.value ? (openBlock(), createElementBlock("span", _hoisted_7$1, " will clear existing " + toDisplayString(entityLabel.value), 1)) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_8, [
            createBaseVNode("div", _hoisted_9, [
              createBaseVNode("button", {
                key: "sl-change-btn",
                class: "button button-secondary mr-3",
                type: "button",
                disabled: isActiveChangeStructure.value,
                onClick: _cache[2] || (_cache[2] = withModifiers(($event) => isActiveChangeStructure.value = true, ["prevent"]))
              }, " Change Import Columns ", 8, _hoisted_10),
              isActiveChangeStructure.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("button", {
                  key: "sl-cancel-btn",
                  class: "button button-secondary mr-3",
                  type: "button",
                  onClick: _cache[3] || (_cache[3] = withModifiers(($event) => isActiveChangeStructure.value = false, ["prevent"]))
                }, " Cancel "),
                createBaseVNode("button", {
                  key: "sl-apply-btn",
                  class: "button button-primary",
                  type: "button",
                  onClick: withModifiers(applyNewSettings, ["prevent"])
                }, " Apply New Settings ")
              ], 64)) : createCommentVNode("", true)
            ]),
            isActiveChangeStructure.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _cache[11] || (_cache[11] = createBaseVNode("h4", { class: "mb-1 mt-3" }, "Columns order and visibility", -1)),
              createBaseVNode("div", _hoisted_11, [
                columns.value && columns.value.length ? (openBlock(), createBlock(_component_draggable, {
                  key: 0,
                  modelValue: columns.value,
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => columns.value = $event),
                  handle: ".anwp-drag-handler",
                  "force-fallback": true,
                  class: "mt-2 d-flex"
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(columns.value, (column) => {
                      return openBlock(), createElementBlock("div", {
                        key: column.name,
                        class: "my-1 mr-1 py-1 px-2 border border-secondary anwp-d-flex-not-important flex-column align-items-center"
                      }, [
                        _cache[10] || (_cache[10] = createBaseVNode("svg", { class: "anwp-icon anwp-icon--s24 anwp-icon--octi anwp-drag-handler" }, [
                          createBaseVNode("use", { "xlink:href": "#icon-grabber" })
                        ], -1)),
                        createBaseVNode("div", {
                          class: normalizeClass(["my-2", column.visible ? "" : "anwp-text-line-through"]),
                          style: { "writing-mode": "vertical-rl" }
                        }, toDisplayString(column.title), 3),
                        createBaseVNode("div", {
                          class: "mt-auto anwp-cursor-pointer",
                          onClick: withModifiers(($event) => column.visible = !column.visible, ["prevent"])
                        }, [
                          column.visible ? (openBlock(), createElementBlock("svg", _hoisted_13, [..._cache[8] || (_cache[8] = [
                            createBaseVNode("use", { "xlink:href": "#icon-eye" }, null, -1)
                          ])])) : (openBlock(), createElementBlock("svg", _hoisted_14, [..._cache[9] || (_cache[9] = [
                            createBaseVNode("use", { "xlink:href": "#icon-eye-off" }, null, -1)
                          ])]))
                        ], 8, _hoisted_12)
                      ]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue"])) : createCommentVNode("", true)
              ])
            ], 64)) : createCommentVNode("", true)
          ]),
          "games_insert" === activePage.value ? (openBlock(), createElementBlock("p", _hoisted_15, " * Before starting data import you should create Competition with proper groups/ties structure (with teams). ")) : createCommentVNode("", true),
          statusMessage.value ? (openBlock(), createElementBlock("div", {
            key: 1,
            id: "sl-tool--message",
            class: normalizeClass(["my-3 p-3", statusMessage.value.blockClass]),
            style: { "max-width": "600px" }
          }, toDisplayString(statusMessage.value.msg), 3)) : createCommentVNode("", true),
          withDirectives(createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_16, [
              _cache[12] || (_cache[12] = createBaseVNode("span", {
                class: "text-muted mr-2",
                style: { "font-size": "13px" }
              }, "Add rows:", -1)),
              createBaseVNode("button", {
                type: "button",
                class: "button button-small mr-1",
                onClick: _cache[5] || (_cache[5] = withModifiers(($event) => addRows(10), ["prevent"]))
              }, "+10"),
              createBaseVNode("button", {
                type: "button",
                class: "button button-small mr-1",
                onClick: _cache[6] || (_cache[6] = withModifiers(($event) => addRows(50), ["prevent"]))
              }, "+50"),
              createBaseVNode("button", {
                type: "button",
                class: "button button-small",
                onClick: _cache[7] || (_cache[7] = withModifiers(($event) => addRows(100), ["prevent"]))
              }, "+100")
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", {
                id: "anwp-fl-batch-import-tool",
                ref_key: "anwpImportJExcelTool",
                ref: anwpImportJExcelTool
              }, null, 512)
            ]),
            _cache[27] || (_cache[27] = createStaticVNode('<div class="mt-2 mb-3 text-muted anwp-w-max-700 d-flex flex-wrap" style="font-size:13px;" data-v-20184428><strong data-v-20184428>Keyboard shortcuts:</strong><div class="w-100" data-v-20184428></div><div data-v-20184428><kbd data-v-20184428>Tab</kbd> / <kbd data-v-20184428>Shift+Tab</kbd> navigate between cells </div><div data-v-20184428><kbd data-v-20184428></kbd> <kbd data-v-20184428></kbd> <kbd data-v-20184428></kbd> <kbd data-v-20184428></kbd> arrow keys to navigate </div><div data-v-20184428><kbd data-v-20184428>Enter</kbd> or click to edit </div><div data-v-20184428>Type any character to start editing with that character </div><div data-v-20184428><kbd data-v-20184428>Esc</kbd> to cancel editing</div></div>', 1)),
            activeRequest.value && importProgress.value.total > 0 ? (openBlock(), createElementBlock("div", _hoisted_17, [
              createBaseVNode("div", _hoisted_18, [
                _cache[13] || (_cache[13] = createBaseVNode("strong", null, "Importing data...", -1)),
                isRelationshipPage.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode(" Processing match " + toDisplayString(importProgress.value.current) + " of " + toDisplayString(importProgress.value.total) + " ", 1),
                  importProgress.value.matchInfo ? (openBlock(), createElementBlock("span", _hoisted_19, " (" + toDisplayString(importProgress.value.matchInfo) + ") ", 1)) : createCommentVNode("", true)
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(" Processing row " + toDisplayString(importProgress.value.current) + " of " + toDisplayString(importProgress.value.total), 1)
                ], 64)),
                createTextVNode(" (" + toDisplayString(importProgress.value.percentage) + "%) ", 1)
              ]),
              createBaseVNode("div", _hoisted_20, [
                createBaseVNode("div", {
                  class: "anwp-progress-bar",
                  style: normalizeStyle([{ "height": "100%", "background-color": "#007bff", "transition": "width 0.3s ease", "display": "flex", "align-items": "center", "justify-content": "center", "color": "white", "font-weight": "600", "font-size": "12px" }, { width: importProgress.value.percentage + "%" }]),
                  role: "progressbar",
                  "aria-valuenow": importProgress.value.percentage,
                  "aria-valuemin": "0",
                  "aria-valuemax": "100"
                }, toDisplayString(importProgress.value.percentage) + "% ", 13, _hoisted_21)
              ])
            ])) : createCommentVNode("", true),
            showConfirmDialog.value ? (openBlock(), createElementBlock("div", _hoisted_22, [
              _cache[17] || (_cache[17] = createBaseVNode("h4", { class: "anwp-mt-0 anwp-mb-3 anwp-font-semibold anwp-text-orange-800" }, [
                createBaseVNode("span", { class: "dashicons dashicons-warning anwp-mr-2" }),
                createTextVNode(" Confirm Replace Import ")
              ], -1)),
              createBaseVNode("p", _hoisted_23, [
                _cache[14] || (_cache[14] = createTextVNode(" You are about to ", -1)),
                createBaseVNode("strong", null, "replace existing " + toDisplayString(entityLabel.value), 1),
                _cache[15] || (_cache[15] = createTextVNode(" for ", -1)),
                createBaseVNode("strong", null, toDisplayString(confirmDialogData.value.matchCount) + " match(es)", 1),
                _cache[16] || (_cache[16] = createTextVNode(". ", -1))
              ]),
              createBaseVNode("p", _hoisted_24, " This will DELETE all existing " + toDisplayString(entityLabel.value) + " for these matches before importing " + toDisplayString(confirmDialogData.value.totalItems) + " new items. ", 1),
              createBaseVNode("div", _hoisted_25, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-primary",
                  onClick: withModifiers(confirmAndSave, ["prevent"])
                }, " Yes, Replace "),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary",
                  onClick: withModifiers(cancelConfirm, ["prevent"])
                }, " Cancel ")
              ])
            ])) : createCommentVNode("", true),
            !(statusMessage.value && statusMessage.value.isError) ? (openBlock(), createElementBlock("div", _hoisted_26, [
              isRelationshipPage.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-secondary px-4 mr-3",
                  disabled: activeRequest.value || isPostImportMode.value,
                  onClick: withModifiers(previewBatchImport, ["prevent"])
                }, " Preview Import ", 8, _hoisted_27),
                createBaseVNode("button", {
                  type: "button",
                  class: "button button-primary px-5 mr-3",
                  disabled: activeRequest.value || isPostImportMode.value || !showBatchPreview.value,
                  onClick: withModifiers(startBatchImport, ["prevent"])
                }, " Import Data ", 8, _hoisted_28)
              ], 64)) : (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                class: "button button-primary px-5 mr-3",
                disabled: activeRequest.value || isPostImportMode.value,
                onClick: withModifiers(saveData, ["prevent"])
              }, "Save Data", 8, _hoisted_29)),
              isPostImportMode.value ? (openBlock(), createElementBlock("button", {
                key: 2,
                type: "button",
                class: "button button-secondary mr-3",
                onClick: withModifiers(clearSuccess, ["prevent"])
              }, "Clear Success")) : createCommentVNode("", true),
              isPostImportMode.value ? (openBlock(), createElementBlock("button", {
                key: 3,
                type: "button",
                class: "button button-secondary",
                onClick: withModifiers(clearAll, ["prevent"])
              }, "Clear All")) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            isRelationshipPage.value && !showBatchPreview.value ? (openBlock(), createElementBlock("div", _hoisted_30, [..._cache[18] || (_cache[18] = [
              createTextVNode(" Click ", -1),
              createBaseVNode("strong", null, "Preview Import", -1),
              createTextVNode(" to group rows by match, validate data, and see a summary before importing. ", -1)
            ])])) : createCommentVNode("", true),
            isRelationshipPage.value && showBatchPreview.value && batchPreviewData.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_31, [
              _cache[25] || (_cache[25] = createBaseVNode("h4", { class: "anwp-mt-0 anwp-mb-3 anwp-font-semibold" }, "Import Preview", -1)),
              createBaseVNode("p", _hoisted_32, [
                _cache[19] || (_cache[19] = createTextVNode(" Mode: ", -1)),
                createBaseVNode("strong", null, toDisplayString(isReplaceMode.value ? "Replace" : "Append"), 1),
                isReplaceMode.value ? (openBlock(), createElementBlock("span", _hoisted_33, " - existing " + toDisplayString(entityLabel.value) + " will be cleared", 1)) : createCommentVNode("", true)
              ]),
              createBaseVNode("table", _hoisted_34, [
                createBaseVNode("thead", null, [
                  createBaseVNode("tr", _hoisted_35, [
                    _cache[20] || (_cache[20] = createBaseVNode("th", { class: "anwp-p-2 anwp-text-left anwp-border anwp-border-blue-300" }, "Match", -1)),
                    _cache[21] || (_cache[21] = createBaseVNode("th", { class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300" }, "Items to Import", -1)),
                    _cache[22] || (_cache[22] = createBaseVNode("th", { class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300" }, "Valid", -1)),
                    _cache[23] || (_cache[23] = createBaseVNode("th", { class: "anwp-p-2 anwp-text-center anwp-border anwp-border-blue-300" }, "Invalid", -1)),
                    hasDuplicates.value ? (openBlock(), createElementBlock("th", _hoisted_36, "Duplicates")) : createCommentVNode("", true)
                  ])
                ]),
                createBaseVNode("tbody", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(batchPreviewData.value, (group, idx) => {
                    return openBlock(), createElementBlock("tr", {
                      key: idx,
                      class: "anwp-bg-white"
                    }, [
                      createBaseVNode("td", _hoisted_37, toDisplayString(group.matchTitle || group.matchKey), 1),
                      createBaseVNode("td", _hoisted_38, toDisplayString(group.total), 1),
                      createBaseVNode("td", _hoisted_39, toDisplayString(group.valid), 1),
                      createBaseVNode("td", _hoisted_40, toDisplayString(group.invalid), 1),
                      hasDuplicates.value ? (openBlock(), createElementBlock("td", _hoisted_41, toDisplayString(group.duplicates || 0), 1)) : createCommentVNode("", true)
                    ]);
                  }), 128))
                ]),
                createBaseVNode("tfoot", null, [
                  createBaseVNode("tr", _hoisted_42, [
                    _cache[24] || (_cache[24] = createBaseVNode("td", { class: "anwp-p-2 anwp-border anwp-border-blue-300" }, "Total", -1)),
                    createBaseVNode("td", _hoisted_43, toDisplayString(previewTotals.value.total), 1),
                    createBaseVNode("td", _hoisted_44, toDisplayString(previewTotals.value.valid), 1),
                    createBaseVNode("td", _hoisted_45, toDisplayString(previewTotals.value.invalid), 1),
                    hasDuplicates.value ? (openBlock(), createElementBlock("td", _hoisted_46, toDisplayString(previewTotals.value.duplicates), 1)) : createCommentVNode("", true)
                  ])
                ])
              ]),
              _cache[26] || (_cache[26] = createBaseVNode("p", { class: "anwp-mt-3 anwp-text-sm anwp-text-gray-600" }, " * Valid/Invalid counts are approximate. Final validation occurs during import. ", -1)),
              previewTotals.value.invalid > 0 ? (openBlock(), createElementBlock("p", _hoisted_47, toDisplayString(previewTotals.value.invalid) + " invalid items will be skipped. ", 1)) : createCommentVNode("", true),
              hasDuplicates.value ? (openBlock(), createElementBlock("p", _hoisted_48, toDisplayString(previewTotals.value.duplicates) + " potential duplicates detected (same player + minute). ", 1)) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ], 512), [
            [vShow, !isActiveChangeStructure.value]
          ])
        ]);
      };
    }
  };
  const AppImportTool = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-20184428"]]);
  const useApiStore = /* @__PURE__ */ defineStore("api", () => {
    const activeRequest = ref("");
    const activeTool = ref("");
    const spinnerUrl = window._anwpToolbox.spinner_url || "";
    return {
      activeRequest,
      activeTool,
      spinnerUrl
    };
  });
  const _sfc_main$3 = {};
  const _hoisted_1$3 = { class: "anwp-icon anwp-icon--octi anwp-icon--s16" };
  function _sfc_render(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$3, [..._cache[0] || (_cache[0] = [
      createBaseVNode("use", { "xlink:href": "#icon-caret-right" }, null, -1)
    ])]);
  }
  const AppDashboardRunBtn = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render]]);
  const _hoisted_1$2 = ["src"];
  const _hoisted_2$1 = {
    key: 1,
    class: "anwp-border anwp-border-gray-300 bg-white py-2 px-4 anwp-w-max-600"
  };
  const _hoisted_3$1 = { class: "mt-1" };
  const _hoisted_4$1 = { class: "mt-1" };
  const _hoisted_5 = { class: "mt-1" };
  const _hoisted_6 = ["disabled"];
  const _hoisted_7 = ["src"];
  const _sfc_main$2 = {
    __name: "AppUpdatePlayerCurrentTeam",
    setup(__props) {
      const AppAxios = axios.create({
        baseURL: window._anwpToolbox.rest_root,
        headers: {
          "X-WP-Nonce": window._anwpToolbox.rest_nonce
        }
      });
      function newAbortSignal(timeout) {
        const abortController = new AbortController();
        setTimeout(() => abortController.abort(), timeout);
        return abortController.signal;
      }
      const toolOptions = reactive({
        player_ids: [],
        updated: 0,
        checked: 0
      });
      const toolCompleted = ref(false);
      const apiStore = useApiStore();
      const notyf2 = new Notyf({ duration: 5e3 });
      const loadInitialData = () => {
        apiStore.activeRequest = "load-data";
        AppAxios.get("anwpfl/toolkit/get_all_player_ids").then((response) => {
          var _a2, _b2;
          if ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.toolOptions) {
            Object.assign(toolOptions, response.data.toolOptions);
          } else {
            notyf2.error(((_b2 = response == null ? void 0 : response.data) == null ? void 0 : _b2.message) ? response.data.message : "Error loading initial Data");
          }
        }).catch((error) => {
          notyf2.error(error);
        }).finally(() => apiStore.activeRequest = "");
      };
      onMounted(() => {
        loadInitialData();
      });
      const runUpdatePlayers = () => {
        if (!toolOptions.player_ids.length) {
          notyf2.success("Task Completed!");
          apiStore.activeRequest = "";
          return;
        }
        apiStore.activeRequest = "update-players";
        const playerId = toolOptions.player_ids.pop();
        updatePlayers(playerId);
      };
      const updatePlayers = (playerId) => {
        AppAxios.post(
          "anwpfl/toolkit/update_player_current_team",
          { playerId },
          {
            timeout: 5e3,
            signal: newAbortSignal(5e3)
          }
        ).then((response) => {
          var _a2, _b2, _c;
          if (((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.result) === true) {
            toolOptions.checked++;
            if (((_b2 = response == null ? void 0 : response.data) == null ? void 0 : _b2.saved) === true) {
              toolOptions.updated++;
            }
            runUpdatePlayers();
          } else {
            notyf2.error(((_c = response == null ? void 0 : response.data) == null ? void 0 : _c.message) ? response.data.message : "Task Error");
          }
        }).catch((error) => {
          console.log(error.code);
          if (error.code === "ECONNABORTED" || error.code === "ERR_CANCELED") {
            runUpdatePlayers();
          } else {
            console.log(error);
            notyf2.error(error);
          }
        });
      };
      return (_ctx, _cache) => {
        return unref(apiStore).activeRequest === "load-data" ? (openBlock(), createElementBlock("img", {
          key: 0,
          class: "align-text-bottom",
          src: unref(apiStore).spinnerUrl,
          alt: "spinner"
        }, null, 8, _hoisted_1$2)) : (openBlock(), createElementBlock("div", _hoisted_2$1, [
          _cache[1] || (_cache[1] = createBaseVNode("h3", { class: "mt-1 mb-3 anwp-text-base" }, " Save Player's Current Team ", -1)),
          createBaseVNode("div", _hoisted_3$1, "Players to check: " + toDisplayString(toolOptions.player_ids.length), 1),
          _cache[2] || (_cache[2] = createBaseVNode("hr", null, null, -1)),
          createBaseVNode("div", _hoisted_4$1, "Players Checked: " + toDisplayString(toolOptions.checked), 1),
          createBaseVNode("div", _hoisted_5, "Players Updated: " + toDisplayString(toolOptions.updated), 1),
          !toolCompleted.value ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: "button d-flex align-items-center justify-content-center anwp-w-80 anwp-h-20 anwp-h-min-20 my-3",
            type: "button",
            disabled: "" !== unref(apiStore).activeRequest,
            onClick: _cache[0] || (_cache[0] = withModifiers(($event) => runUpdatePlayers(), ["prevent"]))
          }, [
            unref(apiStore).activeRequest === "update-players" ? (openBlock(), createElementBlock("img", {
              key: 0,
              class: "align-text-bottom",
              src: unref(apiStore).spinnerUrl,
              alt: "spinner"
            }, null, 8, _hoisted_7)) : (openBlock(), createBlock(AppDashboardRunBtn, { key: 1 }))
          ], 8, _hoisted_6)) : createCommentVNode("", true)
        ]));
      };
    }
  };
  const _hoisted_1$1 = { class: "d-flex align-items-end anwp-w-max-600 anwp-border anwp-border-gray-300 bg-white py-2 px-4 my-2" };
  const _hoisted_2 = { class: "anwp-flex-grow-1" };
  const _hoisted_3 = { class: "mt-1 mb-2 anwp-text-base" };
  const _hoisted_4 = { class: "my-1 anwp-text-sm pr-3" };
  const _sfc_main$1 = {
    __name: "AppToolkitListItem",
    props: {
      toolHeader: {
        type: String,
        default: ""
      },
      toolDescription: {
        type: String,
        default: ""
      },
      toolSlug: {
        type: String,
        default: ""
      }
    },
    setup(__props) {
      const apiStore = useApiStore();
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$1, [
          createBaseVNode("div", _hoisted_2, [
            createBaseVNode("h3", _hoisted_3, toDisplayString(__props.toolHeader), 1),
            createBaseVNode("p", _hoisted_4, toDisplayString(__props.toolDescription), 1)
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("button", {
              class: "button",
              type: "button",
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => unref(apiStore).activeTool = __props.toolSlug, ["prevent"]))
            }, "Select Tool")
          ])
        ]);
      };
    }
  };
  const _hoisted_1 = { class: "anwp-vue-api-import-wrapper px-2" };
  const _sfc_main = {
    __name: "AppToolkit",
    setup(__props) {
      const componentMap = {
        "update-player-current-team": _sfc_main$2
      };
      const apiStore = useApiStore();
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1, [
          unref(apiStore).activeTool && !unref(apiStore).activeRequest ? (openBlock(), createElementBlock("button", {
            key: 0,
            type: "button",
            class: "button button-secondary mb-2",
            onClick: _cache[0] || (_cache[0] = withModifiers(($event) => unref(apiStore).activeTool = "", ["prevent"]))
          }, "  Go Back ")) : createCommentVNode("", true),
          (openBlock(), createBlock(resolveDynamicComponent(componentMap[unref(apiStore).activeTool]))),
          !unref(apiStore).activeTool ? (openBlock(), createBlock(_sfc_main$1, {
            key: 1,
            "tool-header": "Update Player's Current Team",
            "tool-description": "Update the player's 'Current Team' based on the last game played",
            "tool-slug": "update-player-current-team"
          })) : createCommentVNode("", true)
        ]);
      };
    }
  };
  const sides = ["top", "right", "bottom", "left"];
  const alignments = ["start", "end"];
  const placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
  const min = Math.min;
  const max = Math.max;
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
  function getSideAxis(placement) {
    return yAxisSides.has(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  const lrPlacement = ["left", "right"];
  const rlPlacement = ["right", "left"];
  const tbPlacement = ["top", "bottom"];
  const btPlacement = ["bottom", "top"];
  function getSideList(side, isStart, rtl) {
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rlPlacement : lrPlacement;
        return isStart ? lrPlacement : rlPlacement;
      case "left":
      case "right":
        return isStart ? tbPlacement : btPlacement;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list2 = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list2 = list2.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list2 = list2.concat(list2.map(getOppositeAlignmentPlacement));
      }
    }
    return list2;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return __spreadValues({
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, padding);
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y2,
      left: x2,
      right: x2 + width,
      bottom: y2 + height,
      x: x2,
      y: y2
    };
  }
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  const computePosition = (reference, floating, config) => __async(null, null, function* () {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);
    let rects = yield platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i2 = 0; i2 < validMiddleware.length; i2++) {
      const {
        name,
        fn
      } = validMiddleware[i2];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = yield fn({
        x: x2,
        y: y2,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x2 = nextX != null ? nextX : x2;
      y2 = nextY != null ? nextY : y2;
      middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
        [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
      });
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? yield platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x: x2,
            y: y2
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i2 = -1;
      }
    }
    return {
      x: x2,
      y: y2,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  });
  function detectOverflow(state, options) {
    return __async(this, null, function* () {
      var _await$platform$isEle;
      if (options === void 0) {
        options = {};
      }
      const {
        x: x2,
        y: y2,
        platform: platform2,
        rects,
        elements,
        strategy
      } = state;
      const {
        boundary = "clippingAncestors",
        rootBoundary = "viewport",
        elementContext = "floating",
        altBoundary = false,
        padding = 0
      } = evaluate(options, state);
      const paddingObject = getPaddingObject(padding);
      const altContext = elementContext === "floating" ? "reference" : "floating";
      const element = elements[altBoundary ? altContext : elementContext];
      const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({
        element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
        boundary,
        rootBoundary,
        strategy
      }));
      const rect = elementContext === "floating" ? {
        x: x2,
        y: y2,
        width: rects.floating.width,
        height: rects.floating.height
      } : rects.reference;
      const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);
      const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
        x: 1,
        y: 1
      } : {
        x: 1,
        y: 1
      };
      const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements,
        rect,
        offsetParent,
        strategy
      }) : rect);
      return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
      };
    });
  }
  const arrow = (options) => ({
    name: "arrow",
    options,
    fn(state) {
      return __async(this, null, function* () {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          platform: platform2,
          elements,
          middlewareData
        } = state;
        const {
          element,
          padding = 0
        } = evaluate(options, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x: x2,
          y: y2
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = yield platform2.getDimensions(element);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element);
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !(yield platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
        const min$1 = minPadding;
        const max2 = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = clamp(min$1, center, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: __spreadValues({
            [axis]: offset2,
            centerOffset: center - offset2 - alignmentOffset
          }, shouldAddOffset && {
            alignmentOffset
          }),
          reset: shouldAddOffset
        };
      });
    }
  });
  function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter((placement) => {
      if (alignment) {
        return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
      }
      return true;
    });
  }
  const autoPlacement = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "autoPlacement",
      options,
      fn(state) {
        return __async(this, null, function* () {
          var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
          const {
            rects,
            middlewareData,
            placement,
            platform: platform2,
            elements
          } = state;
          const _a3 = evaluate(options, state), {
            crossAxis = false,
            alignment,
            allowedPlacements = placements,
            autoAlignment = true
          } = _a3, detectOverflowOptions = __objRest(_a3, [
            "crossAxis",
            "alignment",
            "allowedPlacements",
            "autoAlignment"
          ]);
          const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
          const overflow = yield detectOverflow(state, detectOverflowOptions);
          const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
          const currentPlacement = placements$1[currentIndex];
          if (currentPlacement == null) {
            return {};
          }
          const alignmentSides = getAlignmentSides(currentPlacement, rects, yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
          if (placement !== currentPlacement) {
            return {
              reset: {
                placement: placements$1[0]
              }
            };
          }
          const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
          const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
            placement: currentPlacement,
            overflows: currentOverflows
          }];
          const nextPlacement = placements$1[currentIndex + 1];
          if (nextPlacement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          const placementsSortedByMostSpace = allOverflows.map((d2) => {
            const alignment2 = getAlignment(d2.placement);
            return [d2.placement, alignment2 && crossAxis ? (
              // Check along the mainAxis and main crossAxis side.
              d2.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0)
            ) : (
              // Check only the mainAxis.
              d2.overflows[0]
            ), d2.overflows];
          }).sort((a2, b2) => a2[1] - b2[1]);
          const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d2) => d2[2].slice(
            0,
            // Aligned placements should not check their opposite crossAxis
            // side.
            getAlignment(d2[0]) ? 2 : 3
          ).every((v2) => v2 <= 0));
          const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
          if (resetPlacement !== placement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows
              },
              reset: {
                placement: resetPlacement
              }
            };
          }
          return {};
        });
      }
    };
  };
  const flip = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      fn(state) {
        return __async(this, null, function* () {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements
          } = state;
          const _a3 = evaluate(options, state), {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true
          } = _a3, detectOverflowOptions = __objRest(_a3, [
            "mainAxis",
            "crossAxis",
            "fallbackPlacements",
            "fallbackStrategy",
            "fallbackAxisSideDirection",
            "flipAlignment"
          ]);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const initialSideAxis = getSideAxis(initialPlacement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
          if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements2 = [initialPlacement, ...fallbackPlacements];
          const overflow = yield detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides2 = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements2[nextIndex];
            if (nextPlacement) {
              const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
              if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
              // overflows the main axis.
              overflowsData.every((d2) => getSideAxis(d2.placement) === initialSideAxis ? d2.overflows[0] > 0 : true)) {
                return {
                  data: {
                    index: nextIndex,
                    overflows: overflowsData
                  },
                  reset: {
                    placement: nextPlacement
                  }
                };
              }
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$filter2;
                  const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                    if (hasFallbackAxisSideDirection) {
                      const currentSideAxis = getSideAxis(d2.placement);
                      return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                      // reading directions favoring greater width.
                      currentSideAxis === "y";
                    }
                    return true;
                  }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        });
      }
    };
  };
  const originSides = /* @__PURE__ */ new Set(["left", "top"]);
  function convertValueToCoords(state, options) {
    return __async(this, null, function* () {
      const {
        placement,
        platform: platform2,
        elements
      } = state;
      const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isVertical = getSideAxis(placement) === "y";
      const mainAxisMulti = originSides.has(side) ? -1 : 1;
      const crossAxisMulti = rtl && isVertical ? -1 : 1;
      const rawValue = evaluate(options, state);
      let {
        mainAxis,
        crossAxis,
        alignmentAxis
      } = typeof rawValue === "number" ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
      } : {
        mainAxis: rawValue.mainAxis || 0,
        crossAxis: rawValue.crossAxis || 0,
        alignmentAxis: rawValue.alignmentAxis
      };
      if (alignment && typeof alignmentAxis === "number") {
        crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
      }
      return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
      } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
      };
    });
  }
  const offset = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      fn(state) {
        return __async(this, null, function* () {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x2,
            y: y2,
            placement,
            middlewareData
          } = state;
          const diffCoords = yield convertValueToCoords(state, options);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x2 + diffCoords.x,
            y: y2 + diffCoords.y,
            data: __spreadProps(__spreadValues({}, diffCoords), {
              placement
            })
          };
        });
      }
    };
  };
  const shift = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      fn(state) {
        return __async(this, null, function* () {
          const {
            x: x2,
            y: y2,
            placement
          } = state;
          const _a3 = evaluate(options, state), {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x3,
                  y: y3
                } = _ref;
                return {
                  x: x3,
                  y: y3
                };
              }
            }
          } = _a3, detectOverflowOptions = __objRest(_a3, [
            "mainAxis",
            "crossAxis",
            "limiter"
          ]);
          const coords = {
            x: x2,
            y: y2
          };
          const overflow = yield detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          }));
          return __spreadProps(__spreadValues({}, limitedCoords), {
            data: {
              x: limitedCoords.x - x2,
              y: limitedCoords.y - y2,
              enabled: {
                [mainAxis]: checkMainAxis,
                [crossAxis]: checkCrossAxis
              }
            }
          });
        });
      }
    };
  };
  const size = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "size",
      options,
      fn(state) {
        return __async(this, null, function* () {
          var _state$middlewareData, _state$middlewareData2;
          const {
            placement,
            rects,
            platform: platform2,
            elements
          } = state;
          const _a3 = evaluate(options, state), {
            apply: apply2 = () => {
            }
          } = _a3, detectOverflowOptions = __objRest(_a3, [
            "apply"
          ]);
          const overflow = yield detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === "y";
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === ((yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const maximumClippingHeight = height - overflow.top - overflow.bottom;
          const maximumClippingWidth = width - overflow.left - overflow.right;
          const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
          const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
            availableWidth = maximumClippingWidth;
          }
          if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
            availableHeight = maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
            }
          }
          yield apply2(__spreadProps(__spreadValues({}, state), {
            availableWidth,
            availableHeight
          }));
          const nextDimensions = yield platform2.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        });
      }
    };
  };
  function n$1(t) {
    var e;
    return (null == (e = t.ownerDocument) ? void 0 : e.defaultView) || window;
  }
  function o(t) {
    return n$1(t).getComputedStyle(t);
  }
  const i = Math.min, r = Math.max, l = Math.round;
  function c$2(t) {
    const e = o(t);
    let n2 = parseFloat(e.width), i2 = parseFloat(e.height);
    const r2 = t.offsetWidth, c2 = t.offsetHeight, s2 = l(n2) !== r2 || l(i2) !== c2;
    return s2 && (n2 = r2, i2 = c2), { width: n2, height: i2, fallback: s2 };
  }
  function s(t) {
    return h$3(t) ? (t.nodeName || "").toLowerCase() : "";
  }
  let f$2;
  function u() {
    if (f$2) return f$2;
    const t = navigator.userAgentData;
    return t && Array.isArray(t.brands) ? (f$2 = t.brands.map(((t2) => t2.brand + "/" + t2.version)).join(" "), f$2) : navigator.userAgent;
  }
  function a(t) {
    return t instanceof n$1(t).HTMLElement;
  }
  function d$1(t) {
    return t instanceof n$1(t).Element;
  }
  function h$3(t) {
    return t instanceof n$1(t).Node;
  }
  function p$2(t) {
    if ("undefined" == typeof ShadowRoot) return false;
    return t instanceof n$1(t).ShadowRoot || t instanceof ShadowRoot;
  }
  function g$2(t) {
    const { overflow: e, overflowX: n2, overflowY: i2, display: r2 } = o(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + i2 + n2) && !["inline", "contents"].includes(r2);
  }
  function m$2(t) {
    return ["table", "td", "th"].includes(s(t));
  }
  function y$1(t) {
    const e = /firefox/i.test(u()), n2 = o(t), i2 = n2.backdropFilter || n2.WebkitBackdropFilter;
    return "none" !== n2.transform || "none" !== n2.perspective || !!i2 && "none" !== i2 || e && "filter" === n2.willChange || e && !!n2.filter && "none" !== n2.filter || ["transform", "perspective"].some(((t2) => n2.willChange.includes(t2))) || ["paint", "layout", "strict", "content"].some(((t2) => {
      const e2 = n2.contain;
      return null != e2 && e2.includes(t2);
    }));
  }
  function x$2() {
    return !/^((?!chrome|android).)*safari/i.test(u());
  }
  function w(t) {
    return ["html", "body", "#document"].includes(s(t));
  }
  function v$1(t) {
    return d$1(t) ? t : t.contextElement;
  }
  const b$2 = { x: 1, y: 1 };
  function L(t) {
    const e = v$1(t);
    if (!a(e)) return b$2;
    const n2 = e.getBoundingClientRect(), { width: o2, height: i2, fallback: r2 } = c$2(e);
    let s2 = (r2 ? l(n2.width) : n2.width) / o2, f2 = (r2 ? l(n2.height) : n2.height) / i2;
    return s2 && Number.isFinite(s2) || (s2 = 1), f2 && Number.isFinite(f2) || (f2 = 1), { x: s2, y: f2 };
  }
  function E$2(t, e, o2, i2) {
    var r2, l2;
    void 0 === e && (e = false), void 0 === o2 && (o2 = false);
    const c2 = t.getBoundingClientRect(), s2 = v$1(t);
    let f2 = b$2;
    e && (i2 ? d$1(i2) && (f2 = L(i2)) : f2 = L(t));
    const u2 = s2 ? n$1(s2) : window, a2 = !x$2() && o2;
    let h2 = (c2.left + (a2 && (null == (r2 = u2.visualViewport) ? void 0 : r2.offsetLeft) || 0)) / f2.x, p2 = (c2.top + (a2 && (null == (l2 = u2.visualViewport) ? void 0 : l2.offsetTop) || 0)) / f2.y, g2 = c2.width / f2.x, m2 = c2.height / f2.y;
    if (s2) {
      const t2 = n$1(s2), e2 = i2 && d$1(i2) ? n$1(i2) : i2;
      let o3 = t2.frameElement;
      for (; o3 && i2 && e2 !== t2; ) {
        const t3 = L(o3), e3 = o3.getBoundingClientRect(), i3 = getComputedStyle(o3);
        e3.x += (o3.clientLeft + parseFloat(i3.paddingLeft)) * t3.x, e3.y += (o3.clientTop + parseFloat(i3.paddingTop)) * t3.y, h2 *= t3.x, p2 *= t3.y, g2 *= t3.x, m2 *= t3.y, h2 += e3.x, p2 += e3.y, o3 = n$1(o3).frameElement;
      }
    }
    return { width: g2, height: m2, top: p2, right: h2 + g2, bottom: p2 + m2, left: h2, x: h2, y: p2 };
  }
  function R(t) {
    return ((h$3(t) ? t.ownerDocument : t.document) || window.document).documentElement;
  }
  function T$1(t) {
    return d$1(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
  }
  function C$3(t) {
    return E$2(R(t)).left + T$1(t).scrollLeft;
  }
  function F(t) {
    if ("html" === s(t)) return t;
    const e = t.assignedSlot || t.parentNode || p$2(t) && t.host || R(t);
    return p$2(e) ? e.host : e;
  }
  function W$2(t) {
    const e = F(t);
    return w(e) ? e.ownerDocument.body : a(e) && g$2(e) ? e : W$2(e);
  }
  function D$1(t, e) {
    var o2;
    void 0 === e && (e = []);
    const i2 = W$2(t), r2 = i2 === (null == (o2 = t.ownerDocument) ? void 0 : o2.body), l2 = n$1(i2);
    return r2 ? e.concat(l2, l2.visualViewport || [], g$2(i2) ? i2 : []) : e.concat(i2, D$1(i2));
  }
  function S$3(e, i2, l2) {
    return "viewport" === i2 ? rectToClientRect((function(t, e2) {
      const o2 = n$1(t), i3 = R(t), r2 = o2.visualViewport;
      let l3 = i3.clientWidth, c2 = i3.clientHeight, s2 = 0, f2 = 0;
      if (r2) {
        l3 = r2.width, c2 = r2.height;
        const t2 = x$2();
        (t2 || !t2 && "fixed" === e2) && (s2 = r2.offsetLeft, f2 = r2.offsetTop);
      }
      return { width: l3, height: c2, x: s2, y: f2 };
    })(e, l2)) : d$1(i2) ? rectToClientRect((function(t, e2) {
      const n2 = E$2(t, true, "fixed" === e2), o2 = n2.top + t.clientTop, i3 = n2.left + t.clientLeft, r2 = a(t) ? L(t) : { x: 1, y: 1 };
      return { width: t.clientWidth * r2.x, height: t.clientHeight * r2.y, x: i3 * r2.x, y: o2 * r2.y };
    })(i2, l2)) : rectToClientRect((function(t) {
      const e2 = R(t), n2 = T$1(t), i3 = t.ownerDocument.body, l3 = r(e2.scrollWidth, e2.clientWidth, i3.scrollWidth, i3.clientWidth), c2 = r(e2.scrollHeight, e2.clientHeight, i3.scrollHeight, i3.clientHeight);
      let s2 = -n2.scrollLeft + C$3(t);
      const f2 = -n2.scrollTop;
      return "rtl" === o(i3).direction && (s2 += r(e2.clientWidth, i3.clientWidth) - l3), { width: l3, height: c2, x: s2, y: f2 };
    })(R(e)));
  }
  function A(t) {
    return a(t) && "fixed" !== o(t).position ? t.offsetParent : null;
  }
  function H$2(t) {
    const e = n$1(t);
    let i2 = A(t);
    for (; i2 && m$2(i2) && "static" === o(i2).position; ) i2 = A(i2);
    return i2 && ("html" === s(i2) || "body" === s(i2) && "static" === o(i2).position && !y$1(i2)) ? e : i2 || (function(t2) {
      let e2 = F(t2);
      for (; a(e2) && !w(e2); ) {
        if (y$1(e2)) return e2;
        e2 = F(e2);
      }
      return null;
    })(t) || e;
  }
  function O$1(t, e, n2) {
    const o2 = a(e), i2 = R(e), r2 = E$2(t, true, "fixed" === n2, e);
    let l2 = { scrollLeft: 0, scrollTop: 0 };
    const c2 = { x: 0, y: 0 };
    if (o2 || !o2 && "fixed" !== n2) if (("body" !== s(e) || g$2(i2)) && (l2 = T$1(e)), a(e)) {
      const t2 = E$2(e, true);
      c2.x = t2.x + e.clientLeft, c2.y = t2.y + e.clientTop;
    } else i2 && (c2.x = C$3(i2));
    return { x: r2.left + l2.scrollLeft - c2.x, y: r2.top + l2.scrollTop - c2.y, width: r2.width, height: r2.height };
  }
  const P$1 = { getClippingRect: function(t) {
    let { element: e, boundary: n2, rootBoundary: l2, strategy: c2 } = t;
    const f2 = "clippingAncestors" === n2 ? (function(t2, e2) {
      const n3 = e2.get(t2);
      if (n3) return n3;
      let i2 = D$1(t2).filter(((t3) => d$1(t3) && "body" !== s(t3))), r2 = null;
      const l3 = "fixed" === o(t2).position;
      let c3 = l3 ? F(t2) : t2;
      for (; d$1(c3) && !w(c3); ) {
        const t3 = o(c3), e3 = y$1(c3);
        (l3 ? e3 || r2 : e3 || "static" !== t3.position || !r2 || !["absolute", "fixed"].includes(r2.position)) ? r2 = t3 : i2 = i2.filter(((t4) => t4 !== c3)), c3 = F(c3);
      }
      return e2.set(t2, i2), i2;
    })(e, this._c) : [].concat(n2), u2 = [...f2, l2], a2 = u2[0], h2 = u2.reduce(((t2, n3) => {
      const o2 = S$3(e, n3, c2);
      return t2.top = r(o2.top, t2.top), t2.right = i(o2.right, t2.right), t2.bottom = i(o2.bottom, t2.bottom), t2.left = r(o2.left, t2.left), t2;
    }), S$3(e, a2, c2));
    return { width: h2.right - h2.left, height: h2.bottom - h2.top, x: h2.left, y: h2.top };
  }, convertOffsetParentRelativeRectToViewportRelativeRect: function(t) {
    let { rect: e, offsetParent: n2, strategy: o2 } = t;
    const i2 = a(n2), r2 = R(n2);
    if (n2 === r2) return e;
    let l2 = { scrollLeft: 0, scrollTop: 0 }, c2 = { x: 1, y: 1 };
    const f2 = { x: 0, y: 0 };
    if ((i2 || !i2 && "fixed" !== o2) && (("body" !== s(n2) || g$2(r2)) && (l2 = T$1(n2)), a(n2))) {
      const t2 = E$2(n2);
      c2 = L(n2), f2.x = t2.x + n2.clientLeft, f2.y = t2.y + n2.clientTop;
    }
    return { width: e.width * c2.x, height: e.height * c2.y, x: e.x * c2.x - l2.scrollLeft * c2.x + f2.x, y: e.y * c2.y - l2.scrollTop * c2.y + f2.y };
  }, isElement: d$1, getDimensions: function(t) {
    return a(t) ? c$2(t) : t.getBoundingClientRect();
  }, getOffsetParent: H$2, getDocumentElement: R, getScale: L, getElementRects(t) {
    return __async(this, null, function* () {
      let { reference: e, floating: n2, strategy: o2 } = t;
      const i2 = this.getOffsetParent || H$2, r2 = this.getDimensions;
      return { reference: O$1(e, yield i2(n2), o2), floating: __spreadValues({ x: 0, y: 0 }, yield r2(n2)) };
    });
  }, getClientRects: (t) => Array.from(t.getClientRects()), isRTL: (t) => "rtl" === o(t).direction };
  const B$2 = (t, n2, o2) => {
    const i2 = /* @__PURE__ */ new Map(), r2 = __spreadValues({ platform: P$1 }, o2), l2 = __spreadProps(__spreadValues({}, r2.platform), { _c: i2 });
    return computePosition(t, n2, __spreadProps(__spreadValues({}, r2), { platform: l2 }));
  };
  function ye$2(e, t) {
    for (const o2 in t)
      Object.prototype.hasOwnProperty.call(t, o2) && (typeof t[o2] == "object" && e[o2] ? ye$2(e[o2], t[o2]) : e[o2] = t[o2]);
  }
  const h$2 = {
    // Disable popper components
    disabled: false,
    // Default position offset along main axis (px)
    distance: 5,
    // Default position offset along cross axis (px)
    skidding: 0,
    // Default container where the tooltip will be appended
    container: "body",
    // Element used to compute position and size boundaries
    boundary: void 0,
    // Skip delay & CSS transitions when another popper is shown, so that the popper appear to instanly move to the new position.
    instantMove: false,
    // Auto destroy tooltip DOM nodes (ms)
    disposeTimeout: 150,
    // Triggers on the popper itself
    popperTriggers: [],
    // Positioning strategy
    strategy: "absolute",
    // Prevent overflow
    preventOverflow: true,
    // Flip to the opposite placement if needed
    flip: true,
    // Shift on the cross axis to prevent the popper from overflowing
    shift: true,
    // Overflow padding (px)
    overflowPadding: 0,
    // Arrow padding (px)
    arrowPadding: 0,
    // Compute arrow overflow (useful to hide it)
    arrowOverflow: true,
    /**
     * By default, compute autohide on 'click'.
     */
    autoHideOnMousedown: false,
    // Themes
    themes: {
      tooltip: {
        // Default tooltip placement relative to target element
        placement: "top",
        // Default events that trigger the tooltip
        triggers: ["hover", "focus", "touch"],
        // Close tooltip on click on tooltip target
        hideTriggers: (e) => [...e, "click"],
        // Delay (ms)
        delay: {
          show: 200,
          hide: 0
        },
        // Update popper on content resize
        handleResize: false,
        // Enable HTML content in directive
        html: false,
        // Displayed when tooltip content is loading
        loadingContent: "..."
      },
      dropdown: {
        // Default dropdown placement relative to target element
        placement: "bottom",
        // Default events that trigger the dropdown
        triggers: ["click"],
        // Delay (ms)
        delay: 0,
        // Update popper on content resize
        handleResize: true,
        // Hide on clock outside
        autoHide: true
      },
      menu: {
        $extend: "dropdown",
        triggers: ["hover", "focus"],
        popperTriggers: ["hover"],
        delay: {
          show: 0,
          hide: 400
        }
      }
    }
  };
  function S$2(e, t) {
    let o2 = h$2.themes[e] || {}, i2;
    do
      i2 = o2[t], typeof i2 > "u" ? o2.$extend ? o2 = h$2.themes[o2.$extend] || {} : (o2 = null, i2 = h$2[t]) : o2 = null;
    while (o2);
    return i2;
  }
  function Ze$1(e) {
    const t = [e];
    let o2 = h$2.themes[e] || {};
    do
      o2.$extend && !o2.$resetCss ? (t.push(o2.$extend), o2 = h$2.themes[o2.$extend] || {}) : o2 = null;
    while (o2);
    return t.map((i2) => `v-popper--theme-${i2}`);
  }
  function re$2(e) {
    const t = [e];
    let o2 = h$2.themes[e] || {};
    do
      o2.$extend ? (t.push(o2.$extend), o2 = h$2.themes[o2.$extend] || {}) : o2 = null;
    while (o2);
    return t;
  }
  let $$1 = false;
  if (typeof window < "u") {
    $$1 = false;
    try {
      const e = Object.defineProperty({}, "passive", {
        get() {
          $$1 = true;
        }
      });
      window.addEventListener("test", null, e);
    } catch (e) {
    }
  }
  let _e$2 = false;
  typeof window < "u" && typeof navigator < "u" && (_e$2 = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
  const Te$1 = ["auto", "top", "bottom", "left", "right"].reduce((e, t) => e.concat([
    t,
    `${t}-start`,
    `${t}-end`
  ]), []), pe$2 = {
    hover: "mouseenter",
    focus: "focus",
    click: "click",
    touch: "touchstart",
    pointer: "pointerdown"
  }, ae$1 = {
    hover: "mouseleave",
    focus: "blur",
    click: "click",
    touch: "touchend",
    pointer: "pointerup"
  };
  function de$2(e, t) {
    const o2 = e.indexOf(t);
    o2 !== -1 && e.splice(o2, 1);
  }
  function G$2() {
    return new Promise((e) => requestAnimationFrame(() => {
      requestAnimationFrame(e);
    }));
  }
  const d = [];
  let g$1 = null;
  const le$2 = {};
  function he$2(e) {
    let t = le$2[e];
    return t || (t = le$2[e] = []), t;
  }
  let Y$1 = function() {
  };
  typeof window < "u" && (Y$1 = window.Element);
  function n(e) {
    return function(t) {
      return S$2(t.theme, e);
    };
  }
  const q$2 = "__floating-vue__popper", Q$1 = () => /* @__PURE__ */ defineComponent({
    name: "VPopper",
    provide() {
      return {
        [q$2]: {
          parentPopper: this
        }
      };
    },
    inject: {
      [q$2]: { default: null }
    },
    props: {
      theme: {
        type: String,
        required: true
      },
      targetNodes: {
        type: Function,
        required: true
      },
      referenceNode: {
        type: Function,
        default: null
      },
      popperNode: {
        type: Function,
        required: true
      },
      shown: {
        type: Boolean,
        default: false
      },
      showGroup: {
        type: String,
        default: null
      },
      // eslint-disable-next-line vue/require-prop-types
      ariaId: {
        default: null
      },
      disabled: {
        type: Boolean,
        default: n("disabled")
      },
      positioningDisabled: {
        type: Boolean,
        default: n("positioningDisabled")
      },
      placement: {
        type: String,
        default: n("placement"),
        validator: (e) => Te$1.includes(e)
      },
      delay: {
        type: [String, Number, Object],
        default: n("delay")
      },
      distance: {
        type: [Number, String],
        default: n("distance")
      },
      skidding: {
        type: [Number, String],
        default: n("skidding")
      },
      triggers: {
        type: Array,
        default: n("triggers")
      },
      showTriggers: {
        type: [Array, Function],
        default: n("showTriggers")
      },
      hideTriggers: {
        type: [Array, Function],
        default: n("hideTriggers")
      },
      popperTriggers: {
        type: Array,
        default: n("popperTriggers")
      },
      popperShowTriggers: {
        type: [Array, Function],
        default: n("popperShowTriggers")
      },
      popperHideTriggers: {
        type: [Array, Function],
        default: n("popperHideTriggers")
      },
      container: {
        type: [String, Object, Y$1, Boolean],
        default: n("container")
      },
      boundary: {
        type: [String, Y$1],
        default: n("boundary")
      },
      strategy: {
        type: String,
        validator: (e) => ["absolute", "fixed"].includes(e),
        default: n("strategy")
      },
      autoHide: {
        type: [Boolean, Function],
        default: n("autoHide")
      },
      handleResize: {
        type: Boolean,
        default: n("handleResize")
      },
      instantMove: {
        type: Boolean,
        default: n("instantMove")
      },
      eagerMount: {
        type: Boolean,
        default: n("eagerMount")
      },
      popperClass: {
        type: [String, Array, Object],
        default: n("popperClass")
      },
      computeTransformOrigin: {
        type: Boolean,
        default: n("computeTransformOrigin")
      },
      /**
       * @deprecated
       */
      autoMinSize: {
        type: Boolean,
        default: n("autoMinSize")
      },
      autoSize: {
        type: [Boolean, String],
        default: n("autoSize")
      },
      /**
       * @deprecated
       */
      autoMaxSize: {
        type: Boolean,
        default: n("autoMaxSize")
      },
      autoBoundaryMaxSize: {
        type: Boolean,
        default: n("autoBoundaryMaxSize")
      },
      preventOverflow: {
        type: Boolean,
        default: n("preventOverflow")
      },
      overflowPadding: {
        type: [Number, String],
        default: n("overflowPadding")
      },
      arrowPadding: {
        type: [Number, String],
        default: n("arrowPadding")
      },
      arrowOverflow: {
        type: Boolean,
        default: n("arrowOverflow")
      },
      flip: {
        type: Boolean,
        default: n("flip")
      },
      shift: {
        type: Boolean,
        default: n("shift")
      },
      shiftCrossAxis: {
        type: Boolean,
        default: n("shiftCrossAxis")
      },
      noAutoFocus: {
        type: Boolean,
        default: n("noAutoFocus")
      },
      disposeTimeout: {
        type: Number,
        default: n("disposeTimeout")
      }
    },
    emits: {
      show: () => true,
      hide: () => true,
      "update:shown": (e) => true,
      "apply-show": () => true,
      "apply-hide": () => true,
      "close-group": () => true,
      "close-directive": () => true,
      "auto-hide": () => true,
      resize: () => true
    },
    data() {
      return {
        isShown: false,
        isMounted: false,
        skipTransition: false,
        classes: {
          showFrom: false,
          showTo: false,
          hideFrom: false,
          hideTo: true
        },
        result: {
          x: 0,
          y: 0,
          placement: "",
          strategy: this.strategy,
          arrow: {
            x: 0,
            y: 0,
            centerOffset: 0
          },
          transformOrigin: null
        },
        randomId: `popper_${[Math.random(), Date.now()].map((e) => e.toString(36).substring(2, 10)).join("_")}`,
        shownChildren: /* @__PURE__ */ new Set(),
        lastAutoHide: true,
        pendingHide: false,
        containsGlobalTarget: false,
        isDisposed: true,
        mouseDownContains: false
      };
    },
    computed: {
      popperId() {
        return this.ariaId != null ? this.ariaId : this.randomId;
      },
      shouldMountContent() {
        return this.eagerMount || this.isMounted;
      },
      slotData() {
        return {
          popperId: this.popperId,
          isShown: this.isShown,
          shouldMountContent: this.shouldMountContent,
          skipTransition: this.skipTransition,
          autoHide: typeof this.autoHide == "function" ? this.lastAutoHide : this.autoHide,
          show: this.show,
          hide: this.hide,
          handleResize: this.handleResize,
          onResize: this.onResize,
          classes: __spreadProps(__spreadValues({}, this.classes), {
            popperClass: this.popperClass
          }),
          result: this.positioningDisabled ? null : this.result,
          attrs: this.$attrs
        };
      },
      parentPopper() {
        var e;
        return (e = this[q$2]) == null ? void 0 : e.parentPopper;
      },
      hasPopperShowTriggerHover() {
        var e, t;
        return ((e = this.popperTriggers) == null ? void 0 : e.includes("hover")) || ((t = this.popperShowTriggers) == null ? void 0 : t.includes("hover"));
      }
    },
    watch: __spreadValues({
      shown: "$_autoShowHide",
      disabled(e) {
        e ? this.dispose() : this.init();
      },
      container() {
        return __async(this, null, function* () {
          this.isShown && (this.$_ensureTeleport(), yield this.$_computePosition());
        });
      },
      triggers: {
        handler: "$_refreshListeners",
        deep: true
      },
      positioningDisabled: "$_refreshListeners"
    }, [
      "placement",
      "distance",
      "skidding",
      "boundary",
      "strategy",
      "overflowPadding",
      "arrowPadding",
      "preventOverflow",
      "shift",
      "shiftCrossAxis",
      "flip"
    ].reduce((e, t) => (e[t] = "$_computePosition", e), {})),
    created() {
      this.autoMinSize && console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.'), this.autoMaxSize && console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
    },
    mounted() {
      this.init(), this.$_detachPopperNode();
    },
    activated() {
      this.$_autoShowHide();
    },
    deactivated() {
      this.hide();
    },
    beforeUnmount() {
      this.dispose();
    },
    methods: {
      show({ event: e = null, skipDelay: t = false, force: o2 = false } = {}) {
        var i2, s2;
        (i2 = this.parentPopper) != null && i2.lockedChild && this.parentPopper.lockedChild !== this || (this.pendingHide = false, (o2 || !this.disabled) && (((s2 = this.parentPopper) == null ? void 0 : s2.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_scheduleShow(e, t), this.$emit("show"), this.$_showFrameLocked = true, requestAnimationFrame(() => {
          this.$_showFrameLocked = false;
        })), this.$emit("update:shown", true));
      },
      hide({ event: e = null, skipDelay: t = false } = {}) {
        var o2;
        if (!this.$_hideInProgress) {
          if (this.shownChildren.size > 0) {
            this.pendingHide = true;
            return;
          }
          if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
            this.parentPopper && (this.parentPopper.lockedChild = this, clearTimeout(this.parentPopper.lockedChildTimer), this.parentPopper.lockedChildTimer = setTimeout(() => {
              this.parentPopper.lockedChild === this && (this.parentPopper.lockedChild.hide({ skipDelay: t }), this.parentPopper.lockedChild = null);
            }, 1e3));
            return;
          }
          ((o2 = this.parentPopper) == null ? void 0 : o2.lockedChild) === this && (this.parentPopper.lockedChild = null), this.pendingHide = false, this.$_scheduleHide(e, t), this.$emit("hide"), this.$emit("update:shown", false);
        }
      },
      init() {
        var _a3;
        var e;
        this.isDisposed && (this.isDisposed = false, this.isMounted = false, this.$_events = [], this.$_preventShow = false, this.$_referenceNode = (_a3 = (e = this.referenceNode) == null ? void 0 : e.call(this)) != null ? _a3 : this.$el, this.$_targetNodes = this.targetNodes().filter((t) => t.nodeType === t.ELEMENT_NODE), this.$_popperNode = this.popperNode(), this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner"), this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container"), this.$_swapTargetAttrs("title", "data-original-title"), this.$_detachPopperNode(), this.triggers.length && this.$_addEventListeners(), this.shown && this.show());
      },
      dispose() {
        this.isDisposed || (this.isDisposed = true, this.$_removeEventListeners(), this.hide({ skipDelay: true }), this.$_detachPopperNode(), this.isMounted = false, this.isShown = false, this.$_updateParentShownChildren(false), this.$_swapTargetAttrs("data-original-title", "title"));
      },
      onResize() {
        return __async(this, null, function* () {
          this.isShown && (yield this.$_computePosition(), this.$emit("resize"));
        });
      },
      $_computePosition() {
        return __async(this, null, function* () {
          var _a3;
          if (this.isDisposed || this.positioningDisabled)
            return;
          const e = {
            strategy: this.strategy,
            middleware: []
          };
          (this.distance || this.skidding) && e.middleware.push(offset({
            mainAxis: this.distance,
            crossAxis: this.skidding
          }));
          const t = this.placement.startsWith("auto");
          if (t ? e.middleware.push(autoPlacement({
            alignment: (_a3 = this.placement.split("-")[1]) != null ? _a3 : ""
          })) : e.placement = this.placement, this.preventOverflow && (this.shift && e.middleware.push(shift({
            padding: this.overflowPadding,
            boundary: this.boundary,
            crossAxis: this.shiftCrossAxis
          })), !t && this.flip && e.middleware.push(flip({
            padding: this.overflowPadding,
            boundary: this.boundary
          }))), e.middleware.push(arrow({
            element: this.$_arrowNode,
            padding: this.arrowPadding
          })), this.arrowOverflow && e.middleware.push({
            name: "arrowOverflow",
            fn: ({ placement: i2, rects: s2, middlewareData: r2 }) => {
              let p2;
              const { centerOffset: a2 } = r2.arrow;
              return i2.startsWith("top") || i2.startsWith("bottom") ? p2 = Math.abs(a2) > s2.reference.width / 2 : p2 = Math.abs(a2) > s2.reference.height / 2, {
                data: {
                  overflow: p2
                }
              };
            }
          }), this.autoMinSize || this.autoSize) {
            const i2 = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
            e.middleware.push({
              name: "autoSize",
              fn: ({ rects: s2, placement: r2, middlewareData: p2 }) => {
                var u2;
                if ((u2 = p2.autoSize) != null && u2.skip)
                  return {};
                let a2, l2;
                return r2.startsWith("top") || r2.startsWith("bottom") ? a2 = s2.reference.width : l2 = s2.reference.height, this.$_innerNode.style[i2 === "min" ? "minWidth" : i2 === "max" ? "maxWidth" : "width"] = a2 != null ? `${a2}px` : null, this.$_innerNode.style[i2 === "min" ? "minHeight" : i2 === "max" ? "maxHeight" : "height"] = l2 != null ? `${l2}px` : null, {
                  data: {
                    skip: true
                  },
                  reset: {
                    rects: true
                  }
                };
              }
            });
          }
          (this.autoMaxSize || this.autoBoundaryMaxSize) && (this.$_innerNode.style.maxWidth = null, this.$_innerNode.style.maxHeight = null, e.middleware.push(size({
            boundary: this.boundary,
            padding: this.overflowPadding,
            apply: ({ availableWidth: i2, availableHeight: s2 }) => {
              this.$_innerNode.style.maxWidth = i2 != null ? `${i2}px` : null, this.$_innerNode.style.maxHeight = s2 != null ? `${s2}px` : null;
            }
          })));
          const o2 = yield B$2(this.$_referenceNode, this.$_popperNode, e);
          Object.assign(this.result, {
            x: o2.x,
            y: o2.y,
            placement: o2.placement,
            strategy: o2.strategy,
            arrow: __spreadValues(__spreadValues({}, o2.middlewareData.arrow), o2.middlewareData.arrowOverflow)
          });
        });
      },
      $_scheduleShow(e, t = false) {
        if (this.$_updateParentShownChildren(true), this.$_hideInProgress = false, clearTimeout(this.$_scheduleTimer), g$1 && this.instantMove && g$1.instantMove && g$1 !== this.parentPopper) {
          g$1.$_applyHide(true), this.$_applyShow(true);
          return;
        }
        t ? this.$_applyShow() : this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
      },
      $_scheduleHide(e, t = false) {
        if (this.shownChildren.size > 0) {
          this.pendingHide = true;
          return;
        }
        this.$_updateParentShownChildren(false), this.$_hideInProgress = true, clearTimeout(this.$_scheduleTimer), this.isShown && (g$1 = this), t ? this.$_applyHide() : this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
      },
      $_computeDelay(e) {
        const t = this.delay;
        return parseInt(t && t[e] || t || 0);
      },
      $_applyShow(e = false) {
        return __async(this, null, function* () {
          clearTimeout(this.$_disposeTimer), clearTimeout(this.$_scheduleTimer), this.skipTransition = e, !this.isShown && (this.$_ensureTeleport(), yield G$2(), yield this.$_computePosition(), yield this.$_applyShowEffect(), this.positioningDisabled || this.$_registerEventListeners([
            ...D$1(this.$_referenceNode),
            ...D$1(this.$_popperNode)
          ], "scroll", () => {
            this.$_computePosition();
          }));
        });
      },
      $_applyShowEffect() {
        return __async(this, null, function* () {
          if (this.$_hideInProgress)
            return;
          if (this.computeTransformOrigin) {
            const t = this.$_referenceNode.getBoundingClientRect(), o2 = this.$_popperNode.querySelector(".v-popper__wrapper"), i2 = o2.parentNode.getBoundingClientRect(), s2 = t.x + t.width / 2 - (i2.left + o2.offsetLeft), r2 = t.y + t.height / 2 - (i2.top + o2.offsetTop);
            this.result.transformOrigin = `${s2}px ${r2}px`;
          }
          this.isShown = true, this.$_applyAttrsToTarget({
            "aria-describedby": this.popperId,
            "data-popper-shown": ""
          });
          const e = this.showGroup;
          if (e) {
            let t;
            for (let o2 = 0; o2 < d.length; o2++)
              t = d[o2], t.showGroup !== e && (t.hide(), t.$emit("close-group"));
          }
          d.push(this), document.body.classList.add("v-popper--some-open");
          for (const t of re$2(this.theme))
            he$2(t).push(this), document.body.classList.add(`v-popper--some-open--${t}`);
          this.$emit("apply-show"), this.classes.showFrom = true, this.classes.showTo = false, this.classes.hideFrom = false, this.classes.hideTo = false, yield G$2(), this.classes.showFrom = false, this.classes.showTo = true, this.noAutoFocus || this.$_popperNode.focus();
        });
      },
      $_applyHide(e = false) {
        return __async(this, null, function* () {
          if (this.shownChildren.size > 0) {
            this.pendingHide = true, this.$_hideInProgress = false;
            return;
          }
          if (clearTimeout(this.$_scheduleTimer), !this.isShown)
            return;
          this.skipTransition = e, de$2(d, this), d.length === 0 && document.body.classList.remove("v-popper--some-open");
          for (const o2 of re$2(this.theme)) {
            const i2 = he$2(o2);
            de$2(i2, this), i2.length === 0 && document.body.classList.remove(`v-popper--some-open--${o2}`);
          }
          g$1 === this && (g$1 = null), this.isShown = false, this.$_applyAttrsToTarget({
            "aria-describedby": void 0,
            "data-popper-shown": void 0
          }), clearTimeout(this.$_disposeTimer);
          const t = this.disposeTimeout;
          t !== null && (this.$_disposeTimer = setTimeout(() => {
            this.$_popperNode && (this.$_detachPopperNode(), this.isMounted = false);
          }, t)), this.$_removeEventListeners("scroll"), this.$emit("apply-hide"), this.classes.showFrom = false, this.classes.showTo = false, this.classes.hideFrom = true, this.classes.hideTo = false, yield G$2(), this.classes.hideFrom = false, this.classes.hideTo = true;
        });
      },
      $_autoShowHide() {
        this.shown ? this.show() : this.hide();
      },
      $_ensureTeleport() {
        if (this.isDisposed)
          return;
        let e = this.container;
        if (typeof e == "string" ? e = window.document.querySelector(e) : e === false && (e = this.$_targetNodes[0].parentNode), !e)
          throw new Error("No container for popover: " + this.container);
        e.appendChild(this.$_popperNode), this.isMounted = true;
      },
      $_addEventListeners() {
        const e = (o2) => {
          this.isShown && !this.$_hideInProgress || (o2.usedByTooltip = true, !this.$_preventShow && this.show({ event: o2 }));
        };
        this.$_registerTriggerListeners(this.$_targetNodes, pe$2, this.triggers, this.showTriggers, e), this.$_registerTriggerListeners([this.$_popperNode], pe$2, this.popperTriggers, this.popperShowTriggers, e);
        const t = (o2) => {
          o2.usedByTooltip || this.hide({ event: o2 });
        };
        this.$_registerTriggerListeners(this.$_targetNodes, ae$1, this.triggers, this.hideTriggers, t), this.$_registerTriggerListeners([this.$_popperNode], ae$1, this.popperTriggers, this.popperHideTriggers, t);
      },
      $_registerEventListeners(e, t, o2) {
        this.$_events.push({ targetNodes: e, eventType: t, handler: o2 }), e.forEach((i2) => i2.addEventListener(t, o2, $$1 ? {
          passive: true
        } : void 0));
      },
      $_registerTriggerListeners(e, t, o2, i2, s2) {
        let r2 = o2;
        i2 != null && (r2 = typeof i2 == "function" ? i2(r2) : i2), r2.forEach((p2) => {
          const a2 = t[p2];
          a2 && this.$_registerEventListeners(e, a2, s2);
        });
      },
      $_removeEventListeners(e) {
        const t = [];
        this.$_events.forEach((o2) => {
          const { targetNodes: i2, eventType: s2, handler: r2 } = o2;
          !e || e === s2 ? i2.forEach((p2) => p2.removeEventListener(s2, r2)) : t.push(o2);
        }), this.$_events = t;
      },
      $_refreshListeners() {
        this.isDisposed || (this.$_removeEventListeners(), this.$_addEventListeners());
      },
      $_handleGlobalClose(e, t = false) {
        this.$_showFrameLocked || (this.hide({ event: e }), e.closePopover ? this.$emit("close-directive") : this.$emit("auto-hide"), t && (this.$_preventShow = true, setTimeout(() => {
          this.$_preventShow = false;
        }, 300)));
      },
      $_detachPopperNode() {
        this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
      },
      $_swapTargetAttrs(e, t) {
        for (const o2 of this.$_targetNodes) {
          const i2 = o2.getAttribute(e);
          i2 && (o2.removeAttribute(e), o2.setAttribute(t, i2));
        }
      },
      $_applyAttrsToTarget(e) {
        for (const t of this.$_targetNodes)
          for (const o2 in e) {
            const i2 = e[o2];
            i2 == null ? t.removeAttribute(o2) : t.setAttribute(o2, i2);
          }
      },
      $_updateParentShownChildren(e) {
        let t = this.parentPopper;
        for (; t; )
          e ? t.shownChildren.add(this.randomId) : (t.shownChildren.delete(this.randomId), t.pendingHide && t.hide()), t = t.parentPopper;
      },
      $_isAimingPopper() {
        const e = this.$_referenceNode.getBoundingClientRect();
        if (y >= e.left && y <= e.right && _ >= e.top && _ <= e.bottom) {
          const t = this.$_popperNode.getBoundingClientRect(), o2 = y - c$1, i2 = _ - m$1, r2 = t.left + t.width / 2 - c$1 + (t.top + t.height / 2) - m$1 + t.width + t.height, p2 = c$1 + o2 * r2, a2 = m$1 + i2 * r2;
          return C$2(c$1, m$1, p2, a2, t.left, t.top, t.left, t.bottom) || // Left edge
          C$2(c$1, m$1, p2, a2, t.left, t.top, t.right, t.top) || // Top edge
          C$2(c$1, m$1, p2, a2, t.right, t.top, t.right, t.bottom) || // Right edge
          C$2(c$1, m$1, p2, a2, t.left, t.bottom, t.right, t.bottom);
        }
        return false;
      }
    },
    render() {
      return this.$slots.default(this.slotData);
    }
  });
  if (typeof document < "u" && typeof window < "u") {
    if (_e$2) {
      const e = $$1 ? {
        passive: true,
        capture: true
      } : true;
      document.addEventListener("touchstart", (t) => ue$2(t, true), e), document.addEventListener("touchend", (t) => fe$2(t, true), e);
    } else
      window.addEventListener("mousedown", (e) => ue$2(e, false), true), window.addEventListener("click", (e) => fe$2(e, false), true);
    window.addEventListener("resize", tt$1);
  }
  function ue$2(e, t) {
    if (h$2.autoHideOnMousedown)
      Pe$1(e, t);
    else
      for (let o2 = 0; o2 < d.length; o2++) {
        const i2 = d[o2];
        try {
          i2.mouseDownContains = i2.popperNode().contains(e.target);
        } catch (e2) {
        }
      }
  }
  function fe$2(e, t) {
    h$2.autoHideOnMousedown || Pe$1(e, t);
  }
  function Pe$1(e, t) {
    const o2 = {};
    for (let i2 = d.length - 1; i2 >= 0; i2--) {
      const s2 = d[i2];
      try {
        const r2 = s2.containsGlobalTarget = s2.mouseDownContains || s2.popperNode().contains(e.target);
        s2.pendingHide = false, requestAnimationFrame(() => {
          if (s2.pendingHide = false, !o2[s2.randomId] && ce$1(s2, r2, e)) {
            if (s2.$_handleGlobalClose(e, t), !e.closeAllPopover && e.closePopover && r2) {
              let a2 = s2.parentPopper;
              for (; a2; )
                o2[a2.randomId] = true, a2 = a2.parentPopper;
              return;
            }
            let p2 = s2.parentPopper;
            for (; p2 && ce$1(p2, p2.containsGlobalTarget, e); ) {
              p2.$_handleGlobalClose(e, t);
              p2 = p2.parentPopper;
            }
          }
        });
      } catch (e2) {
      }
    }
  }
  function ce$1(e, t, o2) {
    return o2.closeAllPopover || o2.closePopover && t || et$1(e, o2) && !t;
  }
  function et$1(e, t) {
    if (typeof e.autoHide == "function") {
      const o2 = e.autoHide(t);
      return e.lastAutoHide = o2, o2;
    }
    return e.autoHide;
  }
  function tt$1() {
    for (let e = 0; e < d.length; e++)
      d[e].$_computePosition();
  }
  let c$1 = 0, m$1 = 0, y = 0, _ = 0;
  typeof window < "u" && window.addEventListener("mousemove", (e) => {
    c$1 = y, m$1 = _, y = e.clientX, _ = e.clientY;
  }, $$1 ? {
    passive: true
  } : void 0);
  function C$2(e, t, o2, i2, s2, r2, p2, a2) {
    const l2 = ((p2 - s2) * (t - r2) - (a2 - r2) * (e - s2)) / ((a2 - r2) * (o2 - e) - (p2 - s2) * (i2 - t)), u2 = ((o2 - e) * (t - r2) - (i2 - t) * (e - s2)) / ((a2 - r2) * (o2 - e) - (p2 - s2) * (i2 - t));
    return l2 >= 0 && l2 <= 1 && u2 >= 0 && u2 <= 1;
  }
  const ot$1 = {
    extends: Q$1()
  }, B$1 = (e, t) => {
    const o2 = e.__vccOpts || e;
    for (const [i2, s2] of t)
      o2[i2] = s2;
    return o2;
  };
  function it(e, t, o2, i2, s2, r2) {
    return openBlock(), createElementBlock("div", {
      ref: "reference",
      class: normalizeClass(["v-popper", {
        "v-popper--shown": e.slotData.isShown
      }])
    }, [
      renderSlot(e.$slots, "default", normalizeProps(guardReactiveProps(e.slotData)))
    ], 2);
  }
  const st$1 = /* @__PURE__ */ B$1(ot$1, [["render", it]]);
  function nt$1() {
    var e = window.navigator.userAgent, t = e.indexOf("MSIE ");
    if (t > 0)
      return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
    var o2 = e.indexOf("Trident/");
    if (o2 > 0) {
      var i2 = e.indexOf("rv:");
      return parseInt(e.substring(i2 + 3, e.indexOf(".", i2)), 10);
    }
    var s2 = e.indexOf("Edge/");
    return s2 > 0 ? parseInt(e.substring(s2 + 5, e.indexOf(".", s2)), 10) : -1;
  }
  let z;
  function X$2() {
    X$2.init || (X$2.init = true, z = nt$1() !== -1);
  }
  var E$1 = {
    name: "ResizeObserver",
    props: {
      emitOnMount: {
        type: Boolean,
        default: false
      },
      ignoreWidth: {
        type: Boolean,
        default: false
      },
      ignoreHeight: {
        type: Boolean,
        default: false
      }
    },
    emits: [
      "notify"
    ],
    mounted() {
      X$2(), nextTick(() => {
        this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize();
      });
      const e = document.createElement("object");
      this._resizeObject = e, e.setAttribute("aria-hidden", "true"), e.setAttribute("tabindex", -1), e.onload = this.addResizeHandlers, e.type = "text/html", z && this.$el.appendChild(e), e.data = "about:blank", z || this.$el.appendChild(e);
    },
    beforeUnmount() {
      this.removeResizeHandlers();
    },
    methods: {
      compareAndNotify() {
        (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize());
      },
      emitSize() {
        this.$emit("notify", {
          width: this._w,
          height: this._h
        });
      },
      addResizeHandlers() {
        this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify), this.compareAndNotify();
      },
      removeResizeHandlers() {
        this._resizeObject && this._resizeObject.onload && (!z && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null);
      }
    }
  };
  const rt$1 = /* @__PURE__ */ withScopeId();
  pushScopeId("data-v-b329ee4c");
  const pt$1 = {
    class: "resize-observer",
    tabindex: "-1"
  };
  popScopeId();
  const at$1 = /* @__PURE__ */ rt$1((e, t, o2, i2, s2, r2) => (openBlock(), createBlock("div", pt$1)));
  E$1.render = at$1;
  E$1.__scopeId = "data-v-b329ee4c";
  E$1.__file = "src/components/ResizeObserver.vue";
  const Z$2 = (e = "theme") => ({
    computed: {
      themeClass() {
        return Ze$1(this[e]);
      }
    }
  }), dt$1 = /* @__PURE__ */ defineComponent({
    name: "VPopperContent",
    components: {
      ResizeObserver: E$1
    },
    mixins: [
      Z$2()
    ],
    props: {
      popperId: String,
      theme: String,
      shown: Boolean,
      mounted: Boolean,
      skipTransition: Boolean,
      autoHide: Boolean,
      handleResize: Boolean,
      classes: Object,
      result: Object
    },
    emits: [
      "hide",
      "resize"
    ],
    methods: {
      toPx(e) {
        return e != null && !isNaN(e) ? `${e}px` : null;
      }
    }
  }), lt$1 = ["id", "aria-hidden", "tabindex", "data-popper-placement"], ht$1 = {
    ref: "inner",
    class: "v-popper__inner"
  }, ut$1 = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-outer" }, null, -1), ft = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-inner" }, null, -1), ct$1 = [
    ut$1,
    ft
  ];
  function mt$1(e, t, o2, i2, s2, r2) {
    const p2 = resolveComponent("ResizeObserver");
    return openBlock(), createElementBlock("div", {
      id: e.popperId,
      ref: "popover",
      class: normalizeClass(["v-popper__popper", [
        e.themeClass,
        e.classes.popperClass,
        {
          "v-popper__popper--shown": e.shown,
          "v-popper__popper--hidden": !e.shown,
          "v-popper__popper--show-from": e.classes.showFrom,
          "v-popper__popper--show-to": e.classes.showTo,
          "v-popper__popper--hide-from": e.classes.hideFrom,
          "v-popper__popper--hide-to": e.classes.hideTo,
          "v-popper__popper--skip-transition": e.skipTransition,
          "v-popper__popper--arrow-overflow": e.result && e.result.arrow.overflow,
          "v-popper__popper--no-positioning": !e.result
        }
      ]]),
      style: normalizeStyle(e.result ? {
        position: e.result.strategy,
        transform: `translate3d(${Math.round(e.result.x)}px,${Math.round(e.result.y)}px,0)`
      } : void 0),
      "aria-hidden": e.shown ? "false" : "true",
      tabindex: e.autoHide ? 0 : void 0,
      "data-popper-placement": e.result ? e.result.placement : void 0,
      onKeyup: t[2] || (t[2] = withKeys((a2) => e.autoHide && e.$emit("hide"), ["esc"]))
    }, [
      createBaseVNode("div", {
        class: "v-popper__backdrop",
        onClick: t[0] || (t[0] = (a2) => e.autoHide && e.$emit("hide"))
      }),
      createBaseVNode("div", {
        class: "v-popper__wrapper",
        style: normalizeStyle(e.result ? {
          transformOrigin: e.result.transformOrigin
        } : void 0)
      }, [
        createBaseVNode("div", ht$1, [
          e.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", null, [
              renderSlot(e.$slots, "default")
            ]),
            e.handleResize ? (openBlock(), createBlock(p2, {
              key: 0,
              onNotify: t[1] || (t[1] = (a2) => e.$emit("resize", a2))
            })) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true)
        ], 512),
        createBaseVNode("div", {
          ref: "arrow",
          class: "v-popper__arrow-container",
          style: normalizeStyle(e.result ? {
            left: e.toPx(e.result.arrow.x),
            top: e.toPx(e.result.arrow.y)
          } : void 0)
        }, ct$1, 4)
      ], 4)
    ], 46, lt$1);
  }
  const ee$2 = /* @__PURE__ */ B$1(dt$1, [["render", mt$1]]), te$2 = {
    methods: {
      show(...e) {
        return this.$refs.popper.show(...e);
      },
      hide(...e) {
        return this.$refs.popper.hide(...e);
      },
      dispose(...e) {
        return this.$refs.popper.dispose(...e);
      },
      onResize(...e) {
        return this.$refs.popper.onResize(...e);
      }
    }
  };
  let K$1 = function() {
  };
  typeof window < "u" && (K$1 = window.Element);
  const gt = /* @__PURE__ */ defineComponent({
    name: "VPopperWrapper",
    components: {
      Popper: st$1,
      PopperContent: ee$2
    },
    mixins: [
      te$2,
      Z$2("finalTheme")
    ],
    props: {
      theme: {
        type: String,
        default: null
      },
      referenceNode: {
        type: Function,
        default: null
      },
      shown: {
        type: Boolean,
        default: false
      },
      showGroup: {
        type: String,
        default: null
      },
      // eslint-disable-next-line vue/require-prop-types
      ariaId: {
        default: null
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      positioningDisabled: {
        type: Boolean,
        default: void 0
      },
      placement: {
        type: String,
        default: void 0
      },
      delay: {
        type: [String, Number, Object],
        default: void 0
      },
      distance: {
        type: [Number, String],
        default: void 0
      },
      skidding: {
        type: [Number, String],
        default: void 0
      },
      triggers: {
        type: Array,
        default: void 0
      },
      showTriggers: {
        type: [Array, Function],
        default: void 0
      },
      hideTriggers: {
        type: [Array, Function],
        default: void 0
      },
      popperTriggers: {
        type: Array,
        default: void 0
      },
      popperShowTriggers: {
        type: [Array, Function],
        default: void 0
      },
      popperHideTriggers: {
        type: [Array, Function],
        default: void 0
      },
      container: {
        type: [String, Object, K$1, Boolean],
        default: void 0
      },
      boundary: {
        type: [String, K$1],
        default: void 0
      },
      strategy: {
        type: String,
        default: void 0
      },
      autoHide: {
        type: [Boolean, Function],
        default: void 0
      },
      handleResize: {
        type: Boolean,
        default: void 0
      },
      instantMove: {
        type: Boolean,
        default: void 0
      },
      eagerMount: {
        type: Boolean,
        default: void 0
      },
      popperClass: {
        type: [String, Array, Object],
        default: void 0
      },
      computeTransformOrigin: {
        type: Boolean,
        default: void 0
      },
      /**
       * @deprecated
       */
      autoMinSize: {
        type: Boolean,
        default: void 0
      },
      autoSize: {
        type: [Boolean, String],
        default: void 0
      },
      /**
       * @deprecated
       */
      autoMaxSize: {
        type: Boolean,
        default: void 0
      },
      autoBoundaryMaxSize: {
        type: Boolean,
        default: void 0
      },
      preventOverflow: {
        type: Boolean,
        default: void 0
      },
      overflowPadding: {
        type: [Number, String],
        default: void 0
      },
      arrowPadding: {
        type: [Number, String],
        default: void 0
      },
      arrowOverflow: {
        type: Boolean,
        default: void 0
      },
      flip: {
        type: Boolean,
        default: void 0
      },
      shift: {
        type: Boolean,
        default: void 0
      },
      shiftCrossAxis: {
        type: Boolean,
        default: void 0
      },
      noAutoFocus: {
        type: Boolean,
        default: void 0
      },
      disposeTimeout: {
        type: Number,
        default: void 0
      }
    },
    emits: {
      show: () => true,
      hide: () => true,
      "update:shown": (e) => true,
      "apply-show": () => true,
      "apply-hide": () => true,
      "close-group": () => true,
      "close-directive": () => true,
      "auto-hide": () => true,
      resize: () => true
    },
    computed: {
      finalTheme() {
        var _a2;
        return (_a2 = this.theme) != null ? _a2 : this.$options.vPopperTheme;
      }
    },
    methods: {
      getTargetNodes() {
        return Array.from(this.$el.children).filter((e) => e !== this.$refs.popperContent.$el);
      }
    }
  });
  function wt$1(e, t, o2, i2, s2, r2) {
    const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
    return openBlock(), createBlock(a2, mergeProps({ ref: "popper" }, e.$props, {
      theme: e.finalTheme,
      "target-nodes": e.getTargetNodes,
      "popper-node": () => e.$refs.popperContent.$el,
      class: [
        e.themeClass
      ],
      onShow: t[0] || (t[0] = () => e.$emit("show")),
      onHide: t[1] || (t[1] = () => e.$emit("hide")),
      "onUpdate:shown": t[2] || (t[2] = (l2) => e.$emit("update:shown", l2)),
      onApplyShow: t[3] || (t[3] = () => e.$emit("apply-show")),
      onApplyHide: t[4] || (t[4] = () => e.$emit("apply-hide")),
      onCloseGroup: t[5] || (t[5] = () => e.$emit("close-group")),
      onCloseDirective: t[6] || (t[6] = () => e.$emit("close-directive")),
      onAutoHide: t[7] || (t[7] = () => e.$emit("auto-hide")),
      onResize: t[8] || (t[8] = () => e.$emit("resize"))
    }), {
      default: withCtx(({
        popperId: l2,
        isShown: u2,
        shouldMountContent: L2,
        skipTransition: D2,
        autoHide: I2,
        show: F2,
        hide: v2,
        handleResize: R2,
        onResize: j2,
        classes: V2,
        result: Ee2
      }) => [
        renderSlot(e.$slots, "default", {
          shown: u2,
          show: F2,
          hide: v2
        }),
        createVNode(p2, {
          ref: "popperContent",
          "popper-id": l2,
          theme: e.finalTheme,
          shown: u2,
          mounted: L2,
          "skip-transition": D2,
          "auto-hide": I2,
          "handle-resize": R2,
          classes: V2,
          result: Ee2,
          onHide: v2,
          onResize: j2
        }, {
          default: withCtx(() => [
            renderSlot(e.$slots, "popper", {
              shown: u2,
              hide: v2
            })
          ]),
          _: 2
        }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
      ]),
      _: 3
    }, 16, ["theme", "target-nodes", "popper-node", "class"]);
  }
  const k = /* @__PURE__ */ B$1(gt, [["render", wt$1]]), Se$1 = __spreadProps(__spreadValues({}, k), {
    name: "VDropdown",
    vPopperTheme: "dropdown"
  }), be$2 = __spreadProps(__spreadValues({}, k), {
    name: "VMenu",
    vPopperTheme: "menu"
  }), Ce$2 = __spreadProps(__spreadValues({}, k), {
    name: "VTooltip",
    vPopperTheme: "tooltip"
  }), $t$1 = /* @__PURE__ */ defineComponent({
    name: "VTooltipDirective",
    components: {
      Popper: Q$1(),
      PopperContent: ee$2
    },
    mixins: [
      te$2
    ],
    inheritAttrs: false,
    props: {
      theme: {
        type: String,
        default: "tooltip"
      },
      html: {
        type: Boolean,
        default: (e) => S$2(e.theme, "html")
      },
      content: {
        type: [String, Number, Function],
        default: null
      },
      loadingContent: {
        type: String,
        default: (e) => S$2(e.theme, "loadingContent")
      },
      targetNodes: {
        type: Function,
        required: true
      }
    },
    data() {
      return {
        asyncContent: null
      };
    },
    computed: {
      isContentAsync() {
        return typeof this.content == "function";
      },
      loading() {
        return this.isContentAsync && this.asyncContent == null;
      },
      finalContent() {
        return this.isContentAsync ? this.loading ? this.loadingContent : this.asyncContent : this.content;
      }
    },
    watch: {
      content: {
        handler() {
          this.fetchContent(true);
        },
        immediate: true
      },
      finalContent() {
        return __async(this, null, function* () {
          yield this.$nextTick(), this.$refs.popper.onResize();
        });
      }
    },
    created() {
      this.$_fetchId = 0;
    },
    methods: {
      fetchContent(e) {
        if (typeof this.content == "function" && this.$_isShown && (e || !this.$_loading && this.asyncContent == null)) {
          this.asyncContent = null, this.$_loading = true;
          const t = ++this.$_fetchId, o2 = this.content(this);
          o2.then ? o2.then((i2) => this.onResult(t, i2)) : this.onResult(t, o2);
        }
      },
      onResult(e, t) {
        e === this.$_fetchId && (this.$_loading = false, this.asyncContent = t);
      },
      onShow() {
        this.$_isShown = true, this.fetchContent();
      },
      onHide() {
        this.$_isShown = false;
      }
    }
  }), vt$1 = ["innerHTML"], yt = ["textContent"];
  function _t$1(e, t, o2, i2, s2, r2) {
    const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
    return openBlock(), createBlock(a2, mergeProps({ ref: "popper" }, e.$attrs, {
      theme: e.theme,
      "target-nodes": e.targetNodes,
      "popper-node": () => e.$refs.popperContent.$el,
      onApplyShow: e.onShow,
      onApplyHide: e.onHide
    }), {
      default: withCtx(({
        popperId: l2,
        isShown: u2,
        shouldMountContent: L2,
        skipTransition: D2,
        autoHide: I2,
        hide: F2,
        handleResize: v2,
        onResize: R2,
        classes: j2,
        result: V2
      }) => [
        createVNode(p2, {
          ref: "popperContent",
          class: normalizeClass({
            "v-popper--tooltip-loading": e.loading
          }),
          "popper-id": l2,
          theme: e.theme,
          shown: u2,
          mounted: L2,
          "skip-transition": D2,
          "auto-hide": I2,
          "handle-resize": v2,
          classes: j2,
          result: V2,
          onHide: F2,
          onResize: R2
        }, {
          default: withCtx(() => [
            e.html ? (openBlock(), createElementBlock("div", {
              key: 0,
              innerHTML: e.finalContent
            }, null, 8, vt$1)) : (openBlock(), createElementBlock("div", {
              key: 1,
              textContent: toDisplayString(e.finalContent)
            }, null, 8, yt))
          ]),
          _: 2
        }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
      ]),
      _: 1
    }, 16, ["theme", "target-nodes", "popper-node", "onApplyShow", "onApplyHide"]);
  }
  const ze$1 = /* @__PURE__ */ B$1($t$1, [["render", _t$1]]), Ae$1 = "v-popper--has-tooltip";
  function Tt$1(e, t) {
    let o2 = e.placement;
    if (!o2 && t)
      for (const i2 of Te$1)
        t[i2] && (o2 = i2);
    return o2 || (o2 = S$2(e.theme || "tooltip", "placement")), o2;
  }
  function Ne$1(e, t, o2) {
    let i2;
    const s2 = typeof t;
    return s2 === "string" ? i2 = { content: t } : t && s2 === "object" ? i2 = t : i2 = { content: false }, i2.placement = Tt$1(i2, o2), i2.targetNodes = () => [e], i2.referenceNode = () => e, i2;
  }
  let x$1, b$1, Pt$1 = 0;
  function St$1() {
    if (x$1)
      return;
    b$1 = ref([]), x$1 = createApp({
      name: "VTooltipDirectiveApp",
      setup() {
        return {
          directives: b$1
        };
      },
      render() {
        return this.directives.map((t) => h$4(ze$1, __spreadProps(__spreadValues({}, t.options), {
          shown: t.shown || t.options.shown,
          key: t.id
        })));
      },
      devtools: {
        hide: true
      }
    });
    const e = document.createElement("div");
    document.body.appendChild(e), x$1.mount(e);
  }
  function bt$1(e, t, o2) {
    St$1();
    const i2 = ref(Ne$1(e, t, o2)), s2 = ref(false), r2 = {
      id: Pt$1++,
      options: i2,
      shown: s2
    };
    return b$1.value.push(r2), e.classList && e.classList.add(Ae$1), e.$_popper = {
      options: i2,
      item: r2,
      show() {
        s2.value = true;
      },
      hide() {
        s2.value = false;
      }
    };
  }
  function He$1(e) {
    if (e.$_popper) {
      const t = b$1.value.indexOf(e.$_popper.item);
      t !== -1 && b$1.value.splice(t, 1), delete e.$_popper, delete e.$_popperOldShown, delete e.$_popperMountTarget;
    }
    e.classList && e.classList.remove(Ae$1);
  }
  function me$2(e, { value: t, modifiers: o2 }) {
    const i2 = Ne$1(e, t, o2);
    if (!i2.content || S$2(i2.theme || "tooltip", "disabled"))
      He$1(e);
    else {
      let s2;
      e.$_popper ? (s2 = e.$_popper, s2.options.value = i2) : s2 = bt$1(e, t, o2), typeof t.shown < "u" && t.shown !== e.$_popperOldShown && (e.$_popperOldShown = t.shown, t.shown ? s2.show() : s2.hide());
    }
  }
  const oe$2 = {
    beforeMount: me$2,
    updated: me$2,
    beforeUnmount(e) {
      He$1(e);
    }
  };
  function ge$2(e) {
    e.addEventListener("mousedown", H$1), e.addEventListener("click", H$1), e.addEventListener("touchstart", Oe$2, $$1 ? {
      passive: true
    } : false);
  }
  function we$2(e) {
    e.removeEventListener("mousedown", H$1), e.removeEventListener("click", H$1), e.removeEventListener("touchstart", Oe$2), e.removeEventListener("touchend", Me$1), e.removeEventListener("touchcancel", Be$1);
  }
  function H$1(e) {
    const t = e.currentTarget;
    e.closePopover = !t.$_vclosepopover_touch, e.closeAllPopover = t.$_closePopoverModifiers && !!t.$_closePopoverModifiers.all;
  }
  function Oe$2(e) {
    if (e.changedTouches.length === 1) {
      const t = e.currentTarget;
      t.$_vclosepopover_touch = true;
      const o2 = e.changedTouches[0];
      t.$_vclosepopover_touchPoint = o2, t.addEventListener("touchend", Me$1), t.addEventListener("touchcancel", Be$1);
    }
  }
  function Me$1(e) {
    const t = e.currentTarget;
    if (t.$_vclosepopover_touch = false, e.changedTouches.length === 1) {
      const o2 = e.changedTouches[0], i2 = t.$_vclosepopover_touchPoint;
      e.closePopover = Math.abs(o2.screenY - i2.screenY) < 20 && Math.abs(o2.screenX - i2.screenX) < 20, e.closeAllPopover = t.$_closePopoverModifiers && !!t.$_closePopoverModifiers.all;
    }
  }
  function Be$1(e) {
    const t = e.currentTarget;
    t.$_vclosepopover_touch = false;
  }
  const ie$2 = {
    beforeMount(e, { value: t, modifiers: o2 }) {
      e.$_closePopoverModifiers = o2, (typeof t > "u" || t) && ge$2(e);
    },
    updated(e, { value: t, oldValue: o2, modifiers: i2 }) {
      e.$_closePopoverModifiers = i2, t !== o2 && (typeof t > "u" || t ? ge$2(e) : we$2(e));
    },
    beforeUnmount(e) {
      we$2(e);
    }
  };
  function Ct$1(e, t = {}) {
    e.$_vTooltipInstalled || (e.$_vTooltipInstalled = true, ye$2(h$2, t), e.directive("tooltip", oe$2), e.directive("close-popper", ie$2), e.component("VTooltip", Ce$2), e.component("VDropdown", Se$1), e.component("VMenu", be$2));
  }
  const Gt$1 = {
    // eslint-disable-next-line no-undef
    version: "5.2.2",
    install: Ct$1,
    options: h$2
  };
  var b = { name: "Toggle", emits: ["input", "update:modelValue", "change"], props: __spreadProps(__spreadValues({}, { value: { validator: function(e) {
    return (e2) => -1 !== ["number", "string", "boolean"].indexOf(typeof e2) || null == e2;
  }, required: false }, modelValue: { validator: function(e) {
    return (e2) => -1 !== ["number", "string", "boolean"].indexOf(typeof e2) || null == e2;
  }, required: false } }), { id: { type: [String, Number], required: false, default: "toggle" }, name: { type: [String, Number], required: false, default: "toggle" }, disabled: { type: Boolean, required: false, default: false }, required: { type: Boolean, required: false, default: false }, falseValue: { type: [String, Number, Boolean], required: false, default: false }, trueValue: { type: [String, Number, Boolean], required: false, default: true }, onLabel: { type: [String, Object], required: false, default: "" }, offLabel: { type: [String, Object], required: false, default: "" }, classes: { type: Object, required: false, default: () => ({}) }, labelledby: { type: String, required: false }, describedby: { type: String, required: false }, aria: { required: false, type: Object, default: () => ({}) } }), setup(a2, d2) {
    const n2 = (function(a3, d3, n3) {
      const { value: t2, modelValue: u3, falseValue: i3, trueValue: c2, disabled: r2 } = toRefs(a3), o2 = u3 && void 0 !== u3.value ? u3 : t2, s2 = computed((() => o2.value === c2.value)), g2 = (e) => {
        d3.emit("input", e), d3.emit("update:modelValue", e), d3.emit("change", e);
      }, b2 = () => {
        g2(c2.value);
      }, f2 = () => {
        g2(i3.value);
      };
      return -1 !== [null, void 0, false, 0, "0", "off"].indexOf(o2.value) && -1 === [i3.value, c2.value].indexOf(o2.value) && f2(), -1 !== [true, 1, "1", "on"].indexOf(o2.value) && -1 === [i3.value, c2.value].indexOf(o2.value) && b2(), { externalValue: o2, checked: s2, update: g2, check: b2, uncheck: f2, handleInput: (e) => {
        g2(e.target.checked ? c2.value : i3.value);
      }, handleClick: () => {
        r2.value || (s2.value ? f2() : b2());
      } };
    })(a2, d2), t = (function(a3, d3, n3) {
      const { trueValue: t2, falseValue: u3, onLabel: i3, offLabel: c2 } = toRefs(a3), r2 = n3.checked, o2 = n3.update;
      return { label: computed((() => {
        let e = r2.value ? i3.value : c2.value;
        return e || (e = "&nbsp;"), e;
      })), toggle: () => {
        o2(r2.value ? u3.value : t2.value);
      }, on: () => {
        o2(t2.value);
      }, off: () => {
        o2(u3.value);
      } };
    })(a2, 0, { checked: n2.checked, update: n2.update }), u2 = (function(a3, d3, n3) {
      const t2 = toRefs(a3), u3 = t2.disabled, i3 = n3.checked, c2 = computed((() => __spreadValues({ container: "toggle-container", toggle: "toggle", toggleOn: "toggle-on", toggleOff: "toggle-off", toggleOnDisabled: "toggle-on-disabled", toggleOffDisabled: "toggle-off-disabled", handle: "toggle-handle", handleOn: "toggle-handle-on", handleOff: "toggle-handle-off", handleOnDisabled: "toggle-handle-on-disabled", handleOffDisabled: "toggle-handle-off-disabled", label: "toggle-label" }, t2.classes.value)));
      return { classList: computed((() => ({ container: c2.value.container, toggle: [c2.value.toggle, u3.value ? i3.value ? c2.value.toggleOnDisabled : c2.value.toggleOffDisabled : i3.value ? c2.value.toggleOn : c2.value.toggleOff], handle: [c2.value.handle, u3.value ? i3.value ? c2.value.handleOnDisabled : c2.value.handleOffDisabled : i3.value ? c2.value.handleOn : c2.value.handleOff], label: c2.value.label }))) };
    })(a2, 0, { checked: n2.checked }), i2 = (function(l2, a3, d3) {
      const { disabled: n3 } = toRefs(l2), t2 = d3.check, u3 = d3.uncheck, i3 = d3.checked;
      return { handleSpace: () => {
        n3.value || (i3.value ? u3() : t2());
      } };
    })(a2, 0, { check: n2.check, uncheck: n2.uncheck, checked: n2.checked });
    return __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, n2), u2), t), i2);
  } };
  const f$1 = ["tabindex", "aria-checked", "aria-describedby", "aria-labelledby"], h$1 = ["id", "name", "value", "checked", "disabled"], v = ["innerHTML"], p$1 = ["checked"];
  b.render = function(e, l2, b2, k2, y2, O2) {
    return openBlock(), createElementBlock("div", mergeProps({ class: e.classList.container, tabindex: b2.disabled ? void 0 : 0, "aria-checked": e.checked, "aria-describedby": b2.describedby, "aria-labelledby": b2.labelledby, role: "switch" }, b2.aria, { onKeypress: l2[1] || (l2[1] = withKeys(withModifiers(((...l3) => e.handleSpace && e.handleSpace(...l3)), ["prevent"]), ["space"])) }), [withDirectives(createBaseVNode("input", { type: "checkbox", id: b2.id, name: b2.name, value: b2.trueValue, checked: e.checked, disabled: b2.disabled }, null, 8, h$1), [[vShow, false]]), createBaseVNode("div", { class: normalizeClass(e.classList.toggle), onClick: l2[0] || (l2[0] = (...l3) => e.handleClick && e.handleClick(...l3)) }, [createBaseVNode("span", { class: normalizeClass(e.classList.handle) }, null, 2), renderSlot(e.$slots, "label", { checked: e.checked, classList: e.classList }, (() => [createBaseVNode("span", { class: normalizeClass(e.classList.label), innerHTML: e.label }, null, 10, v)])), b2.required ? (openBlock(), createElementBlock("input", { key: 0, type: "checkbox", style: { appearance: "none", height: "1px", margin: "0", padding: "0", fontSize: "0", background: "transparent", position: "absolute", width: "100%", bottom: "0", outline: "none" }, checked: e.checked, "aria-hidden": "true", tabindex: "-1", required: "" }, null, 8, p$1)) : createCommentVNode("v-if", true)], 2)], 16, f$1);
  }, b.__file = "src/Toggle.vue";
  var E = Object.defineProperty, M$1 = Object.defineProperties;
  var x = Object.getOwnPropertyDescriptors;
  var V$1 = Object.getOwnPropertySymbols;
  var I$1 = Object.prototype.hasOwnProperty, N = Object.prototype.propertyIsEnumerable;
  var C$1 = (e, t, s2) => t in e ? E(e, t, { enumerable: true, configurable: true, writable: true, value: s2 }) : e[t] = s2, f = (e, t) => {
    for (var s2 in t || (t = {}))
      I$1.call(t, s2) && C$1(e, s2, t[s2]);
    if (V$1)
      for (var s2 of V$1(t))
        N.call(t, s2) && C$1(e, s2, t[s2]);
    return e;
  }, m = (e, t) => M$1(e, x(t));
  const U = {
    props: {
      autoscroll: {
        type: Boolean,
        default: true
      }
    },
    watch: {
      typeAheadPointer() {
        this.autoscroll && this.maybeAdjustScroll();
      },
      open(e) {
        this.autoscroll && e && this.$nextTick(() => this.maybeAdjustScroll());
      }
    },
    methods: {
      maybeAdjustScroll() {
        var t;
        const e = ((t = this.$refs.dropdownMenu) == null ? void 0 : t.children[this.typeAheadPointer]) || false;
        if (e) {
          const s2 = this.getDropdownViewport(), { top: n2, bottom: l2, height: i2 } = e.getBoundingClientRect();
          if (n2 < s2.top)
            return this.$refs.dropdownMenu.scrollTop = e.offsetTop;
          if (l2 > s2.bottom)
            return this.$refs.dropdownMenu.scrollTop = e.offsetTop - (s2.height - i2);
        }
      },
      getDropdownViewport() {
        return this.$refs.dropdownMenu ? this.$refs.dropdownMenu.getBoundingClientRect() : {
          height: 0,
          top: 0,
          bottom: 0
        };
      }
    }
  }, q$1 = {
    data() {
      return {
        typeAheadPointer: -1
      };
    },
    watch: {
      filteredOptions() {
        for (let e = 0; e < this.filteredOptions.length; e++)
          if (this.selectable(this.filteredOptions[e])) {
            this.typeAheadPointer = e;
            break;
          }
      },
      open(e) {
        e && this.typeAheadToLastSelected();
      },
      selectedValue() {
        this.open && this.typeAheadToLastSelected();
      }
    },
    methods: {
      typeAheadUp() {
        for (let e = this.typeAheadPointer - 1; e >= 0; e--)
          if (this.selectable(this.filteredOptions[e])) {
            this.typeAheadPointer = e;
            break;
          }
      },
      typeAheadDown() {
        for (let e = this.typeAheadPointer + 1; e < this.filteredOptions.length; e++)
          if (this.selectable(this.filteredOptions[e])) {
            this.typeAheadPointer = e;
            break;
          }
      },
      typeAheadSelect() {
        const e = this.filteredOptions[this.typeAheadPointer];
        e && this.selectable(e) && this.select(e);
      },
      typeAheadToLastSelected() {
        this.typeAheadPointer = this.selectedValue.length !== 0 ? this.filteredOptions.indexOf(this.selectedValue[this.selectedValue.length - 1]) : -1;
      }
    }
  }, J$1 = {
    props: {
      loading: {
        type: Boolean,
        default: false
      }
    },
    data() {
      return {
        mutableLoading: false
      };
    },
    watch: {
      search() {
        this.$emit("search", this.search, this.toggleLoading);
      },
      loading(e) {
        this.mutableLoading = e;
      }
    },
    methods: {
      toggleLoading(e = null) {
        return e == null ? this.mutableLoading = !this.mutableLoading : this.mutableLoading = e;
      }
    }
  }, S$1 = (e, t) => {
    const s2 = e.__vccOpts || e;
    for (const [n2, l2] of t)
      s2[n2] = l2;
    return s2;
  }, H = {}, X$1 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "10",
    height: "10"
  }, Y = /* @__PURE__ */ createBaseVNode("path", { d: "M6.895455 5l2.842897-2.842898c.348864-.348863.348864-.914488 0-1.263636L9.106534.261648c-.348864-.348864-.914489-.348864-1.263636 0L5 3.104545 2.157102.261648c-.348863-.348864-.914488-.348864-1.263636 0L.261648.893466c-.348864.348864-.348864.914489 0 1.263636L3.104545 5 .261648 7.842898c-.348864.348863-.348864.914488 0 1.263636l.631818.631818c.348864.348864.914773.348864 1.263636 0L5 6.895455l2.842898 2.842897c.348863.348864.914772.348864 1.263636 0l.631818-.631818c.348864-.348864.348864-.914489 0-1.263636L6.895455 5z" }, null, -1), Q = [
    Y
  ];
  function G$1(e, t) {
    return openBlock(), createElementBlock("svg", X$1, Q);
  }
  const W$1 = /* @__PURE__ */ S$1(H, [["render", G$1]]), Z$1 = {}, ee$1 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "14",
    height: "10"
  }, te$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M9.211364 7.59931l4.48338-4.867229c.407008-.441854.407008-1.158247 0-1.60046l-.73712-.80023c-.407008-.441854-1.066904-.441854-1.474243 0L7 5.198617 2.51662.33139c-.407008-.441853-1.066904-.441853-1.474243 0l-.737121.80023c-.407008.441854-.407008 1.158248 0 1.600461l4.48338 4.867228L7 10l2.211364-2.40069z" }, null, -1), se$1 = [
    te$1
  ];
  function ie$1(e, t) {
    return openBlock(), createElementBlock("svg", ee$1, se$1);
  }
  const oe$1 = /* @__PURE__ */ S$1(Z$1, [["render", ie$1]]), T = {
    Deselect: W$1,
    OpenIndicator: oe$1
  }, ne = {
    mounted(e, { instance: t }) {
      if (t.appendToBody) {
        const {
          height: s2,
          top: n2,
          left: l2,
          width: i2
        } = t.$refs.toggle.getBoundingClientRect();
        let y2 = window.scrollX || window.pageXOffset, o2 = window.scrollY || window.pageYOffset;
        e.unbindPosition = t.calculatePosition(e, t, {
          width: i2 + "px",
          left: y2 + l2 + "px",
          top: o2 + n2 + s2 + "px"
        }), document.body.appendChild(e);
      }
    },
    unmounted(e, { instance: t }) {
      t.appendToBody && (e.unbindPosition && typeof e.unbindPosition == "function" && e.unbindPosition(), e.parentNode && e.parentNode.removeChild(e));
    }
  };
  function le$1(e) {
    const t = {};
    return Object.keys(e).sort().forEach((s2) => {
      t[s2] = e[s2];
    }), JSON.stringify(t);
  }
  let ae = 0;
  function re$1() {
    return ++ae;
  }
  const de$1 = {
    components: f({}, T),
    directives: { appendToBody: ne },
    mixins: [U, q$1, J$1],
    compatConfig: {
      MODE: 3
    },
    emits: [
      "open",
      "close",
      "update:modelValue",
      "search",
      "search:compositionstart",
      "search:compositionend",
      "search:keydown",
      "search:blur",
      "search:focus",
      "search:input",
      "option:created",
      "option:selecting",
      "option:selected",
      "option:deselecting",
      "option:deselected"
    ],
    props: {
      modelValue: {},
      components: {
        type: Object,
        default: () => ({})
      },
      options: {
        type: Array,
        default() {
          return [];
        }
      },
      disabled: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: true
      },
      deselectFromDropdown: {
        type: Boolean,
        default: false
      },
      searchable: {
        type: Boolean,
        default: true
      },
      multiple: {
        type: Boolean,
        default: false
      },
      placeholder: {
        type: String,
        default: ""
      },
      transition: {
        type: String,
        default: "vs__fade"
      },
      clearSearchOnSelect: {
        type: Boolean,
        default: true
      },
      closeOnSelect: {
        type: Boolean,
        default: true
      },
      label: {
        type: String,
        default: "label"
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      reduce: {
        type: Function,
        default: (e) => e
      },
      selectable: {
        type: Function,
        default: (e) => true
      },
      getOptionLabel: {
        type: Function,
        default(e) {
          return typeof e == "object" ? e.hasOwnProperty(this.label) ? e[this.label] : console.warn(`[vue-select warn]: Label key "option.${this.label}" does not exist in options object ${JSON.stringify(e)}.
https://vue-select.org/api/props.html#getoptionlabel`) : e;
        }
      },
      getOptionKey: {
        type: Function,
        default(e) {
          if (typeof e != "object")
            return e;
          try {
            return e.hasOwnProperty("id") ? e.id : le$1(e);
          } catch (t) {
            return console.warn(`[vue-select warn]: Could not stringify this option to generate unique key. Please provide'getOptionKey' prop to return a unique key for each option.
https://vue-select.org/api/props.html#getoptionkey`, e, t);
          }
        }
      },
      onTab: {
        type: Function,
        default: function() {
          this.selectOnTab && !this.isComposing && this.typeAheadSelect();
        }
      },
      taggable: {
        type: Boolean,
        default: false
      },
      tabindex: {
        type: Number,
        default: null
      },
      pushTags: {
        type: Boolean,
        default: false
      },
      filterable: {
        type: Boolean,
        default: true
      },
      filterBy: {
        type: Function,
        default(e, t, s2) {
          return (t || "").toLocaleLowerCase().indexOf(s2.toLocaleLowerCase()) > -1;
        }
      },
      filter: {
        type: Function,
        default(e, t) {
          return e.filter((s2) => {
            let n2 = this.getOptionLabel(s2);
            return typeof n2 == "number" && (n2 = n2.toString()), this.filterBy(s2, n2, t);
          });
        }
      },
      createOption: {
        type: Function,
        default(e) {
          return typeof this.optionList[0] == "object" ? { [this.label]: e } : e;
        }
      },
      resetOnOptionsChange: {
        default: false,
        validator: (e) => ["function", "boolean"].includes(typeof e)
      },
      clearSearchOnBlur: {
        type: Function,
        default: function({ clearSearchOnSelect: e, multiple: t }) {
          return e && !t;
        }
      },
      noDrop: {
        type: Boolean,
        default: false
      },
      inputId: {
        type: String
      },
      dir: {
        type: String,
        default: "auto"
      },
      selectOnTab: {
        type: Boolean,
        default: false
      },
      selectOnKeyCodes: {
        type: Array,
        default: () => [13]
      },
      searchInputQuerySelector: {
        type: String,
        default: "[type=search]"
      },
      mapKeydown: {
        type: Function,
        default: (e, t) => e
      },
      appendToBody: {
        type: Boolean,
        default: false
      },
      calculatePosition: {
        type: Function,
        default(e, t, { width: s2, top: n2, left: l2 }) {
          e.style.top = n2, e.style.left = l2, e.style.width = s2;
        }
      },
      dropdownShouldOpen: {
        type: Function,
        default({ noDrop: e, open: t, mutableLoading: s2 }) {
          return e ? false : t && !s2;
        }
      },
      uid: {
        type: [String, Number],
        default: () => re$1()
      }
    },
    data() {
      return {
        search: "",
        open: false,
        isComposing: false,
        pushedTags: [],
        _value: [],
        deselectButtons: []
      };
    },
    computed: {
      isReducingValues() {
        return this.$props.reduce !== this.$options.props.reduce.default;
      },
      isTrackingValues() {
        return typeof this.modelValue == "undefined" || this.isReducingValues;
      },
      selectedValue() {
        let e = this.modelValue;
        return this.isTrackingValues && (e = this.$data._value), e != null && e !== "" ? [].concat(e) : [];
      },
      optionList() {
        return this.options.concat(this.pushTags ? this.pushedTags : []);
      },
      searchEl() {
        return this.$slots.search ? this.$refs.selectedOptions.querySelector(this.searchInputQuerySelector) : this.$refs.search;
      },
      scope() {
        const e = {
          search: this.search,
          loading: this.loading,
          searching: this.searching,
          filteredOptions: this.filteredOptions
        };
        return {
          search: {
            attributes: f({
              disabled: this.disabled,
              placeholder: this.searchPlaceholder,
              tabindex: this.tabindex,
              readonly: !this.searchable,
              id: this.inputId,
              "aria-autocomplete": "list",
              "aria-labelledby": `vs${this.uid}__combobox`,
              "aria-controls": `vs${this.uid}__listbox`,
              ref: "search",
              type: "search",
              autocomplete: this.autocomplete,
              value: this.search
            }, this.dropdownOpen && this.filteredOptions[this.typeAheadPointer] ? {
              "aria-activedescendant": `vs${this.uid}__option-${this.typeAheadPointer}`
            } : {}),
            events: {
              compositionstart: () => this.isComposing = true,
              compositionend: () => this.isComposing = false,
              keydown: this.onSearchKeyDown,
              blur: this.onSearchBlur,
              focus: this.onSearchFocus,
              input: (t) => this.search = t.target.value
            }
          },
          spinner: {
            loading: this.mutableLoading
          },
          noOptions: {
            search: this.search,
            loading: this.mutableLoading,
            searching: this.searching
          },
          openIndicator: {
            attributes: {
              ref: "openIndicator",
              role: "presentation",
              class: "vs__open-indicator"
            }
          },
          listHeader: e,
          listFooter: e,
          header: m(f({}, e), { deselect: this.deselect }),
          footer: m(f({}, e), { deselect: this.deselect })
        };
      },
      childComponents() {
        return f(f({}, T), this.components);
      },
      stateClasses() {
        return {
          "vs--open": this.dropdownOpen,
          "vs--single": !this.multiple,
          "vs--multiple": this.multiple,
          "vs--searching": this.searching && !this.noDrop,
          "vs--searchable": this.searchable && !this.noDrop,
          "vs--unsearchable": !this.searchable,
          "vs--loading": this.mutableLoading,
          "vs--disabled": this.disabled
        };
      },
      searching() {
        return !!this.search;
      },
      dropdownOpen() {
        return this.dropdownShouldOpen(this);
      },
      searchPlaceholder() {
        return this.isValueEmpty && this.placeholder ? this.placeholder : void 0;
      },
      filteredOptions() {
        const e = [].concat(this.optionList);
        if (!this.filterable && !this.taggable)
          return e;
        const t = this.search.length ? this.filter(e, this.search, this) : e;
        if (this.taggable && this.search.length) {
          const s2 = this.createOption(this.search);
          this.optionExists(s2) || t.unshift(s2);
        }
        return t;
      },
      isValueEmpty() {
        return this.selectedValue.length === 0;
      },
      showClearButton() {
        return !this.multiple && this.clearable && !this.open && !this.isValueEmpty;
      }
    },
    watch: {
      options(e, t) {
        const s2 = () => typeof this.resetOnOptionsChange == "function" ? this.resetOnOptionsChange(e, t, this.selectedValue) : this.resetOnOptionsChange;
        !this.taggable && s2() && this.clearSelection(), this.modelValue && this.isTrackingValues && this.setInternalValueFromOptions(this.modelValue);
      },
      modelValue: {
        immediate: true,
        handler(e) {
          this.isTrackingValues && this.setInternalValueFromOptions(e);
        }
      },
      multiple() {
        this.clearSelection();
      },
      open(e) {
        this.$emit(e ? "open" : "close");
      }
    },
    created() {
      this.mutableLoading = this.loading;
    },
    methods: {
      setInternalValueFromOptions(e) {
        Array.isArray(e) ? this.$data._value = e.map((t) => this.findOptionFromReducedValue(t)) : this.$data._value = this.findOptionFromReducedValue(e);
      },
      select(e) {
        this.$emit("option:selecting", e), this.isOptionSelected(e) ? this.deselectFromDropdown && (this.clearable || this.multiple && this.selectedValue.length > 1) && this.deselect(e) : (this.taggable && !this.optionExists(e) && (this.$emit("option:created", e), this.pushTag(e)), this.multiple && (e = this.selectedValue.concat(e)), this.updateValue(e), this.$emit("option:selected", e)), this.onAfterSelect(e);
      },
      deselect(e) {
        this.$emit("option:deselecting", e), this.updateValue(this.selectedValue.filter((t) => !this.optionComparator(t, e))), this.$emit("option:deselected", e);
      },
      clearSelection() {
        this.updateValue(this.multiple ? [] : null);
      },
      onAfterSelect(e) {
        this.closeOnSelect && (this.open = !this.open, this.searchEl.blur()), this.clearSearchOnSelect && (this.search = "");
      },
      updateValue(e) {
        typeof this.modelValue == "undefined" && (this.$data._value = e), e !== null && (Array.isArray(e) ? e = e.map((t) => this.reduce(t)) : e = this.reduce(e)), this.$emit("update:modelValue", e);
      },
      toggleDropdown(e) {
        const t = e.target !== this.searchEl;
        t && e.preventDefault();
        const s2 = [
          ...this.deselectButtons || [],
          this.$refs.clearButton
        ];
        if (this.searchEl === void 0 || s2.filter(Boolean).some((n2) => n2.contains(e.target) || n2 === e.target)) {
          e.preventDefault();
          return;
        }
        this.open && t ? this.searchEl.blur() : this.disabled || (this.open = true, this.searchEl.focus());
      },
      isOptionSelected(e) {
        return this.selectedValue.some((t) => this.optionComparator(t, e));
      },
      isOptionDeselectable(e) {
        return this.isOptionSelected(e) && this.deselectFromDropdown;
      },
      optionComparator(e, t) {
        return this.getOptionKey(e) === this.getOptionKey(t);
      },
      findOptionFromReducedValue(e) {
        const t = (n2) => JSON.stringify(this.reduce(n2)) === JSON.stringify(e), s2 = [...this.options, ...this.pushedTags].filter(t);
        return s2.length === 1 ? s2[0] : s2.find((n2) => this.optionComparator(n2, this.$data._value)) || e;
      },
      closeSearchOptions() {
        this.open = false, this.$emit("search:blur");
      },
      maybeDeleteValue() {
        if (!this.searchEl.value.length && this.selectedValue && this.selectedValue.length && this.clearable) {
          let e = null;
          this.multiple && (e = [
            ...this.selectedValue.slice(0, this.selectedValue.length - 1)
          ]), this.updateValue(e);
        }
      },
      optionExists(e) {
        return this.optionList.some((t) => this.optionComparator(t, e));
      },
      normalizeOptionForSlot(e) {
        return typeof e == "object" ? e : { [this.label]: e };
      },
      pushTag(e) {
        this.pushedTags.push(e);
      },
      onEscape() {
        this.search.length ? this.search = "" : this.searchEl.blur();
      },
      onSearchBlur() {
        if (this.mousedown && !this.searching)
          this.mousedown = false;
        else {
          const { clearSearchOnSelect: e, multiple: t } = this;
          this.clearSearchOnBlur({ clearSearchOnSelect: e, multiple: t }) && (this.search = ""), this.closeSearchOptions();
          return;
        }
        if (this.search.length === 0 && this.options.length === 0) {
          this.closeSearchOptions();
          return;
        }
      },
      onSearchFocus() {
        this.open = true, this.$emit("search:focus");
      },
      onMousedown() {
        this.mousedown = true;
      },
      onMouseUp() {
        this.mousedown = false;
      },
      onSearchKeyDown(e) {
        const t = (l2) => (l2.preventDefault(), !this.isComposing && this.typeAheadSelect()), s2 = {
          8: (l2) => this.maybeDeleteValue(),
          9: (l2) => this.onTab(),
          27: (l2) => this.onEscape(),
          38: (l2) => (l2.preventDefault(), this.typeAheadUp()),
          40: (l2) => (l2.preventDefault(), this.typeAheadDown())
        };
        this.selectOnKeyCodes.forEach((l2) => s2[l2] = t);
        const n2 = this.mapKeydown(s2, this);
        if (typeof n2[e.keyCode] == "function")
          return n2[e.keyCode](e);
      }
    }
  }, he$1 = ["dir"], ce = ["id", "aria-expanded", "aria-owns"], ue$1 = {
    ref: "selectedOptions",
    class: "vs__selected-options"
  }, pe$1 = ["disabled", "title", "aria-label", "onClick"], fe$1 = {
    ref: "actions",
    class: "vs__actions"
  }, ge$1 = ["disabled"], ye$1 = { class: "vs__spinner" }, me$1 = ["id"], be$1 = ["id", "aria-selected", "onMouseover", "onClick"], _e$1 = {
    key: 0,
    class: "vs__no-options"
  }, Oe$1 = /* @__PURE__ */ createTextVNode(" Sorry, no matching options. "), we$1 = ["id"];
  function ve$1(e, t, s2, n2, l2, i2) {
    const y2 = resolveDirective("append-to-body");
    return openBlock(), createElementBlock("div", {
      dir: s2.dir,
      class: normalizeClass(["v-select", i2.stateClasses])
    }, [
      renderSlot(e.$slots, "header", normalizeProps(guardReactiveProps(i2.scope.header))),
      createBaseVNode("div", {
        id: `vs${s2.uid}__combobox`,
        ref: "toggle",
        class: "vs__dropdown-toggle",
        role: "combobox",
        "aria-expanded": i2.dropdownOpen.toString(),
        "aria-owns": `vs${s2.uid}__listbox`,
        "aria-label": "Search for option",
        onMousedown: t[1] || (t[1] = (o2) => i2.toggleDropdown(o2))
      }, [
        createBaseVNode("div", ue$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(i2.selectedValue, (o2, p2) => renderSlot(e.$slots, "selected-option-container", {
            option: i2.normalizeOptionForSlot(o2),
            deselect: i2.deselect,
            multiple: s2.multiple,
            disabled: s2.disabled
          }, () => [
            (openBlock(), createElementBlock("span", {
              key: s2.getOptionKey(o2),
              class: "vs__selected"
            }, [
              renderSlot(e.$slots, "selected-option", normalizeProps(guardReactiveProps(i2.normalizeOptionForSlot(o2))), () => [
                createTextVNode(toDisplayString(s2.getOptionLabel(o2)), 1)
              ]),
              s2.multiple ? (openBlock(), createElementBlock("button", {
                key: 0,
                ref_for: true,
                ref: (g2) => l2.deselectButtons[p2] = g2,
                disabled: s2.disabled,
                type: "button",
                class: "vs__deselect",
                title: `Deselect ${s2.getOptionLabel(o2)}`,
                "aria-label": `Deselect ${s2.getOptionLabel(o2)}`,
                onClick: (g2) => i2.deselect(o2)
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(i2.childComponents.Deselect)))
              ], 8, pe$1)) : createCommentVNode("", true)
            ]))
          ])), 256)),
          renderSlot(e.$slots, "search", normalizeProps(guardReactiveProps(i2.scope.search)), () => [
            createBaseVNode("input", mergeProps({ class: "vs__search" }, i2.scope.search.attributes, toHandlers(i2.scope.search.events)), null, 16)
          ])
        ], 512),
        createBaseVNode("div", fe$1, [
          withDirectives(createBaseVNode("button", {
            ref: "clearButton",
            disabled: s2.disabled,
            type: "button",
            class: "vs__clear",
            title: "Clear Selected",
            "aria-label": "Clear Selected",
            onClick: t[0] || (t[0] = (...o2) => i2.clearSelection && i2.clearSelection(...o2))
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(i2.childComponents.Deselect)))
          ], 8, ge$1), [
            [vShow, i2.showClearButton]
          ]),
          renderSlot(e.$slots, "open-indicator", normalizeProps(guardReactiveProps(i2.scope.openIndicator)), () => [
            s2.noDrop ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(i2.childComponents.OpenIndicator), normalizeProps(mergeProps({ key: 0 }, i2.scope.openIndicator.attributes)), null, 16))
          ]),
          renderSlot(e.$slots, "spinner", normalizeProps(guardReactiveProps(i2.scope.spinner)), () => [
            withDirectives(createBaseVNode("div", ye$1, "Loading...", 512), [
              [vShow, e.mutableLoading]
            ])
          ])
        ], 512)
      ], 40, ce),
      createVNode(Transition, { name: s2.transition }, {
        default: withCtx(() => [
          i2.dropdownOpen ? withDirectives((openBlock(), createElementBlock("ul", {
            id: `vs${s2.uid}__listbox`,
            ref: "dropdownMenu",
            key: `vs${s2.uid}__listbox`,
            class: "vs__dropdown-menu",
            role: "listbox",
            tabindex: "-1",
            onMousedown: t[2] || (t[2] = withModifiers((...o2) => i2.onMousedown && i2.onMousedown(...o2), ["prevent"])),
            onMouseup: t[3] || (t[3] = (...o2) => i2.onMouseUp && i2.onMouseUp(...o2))
          }, [
            renderSlot(e.$slots, "list-header", normalizeProps(guardReactiveProps(i2.scope.listHeader))),
            (openBlock(true), createElementBlock(Fragment, null, renderList(i2.filteredOptions, (o2, p2) => (openBlock(), createElementBlock("li", {
              id: `vs${s2.uid}__option-${p2}`,
              key: s2.getOptionKey(o2),
              role: "option",
              class: normalizeClass(["vs__dropdown-option", {
                "vs__dropdown-option--deselect": i2.isOptionDeselectable(o2) && p2 === e.typeAheadPointer,
                "vs__dropdown-option--selected": i2.isOptionSelected(o2),
                "vs__dropdown-option--highlight": p2 === e.typeAheadPointer,
                "vs__dropdown-option--disabled": !s2.selectable(o2)
              }]),
              "aria-selected": p2 === e.typeAheadPointer ? true : null,
              onMouseover: (g2) => s2.selectable(o2) ? e.typeAheadPointer = p2 : null,
              onClick: withModifiers((g2) => s2.selectable(o2) ? i2.select(o2) : null, ["prevent", "stop"])
            }, [
              renderSlot(e.$slots, "option", normalizeProps(guardReactiveProps(i2.normalizeOptionForSlot(o2))), () => [
                createTextVNode(toDisplayString(s2.getOptionLabel(o2)), 1)
              ])
            ], 42, be$1))), 128)),
            i2.filteredOptions.length === 0 ? (openBlock(), createElementBlock("li", _e$1, [
              renderSlot(e.$slots, "no-options", normalizeProps(guardReactiveProps(i2.scope.noOptions)), () => [
                Oe$1
              ])
            ])) : createCommentVNode("", true),
            renderSlot(e.$slots, "list-footer", normalizeProps(guardReactiveProps(i2.scope.listFooter)))
          ], 40, me$1)), [
            [y2]
          ]) : (openBlock(), createElementBlock("ul", {
            key: 1,
            id: `vs${s2.uid}__listbox`,
            role: "listbox",
            style: { display: "none", visibility: "hidden" }
          }, null, 8, we$1))
        ]),
        _: 3
      }, 8, ["name"]),
      renderSlot(e.$slots, "footer", normalizeProps(guardReactiveProps(i2.scope.footer)))
    ], 10, he$1);
  }
  const Ce$1 = /* @__PURE__ */ S$1(de$1, [["render", ve$1]]);
  var rn = Object.defineProperty;
  var Ne = Object.getOwnPropertySymbols;
  var vt = Object.prototype.hasOwnProperty, bt = Object.prototype.propertyIsEnumerable;
  var mt = (t, e, n2) => e in t ? rn(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2, fe = (t, e) => {
    for (var n2 in e || (e = {}))
      vt.call(e, n2) && mt(t, n2, e[n2]);
    if (Ne)
      for (var n2 of Ne(e))
        bt.call(e, n2) && mt(t, n2, e[n2]);
    return t;
  };
  var Ve = (t, e) => {
    var n2 = {};
    for (var o2 in t)
      vt.call(t, o2) && e.indexOf(o2) < 0 && (n2[o2] = t[o2]);
    if (t != null && Ne)
      for (var o2 of Ne(t))
        e.indexOf(o2) < 0 && bt.call(t, o2) && (n2[o2] = t[o2]);
    return n2;
  };
  const Bt = "[vue-draggable-plus]: ";
  function gn(t) {
    console.warn(Bt + t);
  }
  function mn(t) {
    console.error(Bt + t);
  }
  function wt(t, e, n2) {
    return n2 >= 0 && n2 < t.length && t.splice(n2, 0, t.splice(e, 1)[0]), t;
  }
  function vn(t) {
    return t.replace(/-(\w)/g, (e, n2) => n2 ? n2.toUpperCase() : "");
  }
  function bn(t) {
    return Object.keys(t).reduce((e, n2) => (typeof t[n2] != "undefined" && (e[vn(n2)] = t[n2]), e), {});
  }
  function Et(t, e) {
    return Array.isArray(t) && t.splice(e, 1), t;
  }
  function St(t, e, n2) {
    return Array.isArray(t) && t.splice(e, 0, n2), t;
  }
  function yn(t) {
    return typeof t == "undefined";
  }
  function wn(t) {
    return typeof t == "string";
  }
  function Dt(t, e, n2) {
    const o2 = t.children[n2];
    t.insertBefore(e, o2);
  }
  function qe(t) {
    t.parentNode && t.parentNode.removeChild(t);
  }
  function En(t, e = document) {
    var o2;
    let n2 = null;
    return typeof (e == null ? void 0 : e.querySelector) == "function" ? n2 = (o2 = e == null ? void 0 : e.querySelector) == null ? void 0 : o2.call(e, t) : n2 = document.querySelector(t), n2 || gn(`Element not found: ${t}`), n2;
  }
  function Sn(t, e, n2 = null) {
    return function(...o2) {
      return t.apply(n2, o2), e.apply(n2, o2);
    };
  }
  function Dn(t, e) {
    const n2 = fe({}, t);
    return Object.keys(e).forEach((o2) => {
      n2[o2] ? n2[o2] = Sn(t[o2], e[o2]) : n2[o2] = e[o2];
    }), n2;
  }
  function _n(t) {
    return t instanceof HTMLElement;
  }
  function _t(t, e) {
    Object.keys(t).forEach((n2) => {
      e(n2, t[n2]);
    });
  }
  function Tn(t) {
    return t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
    (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97);
  }
  const Cn = Object.assign;
  function Tt(t, e) {
    var n2 = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(t);
      e && (o2 = o2.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(t, r2).enumerable;
      })), n2.push.apply(n2, o2);
    }
    return n2;
  }
  function te(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e] != null ? arguments[e] : {};
      e % 2 ? Tt(Object(n2), true).forEach(function(o2) {
        On(t, o2, n2[o2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n2)) : Tt(Object(n2)).forEach(function(o2) {
        Object.defineProperty(t, o2, Object.getOwnPropertyDescriptor(n2, o2));
      });
    }
    return t;
  }
  function Xe(t) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Xe = function(e) {
      return typeof e;
    } : Xe = function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, Xe(t);
  }
  function On(t, e, n2) {
    return e in t ? Object.defineProperty(t, e, {
      value: n2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : t[e] = n2, t;
  }
  function re() {
    return re = Object.assign || function(t) {
      for (var e = 1; e < arguments.length; e++) {
        var n2 = arguments[e];
        for (var o2 in n2)
          Object.prototype.hasOwnProperty.call(n2, o2) && (t[o2] = n2[o2]);
      }
      return t;
    }, re.apply(this, arguments);
  }
  function In(t, e) {
    if (t == null)
      return {};
    var n2 = {}, o2 = Object.keys(t), r2, i2;
    for (i2 = 0; i2 < o2.length; i2++)
      r2 = o2[i2], !(e.indexOf(r2) >= 0) && (n2[r2] = t[r2]);
    return n2;
  }
  function An(t, e) {
    if (t == null)
      return {};
    var n2 = In(t, e), o2, r2;
    if (Object.getOwnPropertySymbols) {
      var i2 = Object.getOwnPropertySymbols(t);
      for (r2 = 0; r2 < i2.length; r2++)
        o2 = i2[r2], !(e.indexOf(o2) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o2) && (n2[o2] = t[o2]);
    }
    return n2;
  }
  var xn = "1.15.2";
  function oe(t) {
    if (typeof window != "undefined" && window.navigator)
      return !!/* @__PURE__ */ navigator.userAgent.match(t);
  }
  var ie = oe(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), Ae = oe(/Edge/i), Ct = oe(/firefox/i), _e = oe(/safari/i) && !oe(/chrome/i) && !oe(/android/i), kt = oe(/iP(ad|od|hone)/i), Ht = oe(/chrome/i) && oe(/android/i), Lt = {
    capture: false,
    passive: false
  };
  function D(t, e, n2) {
    t.addEventListener(e, n2, !ie && Lt);
  }
  function S(t, e, n2) {
    t.removeEventListener(e, n2, !ie && Lt);
  }
  function Le(t, e) {
    if (e) {
      if (e[0] === ">" && (e = e.substring(1)), t)
        try {
          if (t.matches)
            return t.matches(e);
          if (t.msMatchesSelector)
            return t.msMatchesSelector(e);
          if (t.webkitMatchesSelector)
            return t.webkitMatchesSelector(e);
        } catch (n2) {
          return false;
        }
      return false;
    }
  }
  function Nn(t) {
    return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode;
  }
  function Z(t, e, n2, o2) {
    if (t) {
      n2 = n2 || document;
      do {
        if (e != null && (e[0] === ">" ? t.parentNode === n2 && Le(t, e) : Le(t, e)) || o2 && t === n2)
          return t;
        if (t === n2)
          break;
      } while (t = Nn(t));
    }
    return null;
  }
  var Ot = /\s+/g;
  function V(t, e, n2) {
    if (t && e)
      if (t.classList)
        t.classList[n2 ? "add" : "remove"](e);
      else {
        var o2 = (" " + t.className + " ").replace(Ot, " ").replace(" " + e + " ", " ");
        t.className = (o2 + (n2 ? " " + e : "")).replace(Ot, " ");
      }
  }
  function h(t, e, n2) {
    var o2 = t && t.style;
    if (o2) {
      if (n2 === void 0)
        return document.defaultView && document.defaultView.getComputedStyle ? n2 = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (n2 = t.currentStyle), e === void 0 ? n2 : n2[e];
      !(e in o2) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), o2[e] = n2 + (typeof n2 == "string" ? "" : "px");
    }
  }
  function ye(t, e) {
    var n2 = "";
    if (typeof t == "string")
      n2 = t;
    else
      do {
        var o2 = h(t, "transform");
        o2 && o2 !== "none" && (n2 = o2 + " " + n2);
      } while (!e && (t = t.parentNode));
    var r2 = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    return r2 && new r2(n2);
  }
  function Wt(t, e, n2) {
    if (t) {
      var o2 = t.getElementsByTagName(e), r2 = 0, i2 = o2.length;
      if (n2)
        for (; r2 < i2; r2++)
          n2(o2[r2], r2);
      return o2;
    }
    return [];
  }
  function ee() {
    var t = document.scrollingElement;
    return t || document.documentElement;
  }
  function M(t, e, n2, o2, r2) {
    if (!(!t.getBoundingClientRect && t !== window)) {
      var i2, a2, l2, s2, u2, d2, f2;
      if (t !== window && t.parentNode && t !== ee() ? (i2 = t.getBoundingClientRect(), a2 = i2.top, l2 = i2.left, s2 = i2.bottom, u2 = i2.right, d2 = i2.height, f2 = i2.width) : (a2 = 0, l2 = 0, s2 = window.innerHeight, u2 = window.innerWidth, d2 = window.innerHeight, f2 = window.innerWidth), (e || n2) && t !== window && (r2 = r2 || t.parentNode, !ie))
        do
          if (r2 && r2.getBoundingClientRect && (h(r2, "transform") !== "none" || n2 && h(r2, "position") !== "static")) {
            var m2 = r2.getBoundingClientRect();
            a2 -= m2.top + parseInt(h(r2, "border-top-width")), l2 -= m2.left + parseInt(h(r2, "border-left-width")), s2 = a2 + i2.height, u2 = l2 + i2.width;
            break;
          }
        while (r2 = r2.parentNode);
      if (o2 && t !== window) {
        var y2 = ye(r2 || t), b2 = y2 && y2.a, E2 = y2 && y2.d;
        y2 && (a2 /= E2, l2 /= b2, f2 /= b2, d2 /= E2, s2 = a2 + d2, u2 = l2 + f2);
      }
      return {
        top: a2,
        left: l2,
        bottom: s2,
        right: u2,
        width: f2,
        height: d2
      };
    }
  }
  function It(t, e, n2) {
    for (var o2 = ue(t, true), r2 = M(t)[e]; o2; ) {
      var i2 = M(o2)[n2], a2 = void 0;
      if (a2 = r2 >= i2, !a2)
        return o2;
      if (o2 === ee())
        break;
      o2 = ue(o2, false);
    }
    return false;
  }
  function we(t, e, n2, o2) {
    for (var r2 = 0, i2 = 0, a2 = t.children; i2 < a2.length; ) {
      if (a2[i2].style.display !== "none" && a2[i2] !== p.ghost && (o2 || a2[i2] !== p.dragged) && Z(a2[i2], n2.draggable, t, false)) {
        if (r2 === e)
          return a2[i2];
        r2++;
      }
      i2++;
    }
    return null;
  }
  function dt(t, e) {
    for (var n2 = t.lastElementChild; n2 && (n2 === p.ghost || h(n2, "display") === "none" || e && !Le(n2, e)); )
      n2 = n2.previousElementSibling;
    return n2 || null;
  }
  function K(t, e) {
    var n2 = 0;
    if (!t || !t.parentNode)
      return -1;
    for (; t = t.previousElementSibling; )
      t.nodeName.toUpperCase() !== "TEMPLATE" && t !== p.clone && (!e || Le(t, e)) && n2++;
    return n2;
  }
  function At(t) {
    var e = 0, n2 = 0, o2 = ee();
    if (t)
      do {
        var r2 = ye(t), i2 = r2.a, a2 = r2.d;
        e += t.scrollLeft * i2, n2 += t.scrollTop * a2;
      } while (t !== o2 && (t = t.parentNode));
    return [e, n2];
  }
  function Pn(t, e) {
    for (var n2 in t)
      if (t.hasOwnProperty(n2)) {
        for (var o2 in e)
          if (e.hasOwnProperty(o2) && e[o2] === t[n2][o2])
            return Number(n2);
      }
    return -1;
  }
  function ue(t, e) {
    if (!t || !t.getBoundingClientRect)
      return ee();
    var n2 = t, o2 = false;
    do
      if (n2.clientWidth < n2.scrollWidth || n2.clientHeight < n2.scrollHeight) {
        var r2 = h(n2);
        if (n2.clientWidth < n2.scrollWidth && (r2.overflowX == "auto" || r2.overflowX == "scroll") || n2.clientHeight < n2.scrollHeight && (r2.overflowY == "auto" || r2.overflowY == "scroll")) {
          if (!n2.getBoundingClientRect || n2 === document.body)
            return ee();
          if (o2 || e)
            return n2;
          o2 = true;
        }
      }
    while (n2 = n2.parentNode);
    return ee();
  }
  function Mn(t, e) {
    if (t && e)
      for (var n2 in e)
        e.hasOwnProperty(n2) && (t[n2] = e[n2]);
    return t;
  }
  function Ke(t, e) {
    return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width);
  }
  var Te;
  function Gt(t, e) {
    return function() {
      if (!Te) {
        var n2 = arguments, o2 = this;
        n2.length === 1 ? t.call(o2, n2[0]) : t.apply(o2, n2), Te = setTimeout(function() {
          Te = void 0;
        }, e);
      }
    };
  }
  function Fn() {
    clearTimeout(Te), Te = void 0;
  }
  function jt(t, e, n2) {
    t.scrollLeft += e, t.scrollTop += n2;
  }
  function zt(t) {
    var e = window.Polymer, n2 = window.jQuery || window.Zepto;
    return e && e.dom ? e.dom(t).cloneNode(true) : n2 ? n2(t).clone(true)[0] : t.cloneNode(true);
  }
  function Ut(t, e, n2) {
    var o2 = {};
    return Array.from(t.children).forEach(function(r2) {
      var i2, a2, l2, s2;
      if (!(!Z(r2, e.draggable, t, false) || r2.animated || r2 === n2)) {
        var u2 = M(r2);
        o2.left = Math.min((i2 = o2.left) !== null && i2 !== void 0 ? i2 : 1 / 0, u2.left), o2.top = Math.min((a2 = o2.top) !== null && a2 !== void 0 ? a2 : 1 / 0, u2.top), o2.right = Math.max((l2 = o2.right) !== null && l2 !== void 0 ? l2 : -1 / 0, u2.right), o2.bottom = Math.max((s2 = o2.bottom) !== null && s2 !== void 0 ? s2 : -1 / 0, u2.bottom);
      }
    }), o2.width = o2.right - o2.left, o2.height = o2.bottom - o2.top, o2.x = o2.left, o2.y = o2.top, o2;
  }
  var q = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
  function Rn() {
    var t = [], e;
    return {
      captureAnimationState: function() {
        if (t = [], !!this.options.animation) {
          var o2 = [].slice.call(this.el.children);
          o2.forEach(function(r2) {
            if (!(h(r2, "display") === "none" || r2 === p.ghost)) {
              t.push({
                target: r2,
                rect: M(r2)
              });
              var i2 = te({}, t[t.length - 1].rect);
              if (r2.thisAnimationDuration) {
                var a2 = ye(r2, true);
                a2 && (i2.top -= a2.f, i2.left -= a2.e);
              }
              r2.fromRect = i2;
            }
          });
        }
      },
      addAnimationState: function(o2) {
        t.push(o2);
      },
      removeAnimationState: function(o2) {
        t.splice(Pn(t, {
          target: o2
        }), 1);
      },
      animateAll: function(o2) {
        var r2 = this;
        if (!this.options.animation) {
          clearTimeout(e), typeof o2 == "function" && o2();
          return;
        }
        var i2 = false, a2 = 0;
        t.forEach(function(l2) {
          var s2 = 0, u2 = l2.target, d2 = u2.fromRect, f2 = M(u2), m2 = u2.prevFromRect, y2 = u2.prevToRect, b2 = l2.rect, E2 = ye(u2, true);
          E2 && (f2.top -= E2.f, f2.left -= E2.e), u2.toRect = f2, u2.thisAnimationDuration && Ke(m2, f2) && !Ke(d2, f2) && // Make sure animatingRect is on line between toRect & fromRect
          (b2.top - f2.top) / (b2.left - f2.left) === (d2.top - f2.top) / (d2.left - f2.left) && (s2 = Yn(b2, m2, y2, r2.options)), Ke(f2, d2) || (u2.prevFromRect = d2, u2.prevToRect = f2, s2 || (s2 = r2.options.animation), r2.animate(u2, b2, f2, s2)), s2 && (i2 = true, a2 = Math.max(a2, s2), clearTimeout(u2.animationResetTimer), u2.animationResetTimer = setTimeout(function() {
            u2.animationTime = 0, u2.prevFromRect = null, u2.fromRect = null, u2.prevToRect = null, u2.thisAnimationDuration = null;
          }, s2), u2.thisAnimationDuration = s2);
        }), clearTimeout(e), i2 ? e = setTimeout(function() {
          typeof o2 == "function" && o2();
        }, a2) : typeof o2 == "function" && o2(), t = [];
      },
      animate: function(o2, r2, i2, a2) {
        if (a2) {
          h(o2, "transition", ""), h(o2, "transform", "");
          var l2 = ye(this.el), s2 = l2 && l2.a, u2 = l2 && l2.d, d2 = (r2.left - i2.left) / (s2 || 1), f2 = (r2.top - i2.top) / (u2 || 1);
          o2.animatingX = !!d2, o2.animatingY = !!f2, h(o2, "transform", "translate3d(" + d2 + "px," + f2 + "px,0)"), this.forRepaintDummy = Xn(o2), h(o2, "transition", "transform " + a2 + "ms" + (this.options.easing ? " " + this.options.easing : "")), h(o2, "transform", "translate3d(0,0,0)"), typeof o2.animated == "number" && clearTimeout(o2.animated), o2.animated = setTimeout(function() {
            h(o2, "transition", ""), h(o2, "transform", ""), o2.animated = false, o2.animatingX = false, o2.animatingY = false;
          }, a2);
        }
      }
    };
  }
  function Xn(t) {
    return t.offsetWidth;
  }
  function Yn(t, e, n2, o2) {
    return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - n2.top, 2) + Math.pow(e.left - n2.left, 2)) * o2.animation;
  }
  var ge = [], Je = {
    initializeByDefault: true
  }, xe = {
    mount: function(e) {
      for (var n2 in Je)
        Je.hasOwnProperty(n2) && !(n2 in e) && (e[n2] = Je[n2]);
      ge.forEach(function(o2) {
        if (o2.pluginName === e.pluginName)
          throw "Sortable: Cannot mount plugin ".concat(e.pluginName, " more than once");
      }), ge.push(e);
    },
    pluginEvent: function(e, n2, o2) {
      var r2 = this;
      this.eventCanceled = false, o2.cancel = function() {
        r2.eventCanceled = true;
      };
      var i2 = e + "Global";
      ge.forEach(function(a2) {
        n2[a2.pluginName] && (n2[a2.pluginName][i2] && n2[a2.pluginName][i2](te({
          sortable: n2
        }, o2)), n2.options[a2.pluginName] && n2[a2.pluginName][e] && n2[a2.pluginName][e](te({
          sortable: n2
        }, o2)));
      });
    },
    initializePlugins: function(e, n2, o2, r2) {
      ge.forEach(function(l2) {
        var s2 = l2.pluginName;
        if (!(!e.options[s2] && !l2.initializeByDefault)) {
          var u2 = new l2(e, n2, e.options);
          u2.sortable = e, u2.options = e.options, e[s2] = u2, re(o2, u2.defaults);
        }
      });
      for (var i2 in e.options)
        if (e.options.hasOwnProperty(i2)) {
          var a2 = this.modifyOption(e, i2, e.options[i2]);
          typeof a2 != "undefined" && (e.options[i2] = a2);
        }
    },
    getEventProperties: function(e, n2) {
      var o2 = {};
      return ge.forEach(function(r2) {
        typeof r2.eventProperties == "function" && re(o2, r2.eventProperties.call(n2[r2.pluginName], e));
      }), o2;
    },
    modifyOption: function(e, n2, o2) {
      var r2;
      return ge.forEach(function(i2) {
        e[i2.pluginName] && i2.optionListeners && typeof i2.optionListeners[n2] == "function" && (r2 = i2.optionListeners[n2].call(e[i2.pluginName], o2));
      }), r2;
    }
  };
  function Bn(t) {
    var e = t.sortable, n2 = t.rootEl, o2 = t.name, r2 = t.targetEl, i2 = t.cloneEl, a2 = t.toEl, l2 = t.fromEl, s2 = t.oldIndex, u2 = t.newIndex, d2 = t.oldDraggableIndex, f2 = t.newDraggableIndex, m2 = t.originalEvent, y2 = t.putSortable, b2 = t.extraEventProperties;
    if (e = e || n2 && n2[q], !!e) {
      var E2, k2 = e.options, H2 = "on" + o2.charAt(0).toUpperCase() + o2.substr(1);
      window.CustomEvent && !ie && !Ae ? E2 = new CustomEvent(o2, {
        bubbles: true,
        cancelable: true
      }) : (E2 = document.createEvent("Event"), E2.initEvent(o2, true, true)), E2.to = a2 || n2, E2.from = l2 || n2, E2.item = r2 || n2, E2.clone = i2, E2.oldIndex = s2, E2.newIndex = u2, E2.oldDraggableIndex = d2, E2.newDraggableIndex = f2, E2.originalEvent = m2, E2.pullMode = y2 ? y2.lastPutMode : void 0;
      var F2 = te(te({}, b2), xe.getEventProperties(o2, e));
      for (var A2 in F2)
        E2[A2] = F2[A2];
      n2 && n2.dispatchEvent(E2), k2[H2] && k2[H2].call(e, E2);
    }
  }
  var kn = ["evt"], G = function(e, n2) {
    var o2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r2 = o2.evt, i2 = An(o2, kn);
    xe.pluginEvent.bind(p)(e, n2, te({
      dragEl: c,
      parentEl: I,
      ghostEl: g,
      rootEl: C,
      nextEl: pe,
      lastDownEl: Ye,
      cloneEl: O,
      cloneHidden: se,
      dragStarted: Ee,
      putSortable: X,
      activeSortable: p.active,
      originalEvent: r2,
      oldIndex: be,
      oldDraggableIndex: Ce,
      newIndex: $,
      newDraggableIndex: le,
      hideGhostForTarget: Kt,
      unhideGhostForTarget: Jt,
      cloneNowHidden: function() {
        se = true;
      },
      cloneNowShown: function() {
        se = false;
      },
      dispatchSortableEvent: function(l2) {
        W({
          sortable: n2,
          name: l2,
          originalEvent: r2
        });
      }
    }, i2));
  };
  function W(t) {
    Bn(te({
      putSortable: X,
      cloneEl: O,
      targetEl: c,
      rootEl: C,
      oldIndex: be,
      oldDraggableIndex: Ce,
      newIndex: $,
      newDraggableIndex: le
    }, t));
  }
  var c, I, g, C, pe, Ye, O, se, be, $, Ce, le, Pe, X, ve = false, We = false, Ge = [], de, J, Ze, Qe, xt, Nt, Ee, me, Oe, Ie = false, Me = false, Be, B, et = [], at = false, je = [], Ue = typeof document != "undefined", Fe = kt, Pt = Ae || ie ? "cssFloat" : "float", Hn = Ue && !Ht && !kt && "draggable" in document.createElement("div"), Vt = (function() {
    if (Ue) {
      if (ie)
        return false;
      var t = document.createElement("x");
      return t.style.cssText = "pointer-events:auto", t.style.pointerEvents === "auto";
    }
  })(), $t = function(e, n2) {
    var o2 = h(e), r2 = parseInt(o2.width) - parseInt(o2.paddingLeft) - parseInt(o2.paddingRight) - parseInt(o2.borderLeftWidth) - parseInt(o2.borderRightWidth), i2 = we(e, 0, n2), a2 = we(e, 1, n2), l2 = i2 && h(i2), s2 = a2 && h(a2), u2 = l2 && parseInt(l2.marginLeft) + parseInt(l2.marginRight) + M(i2).width, d2 = s2 && parseInt(s2.marginLeft) + parseInt(s2.marginRight) + M(a2).width;
    if (o2.display === "flex")
      return o2.flexDirection === "column" || o2.flexDirection === "column-reverse" ? "vertical" : "horizontal";
    if (o2.display === "grid")
      return o2.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
    if (i2 && l2.float && l2.float !== "none") {
      var f2 = l2.float === "left" ? "left" : "right";
      return a2 && (s2.clear === "both" || s2.clear === f2) ? "vertical" : "horizontal";
    }
    return i2 && (l2.display === "block" || l2.display === "flex" || l2.display === "table" || l2.display === "grid" || u2 >= r2 && o2[Pt] === "none" || a2 && o2[Pt] === "none" && u2 + d2 > r2) ? "vertical" : "horizontal";
  }, Ln = function(e, n2, o2) {
    var r2 = o2 ? e.left : e.top, i2 = o2 ? e.right : e.bottom, a2 = o2 ? e.width : e.height, l2 = o2 ? n2.left : n2.top, s2 = o2 ? n2.right : n2.bottom, u2 = o2 ? n2.width : n2.height;
    return r2 === l2 || i2 === s2 || r2 + a2 / 2 === l2 + u2 / 2;
  }, Wn = function(e, n2) {
    var o2;
    return Ge.some(function(r2) {
      var i2 = r2[q].options.emptyInsertThreshold;
      if (!(!i2 || dt(r2))) {
        var a2 = M(r2), l2 = e >= a2.left - i2 && e <= a2.right + i2, s2 = n2 >= a2.top - i2 && n2 <= a2.bottom + i2;
        if (l2 && s2)
          return o2 = r2;
      }
    }), o2;
  }, qt = function(e) {
    function n2(i2, a2) {
      return function(l2, s2, u2, d2) {
        var f2 = l2.options.group.name && s2.options.group.name && l2.options.group.name === s2.options.group.name;
        if (i2 == null && (a2 || f2))
          return true;
        if (i2 == null || i2 === false)
          return false;
        if (a2 && i2 === "clone")
          return i2;
        if (typeof i2 == "function")
          return n2(i2(l2, s2, u2, d2), a2)(l2, s2, u2, d2);
        var m2 = (a2 ? l2 : s2).options.group.name;
        return i2 === true || typeof i2 == "string" && i2 === m2 || i2.join && i2.indexOf(m2) > -1;
      };
    }
    var o2 = {}, r2 = e.group;
    (!r2 || Xe(r2) != "object") && (r2 = {
      name: r2
    }), o2.name = r2.name, o2.checkPull = n2(r2.pull, true), o2.checkPut = n2(r2.put), o2.revertClone = r2.revertClone, e.group = o2;
  }, Kt = function() {
    !Vt && g && h(g, "display", "none");
  }, Jt = function() {
    !Vt && g && h(g, "display", "");
  };
  Ue && !Ht && document.addEventListener("click", function(t) {
    if (We)
      return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), We = false, false;
  }, true);
  var he = function(e) {
    if (c) {
      e = e.touches ? e.touches[0] : e;
      var n2 = Wn(e.clientX, e.clientY);
      if (n2) {
        var o2 = {};
        for (var r2 in e)
          e.hasOwnProperty(r2) && (o2[r2] = e[r2]);
        o2.target = o2.rootEl = n2, o2.preventDefault = void 0, o2.stopPropagation = void 0, n2[q]._onDragOver(o2);
      }
    }
  }, Gn = function(e) {
    c && c.parentNode[q]._isOutsideThisEl(e.target);
  };
  function p(t, e) {
    if (!(t && t.nodeType && t.nodeType === 1))
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));
    this.el = t, this.options = e = re({}, e), t[q] = this;
    var n2 = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*",
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function() {
        return $t(t, this.options);
      },
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      ignore: "a, img",
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function(a2, l2) {
        a2.setData("Text", l2.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: "data-id",
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: p.supportPointer !== false && "PointerEvent" in window && !_e,
      emptyInsertThreshold: 5
    };
    xe.initializePlugins(this, t, n2);
    for (var o2 in n2)
      !(o2 in e) && (e[o2] = n2[o2]);
    qt(e);
    for (var r2 in this)
      r2.charAt(0) === "_" && typeof this[r2] == "function" && (this[r2] = this[r2].bind(this));
    this.nativeDraggable = e.forceFallback ? false : Hn, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? D(t, "pointerdown", this._onTapStart) : (D(t, "mousedown", this._onTapStart), D(t, "touchstart", this._onTapStart)), this.nativeDraggable && (D(t, "dragover", this), D(t, "dragenter", this)), Ge.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), re(this, Rn());
  }
  p.prototype = /** @lends Sortable.prototype */
  {
    constructor: p,
    _isOutsideThisEl: function(e) {
      !this.el.contains(e) && e !== this.el && (me = null);
    },
    _getDirection: function(e, n2) {
      return typeof this.options.direction == "function" ? this.options.direction.call(this, e, n2, c) : this.options.direction;
    },
    _onTapStart: function(e) {
      if (e.cancelable) {
        var n2 = this, o2 = this.el, r2 = this.options, i2 = r2.preventOnFilter, a2 = e.type, l2 = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, s2 = (l2 || e).target, u2 = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || s2, d2 = r2.filter;
        if (Jn(o2), !c && !(/mousedown|pointerdown/.test(a2) && e.button !== 0 || r2.disabled) && !u2.isContentEditable && !(!this.nativeDraggable && _e && s2 && s2.tagName.toUpperCase() === "SELECT") && (s2 = Z(s2, r2.draggable, o2, false), !(s2 && s2.animated) && Ye !== s2)) {
          if (be = K(s2), Ce = K(s2, r2.draggable), typeof d2 == "function") {
            if (d2.call(this, e, s2, this)) {
              W({
                sortable: n2,
                rootEl: u2,
                name: "filter",
                targetEl: s2,
                toEl: o2,
                fromEl: o2
              }), G("filter", n2, {
                evt: e
              }), i2 && e.cancelable && e.preventDefault();
              return;
            }
          } else if (d2 && (d2 = d2.split(",").some(function(f2) {
            if (f2 = Z(u2, f2.trim(), o2, false), f2)
              return W({
                sortable: n2,
                rootEl: f2,
                name: "filter",
                targetEl: s2,
                fromEl: o2,
                toEl: o2
              }), G("filter", n2, {
                evt: e
              }), true;
          }), d2)) {
            i2 && e.cancelable && e.preventDefault();
            return;
          }
          r2.handle && !Z(u2, r2.handle, o2, false) || this._prepareDragStart(e, l2, s2);
        }
      }
    },
    _prepareDragStart: function(e, n2, o2) {
      var r2 = this, i2 = r2.el, a2 = r2.options, l2 = i2.ownerDocument, s2;
      if (o2 && !c && o2.parentNode === i2) {
        var u2 = M(o2);
        if (C = i2, c = o2, I = c.parentNode, pe = c.nextSibling, Ye = o2, Pe = a2.group, p.dragged = c, de = {
          target: c,
          clientX: (n2 || e).clientX,
          clientY: (n2 || e).clientY
        }, xt = de.clientX - u2.left, Nt = de.clientY - u2.top, this._lastX = (n2 || e).clientX, this._lastY = (n2 || e).clientY, c.style["will-change"] = "all", s2 = function() {
          if (G("delayEnded", r2, {
            evt: e
          }), p.eventCanceled) {
            r2._onDrop();
            return;
          }
          r2._disableDelayedDragEvents(), !Ct && r2.nativeDraggable && (c.draggable = true), r2._triggerDragStart(e, n2), W({
            sortable: r2,
            name: "choose",
            originalEvent: e
          }), V(c, a2.chosenClass, true);
        }, a2.ignore.split(",").forEach(function(d2) {
          Wt(c, d2.trim(), tt);
        }), D(l2, "dragover", he), D(l2, "mousemove", he), D(l2, "touchmove", he), D(l2, "mouseup", r2._onDrop), D(l2, "touchend", r2._onDrop), D(l2, "touchcancel", r2._onDrop), Ct && this.nativeDraggable && (this.options.touchStartThreshold = 4, c.draggable = true), G("delayStart", this, {
          evt: e
        }), a2.delay && (!a2.delayOnTouchOnly || n2) && (!this.nativeDraggable || !(Ae || ie))) {
          if (p.eventCanceled) {
            this._onDrop();
            return;
          }
          D(l2, "mouseup", r2._disableDelayedDrag), D(l2, "touchend", r2._disableDelayedDrag), D(l2, "touchcancel", r2._disableDelayedDrag), D(l2, "mousemove", r2._delayedDragTouchMoveHandler), D(l2, "touchmove", r2._delayedDragTouchMoveHandler), a2.supportPointer && D(l2, "pointermove", r2._delayedDragTouchMoveHandler), r2._dragStartTimer = setTimeout(s2, a2.delay);
        } else
          s2();
      }
    },
    _delayedDragTouchMoveHandler: function(e) {
      var n2 = e.touches ? e.touches[0] : e;
      Math.max(Math.abs(n2.clientX - this._lastX), Math.abs(n2.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
    },
    _disableDelayedDrag: function() {
      c && tt(c), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function() {
      var e = this.el.ownerDocument;
      S(e, "mouseup", this._disableDelayedDrag), S(e, "touchend", this._disableDelayedDrag), S(e, "touchcancel", this._disableDelayedDrag), S(e, "mousemove", this._delayedDragTouchMoveHandler), S(e, "touchmove", this._delayedDragTouchMoveHandler), S(e, "pointermove", this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function(e, n2) {
      n2 = n2 || e.pointerType == "touch" && e, !this.nativeDraggable || n2 ? this.options.supportPointer ? D(document, "pointermove", this._onTouchMove) : n2 ? D(document, "touchmove", this._onTouchMove) : D(document, "mousemove", this._onTouchMove) : (D(c, "dragend", this), D(C, "dragstart", this._onDragStart));
      try {
        document.selection ? ke(function() {
          document.selection.empty();
        }) : window.getSelection().removeAllRanges();
      } catch (o2) {
      }
    },
    _dragStarted: function(e, n2) {
      if (ve = false, C && c) {
        G("dragStarted", this, {
          evt: n2
        }), this.nativeDraggable && D(document, "dragover", Gn);
        var o2 = this.options;
        !e && V(c, o2.dragClass, false), V(c, o2.ghostClass, true), p.active = this, e && this._appendGhost(), W({
          sortable: this,
          name: "start",
          originalEvent: n2
        });
      } else
        this._nulling();
    },
    _emulateDragOver: function() {
      if (J) {
        this._lastX = J.clientX, this._lastY = J.clientY, Kt();
        for (var e = document.elementFromPoint(J.clientX, J.clientY), n2 = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(J.clientX, J.clientY), e !== n2); )
          n2 = e;
        if (c.parentNode[q]._isOutsideThisEl(e), n2)
          do {
            if (n2[q]) {
              var o2 = void 0;
              if (o2 = n2[q]._onDragOver({
                clientX: J.clientX,
                clientY: J.clientY,
                target: e,
                rootEl: n2
              }), o2 && !this.options.dragoverBubble)
                break;
            }
            e = n2;
          } while (n2 = n2.parentNode);
        Jt();
      }
    },
    _onTouchMove: function(e) {
      if (de) {
        var n2 = this.options, o2 = n2.fallbackTolerance, r2 = n2.fallbackOffset, i2 = e.touches ? e.touches[0] : e, a2 = g && ye(g, true), l2 = g && a2 && a2.a, s2 = g && a2 && a2.d, u2 = Fe && B && At(B), d2 = (i2.clientX - de.clientX + r2.x) / (l2 || 1) + (u2 ? u2[0] - et[0] : 0) / (l2 || 1), f2 = (i2.clientY - de.clientY + r2.y) / (s2 || 1) + (u2 ? u2[1] - et[1] : 0) / (s2 || 1);
        if (!p.active && !ve) {
          if (o2 && Math.max(Math.abs(i2.clientX - this._lastX), Math.abs(i2.clientY - this._lastY)) < o2)
            return;
          this._onDragStart(e, true);
        }
        if (g) {
          a2 ? (a2.e += d2 - (Ze || 0), a2.f += f2 - (Qe || 0)) : a2 = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: d2,
            f: f2
          };
          var m2 = "matrix(".concat(a2.a, ",").concat(a2.b, ",").concat(a2.c, ",").concat(a2.d, ",").concat(a2.e, ",").concat(a2.f, ")");
          h(g, "webkitTransform", m2), h(g, "mozTransform", m2), h(g, "msTransform", m2), h(g, "transform", m2), Ze = d2, Qe = f2, J = i2;
        }
        e.cancelable && e.preventDefault();
      }
    },
    _appendGhost: function() {
      if (!g) {
        var e = this.options.fallbackOnBody ? document.body : C, n2 = M(c, true, Fe, true, e), o2 = this.options;
        if (Fe) {
          for (B = e; h(B, "position") === "static" && h(B, "transform") === "none" && B !== document; )
            B = B.parentNode;
          B !== document.body && B !== document.documentElement ? (B === document && (B = ee()), n2.top += B.scrollTop, n2.left += B.scrollLeft) : B = ee(), et = At(B);
        }
        g = c.cloneNode(true), V(g, o2.ghostClass, false), V(g, o2.fallbackClass, true), V(g, o2.dragClass, true), h(g, "transition", ""), h(g, "transform", ""), h(g, "box-sizing", "border-box"), h(g, "margin", 0), h(g, "top", n2.top), h(g, "left", n2.left), h(g, "width", n2.width), h(g, "height", n2.height), h(g, "opacity", "0.8"), h(g, "position", Fe ? "absolute" : "fixed"), h(g, "zIndex", "100000"), h(g, "pointerEvents", "none"), p.ghost = g, e.appendChild(g), h(g, "transform-origin", xt / parseInt(g.style.width) * 100 + "% " + Nt / parseInt(g.style.height) * 100 + "%");
      }
    },
    _onDragStart: function(e, n2) {
      var o2 = this, r2 = e.dataTransfer, i2 = o2.options;
      if (G("dragStart", this, {
        evt: e
      }), p.eventCanceled) {
        this._onDrop();
        return;
      }
      G("setupClone", this), p.eventCanceled || (O = zt(c), O.removeAttribute("id"), O.draggable = false, O.style["will-change"] = "", this._hideClone(), V(O, this.options.chosenClass, false), p.clone = O), o2.cloneId = ke(function() {
        G("clone", o2), !p.eventCanceled && (o2.options.removeCloneOnHide || C.insertBefore(O, c), o2._hideClone(), W({
          sortable: o2,
          name: "clone"
        }));
      }), !n2 && V(c, i2.dragClass, true), n2 ? (We = true, o2._loopId = setInterval(o2._emulateDragOver, 50)) : (S(document, "mouseup", o2._onDrop), S(document, "touchend", o2._onDrop), S(document, "touchcancel", o2._onDrop), r2 && (r2.effectAllowed = "move", i2.setData && i2.setData.call(o2, r2, c)), D(document, "drop", o2), h(c, "transform", "translateZ(0)")), ve = true, o2._dragStartId = ke(o2._dragStarted.bind(o2, n2, e)), D(document, "selectstart", o2), Ee = true, _e && h(document.body, "user-select", "none");
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function(e) {
      var n2 = this.el, o2 = e.target, r2, i2, a2, l2 = this.options, s2 = l2.group, u2 = p.active, d2 = Pe === s2, f2 = l2.sort, m2 = X || u2, y2, b2 = this, E2 = false;
      if (at)
        return;
      function k2(ce2, nn) {
        G(ce2, b2, te({
          evt: e,
          isOwner: d2,
          axis: y2 ? "vertical" : "horizontal",
          revert: a2,
          dragRect: r2,
          targetRect: i2,
          canSort: f2,
          fromSortable: m2,
          target: o2,
          completed: F2,
          onMove: function(gt2, on) {
            return Re(C, n2, c, r2, gt2, M(gt2), e, on);
          },
          changed: A2
        }, nn));
      }
      function H2() {
        k2("dragOverAnimationCapture"), b2.captureAnimationState(), b2 !== m2 && m2.captureAnimationState();
      }
      function F2(ce2) {
        return k2("dragOverCompleted", {
          insertion: ce2
        }), ce2 && (d2 ? u2._hideClone() : u2._showClone(b2), b2 !== m2 && (V(c, X ? X.options.ghostClass : u2.options.ghostClass, false), V(c, l2.ghostClass, true)), X !== b2 && b2 !== p.active ? X = b2 : b2 === p.active && X && (X = null), m2 === b2 && (b2._ignoreWhileAnimating = o2), b2.animateAll(function() {
          k2("dragOverAnimationComplete"), b2._ignoreWhileAnimating = null;
        }), b2 !== m2 && (m2.animateAll(), m2._ignoreWhileAnimating = null)), (o2 === c && !c.animated || o2 === n2 && !o2.animated) && (me = null), !l2.dragoverBubble && !e.rootEl && o2 !== document && (c.parentNode[q]._isOutsideThisEl(e.target), !ce2 && he(e)), !l2.dragoverBubble && e.stopPropagation && e.stopPropagation(), E2 = true;
      }
      function A2() {
        $ = K(c), le = K(c, l2.draggable), W({
          sortable: b2,
          name: "change",
          toEl: n2,
          newIndex: $,
          newDraggableIndex: le,
          originalEvent: e
        });
      }
      if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), o2 = Z(o2, l2.draggable, n2, true), k2("dragOver"), p.eventCanceled)
        return E2;
      if (c.contains(e.target) || o2.animated && o2.animatingX && o2.animatingY || b2._ignoreWhileAnimating === o2)
        return F2(false);
      if (We = false, u2 && !l2.disabled && (d2 ? f2 || (a2 = I !== C) : X === this || (this.lastPutMode = Pe.checkPull(this, u2, c, e)) && s2.checkPut(this, u2, c, e))) {
        if (y2 = this._getDirection(e, o2) === "vertical", r2 = M(c), k2("dragOverValid"), p.eventCanceled)
          return E2;
        if (a2)
          return I = C, H2(), this._hideClone(), k2("revert"), p.eventCanceled || (pe ? C.insertBefore(c, pe) : C.appendChild(c)), F2(true);
        var L2 = dt(n2, l2.draggable);
        if (!L2 || Vn(e, y2, this) && !L2.animated) {
          if (L2 === c)
            return F2(false);
          if (L2 && n2 === e.target && (o2 = L2), o2 && (i2 = M(o2)), Re(C, n2, c, r2, o2, i2, e, !!o2) !== false)
            return H2(), L2 && L2.nextSibling ? n2.insertBefore(c, L2.nextSibling) : n2.appendChild(c), I = n2, A2(), F2(true);
        } else if (L2 && Un(e, y2, this)) {
          var ne2 = we(n2, 0, l2, true);
          if (ne2 === c)
            return F2(false);
          if (o2 = ne2, i2 = M(o2), Re(C, n2, c, r2, o2, i2, e, false) !== false)
            return H2(), n2.insertBefore(c, ne2), I = n2, A2(), F2(true);
        } else if (o2.parentNode === n2) {
          i2 = M(o2);
          var j2 = 0, Q2, v2 = c.parentNode !== n2, w2 = !Ln(c.animated && c.toRect || r2, o2.animated && o2.toRect || i2, y2), x2 = y2 ? "top" : "left", N2 = It(o2, "top", "top") || It(c, "top", "top"), _2 = N2 ? N2.scrollTop : void 0;
          me !== o2 && (Q2 = i2[x2], Ie = false, Me = !w2 && l2.invertSwap || v2), j2 = $n(e, o2, i2, y2, w2 ? 1 : l2.swapThreshold, l2.invertedSwapThreshold == null ? l2.swapThreshold : l2.invertedSwapThreshold, Me, me === o2);
          var T2;
          if (j2 !== 0) {
            var R2 = K(c);
            do
              R2 -= j2, T2 = I.children[R2];
            while (T2 && (h(T2, "display") === "none" || T2 === g));
          }
          if (j2 === 0 || T2 === o2)
            return F2(false);
          me = o2, Oe = j2;
          var Y2 = o2.nextElementSibling, z2 = false;
          z2 = j2 === 1;
          var ae2 = Re(C, n2, c, r2, o2, i2, e, z2);
          if (ae2 !== false)
            return (ae2 === 1 || ae2 === -1) && (z2 = ae2 === 1), at = true, setTimeout(zn, 30), H2(), z2 && !Y2 ? n2.appendChild(c) : o2.parentNode.insertBefore(c, z2 ? Y2 : o2), N2 && jt(N2, 0, _2 - N2.scrollTop), I = c.parentNode, Q2 !== void 0 && !Me && (Be = Math.abs(Q2 - M(o2)[x2])), A2(), F2(true);
        }
        if (n2.contains(c))
          return F2(false);
      }
      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function() {
      S(document, "mousemove", this._onTouchMove), S(document, "touchmove", this._onTouchMove), S(document, "pointermove", this._onTouchMove), S(document, "dragover", he), S(document, "mousemove", he), S(document, "touchmove", he);
    },
    _offUpEvents: function() {
      var e = this.el.ownerDocument;
      S(e, "mouseup", this._onDrop), S(e, "touchend", this._onDrop), S(e, "pointerup", this._onDrop), S(e, "touchcancel", this._onDrop), S(document, "selectstart", this);
    },
    _onDrop: function(e) {
      var n2 = this.el, o2 = this.options;
      if ($ = K(c), le = K(c, o2.draggable), G("drop", this, {
        evt: e
      }), I = c && c.parentNode, $ = K(c), le = K(c, o2.draggable), p.eventCanceled) {
        this._nulling();
        return;
      }
      ve = false, Me = false, Ie = false, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), lt(this.cloneId), lt(this._dragStartId), this.nativeDraggable && (S(document, "drop", this), S(n2, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), _e && h(document.body, "user-select", ""), h(c, "transform", ""), e && (Ee && (e.cancelable && e.preventDefault(), !o2.dropBubble && e.stopPropagation()), g && g.parentNode && g.parentNode.removeChild(g), (C === I || X && X.lastPutMode !== "clone") && O && O.parentNode && O.parentNode.removeChild(O), c && (this.nativeDraggable && S(c, "dragend", this), tt(c), c.style["will-change"] = "", Ee && !ve && V(c, X ? X.options.ghostClass : this.options.ghostClass, false), V(c, this.options.chosenClass, false), W({
        sortable: this,
        name: "unchoose",
        toEl: I,
        newIndex: null,
        newDraggableIndex: null,
        originalEvent: e
      }), C !== I ? ($ >= 0 && (W({
        rootEl: I,
        name: "add",
        toEl: I,
        fromEl: C,
        originalEvent: e
      }), W({
        sortable: this,
        name: "remove",
        toEl: I,
        originalEvent: e
      }), W({
        rootEl: I,
        name: "sort",
        toEl: I,
        fromEl: C,
        originalEvent: e
      }), W({
        sortable: this,
        name: "sort",
        toEl: I,
        originalEvent: e
      })), X && X.save()) : $ !== be && $ >= 0 && (W({
        sortable: this,
        name: "update",
        toEl: I,
        originalEvent: e
      }), W({
        sortable: this,
        name: "sort",
        toEl: I,
        originalEvent: e
      })), p.active && (($ == null || $ === -1) && ($ = be, le = Ce), W({
        sortable: this,
        name: "end",
        toEl: I,
        originalEvent: e
      }), this.save()))), this._nulling();
    },
    _nulling: function() {
      G("nulling", this), C = c = I = g = pe = O = Ye = se = de = J = Ee = $ = le = be = Ce = me = Oe = X = Pe = p.dragged = p.ghost = p.clone = p.active = null, je.forEach(function(e) {
        e.checked = true;
      }), je.length = Ze = Qe = 0;
    },
    handleEvent: function(e) {
      switch (e.type) {
        case "drop":
        case "dragend":
          this._onDrop(e);
          break;
        case "dragenter":
        case "dragover":
          c && (this._onDragOver(e), jn(e));
          break;
        case "selectstart":
          e.preventDefault();
          break;
      }
    },
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function() {
      for (var e = [], n2, o2 = this.el.children, r2 = 0, i2 = o2.length, a2 = this.options; r2 < i2; r2++)
        n2 = o2[r2], Z(n2, a2.draggable, this.el, false) && e.push(n2.getAttribute(a2.dataIdAttr) || Kn(n2));
      return e;
    },
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function(e, n2) {
      var o2 = {}, r2 = this.el;
      this.toArray().forEach(function(i2, a2) {
        var l2 = r2.children[a2];
        Z(l2, this.options.draggable, r2, false) && (o2[i2] = l2);
      }, this), n2 && this.captureAnimationState(), e.forEach(function(i2) {
        o2[i2] && (r2.removeChild(o2[i2]), r2.appendChild(o2[i2]));
      }), n2 && this.animateAll();
    },
    /**
     * Save the current sorting
     */
    save: function() {
      var e = this.options.store;
      e && e.set && e.set(this);
    },
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function(e, n2) {
      return Z(e, n2 || this.options.draggable, this.el, false);
    },
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function(e, n2) {
      var o2 = this.options;
      if (n2 === void 0)
        return o2[e];
      var r2 = xe.modifyOption(this, e, n2);
      typeof r2 != "undefined" ? o2[e] = r2 : o2[e] = n2, e === "group" && qt(o2);
    },
    /**
     * Destroy
     */
    destroy: function() {
      G("destroy", this);
      var e = this.el;
      e[q] = null, S(e, "mousedown", this._onTapStart), S(e, "touchstart", this._onTapStart), S(e, "pointerdown", this._onTapStart), this.nativeDraggable && (S(e, "dragover", this), S(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(n2) {
        n2.removeAttribute("draggable");
      }), this._onDrop(), this._disableDelayedDragEvents(), Ge.splice(Ge.indexOf(this.el), 1), this.el = e = null;
    },
    _hideClone: function() {
      if (!se) {
        if (G("hideClone", this), p.eventCanceled)
          return;
        h(O, "display", "none"), this.options.removeCloneOnHide && O.parentNode && O.parentNode.removeChild(O), se = true;
      }
    },
    _showClone: function(e) {
      if (e.lastPutMode !== "clone") {
        this._hideClone();
        return;
      }
      if (se) {
        if (G("showClone", this), p.eventCanceled)
          return;
        c.parentNode == C && !this.options.group.revertClone ? C.insertBefore(O, c) : pe ? C.insertBefore(O, pe) : C.appendChild(O), this.options.group.revertClone && this.animate(c, O), h(O, "display", ""), se = false;
      }
    }
  };
  function jn(t) {
    t.dataTransfer && (t.dataTransfer.dropEffect = "move"), t.cancelable && t.preventDefault();
  }
  function Re(t, e, n2, o2, r2, i2, a2, l2) {
    var s2, u2 = t[q], d2 = u2.options.onMove, f2;
    return window.CustomEvent && !ie && !Ae ? s2 = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    }) : (s2 = document.createEvent("Event"), s2.initEvent("move", true, true)), s2.to = e, s2.from = t, s2.dragged = n2, s2.draggedRect = o2, s2.related = r2 || e, s2.relatedRect = i2 || M(e), s2.willInsertAfter = l2, s2.originalEvent = a2, t.dispatchEvent(s2), d2 && (f2 = d2.call(u2, s2, a2)), f2;
  }
  function tt(t) {
    t.draggable = false;
  }
  function zn() {
    at = false;
  }
  function Un(t, e, n2) {
    var o2 = M(we(n2.el, 0, n2.options, true)), r2 = Ut(n2.el, n2.options, g), i2 = 10;
    return e ? t.clientX < r2.left - i2 || t.clientY < o2.top && t.clientX < o2.right : t.clientY < r2.top - i2 || t.clientY < o2.bottom && t.clientX < o2.left;
  }
  function Vn(t, e, n2) {
    var o2 = M(dt(n2.el, n2.options.draggable)), r2 = Ut(n2.el, n2.options, g), i2 = 10;
    return e ? t.clientX > r2.right + i2 || t.clientY > o2.bottom && t.clientX > o2.left : t.clientY > r2.bottom + i2 || t.clientX > o2.right && t.clientY > o2.top;
  }
  function $n(t, e, n2, o2, r2, i2, a2, l2) {
    var s2 = o2 ? t.clientY : t.clientX, u2 = o2 ? n2.height : n2.width, d2 = o2 ? n2.top : n2.left, f2 = o2 ? n2.bottom : n2.right, m2 = false;
    if (!a2) {
      if (l2 && Be < u2 * r2) {
        if (!Ie && (Oe === 1 ? s2 > d2 + u2 * i2 / 2 : s2 < f2 - u2 * i2 / 2) && (Ie = true), Ie)
          m2 = true;
        else if (Oe === 1 ? s2 < d2 + Be : s2 > f2 - Be)
          return -Oe;
      } else if (s2 > d2 + u2 * (1 - r2) / 2 && s2 < f2 - u2 * (1 - r2) / 2)
        return qn(e);
    }
    return m2 = m2 || a2, m2 && (s2 < d2 + u2 * i2 / 2 || s2 > f2 - u2 * i2 / 2) ? s2 > d2 + u2 / 2 ? 1 : -1 : 0;
  }
  function qn(t) {
    return K(c) < K(t) ? 1 : -1;
  }
  function Kn(t) {
    for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n2 = e.length, o2 = 0; n2--; )
      o2 += e.charCodeAt(n2);
    return o2.toString(36);
  }
  function Jn(t) {
    je.length = 0;
    for (var e = t.getElementsByTagName("input"), n2 = e.length; n2--; ) {
      var o2 = e[n2];
      o2.checked && je.push(o2);
    }
  }
  function ke(t) {
    return setTimeout(t, 0);
  }
  function lt(t) {
    return clearTimeout(t);
  }
  Ue && D(document, "touchmove", function(t) {
    (p.active || ve) && t.cancelable && t.preventDefault();
  });
  p.utils = {
    on: D,
    off: S,
    css: h,
    find: Wt,
    is: function(e, n2) {
      return !!Z(e, n2, e, false);
    },
    extend: Mn,
    throttle: Gt,
    closest: Z,
    toggleClass: V,
    clone: zt,
    index: K,
    nextTick: ke,
    cancelNextTick: lt,
    detectDirection: $t,
    getChild: we
  };
  p.get = function(t) {
    return t[q];
  };
  p.mount = function() {
    for (var t = arguments.length, e = new Array(t), n2 = 0; n2 < t; n2++)
      e[n2] = arguments[n2];
    e[0].constructor === Array && (e = e[0]), e.forEach(function(o2) {
      if (!o2.prototype || !o2.prototype.constructor)
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(o2));
      o2.utils && (p.utils = te(te({}, p.utils), o2.utils)), xe.mount(o2);
    });
  };
  p.create = function(t, e) {
    return new p(t, e);
  };
  p.version = xn;
  var P = [], Se, st, ut = false, nt, ot, ze, De;
  function Zn() {
    function t() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      };
      for (var e in this)
        e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
    }
    return t.prototype = {
      dragStarted: function(n2) {
        var o2 = n2.originalEvent;
        this.sortable.nativeDraggable ? D(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? D(document, "pointermove", this._handleFallbackAutoScroll) : o2.touches ? D(document, "touchmove", this._handleFallbackAutoScroll) : D(document, "mousemove", this._handleFallbackAutoScroll);
      },
      dragOverCompleted: function(n2) {
        var o2 = n2.originalEvent;
        !this.options.dragOverBubble && !o2.rootEl && this._handleAutoScroll(o2);
      },
      drop: function() {
        this.sortable.nativeDraggable ? S(document, "dragover", this._handleAutoScroll) : (S(document, "pointermove", this._handleFallbackAutoScroll), S(document, "touchmove", this._handleFallbackAutoScroll), S(document, "mousemove", this._handleFallbackAutoScroll)), Mt(), He(), Fn();
      },
      nulling: function() {
        ze = st = Se = ut = De = nt = ot = null, P.length = 0;
      },
      _handleFallbackAutoScroll: function(n2) {
        this._handleAutoScroll(n2, true);
      },
      _handleAutoScroll: function(n2, o2) {
        var r2 = this, i2 = (n2.touches ? n2.touches[0] : n2).clientX, a2 = (n2.touches ? n2.touches[0] : n2).clientY, l2 = document.elementFromPoint(i2, a2);
        if (ze = n2, o2 || this.options.forceAutoScrollFallback || Ae || ie || _e) {
          rt(n2, this.options, l2, o2);
          var s2 = ue(l2, true);
          ut && (!De || i2 !== nt || a2 !== ot) && (De && Mt(), De = setInterval(function() {
            var u2 = ue(document.elementFromPoint(i2, a2), true);
            u2 !== s2 && (s2 = u2, He()), rt(n2, r2.options, u2, o2);
          }, 10), nt = i2, ot = a2);
        } else {
          if (!this.options.bubbleScroll || ue(l2, true) === ee()) {
            He();
            return;
          }
          rt(n2, this.options, ue(l2, false), false);
        }
      }
    }, re(t, {
      pluginName: "scroll",
      initializeByDefault: true
    });
  }
  function He() {
    P.forEach(function(t) {
      clearInterval(t.pid);
    }), P = [];
  }
  function Mt() {
    clearInterval(De);
  }
  var rt = Gt(function(t, e, n2, o2) {
    if (e.scroll) {
      var r2 = (t.touches ? t.touches[0] : t).clientX, i2 = (t.touches ? t.touches[0] : t).clientY, a2 = e.scrollSensitivity, l2 = e.scrollSpeed, s2 = ee(), u2 = false, d2;
      st !== n2 && (st = n2, He(), Se = e.scroll, d2 = e.scrollFn, Se === true && (Se = ue(n2, true)));
      var f2 = 0, m2 = Se;
      do {
        var y2 = m2, b2 = M(y2), E2 = b2.top, k2 = b2.bottom, H2 = b2.left, F2 = b2.right, A2 = b2.width, L2 = b2.height, ne2 = void 0, j2 = void 0, Q2 = y2.scrollWidth, v2 = y2.scrollHeight, w2 = h(y2), x2 = y2.scrollLeft, N2 = y2.scrollTop;
        y2 === s2 ? (ne2 = A2 < Q2 && (w2.overflowX === "auto" || w2.overflowX === "scroll" || w2.overflowX === "visible"), j2 = L2 < v2 && (w2.overflowY === "auto" || w2.overflowY === "scroll" || w2.overflowY === "visible")) : (ne2 = A2 < Q2 && (w2.overflowX === "auto" || w2.overflowX === "scroll"), j2 = L2 < v2 && (w2.overflowY === "auto" || w2.overflowY === "scroll"));
        var _2 = ne2 && (Math.abs(F2 - r2) <= a2 && x2 + A2 < Q2) - (Math.abs(H2 - r2) <= a2 && !!x2), T2 = j2 && (Math.abs(k2 - i2) <= a2 && N2 + L2 < v2) - (Math.abs(E2 - i2) <= a2 && !!N2);
        if (!P[f2])
          for (var R2 = 0; R2 <= f2; R2++)
            P[R2] || (P[R2] = {});
        (P[f2].vx != _2 || P[f2].vy != T2 || P[f2].el !== y2) && (P[f2].el = y2, P[f2].vx = _2, P[f2].vy = T2, clearInterval(P[f2].pid), (_2 != 0 || T2 != 0) && (u2 = true, P[f2].pid = setInterval(function() {
          o2 && this.layer === 0 && p.active._onTouchMove(ze);
          var Y2 = P[this.layer].vy ? P[this.layer].vy * l2 : 0, z2 = P[this.layer].vx ? P[this.layer].vx * l2 : 0;
          typeof d2 == "function" && d2.call(p.dragged.parentNode[q], z2, Y2, t, ze, P[this.layer].el) !== "continue" || jt(P[this.layer].el, z2, Y2);
        }.bind({
          layer: f2
        }), 24))), f2++;
      } while (e.bubbleScroll && m2 !== s2 && (m2 = ue(m2, false)));
      ut = u2;
    }
  }, 30), Zt = function(e) {
    var n2 = e.originalEvent, o2 = e.putSortable, r2 = e.dragEl, i2 = e.activeSortable, a2 = e.dispatchSortableEvent, l2 = e.hideGhostForTarget, s2 = e.unhideGhostForTarget;
    if (n2) {
      var u2 = o2 || i2;
      l2();
      var d2 = n2.changedTouches && n2.changedTouches.length ? n2.changedTouches[0] : n2, f2 = document.elementFromPoint(d2.clientX, d2.clientY);
      s2(), u2 && !u2.el.contains(f2) && (a2("spill"), this.onSpill({
        dragEl: r2,
        putSortable: o2
      }));
    }
  };
  function ht() {
  }
  ht.prototype = {
    startIndex: null,
    dragStart: function(e) {
      var n2 = e.oldDraggableIndex;
      this.startIndex = n2;
    },
    onSpill: function(e) {
      var n2 = e.dragEl, o2 = e.putSortable;
      this.sortable.captureAnimationState(), o2 && o2.captureAnimationState();
      var r2 = we(this.sortable.el, this.startIndex, this.options);
      r2 ? this.sortable.el.insertBefore(n2, r2) : this.sortable.el.appendChild(n2), this.sortable.animateAll(), o2 && o2.animateAll();
    },
    drop: Zt
  };
  re(ht, {
    pluginName: "revertOnSpill"
  });
  function pt() {
  }
  pt.prototype = {
    onSpill: function(e) {
      var n2 = e.dragEl, o2 = e.putSortable, r2 = o2 || this.sortable;
      r2.captureAnimationState(), n2.parentNode && n2.parentNode.removeChild(n2), r2.animateAll();
    },
    drop: Zt
  };
  re(pt, {
    pluginName: "removeOnSpill"
  });
  p.mount(new Zn());
  p.mount(pt, ht);
  function Qn(t) {
    return t == null ? t : JSON.parse(JSON.stringify(t));
  }
  function eo(t) {
    getCurrentInstance() && onUnmounted(t);
  }
  function to(t) {
    getCurrentInstance() ? onMounted(t) : nextTick(t);
  }
  let Qt = null, en = null;
  function Ft(t = null, e = null) {
    Qt = t, en = e;
  }
  function no() {
    return {
      data: Qt,
      clonedData: en
    };
  }
  const Rt = Symbol("cloneElement");
  function tn(...t) {
    var j2, Q2;
    const e = (j2 = getCurrentInstance()) == null ? void 0 : j2.proxy;
    let n2 = null;
    const o2 = t[0];
    let [, r2, i2] = t;
    Array.isArray(unref(r2)) || (i2 = r2, r2 = null);
    let a2 = null;
    const {
      immediate: l2 = true,
      clone: s2 = Qn,
      customUpdate: u2
    } = (Q2 = unref(i2)) != null ? Q2 : {};
    function d2(v2) {
      var R2;
      const { from: w2, oldIndex: x2, item: N2 } = v2;
      n2 = Array.from(w2.childNodes);
      const _2 = unref((R2 = unref(r2)) == null ? void 0 : R2[x2]), T2 = s2(_2);
      Ft(_2, T2), N2[Rt] = T2;
    }
    function f2(v2) {
      const w2 = v2.item[Rt];
      if (!yn(w2)) {
        if (qe(v2.item), isRef(r2)) {
          const x2 = [...unref(r2)];
          r2.value = St(x2, v2.newDraggableIndex, w2);
          return;
        }
        St(unref(r2), v2.newDraggableIndex, w2);
      }
    }
    function m2(v2) {
      const { from: w2, item: x2, oldIndex: N2, oldDraggableIndex: _2, pullMode: T2, clone: R2 } = v2;
      if (Dt(w2, x2, N2), T2 === "clone") {
        qe(R2);
        return;
      }
      if (isRef(r2)) {
        const Y2 = [...unref(r2)];
        r2.value = Et(Y2, _2);
        return;
      }
      Et(unref(r2), _2);
    }
    function y2(v2) {
      if (u2) {
        u2(v2);
        return;
      }
      const { from: w2, item: x2, oldIndex: N2, oldDraggableIndex: _2, newDraggableIndex: T2 } = v2;
      if (qe(x2), Dt(w2, x2, N2), isRef(r2)) {
        const R2 = [...unref(r2)];
        r2.value = wt(
          R2,
          _2,
          T2
        );
        return;
      }
      wt(unref(r2), _2, T2);
    }
    function b2(v2) {
      const { newIndex: w2, oldIndex: x2, from: N2, to: _2 } = v2;
      let T2 = null;
      const R2 = w2 === x2 && N2 === _2;
      try {
        if (R2) {
          let Y2 = null;
          n2 == null || n2.some((z2, ae2) => {
            if (Y2 && (n2 == null ? void 0 : n2.length) !== _2.childNodes.length)
              return N2.insertBefore(Y2, z2.nextSibling), true;
            const ce2 = _2.childNodes[ae2];
            Y2 = _2 == null ? void 0 : _2.replaceChild(z2, ce2);
          });
        }
      } catch (Y2) {
        T2 = Y2;
      } finally {
        n2 = null;
      }
      nextTick(() => {
        if (Ft(), T2)
          throw T2;
      });
    }
    const E2 = {
      onUpdate: y2,
      onStart: d2,
      onAdd: f2,
      onRemove: m2,
      onEnd: b2
    };
    function k2(v2) {
      const w2 = unref(o2);
      return v2 || (v2 = wn(w2) ? En(w2, e == null ? void 0 : e.$el) : w2), v2 && !_n(v2) && (v2 = v2.$el), v2 || mn("Root element not found"), v2;
    }
    function H2() {
      var N2;
      const _2 = (N2 = unref(i2)) != null ? N2 : {}, { immediate: v2, clone: w2 } = _2, x2 = Ve(_2, ["immediate", "clone"]);
      return _t(x2, (T2, R2) => {
        Tn(T2) && (x2[T2] = (Y2, ...z2) => {
          const ae2 = no();
          return Cn(Y2, ae2), R2(Y2, ...z2);
        });
      }), Dn(
        r2 === null ? {} : E2,
        x2
      );
    }
    const F2 = (v2) => {
      v2 = k2(v2), a2 && A2.destroy(), a2 = new p(v2, H2());
    };
    watch(
      () => i2,
      () => {
        a2 && _t(H2(), (v2, w2) => {
          a2 == null || a2.option(v2, w2);
        });
      },
      { deep: true }
    );
    const A2 = {
      option: (v2, w2) => a2 == null ? void 0 : a2.option(v2, w2),
      destroy: () => {
        a2 == null || a2.destroy(), a2 = null;
      },
      save: () => a2 == null ? void 0 : a2.save(),
      toArray: () => a2 == null ? void 0 : a2.toArray(),
      closest: (...v2) => a2 == null ? void 0 : a2.closest(...v2)
    }, L2 = () => A2 == null ? void 0 : A2.option("disabled", true), ne2 = () => A2 == null ? void 0 : A2.option("disabled", false);
    return to(() => {
      l2 && F2();
    }), eo(A2.destroy), fe({ start: F2, pause: L2, resume: ne2 }, A2);
  }
  const ct = [
    "update",
    "start",
    "add",
    "remove",
    "choose",
    "unchoose",
    "end",
    "sort",
    "filter",
    "clone",
    "move",
    "change"
  ], oo = [
    "clone",
    "animation",
    "ghostClass",
    "group",
    "sort",
    "disabled",
    "store",
    "handle",
    "draggable",
    "swapThreshold",
    "invertSwap",
    "invertedSwapThreshold",
    "removeCloneOnHide",
    "direction",
    "chosenClass",
    "dragClass",
    "ignore",
    "filter",
    "preventOnFilter",
    "easing",
    "setData",
    "dropBubble",
    "dragoverBubble",
    "dataIdAttr",
    "delay",
    "delayOnTouchOnly",
    "touchStartThreshold",
    "forceFallback",
    "fallbackClass",
    "fallbackOnBody",
    "fallbackTolerance",
    "fallbackOffset",
    "supportPointer",
    "emptyInsertThreshold",
    "scroll",
    "forceAutoScrollFallback",
    "scrollSensitivity",
    "scrollSpeed",
    "bubbleScroll",
    "modelValue",
    "tag",
    "target",
    "customUpdate",
    ...ct.map((t) => `on${t.replace(/^\S/, (e) => e.toUpperCase())}`)
  ], lo = /* @__PURE__ */ defineComponent({
    name: "VueDraggable",
    model: {
      prop: "modelValue",
      event: "update:modelValue"
    },
    props: oo,
    emits: ["update:modelValue", ...ct],
    setup(t, { slots: e, emit: n2, expose: o2, attrs: r2 }) {
      const i2 = ct.reduce((d2, f2) => {
        const m2 = `on${f2.replace(/^\S/, (y2) => y2.toUpperCase())}`;
        return d2[m2] = (...y2) => n2(f2, ...y2), d2;
      }, {}), a2 = computed(() => {
        const y2 = toRefs(t), { modelValue: d2 } = y2, f2 = Ve(y2, ["modelValue"]), m2 = Object.entries(f2).reduce((b2, [E2, k2]) => {
          const H2 = unref(k2);
          return H2 !== void 0 && (b2[E2] = H2), b2;
        }, {});
        return fe(fe({}, i2), bn(fe(fe({}, r2), m2)));
      }), l2 = computed({
        get: () => t.modelValue,
        set: (d2) => n2("update:modelValue", d2)
      }), s2 = ref(), u2 = reactive(
        tn(t.target || s2, l2, a2)
      );
      return o2(u2), () => {
        var d2;
        return h$4(t.tag || "div", { ref: s2 }, (d2 = e == null ? void 0 : e.default) == null ? void 0 : d2.call(e, u2));
      };
    }
  });
  Ce$1.props.components.default = () => ({
    Deselect: {
      render: () => h$4("span", { class: "dashicons dashicons-no-alt", style: "font-size: 14px; width: 14px; height: 14px; color: #d63638;" })
    },
    OpenIndicator: {
      render: () => h$4("span", { class: "dashicons dashicons-arrow-down-alt2", style: "font-size: 16px; width: 16px; height: 16px;" })
    }
  });
  window.addEventListener("DOMContentLoaded", () => {
    if (document.getElementById("fl-app-tournament")) {
      const app = createApp(_sfc_main$L);
      const pinia = createPinia();
      const vfm = zo();
      app.component("draggable", lo);
      app.component("Toggle", b);
      app.component("vSelect", Ce$1);
      app.use(Gt$1);
      app.use(vfm);
      app.use(pinia);
      app.mount("#fl-app-tournament");
    }
    if (document.getElementById("fl-app-plugin-health")) {
      const app = createApp(_sfc_main$K);
      app.mount("#fl-app-plugin-health");
    }
    if (document.getElementById("fl-app-player-manual-stats")) {
      const app = createApp(_sfc_main$J);
      app.component("draggable", lo);
      app.mount("#fl-app-player-manual-stats");
    }
    if (document.getElementById("fl-app-match-setup")) {
      const app = createApp(_sfc_main$I);
      app.use(Gt$1);
      app.component("vSelect", Ce$1);
      app.component("Toggle", b);
      app.mount("#fl-app-match-setup");
    }
    if (document.getElementById("fl-app-match")) {
      const app = createApp(_sfc_main$q);
      const pinia = createPinia();
      const vfm = zo();
      app.component("vSelect", Ce$1);
      app.component("Toggle", b);
      app.component("draggable", lo);
      app.use(Gt$1);
      app.use(vfm);
      app.use(pinia);
      app.mount("#fl-app-match");
    }
    if (document.getElementById("fl-app-standing-setup")) {
      const app = createApp(_sfc_main$p);
      app.component("vSelect", Ce$1);
      app.mount("#fl-app-standing-setup");
    }
    if (document.getElementById("fl-app-standing")) {
      const app = createApp(_sfc_main$f);
      const pinia = createPinia();
      const vfm = zo();
      app.component("vSelect", Ce$1);
      app.component("Toggle", b);
      app.use(vfm);
      app.use(pinia);
      app.mount("#fl-app-standing");
    }
    if (document.getElementById("fl-app-squad")) {
      const app = createApp(_sfc_main$7);
      const pinia = createPinia();
      const vfm = zo();
      app.component("draggable", lo);
      app.component("vSelect", Ce$1);
      app.component("Toggle", b);
      app.use(vfm);
      app.use(pinia);
      app.mount("#fl-app-squad");
    }
    if (document.getElementById("fl-app-toolbox--updater")) {
      const app = createApp(_sfc_main$5);
      const pinia = createPinia();
      app.use(pinia);
      app.mount("#fl-app-toolbox--updater");
    }
    if (document.getElementById("fl-app-toolbox--toolkit")) {
      const app = createApp(_sfc_main);
      const pinia = createPinia();
      app.use(pinia);
      app.mount("#fl-app-toolbox--toolkit");
    }
    if (document.getElementById("anwp-fl-batch-import-tool-app")) {
      const app = createApp(AppImportTool);
      app.component("draggable", lo);
      app.component("Toggle", b);
      app.use(Gt$1);
      app.mount("#anwp-fl-batch-import-tool-app");
    }
  });
})();
